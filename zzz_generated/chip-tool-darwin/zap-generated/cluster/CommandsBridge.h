/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#import <CHIP/CHIPDevice.h>
#import <CHIP/CHIPError_Internal.h>

#include <cstdint>
#include <string>
#include <type_traits>

#include <app/data-model/DecodableList.h>
#include <commands/clusters/ModelCommandBridge.h>

/*----------------------------------------------------------------------------*\
| Cluster Name                                                        |   ID   |
|---------------------------------------------------------------------+--------|
| AccessControl                                                       | 0x001F |
| AccountLogin                                                        | 0x050E |
| AdministratorCommissioning                                          | 0x003C |
| ApplicationBasic                                                    | 0x050D |
| ApplicationLauncher                                                 | 0x050C |
| AudioOutput                                                         | 0x050B |
| BarrierControl                                                      | 0x0103 |
| Basic                                                               | 0x0028 |
| BinaryInputBasic                                                    | 0x000F |
| Binding                                                             | 0x001E |
| BooleanState                                                        | 0x0045 |
| BridgedActions                                                      | 0x0025 |
| BridgedDeviceBasic                                                  | 0x0039 |
| Channel                                                             | 0x0504 |
| ColorControl                                                        | 0x0300 |
| ContentLauncher                                                     | 0x050A |
| Descriptor                                                          | 0x001D |
| DiagnosticLogs                                                      | 0x0032 |
| DoorLock                                                            | 0x0101 |
| ElectricalMeasurement                                               | 0x0B04 |
| EthernetNetworkDiagnostics                                          | 0x0037 |
| FixedLabel                                                          | 0x0040 |
| FlowMeasurement                                                     | 0x0404 |
| GeneralCommissioning                                                | 0x0030 |
| GeneralDiagnostics                                                  | 0x0033 |
| GroupKeyManagement                                                  | 0x003F |
| Groups                                                              | 0x0004 |
| Identify                                                            | 0x0003 |
| IlluminanceMeasurement                                              | 0x0400 |
| KeypadInput                                                         | 0x0509 |
| LevelControl                                                        | 0x0008 |
| LocalizationConfiguration                                           | 0x002B |
| LowPower                                                            | 0x0508 |
| MediaInput                                                          | 0x0507 |
| MediaPlayback                                                       | 0x0506 |
| ModeSelect                                                          | 0x0050 |
| NetworkCommissioning                                                | 0x0031 |
| OtaSoftwareUpdateProvider                                           | 0x0029 |
| OtaSoftwareUpdateRequestor                                          | 0x002A |
| OccupancySensing                                                    | 0x0406 |
| OnOff                                                               | 0x0006 |
| OnOffSwitchConfiguration                                            | 0x0007 |
| OperationalCredentials                                              | 0x003E |
| PowerSource                                                         | 0x002F |
| PowerSourceConfiguration                                            | 0x002E |
| PressureMeasurement                                                 | 0x0403 |
| PumpConfigurationAndControl                                         | 0x0200 |
| RelativeHumidityMeasurement                                         | 0x0405 |
| Scenes                                                              | 0x0005 |
| SoftwareDiagnostics                                                 | 0x0034 |
| Switch                                                              | 0x003B |
| TargetNavigator                                                     | 0x0505 |
| TemperatureMeasurement                                              | 0x0402 |
| TestCluster                                                         | 0x050F |
| Thermostat                                                          | 0x0201 |
| ThermostatUserInterfaceConfiguration                                | 0x0204 |
| ThreadNetworkDiagnostics                                            | 0x0035 |
| TimeFormatLocalization                                              | 0x002C |
| UnitLocalization                                                    | 0x002D |
| UserLabel                                                           | 0x0041 |
| WakeOnLan                                                           | 0x0503 |
| WiFiNetworkDiagnostics                                              | 0x0036 |
| WindowCovering                                                      | 0x0102 |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
| Cluster AccessControl                                               | 0x001F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Acl                                                               | 0x0000 |
| * Extension                                                         | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * AccessControlEntryChanged                                         | 0x0000 |
| * AccessControlExtensionChanged                                     | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Event AccessControlEntryChanged
 */
class ReadAccessControlAccessControlEntryChanged : public ModelCommand {
public:
    ReadAccessControlAccessControlEntryChanged()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "access-control-entry-changed");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAccessControlEntryChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportAccessControlAccessControlEntryChanged : public ModelCommand {
public:
    ReportAccessControlAccessControlEntryChanged()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "access-control-entry-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlAccessControlEntryChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event AccessControlExtensionChanged
 */
class ReadAccessControlAccessControlExtensionChanged : public ModelCommand {
public:
    ReadAccessControlAccessControlExtensionChanged()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "access-control-extension-changed");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAccessControlExtensionChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportAccessControlAccessControlExtensionChanged : public ModelCommand {
public:
    ReportAccessControlAccessControlExtensionChanged()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "access-control-extension-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlAccessControlExtensionChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Acl
 */
class ReadAccessControlAcl : public ModelCommand {
public:
    ReadAccessControlAcl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "acl");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAclWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.Acl response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl Acl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlAcl : public ModelCommand {
public:
    ReportAccessControlAcl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "acl");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlAcl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Extension
 */
class ReadAccessControlExtension : public ModelCommand {
public:
    ReadAccessControlExtension()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "extension");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeExtensionWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.Extension response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl Extension Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlExtension : public ModelCommand {
public:
    ReportAccessControlExtension()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "extension");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlExtension() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAccessControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadAccessControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccessControl.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccessControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlServerGeneratedCommandList : public ModelCommand {
public:
    ReportAccessControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAccessControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadAccessControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccessControl.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccessControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlClientGeneratedCommandList : public ModelCommand {
public:
    ReportAccessControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccessControlAttributeList : public ModelCommand {
public:
    ReadAccessControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlAttributeList : public ModelCommand {
public:
    ReportAccessControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccessControlClusterRevision : public ModelCommand {
public:
    ReadAccessControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccessControl * cluster = [[CHIPAccessControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccessControl.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccessControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccessControlClusterRevision : public ModelCommand {
public:
    ReportAccessControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccessControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AccountLogin                                                | 0x050E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * GetSetupPINRequest                                                |   0x00 |
| * LoginRequest                                                      |   0x02 |
| * LogoutRequest                                                     |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command GetSetupPINRequest
 */
class AccountLoginGetSetupPINRequest : public ModelCommand {
public:
    AccountLoginGetSetupPINRequest()
        : ModelCommand("get-setup-pinrequest")
    {
        AddArgument("TempAccountIdentifier", &mTempAccountIdentifier);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPAccountLoginClusterGetSetupPINRequestParams alloc] init];
        params.tempAccountIdentifier = [[NSString alloc] initWithBytes:mTempAccountIdentifier.data()
                                                                length:mTempAccountIdentifier.size()
                                                              encoding:NSUTF8StringEncoding];
        [cluster getSetupPINRequestWithParams:params
                            completionHandler:^(
                                CHIPAccountLoginClusterGetSetupPINResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mTempAccountIdentifier;
};

/*
 * Command LoginRequest
 */
class AccountLoginLoginRequest : public ModelCommand {
public:
    AccountLoginLoginRequest()
        : ModelCommand("login-request")
    {
        AddArgument("TempAccountIdentifier", &mTempAccountIdentifier);
        AddArgument("SetupPIN", &mSetupPIN);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPAccountLoginClusterLoginRequestParams alloc] init];
        params.tempAccountIdentifier = [[NSString alloc] initWithBytes:mTempAccountIdentifier.data()
                                                                length:mTempAccountIdentifier.size()
                                                              encoding:NSUTF8StringEncoding];
        params.setupPIN = [[NSString alloc] initWithBytes:mSetupPIN.data() length:mSetupPIN.size() encoding:NSUTF8StringEncoding];
        [cluster loginRequestWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mTempAccountIdentifier;
    chip::ByteSpan mSetupPIN;
};

/*
 * Command LogoutRequest
 */
class AccountLoginLogoutRequest : public ModelCommand {
public:
    AccountLoginLogoutRequest()
        : ModelCommand("logout-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster logoutRequestWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAccountLoginServerGeneratedCommandList : public ModelCommand {
public:
    ReadAccountLoginServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccountLogin.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccountLogin ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccountLoginServerGeneratedCommandList : public ModelCommand {
public:
    ReportAccountLoginServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAccountLoginClientGeneratedCommandList : public ModelCommand {
public:
    ReadAccountLoginClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AccountLogin.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AccountLogin ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccountLoginClientGeneratedCommandList : public ModelCommand {
public:
    ReportAccountLoginClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAccountLoginAttributeList : public ModelCommand {
public:
    ReadAccountLoginAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccountLoginAttributeList : public ModelCommand {
public:
    ReportAccountLoginAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAccountLoginClusterRevision : public ModelCommand {
public:
    ReadAccountLoginClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAccountLogin * cluster = [[CHIPAccountLogin alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AccountLogin.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AccountLogin ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAccountLoginClusterRevision : public ModelCommand {
public:
    ReportAccountLoginClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAccountLoginClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AdministratorCommissioning                                  | 0x003C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * OpenBasicCommissioningWindow                                      |   0x01 |
| * OpenCommissioningWindow                                           |   0x00 |
| * RevokeCommissioning                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WindowStatus                                                      | 0x0000 |
| * AdminFabricIndex                                                  | 0x0001 |
| * AdminVendorId                                                     | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command OpenBasicCommissioningWindow
 */
class AdministratorCommissioningOpenBasicCommissioningWindow : public ModelCommand {
public:
    AdministratorCommissioningOpenBasicCommissioningWindow()
        : ModelCommand("open-basic-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mCommissioningTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPAdministratorCommissioningClusterOpenBasicCommissioningWindowParams alloc] init];
        params.commissioningTimeout = [NSNumber numberWithUnsignedShort:mCommissioningTimeout];
        [cluster openBasicCommissioningWindowWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mCommissioningTimeout;
};

/*
 * Command OpenCommissioningWindow
 */
class AdministratorCommissioningOpenCommissioningWindow : public ModelCommand {
public:
    AdministratorCommissioningOpenCommissioningWindow()
        : ModelCommand("open-commissioning-window")
    {
        AddArgument("CommissioningTimeout", 0, UINT16_MAX, &mCommissioningTimeout);
        AddArgument("Discriminator", 0, UINT16_MAX, &mDiscriminator);
        AddArgument("Iterations", 0, UINT32_MAX, &mIterations);
        AddArgument("PasscodeID", 0, UINT16_MAX, &mPasscodeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPAdministratorCommissioningClusterOpenCommissioningWindowParams alloc] init];
        params.commissioningTimeout = [NSNumber numberWithUnsignedShort:mCommissioningTimeout];
        params.pakeVerifier = [[NSData alloc] initWithBytes:mPAKEVerifier.data() length:mPAKEVerifier.size()];
        params.discriminator = [NSNumber numberWithUnsignedShort:mDiscriminator];
        params.iterations = [NSNumber numberWithUnsignedInt:mIterations];
        params.salt = [[NSData alloc] initWithBytes:mSalt.data() length:mSalt.size()];
        params.passcodeID = [NSNumber numberWithUnsignedShort:mPasscodeID];
        [cluster openCommissioningWindowWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mCommissioningTimeout;
    chip::ByteSpan mPAKEVerifier;
    uint16_t mDiscriminator;
    uint32_t mIterations;
    chip::ByteSpan mSalt;
    uint16_t mPasscodeID;
};

/*
 * Command RevokeCommissioning
 */
class AdministratorCommissioningRevokeCommissioning : public ModelCommand {
public:
    AdministratorCommissioningRevokeCommissioning()
        : ModelCommand("revoke-commissioning")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster revokeCommissioningWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute WindowStatus
 */
class ReadAdministratorCommissioningWindowStatus : public ModelCommand {
public:
    ReadAdministratorCommissioningWindowStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "window-status");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeWindowStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.WindowStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning WindowStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningWindowStatus : public ModelCommand {
public:
    ReportAdministratorCommissioningWindowStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "window-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningWindowStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AdminFabricIndex
 */
class ReadAdministratorCommissioningAdminFabricIndex : public ModelCommand {
public:
    ReadAdministratorCommissioningAdminFabricIndex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeAdminFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AdminFabricIndex response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AdminFabricIndex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningAdminFabricIndex : public ModelCommand {
public:
    ReportAdministratorCommissioningAdminFabricIndex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "admin-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningAdminFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AdminVendorId
 */
class ReadAdministratorCommissioningAdminVendorId : public ModelCommand {
public:
    ReadAdministratorCommissioningAdminVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "admin-vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeAdminVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AdminVendorId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AdminVendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningAdminVendorId : public ModelCommand {
public:
    ReportAdministratorCommissioningAdminVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "admin-vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningAdminVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAdministratorCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReadAdministratorCommissioningServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AdministratorCommissioning.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AdministratorCommissioning ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReportAdministratorCommissioningServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAdministratorCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReadAdministratorCommissioningClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AdministratorCommissioning.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AdministratorCommissioning ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReportAdministratorCommissioningClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAdministratorCommissioningAttributeList : public ModelCommand {
public:
    ReadAdministratorCommissioningAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningAttributeList : public ModelCommand {
public:
    ReportAdministratorCommissioningAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAdministratorCommissioningClusterRevision : public ModelCommand {
public:
    ReadAdministratorCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAdministratorCommissioning * cluster = [[CHIPAdministratorCommissioning alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AdministratorCommissioning.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AdministratorCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAdministratorCommissioningClusterRevision : public ModelCommand {
public:
    ReportAdministratorCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAdministratorCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003C) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationBasic                                            | 0x050D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0000 |
| * VendorId                                                          | 0x0001 |
| * ApplicationName                                                   | 0x0002 |
| * ProductId                                                         | 0x0003 |
| * ApplicationApp                                                    | 0x0004 |
| * ApplicationStatus                                                 | 0x0005 |
| * ApplicationVersion                                                | 0x0006 |
| * AllowedVendorList                                                 | 0x0007 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute VendorName
 */
class ReadApplicationBasicVendorName : public ModelCommand {
public:
    ReadApplicationBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.VendorName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicVendorName : public ModelCommand {
public:
    ReportApplicationBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadApplicationBasicVendorId : public ModelCommand {
public:
    ReadApplicationBasicVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.VendorId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic VendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicVendorId : public ModelCommand {
public:
    ReportApplicationBasicVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationName
 */
class ReadApplicationBasicApplicationName : public ModelCommand {
public:
    ReadApplicationBasicApplicationName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-name");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeApplicationNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicApplicationName : public ModelCommand {
public:
    ReportApplicationBasicApplicationName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductId
 */
class ReadApplicationBasicProductId : public ModelCommand {
public:
    ReadApplicationBasicProductId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicProductId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeProductIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ProductId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ProductId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicProductId : public ModelCommand {
public:
    ReportApplicationBasicProductId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicProductId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationStatus
 */
class ReadApplicationBasicApplicationStatus : public ModelCommand {
public:
    ReadApplicationBasicApplicationStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-status");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeApplicationStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicApplicationStatus : public ModelCommand {
public:
    ReportApplicationBasicApplicationStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ApplicationVersion
 */
class ReadApplicationBasicApplicationVersion : public ModelCommand {
public:
    ReadApplicationBasicApplicationVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-version");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeApplicationVersionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ApplicationVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ApplicationVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicApplicationVersion : public ModelCommand {
public:
    ReportApplicationBasicApplicationVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicApplicationVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AllowedVendorList
 */
class ReadApplicationBasicAllowedVendorList : public ModelCommand {
public:
    ReadApplicationBasicAllowedVendorList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeAllowedVendorListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AllowedVendorList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AllowedVendorList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicAllowedVendorList : public ModelCommand {
public:
    ReportApplicationBasicAllowedVendorList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "allowed-vendor-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicAllowedVendorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadApplicationBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationBasic.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationBasic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReportApplicationBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadApplicationBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationBasic.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationBasic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReportApplicationBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationBasicAttributeList : public ModelCommand {
public:
    ReadApplicationBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicAttributeList : public ModelCommand {
public:
    ReportApplicationBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationBasicClusterRevision : public ModelCommand {
public:
    ReadApplicationBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationBasic * cluster = [[CHIPApplicationBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationBasic.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationBasicClusterRevision : public ModelCommand {
public:
    ReportApplicationBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050D) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ApplicationLauncher                                         | 0x050C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * HideAppRequest                                                    |   0x02 |
| * LaunchAppRequest                                                  |   0x00 |
| * StopAppRequest                                                    |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ApplicationLauncherList                                           | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideAppRequest
 */
class ApplicationLauncherHideAppRequest : public ModelCommand {
public:
    ApplicationLauncherHideAppRequest()
        : ModelCommand("hide-app-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        __auto_type * params = [[CHIPApplicationLauncherClusterHideAppRequestParams alloc] init];
        // application Struct parsing is not supported yet
        [cluster hideAppRequestWithParams:params
                        completionHandler:^(
                            CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command LaunchAppRequest
 */
class ApplicationLauncherLaunchAppRequest : public ModelCommand {
public:
    ApplicationLauncherLaunchAppRequest()
        : ModelCommand("launch-app-request")
    {
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        __auto_type * params = [[CHIPApplicationLauncherClusterLaunchAppRequestParams alloc] init];
        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        // application Struct parsing is not supported yet
        [cluster launchAppRequestWithParams:params
                          completionHandler:^(
                              CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              CHIP_ERROR err = CHIP_NO_ERROR;
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mData;
};

/*
 * Command StopAppRequest
 */
class ApplicationLauncherStopAppRequest : public ModelCommand {
public:
    ApplicationLauncherStopAppRequest()
        : ModelCommand("stop-app-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        __auto_type * params = [[CHIPApplicationLauncherClusterStopAppRequestParams alloc] init];
        // application Struct parsing is not supported yet
        [cluster stopAppRequestWithParams:params
                        completionHandler:^(
                            CHIPApplicationLauncherClusterLauncherResponseParams * _Nullable values, NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute ApplicationLauncherList
 */
class ReadApplicationLauncherApplicationLauncherList : public ModelCommand {
public:
    ReadApplicationLauncherApplicationLauncherList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "application-launcher-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherApplicationLauncherList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeApplicationLauncherListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.ApplicationLauncherList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher ApplicationLauncherList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationLauncherApplicationLauncherList : public ModelCommand {
public:
    ReportApplicationLauncherApplicationLauncherList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "application-launcher-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherApplicationLauncherList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadApplicationLauncherServerGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationLauncherServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationLauncher.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationLauncher ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationLauncherServerGeneratedCommandList : public ModelCommand {
public:
    ReportApplicationLauncherServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadApplicationLauncherClientGeneratedCommandList : public ModelCommand {
public:
    ReadApplicationLauncherClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ApplicationLauncher.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ApplicationLauncher ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationLauncherClientGeneratedCommandList : public ModelCommand {
public:
    ReportApplicationLauncherClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadApplicationLauncherAttributeList : public ModelCommand {
public:
    ReadApplicationLauncherAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationLauncherAttributeList : public ModelCommand {
public:
    ReportApplicationLauncherAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadApplicationLauncherClusterRevision : public ModelCommand {
public:
    ReadApplicationLauncherClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPApplicationLauncher * cluster = [[CHIPApplicationLauncher alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ApplicationLauncher.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ApplicationLauncher ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportApplicationLauncherClusterRevision : public ModelCommand {
public:
    ReportApplicationLauncherClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportApplicationLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050C) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster AudioOutput                                                 | 0x050B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RenameOutputRequest                                               |   0x01 |
| * SelectOutputRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AudioOutputList                                                   | 0x0000 |
| * CurrentAudioOutput                                                | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RenameOutputRequest
 */
class AudioOutputRenameOutputRequest : public ModelCommand {
public:
    AudioOutputRenameOutputRequest()
        : ModelCommand("rename-output-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        AddArgument("Name", &mName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPAudioOutputClusterRenameOutputRequestParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        params.name = [[NSString alloc] initWithBytes:mName.data() length:mName.size() encoding:NSUTF8StringEncoding];
        [cluster renameOutputRequestWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mIndex;
    chip::ByteSpan mName;
};

/*
 * Command SelectOutputRequest
 */
class AudioOutputSelectOutputRequest : public ModelCommand {
public:
    AudioOutputSelectOutputRequest()
        : ModelCommand("select-output-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPAudioOutputClusterSelectOutputRequestParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        [cluster selectOutputRequestWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mIndex;
};

/*
 * Attribute AudioOutputList
 */
class ReadAudioOutputAudioOutputList : public ModelCommand {
public:
    ReadAudioOutputAudioOutputList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "audio-output-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAudioOutputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAudioOutputListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.AudioOutputList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput AudioOutputList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputAudioOutputList : public ModelCommand {
public:
    ReportAudioOutputAudioOutputList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "audio-output-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputAudioOutputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentAudioOutput
 */
class ReadAudioOutputCurrentAudioOutput : public ModelCommand {
public:
    ReadAudioOutputCurrentAudioOutput()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-audio-output");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputCurrentAudioOutput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentAudioOutputWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.CurrentAudioOutput response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput CurrentAudioOutput Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputCurrentAudioOutput : public ModelCommand {
public:
    ReportAudioOutputCurrentAudioOutput()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-audio-output");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputCurrentAudioOutput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadAudioOutputServerGeneratedCommandList : public ModelCommand {
public:
    ReadAudioOutputServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AudioOutput.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AudioOutput ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputServerGeneratedCommandList : public ModelCommand {
public:
    ReportAudioOutputServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadAudioOutputClientGeneratedCommandList : public ModelCommand {
public:
    ReadAudioOutputClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"AudioOutput.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "AudioOutput ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputClientGeneratedCommandList : public ModelCommand {
public:
    ReportAudioOutputClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadAudioOutputAttributeList : public ModelCommand {
public:
    ReadAudioOutputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputAttributeList : public ModelCommand {
public:
    ReportAudioOutputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadAudioOutputClusterRevision : public ModelCommand {
public:
    ReadAudioOutputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPAudioOutput * cluster = [[CHIPAudioOutput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"AudioOutput.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "AudioOutput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportAudioOutputClusterRevision : public ModelCommand {
public:
    ReportAudioOutputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportAudioOutputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050B) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BarrierControl                                              | 0x0103 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * BarrierControlGoToPercent                                         |   0x00 |
| * BarrierControlStop                                                |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * BarrierMovingState                                                | 0x0001 |
| * BarrierSafetyStatus                                               | 0x0002 |
| * BarrierCapabilities                                               | 0x0003 |
| * BarrierPosition                                                   | 0x000A |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command BarrierControlGoToPercent
 */
class BarrierControlBarrierControlGoToPercent : public ModelCommand {
public:
    BarrierControlBarrierControlGoToPercent()
        : ModelCommand("barrier-control-go-to-percent")
    {
        AddArgument("PercentOpen", 0, UINT8_MAX, &mPercentOpen);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBarrierControlClusterBarrierControlGoToPercentParams alloc] init];
        params.percentOpen = [NSNumber numberWithUnsignedChar:mPercentOpen];
        [cluster barrierControlGoToPercentWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mPercentOpen;
};

/*
 * Command BarrierControlStop
 */
class BarrierControlBarrierControlStop : public ModelCommand {
public:
    BarrierControlBarrierControlStop()
        : ModelCommand("barrier-control-stop")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster barrierControlStopWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute BarrierMovingState
 */
class ReadBarrierControlBarrierMovingState : public ModelCommand {
public:
    ReadBarrierControlBarrierMovingState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-moving-state");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBarrierMovingStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierMovingState response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierMovingState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlBarrierMovingState : public ModelCommand {
public:
    ReportBarrierControlBarrierMovingState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-moving-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierMovingState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierSafetyStatus
 */
class ReadBarrierControlBarrierSafetyStatus : public ModelCommand {
public:
    ReadBarrierControlBarrierSafetyStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBarrierSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierSafetyStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierSafetyStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlBarrierSafetyStatus : public ModelCommand {
public:
    ReportBarrierControlBarrierSafetyStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierCapabilities
 */
class ReadBarrierControlBarrierCapabilities : public ModelCommand {
public:
    ReadBarrierControlBarrierCapabilities()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBarrierCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierCapabilities response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierCapabilities Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlBarrierCapabilities : public ModelCommand {
public:
    ReportBarrierControlBarrierCapabilities()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BarrierPosition
 */
class ReadBarrierControlBarrierPosition : public ModelCommand {
public:
    ReadBarrierControlBarrierPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "barrier-position");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBarrierPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.BarrierPosition response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl BarrierPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlBarrierPosition : public ModelCommand {
public:
    ReportBarrierControlBarrierPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "barrier-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlBarrierPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBarrierControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadBarrierControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BarrierControl.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BarrierControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlServerGeneratedCommandList : public ModelCommand {
public:
    ReportBarrierControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBarrierControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadBarrierControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BarrierControl.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BarrierControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlClientGeneratedCommandList : public ModelCommand {
public:
    ReportBarrierControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBarrierControlAttributeList : public ModelCommand {
public:
    ReadBarrierControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlAttributeList : public ModelCommand {
public:
    ReportBarrierControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBarrierControlClusterRevision : public ModelCommand {
public:
    ReadBarrierControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBarrierControl * cluster = [[CHIPBarrierControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BarrierControl.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BarrierControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBarrierControlClusterRevision : public ModelCommand {
public:
    ReportBarrierControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBarrierControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000103) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Basic                                                       | 0x0028 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DataModelRevision                                                 | 0x0000 |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * ProductID                                                         | 0x0004 |
| * NodeLabel                                                         | 0x0005 |
| * Location                                                          | 0x0006 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * LocalConfigDisabled                                               | 0x0010 |
| * Reachable                                                         | 0x0011 |
| * UniqueID                                                          | 0x0012 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Event StartUp
 */
class ReadBasicStartUp : public ModelCommand {
public:
    ReadBasicStartUp()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "start-up");
        ModelCommand::AddArguments();
    }

    ~ReadBasicStartUp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBasicStartUp : public ModelCommand {
public:
    ReportBasicStartUp()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "start-up");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicStartUp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ShutDown
 */
class ReadBasicShutDown : public ModelCommand {
public:
    ReadBasicShutDown()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "shut-down");
        ModelCommand::AddArguments();
    }

    ~ReadBasicShutDown() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBasicShutDown : public ModelCommand {
public:
    ReportBasicShutDown()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "shut-down");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicShutDown() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event Leave
 */
class ReadBasicLeave : public ModelCommand {
public:
    ReadBasicLeave()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "leave");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLeave() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBasicLeave : public ModelCommand {
public:
    ReportBasicLeave()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "leave");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLeave() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ReachableChanged
 */
class ReadBasicReachableChanged : public ModelCommand {
public:
    ReadBasicReachableChanged()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "reachable-changed");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachableChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBasicReachableChanged : public ModelCommand {
public:
    ReportBasicReachableChanged()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "reachable-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicReachableChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DataModelRevision
 */
class ReadBasicDataModelRevision : public ModelCommand {
public:
    ReadBasicDataModelRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "data-model-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicDataModelRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDataModelRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.DataModelRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic DataModelRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicDataModelRevision : public ModelCommand {
public:
    ReportBasicDataModelRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "data-model-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicDataModelRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadBasicVendorName : public ModelCommand {
public:
    ReadBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.VendorName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicVendorName : public ModelCommand {
public:
    ReportBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBasicVendorID : public ModelCommand {
public:
    ReadBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.VendorID response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicVendorID : public ModelCommand {
public:
    ReportBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBasicProductName : public ModelCommand {
public:
    ReadBasicProductName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicProductName : public ModelCommand {
public:
    ReportBasicProductName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductID
 */
class ReadBasicProductID : public ModelCommand {
public:
    ReadBasicProductID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeProductIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductID response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicProductID : public ModelCommand {
public:
    ReportBasicProductID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBasicNodeLabel : public ModelCommand {
public:
    ReadBasicNodeLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.NodeLabel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic NodeLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteBasicNodeLabel : public ModelCommand {
public:
    WriteBasicNodeLabel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNodeLabelWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogError(chipTool, "Basic NodeLabel Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportBasicNodeLabel : public ModelCommand {
public:
    ReportBasicNodeLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Location
 */
class ReadBasicLocation : public ModelCommand {
public:
    ReadBasicLocation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "location");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLocationWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.Location response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic Location Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteBasicLocation : public ModelCommand {
public:
    WriteBasicLocation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "location");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLocationWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "Basic Location Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportBasicLocation : public ModelCommand {
public:
    ReportBasicLocation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "location");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLocation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBasicHardwareVersion : public ModelCommand {
public:
    ReadBasicHardwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.HardwareVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic HardwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicHardwareVersion : public ModelCommand {
public:
    ReportBasicHardwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBasicHardwareVersionString : public ModelCommand {
public:
    ReadBasicHardwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.HardwareVersionString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic HardwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicHardwareVersionString : public ModelCommand {
public:
    ReportBasicHardwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBasicSoftwareVersion : public ModelCommand {
public:
    ReadBasicSoftwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SoftwareVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SoftwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicSoftwareVersion : public ModelCommand {
public:
    ReportBasicSoftwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBasicSoftwareVersionString : public ModelCommand {
public:
    ReadBasicSoftwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SoftwareVersionString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SoftwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicSoftwareVersionString : public ModelCommand {
public:
    ReportBasicSoftwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBasicManufacturingDate : public ModelCommand {
public:
    ReadBasicManufacturingDate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ManufacturingDate response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ManufacturingDate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicManufacturingDate : public ModelCommand {
public:
    ReportBasicManufacturingDate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBasicPartNumber : public ModelCommand {
public:
    ReadBasicPartNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.PartNumber response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic PartNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicPartNumber : public ModelCommand {
public:
    ReportBasicPartNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBasicProductURL : public ModelCommand {
public:
    ReadBasicProductURL()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductURL response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductURL Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicProductURL : public ModelCommand {
public:
    ReportBasicProductURL()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBasicProductLabel : public ModelCommand {
public:
    ReadBasicProductLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ProductLabel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ProductLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicProductLabel : public ModelCommand {
public:
    ReportBasicProductLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBasicSerialNumber : public ModelCommand {
public:
    ReadBasicSerialNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.SerialNumber response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic SerialNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicSerialNumber : public ModelCommand {
public:
    ReportBasicSerialNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocalConfigDisabled
 */
class ReadBasicLocalConfigDisabled : public ModelCommand {
public:
    ReadBasicLocalConfigDisabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "local-config-disabled");
        ModelCommand::AddArguments();
    }

    ~ReadBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLocalConfigDisabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.LocalConfigDisabled response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic LocalConfigDisabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteBasicLocalConfigDisabled : public ModelCommand {
public:
    WriteBasicLocalConfigDisabled()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeLocalConfigDisabledWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              CHIP_ERROR err = CHIP_NO_ERROR;
                                              err = [CHIPError errorToCHIPErrorCode:error];

                                              ChipLogError(chipTool, "Basic LocalConfigDisabled Error: %s", chip::ErrorStr(err));
                                              SetCommandExitStatus(err);
                                          }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportBasicLocalConfigDisabled : public ModelCommand {
public:
    ReportBasicLocalConfigDisabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "local-config-disabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicLocalConfigDisabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBasicReachable : public ModelCommand {
public:
    ReadBasicReachable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.Reachable response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic Reachable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicReachable : public ModelCommand {
public:
    ReportBasicReachable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UniqueID
 */
class ReadBasicUniqueID : public ModelCommand {
public:
    ReadBasicUniqueID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unique-id");
        ModelCommand::AddArguments();
    }

    ~ReadBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeUniqueIDWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.UniqueID response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic UniqueID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicUniqueID : public ModelCommand {
public:
    ReportBasicUniqueID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unique-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicUniqueID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Basic.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Basic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReportBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Basic.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Basic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReportBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBasicAttributeList : public ModelCommand {
public:
    ReadBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicAttributeList : public ModelCommand {
public:
    ReportBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBasicClusterRevision : public ModelCommand {
public:
    ReadBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBasic * cluster = [[CHIPBasic alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Basic.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Basic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBasicClusterRevision : public ModelCommand {
public:
    ReportBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000028) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BinaryInputBasic                                            | 0x000F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OutOfService                                                      | 0x0051 |
| * PresentValue                                                      | 0x0055 |
| * StatusFlags                                                       | 0x006F |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute OutOfService
 */
class ReadBinaryInputBasicOutOfService : public ModelCommand {
public:
    ReadBinaryInputBasicOutOfService()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "out-of-service");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x00000051) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeOutOfServiceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.OutOfService response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic OutOfService Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteBinaryInputBasicOutOfService : public ModelCommand {
public:
    WriteBinaryInputBasicOutOfService()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) WriteAttribute (0x00000051) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeOutOfServiceWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "BinaryInputBasic OutOfService Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportBinaryInputBasicOutOfService : public ModelCommand {
public:
    ReportBinaryInputBasicOutOfService()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "out-of-service");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicOutOfService() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x00000051) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PresentValue
 */
class ReadBinaryInputBasicPresentValue : public ModelCommand {
public:
    ReadBinaryInputBasicPresentValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "present-value");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x00000055) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributePresentValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.PresentValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic PresentValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteBinaryInputBasicPresentValue : public ModelCommand {
public:
    WriteBinaryInputBasicPresentValue()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) WriteAttribute (0x00000055) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributePresentValueWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "BinaryInputBasic PresentValue Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportBinaryInputBasicPresentValue : public ModelCommand {
public:
    ReportBinaryInputBasicPresentValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "present-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicPresentValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x00000055) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StatusFlags
 */
class ReadBinaryInputBasicStatusFlags : public ModelCommand {
public:
    ReadBinaryInputBasicStatusFlags()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status-flags");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000006F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeStatusFlagsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.StatusFlags response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic StatusFlags Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBinaryInputBasicStatusFlags : public ModelCommand {
public:
    ReportBinaryInputBasicStatusFlags()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status-flags");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicStatusFlags() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000006F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBinaryInputBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadBinaryInputBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BinaryInputBasic.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BinaryInputBasic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBinaryInputBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReportBinaryInputBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBinaryInputBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadBinaryInputBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BinaryInputBasic.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BinaryInputBasic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBinaryInputBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReportBinaryInputBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBinaryInputBasicAttributeList : public ModelCommand {
public:
    ReadBinaryInputBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBinaryInputBasicAttributeList : public ModelCommand {
public:
    ReportBinaryInputBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBinaryInputBasicClusterRevision : public ModelCommand {
public:
    ReadBinaryInputBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinaryInputBasic * cluster = [[CHIPBinaryInputBasic alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BinaryInputBasic.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BinaryInputBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBinaryInputBasicClusterRevision : public ModelCommand {
public:
    ReportBinaryInputBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBinaryInputBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000000F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Binding                                                     | 0x001E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Bind                                                              |   0x00 |
| * Unbind                                                            |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Bind
 */
class BindingBind : public ModelCommand {
public:
    BindingBind()
        : ModelCommand("bind")
    {
        AddArgument("NodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("EndpointId", 0, UINT16_MAX, &mEndpointId);
        AddArgument("ClusterId", 0, UINT32_MAX, &mClusterId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBindingClusterBindParams alloc] init];
        params.nodeId = [NSNumber numberWithUnsignedLongLong:mNodeId];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.endpointId = [NSNumber numberWithUnsignedShort:mEndpointId];
        params.clusterId = [NSNumber numberWithUnsignedInt:mClusterId];
        [cluster bindWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  CHIP_ERROR err = CHIP_NO_ERROR;
                  err = [CHIPError errorToCHIPErrorCode:error];

                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];

        return CHIP_NO_ERROR;
    }

private:
    chip::NodeId mNodeId;
    chip::GroupId mGroupId;
    chip::EndpointId mEndpointId;
    chip::ClusterId mClusterId;
};

/*
 * Command Unbind
 */
class BindingUnbind : public ModelCommand {
public:
    BindingUnbind()
        : ModelCommand("unbind")
    {
        AddArgument("NodeId", 0, UINT64_MAX, &mNodeId);
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("EndpointId", 0, UINT16_MAX, &mEndpointId);
        AddArgument("ClusterId", 0, UINT32_MAX, &mClusterId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBindingClusterUnbindParams alloc] init];
        params.nodeId = [NSNumber numberWithUnsignedLongLong:mNodeId];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.endpointId = [NSNumber numberWithUnsignedShort:mEndpointId];
        params.clusterId = [NSNumber numberWithUnsignedInt:mClusterId];
        [cluster unbindWithParams:params
                completionHandler:^(NSError * _Nullable error) {
                    CHIP_ERROR err = CHIP_NO_ERROR;
                    err = [CHIPError errorToCHIPErrorCode:error];

                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                    SetCommandExitStatus(err);
                }];

        return CHIP_NO_ERROR;
    }

private:
    chip::NodeId mNodeId;
    chip::GroupId mGroupId;
    chip::EndpointId mEndpointId;
    chip::ClusterId mClusterId;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBindingServerGeneratedCommandList : public ModelCommand {
public:
    ReadBindingServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Binding.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Binding ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBindingServerGeneratedCommandList : public ModelCommand {
public:
    ReportBindingServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBindingClientGeneratedCommandList : public ModelCommand {
public:
    ReadBindingClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Binding.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Binding ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBindingClientGeneratedCommandList : public ModelCommand {
public:
    ReportBindingClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBindingAttributeList : public ModelCommand {
public:
    ReadBindingAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBindingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBindingAttributeList : public ModelCommand {
public:
    ReportBindingAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBindingClusterRevision : public ModelCommand {
public:
    ReadBindingClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBindingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBinding * cluster = [[CHIPBinding alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Binding.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Binding ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBindingClusterRevision : public ModelCommand {
public:
    ReportBindingClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBindingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BooleanState                                                | 0x0045 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * StateValue                                                        | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChange                                                       | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Event StateChange
 */
class ReadBooleanStateStateChange : public ModelCommand {
public:
    ReadBooleanStateStateChange()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "state-change");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBooleanStateStateChange : public ModelCommand {
public:
    ReportBooleanStateStateChange()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "state-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateStateChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StateValue
 */
class ReadBooleanStateStateValue : public ModelCommand {
public:
    ReadBooleanStateStateValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "state-value");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStateValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.StateValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState StateValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBooleanStateStateValue : public ModelCommand {
public:
    ReportBooleanStateStateValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "state-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateStateValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBooleanStateServerGeneratedCommandList : public ModelCommand {
public:
    ReadBooleanStateServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BooleanState.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BooleanState ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBooleanStateServerGeneratedCommandList : public ModelCommand {
public:
    ReportBooleanStateServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBooleanStateClientGeneratedCommandList : public ModelCommand {
public:
    ReadBooleanStateClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BooleanState.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BooleanState ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBooleanStateClientGeneratedCommandList : public ModelCommand {
public:
    ReportBooleanStateClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBooleanStateAttributeList : public ModelCommand {
public:
    ReadBooleanStateAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBooleanStateAttributeList : public ModelCommand {
public:
    ReportBooleanStateAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBooleanStateClusterRevision : public ModelCommand {
public:
    ReadBooleanStateClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBooleanState * cluster = [[CHIPBooleanState alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BooleanState.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BooleanState ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBooleanStateClusterRevision : public ModelCommand {
public:
    ReportBooleanStateClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBooleanStateClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000045) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedActions                                              | 0x0025 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * DisableAction                                                     |   0x0A |
| * DisableActionWithDuration                                         |   0x0B |
| * EnableAction                                                      |   0x08 |
| * EnableActionWithDuration                                          |   0x09 |
| * InstantAction                                                     |   0x00 |
| * InstantActionWithTransition                                       |   0x01 |
| * PauseAction                                                       |   0x05 |
| * PauseActionWithDuration                                           |   0x06 |
| * ResumeAction                                                      |   0x07 |
| * StartAction                                                       |   0x02 |
| * StartActionWithDuration                                           |   0x03 |
| * StopAction                                                        |   0x04 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActionList                                                        | 0x0000 |
| * EndpointList                                                      | 0x0001 |
| * SetupUrl                                                          | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateChanged                                                      | 0x0000 |
| * ActionFailed                                                      | 0x0001 |
\*----------------------------------------------------------------------------*/

/*
 * Command DisableAction
 */
class BridgedActionsDisableAction : public ModelCommand {
public:
    BridgedActionsDisableAction()
        : ModelCommand("disable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterDisableActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster disableActionWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command DisableActionWithDuration
 */
class BridgedActionsDisableActionWithDuration : public ModelCommand {
public:
    BridgedActionsDisableActionWithDuration()
        : ModelCommand("disable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterDisableActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster disableActionWithDurationWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command EnableAction
 */
class BridgedActionsEnableAction : public ModelCommand {
public:
    BridgedActionsEnableAction()
        : ModelCommand("enable-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterEnableActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster enableActionWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command EnableActionWithDuration
 */
class BridgedActionsEnableActionWithDuration : public ModelCommand {
public:
    BridgedActionsEnableActionWithDuration()
        : ModelCommand("enable-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterEnableActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster enableActionWithDurationWithParams:params
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command InstantAction
 */
class BridgedActionsInstantAction : public ModelCommand {
public:
    BridgedActionsInstantAction()
        : ModelCommand("instant-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterInstantActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster instantActionWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command InstantActionWithTransition
 */
class BridgedActionsInstantActionWithTransition : public ModelCommand {
public:
    BridgedActionsInstantActionWithTransition()
        : ModelCommand("instant-action-with-transition")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterInstantActionWithTransitionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster instantActionWithTransitionWithParams:params
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint16_t mTransitionTime;
};

/*
 * Command PauseAction
 */
class BridgedActionsPauseAction : public ModelCommand {
public:
    BridgedActionsPauseAction()
        : ModelCommand("pause-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterPauseActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster pauseActionWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command PauseActionWithDuration
 */
class BridgedActionsPauseActionWithDuration : public ModelCommand {
public:
    BridgedActionsPauseActionWithDuration()
        : ModelCommand("pause-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterPauseActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster pauseActionWithDurationWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command ResumeAction
 */
class BridgedActionsResumeAction : public ModelCommand {
public:
    BridgedActionsResumeAction()
        : ModelCommand("resume-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterResumeActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster resumeActionWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command StartAction
 */
class BridgedActionsStartAction : public ModelCommand {
public:
    BridgedActionsStartAction()
        : ModelCommand("start-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterStartActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster startActionWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Command StartActionWithDuration
 */
class BridgedActionsStartActionWithDuration : public ModelCommand {
public:
    BridgedActionsStartActionWithDuration()
        : ModelCommand("start-action-with-duration")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        AddArgument("Duration", 0, UINT32_MAX, &mDuration);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterStartActionWithDurationParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        params.duration = [NSNumber numberWithUnsignedInt:mDuration];
        [cluster startActionWithDurationWithParams:params
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
    uint32_t mDuration;
};

/*
 * Command StopAction
 */
class BridgedActionsStopAction : public ModelCommand {
public:
    BridgedActionsStopAction()
        : ModelCommand("stop-action")
    {
        AddArgument("ActionID", 0, UINT16_MAX, &mActionID);
        AddArgument("InvokeID", 0, UINT32_MAX, &mInvokeID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPBridgedActionsClusterStopActionParams alloc] init];
        params.actionID = [NSNumber numberWithUnsignedShort:mActionID];
        params.invokeID = [NSNumber numberWithUnsignedInt:mInvokeID];
        [cluster stopActionWithParams:params
                    completionHandler:^(NSError * _Nullable error) {
                        CHIP_ERROR err = CHIP_NO_ERROR;
                        err = [CHIPError errorToCHIPErrorCode:error];

                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mActionID;
    uint32_t mInvokeID;
};

/*
 * Event StateChanged
 */
class ReadBridgedActionsStateChanged : public ModelCommand {
public:
    ReadBridgedActionsStateChanged()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "state-changed");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsStateChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBridgedActionsStateChanged : public ModelCommand {
public:
    ReportBridgedActionsStateChanged()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "state-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsStateChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ActionFailed
 */
class ReadBridgedActionsActionFailed : public ModelCommand {
public:
    ReadBridgedActionsActionFailed()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "action-failed");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionFailed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBridgedActionsActionFailed : public ModelCommand {
public:
    ReportBridgedActionsActionFailed()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "action-failed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsActionFailed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActionList
 */
class ReadBridgedActionsActionList : public ModelCommand {
public:
    ReadBridgedActionsActionList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "action-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeActionListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.ActionList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions ActionList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsActionList : public ModelCommand {
public:
    ReportBridgedActionsActionList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "action-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsActionList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndpointList
 */
class ReadBridgedActionsEndpointList : public ModelCommand {
public:
    ReadBridgedActionsEndpointList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "endpoint-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEndpointListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.EndpointList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions EndpointList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsEndpointList : public ModelCommand {
public:
    ReportBridgedActionsEndpointList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "endpoint-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsEndpointList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SetupUrl
 */
class ReadBridgedActionsSetupUrl : public ModelCommand {
public:
    ReadBridgedActionsSetupUrl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "setup-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSetupUrlWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.SetupUrl response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions SetupUrl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsSetupUrl : public ModelCommand {
public:
    ReportBridgedActionsSetupUrl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "setup-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsSetupUrl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBridgedActionsServerGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedActionsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedActions.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedActions ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsServerGeneratedCommandList : public ModelCommand {
public:
    ReportBridgedActionsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBridgedActionsClientGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedActionsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedActions.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedActions ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsClientGeneratedCommandList : public ModelCommand {
public:
    ReportBridgedActionsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedActionsAttributeList : public ModelCommand {
public:
    ReadBridgedActionsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsAttributeList : public ModelCommand {
public:
    ReportBridgedActionsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedActionsClusterRevision : public ModelCommand {
public:
    ReadBridgedActionsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedActions * cluster = [[CHIPBridgedActions alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedActions.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedActions ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedActionsClusterRevision : public ModelCommand {
public:
    ReportBridgedActionsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedActionsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000025) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster BridgedDeviceBasic                                          | 0x0039 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * VendorName                                                        | 0x0001 |
| * VendorID                                                          | 0x0002 |
| * ProductName                                                       | 0x0003 |
| * NodeLabel                                                         | 0x0005 |
| * HardwareVersion                                                   | 0x0007 |
| * HardwareVersionString                                             | 0x0008 |
| * SoftwareVersion                                                   | 0x0009 |
| * SoftwareVersionString                                             | 0x000A |
| * ManufacturingDate                                                 | 0x000B |
| * PartNumber                                                        | 0x000C |
| * ProductURL                                                        | 0x000D |
| * ProductLabel                                                      | 0x000E |
| * SerialNumber                                                      | 0x000F |
| * Reachable                                                         | 0x0011 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StartUp                                                           | 0x0000 |
| * ShutDown                                                          | 0x0001 |
| * Leave                                                             | 0x0002 |
| * ReachableChanged                                                  | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Event StartUp
 */
class ReadBridgedDeviceBasicStartUp : public ModelCommand {
public:
    ReadBridgedDeviceBasicStartUp()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "start-up");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicStartUp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBridgedDeviceBasicStartUp : public ModelCommand {
public:
    ReportBridgedDeviceBasicStartUp()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "start-up");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicStartUp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ShutDown
 */
class ReadBridgedDeviceBasicShutDown : public ModelCommand {
public:
    ReadBridgedDeviceBasicShutDown()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "shut-down");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicShutDown() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBridgedDeviceBasicShutDown : public ModelCommand {
public:
    ReportBridgedDeviceBasicShutDown()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "shut-down");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicShutDown() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event Leave
 */
class ReadBridgedDeviceBasicLeave : public ModelCommand {
public:
    ReadBridgedDeviceBasicLeave()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "leave");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicLeave() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBridgedDeviceBasicLeave : public ModelCommand {
public:
    ReportBridgedDeviceBasicLeave()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "leave");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicLeave() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ReachableChanged
 */
class ReadBridgedDeviceBasicReachableChanged : public ModelCommand {
public:
    ReadBridgedDeviceBasicReachableChanged()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "reachable-changed");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicReachableChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportBridgedDeviceBasicReachableChanged : public ModelCommand {
public:
    ReportBridgedDeviceBasicReachableChanged()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "reachable-changed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicReachableChanged() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorName
 */
class ReadBridgedDeviceBasicVendorName : public ModelCommand {
public:
    ReadBridgedDeviceBasicVendorName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-name");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeVendorNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.VendorName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic VendorName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicVendorName : public ModelCommand {
public:
    ReportBridgedDeviceBasicVendorName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicVendorName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorID
 */
class ReadBridgedDeviceBasicVendorID : public ModelCommand {
public:
    ReadBridgedDeviceBasicVendorID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeVendorIDWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.VendorID response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic VendorID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicVendorID : public ModelCommand {
public:
    ReportBridgedDeviceBasicVendorID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicVendorID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductName
 */
class ReadBridgedDeviceBasicProductName : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-name");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeProductNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicProductName : public ModelCommand {
public:
    ReportBridgedDeviceBasicProductName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicProductName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NodeLabel
 */
class ReadBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    ReadBridgedDeviceBasicNodeLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "node-label");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeNodeLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.NodeLabel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic NodeLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    WriteBridgedDeviceBasicNodeLabel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) WriteAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeNodeLabelWithValue:value
                                completionHandler:^(NSError * _Nullable error) {
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogError(chipTool, "BridgedDeviceBasic NodeLabel Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportBridgedDeviceBasicNodeLabel : public ModelCommand {
public:
    ReportBridgedDeviceBasicNodeLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "node-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicNodeLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersion
 */
class ReadBridgedDeviceBasicHardwareVersion : public ModelCommand {
public:
    ReadBridgedDeviceBasicHardwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeHardwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.HardwareVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic HardwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicHardwareVersion : public ModelCommand {
public:
    ReportBridgedDeviceBasicHardwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicHardwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute HardwareVersionString
 */
class ReadBridgedDeviceBasicHardwareVersionString : public ModelCommand {
public:
    ReadBridgedDeviceBasicHardwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hardware-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeHardwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.HardwareVersionString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic HardwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicHardwareVersionString : public ModelCommand {
public:
    ReportBridgedDeviceBasicHardwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hardware-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicHardwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersion
 */
class ReadBridgedDeviceBasicSoftwareVersion : public ModelCommand {
public:
    ReadBridgedDeviceBasicSoftwareVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeSoftwareVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SoftwareVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SoftwareVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicSoftwareVersion : public ModelCommand {
public:
    ReportBridgedDeviceBasicSoftwareVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicSoftwareVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoftwareVersionString
 */
class ReadBridgedDeviceBasicSoftwareVersionString : public ModelCommand {
public:
    ReadBridgedDeviceBasicSoftwareVersionString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "software-version-string");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeSoftwareVersionStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SoftwareVersionString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SoftwareVersionString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicSoftwareVersionString : public ModelCommand {
public:
    ReportBridgedDeviceBasicSoftwareVersionString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "software-version-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicSoftwareVersionString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ManufacturingDate
 */
class ReadBridgedDeviceBasicManufacturingDate : public ModelCommand {
public:
    ReadBridgedDeviceBasicManufacturingDate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "manufacturing-date");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeManufacturingDateWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ManufacturingDate response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ManufacturingDate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicManufacturingDate : public ModelCommand {
public:
    ReportBridgedDeviceBasicManufacturingDate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "manufacturing-date");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicManufacturingDate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartNumber
 */
class ReadBridgedDeviceBasicPartNumber : public ModelCommand {
public:
    ReadBridgedDeviceBasicPartNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "part-number");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributePartNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.PartNumber response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic PartNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicPartNumber : public ModelCommand {
public:
    ReportBridgedDeviceBasicPartNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "part-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicPartNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductURL
 */
class ReadBridgedDeviceBasicProductURL : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductURL()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-url");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeProductURLWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductURL response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductURL Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicProductURL : public ModelCommand {
public:
    ReportBridgedDeviceBasicProductURL()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-url");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicProductURL() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ProductLabel
 */
class ReadBridgedDeviceBasicProductLabel : public ModelCommand {
public:
    ReadBridgedDeviceBasicProductLabel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "product-label");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeProductLabelWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ProductLabel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ProductLabel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicProductLabel : public ModelCommand {
public:
    ReportBridgedDeviceBasicProductLabel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "product-label");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicProductLabel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SerialNumber
 */
class ReadBridgedDeviceBasicSerialNumber : public ModelCommand {
public:
    ReadBridgedDeviceBasicSerialNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "serial-number");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeSerialNumberWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.SerialNumber response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic SerialNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicSerialNumber : public ModelCommand {
public:
    ReportBridgedDeviceBasicSerialNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "serial-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicSerialNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Reachable
 */
class ReadBridgedDeviceBasicReachable : public ModelCommand {
public:
    ReadBridgedDeviceBasicReachable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reachable");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeReachableWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.Reachable response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic Reachable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicReachable : public ModelCommand {
public:
    ReportBridgedDeviceBasicReachable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reachable");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicReachable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadBridgedDeviceBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedDeviceBasicServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedDeviceBasic.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedDeviceBasic ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicServerGeneratedCommandList : public ModelCommand {
public:
    ReportBridgedDeviceBasicServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadBridgedDeviceBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReadBridgedDeviceBasicClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"BridgedDeviceBasic.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "BridgedDeviceBasic ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicClientGeneratedCommandList : public ModelCommand {
public:
    ReportBridgedDeviceBasicClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadBridgedDeviceBasicAttributeList : public ModelCommand {
public:
    ReadBridgedDeviceBasicAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicAttributeList : public ModelCommand {
public:
    ReportBridgedDeviceBasicAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadBridgedDeviceBasicClusterRevision : public ModelCommand {
public:
    ReadBridgedDeviceBasicClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPBridgedDeviceBasic * cluster = [[CHIPBridgedDeviceBasic alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"BridgedDeviceBasic.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "BridgedDeviceBasic ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportBridgedDeviceBasicClusterRevision : public ModelCommand {
public:
    ReportBridgedDeviceBasicClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportBridgedDeviceBasicClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000039) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Channel                                                     | 0x0504 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeChannelByNumberRequest                                      |   0x02 |
| * ChangeChannelRequest                                              |   0x00 |
| * SkipChannelRequest                                                |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ChannelList                                                       | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeChannelByNumberRequest
 */
class ChannelChangeChannelByNumberRequest : public ModelCommand {
public:
    ChannelChangeChannelByNumberRequest()
        : ModelCommand("change-channel-by-number-request")
    {
        AddArgument("MajorNumber", 0, UINT16_MAX, &mMajorNumber);
        AddArgument("MinorNumber", 0, UINT16_MAX, &mMinorNumber);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPChannelClusterChangeChannelByNumberRequestParams alloc] init];
        params.majorNumber = [NSNumber numberWithUnsignedShort:mMajorNumber];
        params.minorNumber = [NSNumber numberWithUnsignedShort:mMinorNumber];
        [cluster changeChannelByNumberRequestWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mMajorNumber;
    uint16_t mMinorNumber;
};

/*
 * Command ChangeChannelRequest
 */
class ChannelChangeChannelRequest : public ModelCommand {
public:
    ChannelChangeChannelRequest()
        : ModelCommand("change-channel-request")
    {
        AddArgument("Match", &mMatch);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPChannelClusterChangeChannelRequestParams alloc] init];
        params.match = [[NSString alloc] initWithBytes:mMatch.data() length:mMatch.size() encoding:NSUTF8StringEncoding];
        [cluster changeChannelRequestWithParams:params
                              completionHandler:^(
                                  CHIPChannelClusterChangeChannelResponseParams * _Nullable values, NSError * _Nullable error) {
                                  NSLog(@"Values: %@", values);
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mMatch;
};

/*
 * Command SkipChannelRequest
 */
class ChannelSkipChannelRequest : public ModelCommand {
public:
    ChannelSkipChannelRequest()
        : ModelCommand("skip-channel-request")
    {
        AddArgument("Count", 0, UINT16_MAX, &mCount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPChannelClusterSkipChannelRequestParams alloc] init];
        params.count = [NSNumber numberWithUnsignedShort:mCount];
        [cluster skipChannelRequestWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mCount;
};

/*
 * Attribute ChannelList
 */
class ReadChannelChannelList : public ModelCommand {
public:
    ReadChannelChannelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelChannelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeChannelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.ChannelList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel ChannelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportChannelChannelList : public ModelCommand {
public:
    ReportChannelChannelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelChannelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadChannelServerGeneratedCommandList : public ModelCommand {
public:
    ReadChannelServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Channel.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Channel ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportChannelServerGeneratedCommandList : public ModelCommand {
public:
    ReportChannelServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadChannelClientGeneratedCommandList : public ModelCommand {
public:
    ReadChannelClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Channel.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Channel ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportChannelClientGeneratedCommandList : public ModelCommand {
public:
    ReportChannelClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadChannelAttributeList : public ModelCommand {
public:
    ReadChannelAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadChannelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportChannelAttributeList : public ModelCommand {
public:
    ReportChannelAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadChannelClusterRevision : public ModelCommand {
public:
    ReadChannelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadChannelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPChannel * cluster = [[CHIPChannel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Channel.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Channel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportChannelClusterRevision : public ModelCommand {
public:
    ReportChannelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportChannelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000504) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ColorControl                                                | 0x0300 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ColorLoopSet                                                      |   0x44 |
| * EnhancedMoveHue                                                   |   0x41 |
| * EnhancedMoveToHue                                                 |   0x40 |
| * EnhancedMoveToHueAndSaturation                                    |   0x43 |
| * EnhancedStepHue                                                   |   0x42 |
| * MoveColor                                                         |   0x08 |
| * MoveColorTemperature                                              |   0x4B |
| * MoveHue                                                           |   0x01 |
| * MoveSaturation                                                    |   0x04 |
| * MoveToColor                                                       |   0x07 |
| * MoveToColorTemperature                                            |   0x0A |
| * MoveToHue                                                         |   0x00 |
| * MoveToHueAndSaturation                                            |   0x06 |
| * MoveToSaturation                                                  |   0x03 |
| * StepColor                                                         |   0x09 |
| * StepColorTemperature                                              |   0x4C |
| * StepHue                                                           |   0x02 |
| * StepSaturation                                                    |   0x05 |
| * StopMoveStep                                                      |   0x47 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentHue                                                        | 0x0000 |
| * CurrentSaturation                                                 | 0x0001 |
| * RemainingTime                                                     | 0x0002 |
| * CurrentX                                                          | 0x0003 |
| * CurrentY                                                          | 0x0004 |
| * DriftCompensation                                                 | 0x0005 |
| * CompensationText                                                  | 0x0006 |
| * ColorTemperature                                                  | 0x0007 |
| * ColorMode                                                         | 0x0008 |
| * ColorControlOptions                                               | 0x000F |
| * NumberOfPrimaries                                                 | 0x0010 |
| * Primary1X                                                         | 0x0011 |
| * Primary1Y                                                         | 0x0012 |
| * Primary1Intensity                                                 | 0x0013 |
| * Primary2X                                                         | 0x0015 |
| * Primary2Y                                                         | 0x0016 |
| * Primary2Intensity                                                 | 0x0017 |
| * Primary3X                                                         | 0x0019 |
| * Primary3Y                                                         | 0x001A |
| * Primary3Intensity                                                 | 0x001B |
| * Primary4X                                                         | 0x0020 |
| * Primary4Y                                                         | 0x0021 |
| * Primary4Intensity                                                 | 0x0022 |
| * Primary5X                                                         | 0x0024 |
| * Primary5Y                                                         | 0x0025 |
| * Primary5Intensity                                                 | 0x0026 |
| * Primary6X                                                         | 0x0028 |
| * Primary6Y                                                         | 0x0029 |
| * Primary6Intensity                                                 | 0x002A |
| * WhitePointX                                                       | 0x0030 |
| * WhitePointY                                                       | 0x0031 |
| * ColorPointRX                                                      | 0x0032 |
| * ColorPointRY                                                      | 0x0033 |
| * ColorPointRIntensity                                              | 0x0034 |
| * ColorPointGX                                                      | 0x0036 |
| * ColorPointGY                                                      | 0x0037 |
| * ColorPointGIntensity                                              | 0x0038 |
| * ColorPointBX                                                      | 0x003A |
| * ColorPointBY                                                      | 0x003B |
| * ColorPointBIntensity                                              | 0x003C |
| * EnhancedCurrentHue                                                | 0x4000 |
| * EnhancedColorMode                                                 | 0x4001 |
| * ColorLoopActive                                                   | 0x4002 |
| * ColorLoopDirection                                                | 0x4003 |
| * ColorLoopTime                                                     | 0x4004 |
| * ColorLoopStartEnhancedHue                                         | 0x4005 |
| * ColorLoopStoredEnhancedHue                                        | 0x4006 |
| * ColorCapabilities                                                 | 0x400A |
| * ColorTempPhysicalMin                                              | 0x400B |
| * ColorTempPhysicalMax                                              | 0x400C |
| * CoupleColorTempToLevelMinMireds                                   | 0x400D |
| * StartUpColorTemperatureMireds                                     | 0x4010 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ColorLoopSet
 */
class ColorControlColorLoopSet : public ModelCommand {
public:
    ColorControlColorLoopSet()
        : ModelCommand("color-loop-set")
    {
        AddArgument("UpdateFlags", 0, UINT8_MAX, &mUpdateFlags);
        AddArgument("Action", 0, UINT8_MAX, &mAction);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("Time", 0, UINT16_MAX, &mTime);
        AddArgument("StartHue", 0, UINT16_MAX, &mStartHue);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000044) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterColorLoopSetParams alloc] init];
        params.updateFlags = [NSNumber numberWithUnsignedChar:mUpdateFlags];
        params.action = [NSNumber numberWithUnsignedChar:mAction];
        params.direction = [NSNumber numberWithUnsignedChar:mDirection];
        params.time = [NSNumber numberWithUnsignedShort:mTime];
        params.startHue = [NSNumber numberWithUnsignedShort:mStartHue];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster colorLoopSetWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mUpdateFlags;
    uint8_t mAction;
    uint8_t mDirection;
    uint16_t mTime;
    uint16_t mStartHue;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveHue
 */
class ColorControlEnhancedMoveHue : public ModelCommand {
public:
    ColorControlEnhancedMoveHue()
        : ModelCommand("enhanced-move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT16_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000041) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedShort:mRate];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveHueWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             CHIP_ERROR err = CHIP_NO_ERROR;
                             err = [CHIPError errorToCHIPErrorCode:error];

                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveToHue
 */
class ColorControlEnhancedMoveToHue : public ModelCommand {
public:
    ColorControlEnhancedMoveToHue()
        : ModelCommand("enhanced-move-to-hue")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mEnhancedHue);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000040) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:mEnhancedHue];
        params.direction = [NSNumber numberWithUnsignedChar:mDirection];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveToHueWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               CHIP_ERROR err = CHIP_NO_ERROR;
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mEnhancedHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedMoveToHueAndSaturation
 */
class ColorControlEnhancedMoveToHueAndSaturation : public ModelCommand {
public:
    ColorControlEnhancedMoveToHueAndSaturation()
        : ModelCommand("enhanced-move-to-hue-and-saturation")
    {
        AddArgument("EnhancedHue", 0, UINT16_MAX, &mEnhancedHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000043) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterEnhancedMoveToHueAndSaturationParams alloc] init];
        params.enhancedHue = [NSNumber numberWithUnsignedShort:mEnhancedHue];
        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedMoveToHueAndSaturationWithParams:params
                                        completionHandler:^(NSError * _Nullable error) {
                                            CHIP_ERROR err = CHIP_NO_ERROR;
                                            err = [CHIPError errorToCHIPErrorCode:error];

                                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mEnhancedHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command EnhancedStepHue
 */
class ColorControlEnhancedStepHue : public ModelCommand {
public:
    ColorControlEnhancedStepHue()
        : ModelCommand("enhanced-step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000042) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterEnhancedStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedShort:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster enhancedStepHueWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             CHIP_ERROR err = CHIP_NO_ERROR;
                             err = [CHIPError errorToCHIPErrorCode:error];

                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColor
 */
class ColorControlMoveColor : public ModelCommand {
public:
    ColorControlMoveColor()
        : ModelCommand("move-color")
    {
        AddArgument("RateX", INT16_MIN, INT16_MAX, &mRateX);
        AddArgument("RateY", INT16_MIN, INT16_MAX, &mRateY);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveColorParams alloc] init];
        params.rateX = [NSNumber numberWithShort:mRateX];
        params.rateY = [NSNumber numberWithShort:mRateY];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveColorWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    int16_t mRateX;
    int16_t mRateY;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveColorTemperature
 */
class ColorControlMoveColorTemperature : public ModelCommand {
public:
    ColorControlMoveColorTemperature()
        : ModelCommand("move-color-temperature")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT16_MAX, &mRate);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveColorTemperatureParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedShort:mRate];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:mColorTemperatureMinimum];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:mColorTemperatureMaximum];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMoveMode;
    uint16_t mRate;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveHue
 */
class ColorControlMoveHue : public ModelCommand {
public:
    ColorControlMoveHue()
        : ModelCommand("move-hue")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveHueParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveHueWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     CHIP_ERROR err = CHIP_NO_ERROR;
                     err = [CHIPError errorToCHIPErrorCode:error];

                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveSaturation
 */
class ColorControlMoveSaturation : public ModelCommand {
public:
    ColorControlMoveSaturation()
        : ModelCommand("move-saturation")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveSaturationParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColor
 */
class ColorControlMoveToColor : public ModelCommand {
public:
    ColorControlMoveToColor()
        : ModelCommand("move-to-color")
    {
        AddArgument("ColorX", 0, UINT16_MAX, &mColorX);
        AddArgument("ColorY", 0, UINT16_MAX, &mColorY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveToColorParams alloc] init];
        params.colorX = [NSNumber numberWithUnsignedShort:mColorX];
        params.colorY = [NSNumber numberWithUnsignedShort:mColorY];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToColorWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mColorX;
    uint16_t mColorY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToColorTemperature
 */
class ColorControlMoveToColorTemperature : public ModelCommand {
public:
    ColorControlMoveToColorTemperature()
        : ModelCommand("move-to-color-temperature")
    {
        AddArgument("ColorTemperature", 0, UINT16_MAX, &mColorTemperature);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveToColorTemperatureParams alloc] init];
        params.colorTemperature = [NSNumber numberWithUnsignedShort:mColorTemperature];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToColorTemperatureWithParams:params
                                completionHandler:^(NSError * _Nullable error) {
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mColorTemperature;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHue
 */
class ColorControlMoveToHue : public ModelCommand {
public:
    ColorControlMoveToHue()
        : ModelCommand("move-to-hue")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mHue);
        AddArgument("Direction", 0, UINT8_MAX, &mDirection);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveToHueParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:mHue];
        params.direction = [NSNumber numberWithUnsignedChar:mDirection];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToHueWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mHue;
    uint8_t mDirection;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToHueAndSaturation
 */
class ColorControlMoveToHueAndSaturation : public ModelCommand {
public:
    ColorControlMoveToHueAndSaturation()
        : ModelCommand("move-to-hue-and-saturation")
    {
        AddArgument("Hue", 0, UINT8_MAX, &mHue);
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveToHueAndSaturationParams alloc] init];
        params.hue = [NSNumber numberWithUnsignedChar:mHue];
        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToHueAndSaturationWithParams:params
                                completionHandler:^(NSError * _Nullable error) {
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mHue;
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command MoveToSaturation
 */
class ColorControlMoveToSaturation : public ModelCommand {
public:
    ColorControlMoveToSaturation()
        : ModelCommand("move-to-saturation")
    {
        AddArgument("Saturation", 0, UINT8_MAX, &mSaturation);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterMoveToSaturationParams alloc] init];
        params.saturation = [NSNumber numberWithUnsignedChar:mSaturation];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster moveToSaturationWithParams:params
                          completionHandler:^(NSError * _Nullable error) {
                              CHIP_ERROR err = CHIP_NO_ERROR;
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mSaturation;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColor
 */
class ColorControlStepColor : public ModelCommand {
public:
    ColorControlStepColor()
        : ModelCommand("step-color")
    {
        AddArgument("StepX", INT16_MIN, INT16_MAX, &mStepX);
        AddArgument("StepY", INT16_MIN, INT16_MAX, &mStepY);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterStepColorParams alloc] init];
        params.stepX = [NSNumber numberWithShort:mStepX];
        params.stepY = [NSNumber numberWithShort:mStepY];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepColorWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    int16_t mStepX;
    int16_t mStepY;
    uint16_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepColorTemperature
 */
class ColorControlStepColorTemperature : public ModelCommand {
public:
    ColorControlStepColorTemperature()
        : ModelCommand("step-color-temperature")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT16_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("ColorTemperatureMinimum", 0, UINT16_MAX, &mColorTemperatureMinimum);
        AddArgument("ColorTemperatureMaximum", 0, UINT16_MAX, &mColorTemperatureMaximum);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x0000004C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterStepColorTemperatureParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedShort:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.colorTemperatureMinimum = [NSNumber numberWithUnsignedShort:mColorTemperatureMinimum];
        params.colorTemperatureMaximum = [NSNumber numberWithUnsignedShort:mColorTemperatureMaximum];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepColorTemperatureWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mStepMode;
    uint16_t mStepSize;
    uint16_t mTransitionTime;
    uint16_t mColorTemperatureMinimum;
    uint16_t mColorTemperatureMaximum;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepHue
 */
class ColorControlStepHue : public ModelCommand {
public:
    ColorControlStepHue()
        : ModelCommand("step-hue")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterStepHueParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedChar:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepHueWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     CHIP_ERROR err = CHIP_NO_ERROR;
                     err = [CHIPError errorToCHIPErrorCode:error];

                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StepSaturation
 */
class ColorControlStepSaturation : public ModelCommand {
public:
    ColorControlStepSaturation()
        : ModelCommand("step-saturation")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT8_MAX, &mTransitionTime);
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterStepSaturationParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedChar:mTransitionTime];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stepSaturationWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint8_t mTransitionTime;
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Command StopMoveStep
 */
class ColorControlStopMoveStep : public ModelCommand {
public:
    ColorControlStopMoveStep()
        : ModelCommand("stop-move-step")
    {
        AddArgument("OptionsMask", 0, UINT8_MAX, &mOptionsMask);
        AddArgument("OptionsOverride", 0, UINT8_MAX, &mOptionsOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) command (0x00000047) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPColorControlClusterStopMoveStepParams alloc] init];
        params.optionsMask = [NSNumber numberWithUnsignedChar:mOptionsMask];
        params.optionsOverride = [NSNumber numberWithUnsignedChar:mOptionsOverride];
        [cluster stopMoveStepWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mOptionsMask;
    uint8_t mOptionsOverride;
};

/*
 * Attribute CurrentHue
 */
class ReadColorControlCurrentHue : public ModelCommand {
public:
    ReadColorControlCurrentHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentHue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentHue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlCurrentHue : public ModelCommand {
public:
    ReportColorControlCurrentHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentSaturation
 */
class ReadColorControlCurrentSaturation : public ModelCommand {
public:
    ReadColorControlCurrentSaturation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-saturation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentSaturationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentSaturation response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentSaturation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlCurrentSaturation : public ModelCommand {
public:
    ReportColorControlCurrentSaturation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-saturation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentSaturation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadColorControlRemainingTime : public ModelCommand {
public:
    ReadColorControlRemainingTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.RemainingTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl RemainingTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlRemainingTime : public ModelCommand {
public:
    ReportColorControlRemainingTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentX
 */
class ReadColorControlCurrentX : public ModelCommand {
public:
    ReadColorControlCurrentX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentX response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlCurrentX : public ModelCommand {
public:
    ReportColorControlCurrentX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentY
 */
class ReadColorControlCurrentY : public ModelCommand {
public:
    ReadColorControlCurrentY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCurrentY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CurrentY response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CurrentY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlCurrentY : public ModelCommand {
public:
    ReportColorControlCurrentY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCurrentY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DriftCompensation
 */
class ReadColorControlDriftCompensation : public ModelCommand {
public:
    ReadColorControlDriftCompensation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "drift-compensation");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDriftCompensationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.DriftCompensation response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl DriftCompensation Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlDriftCompensation : public ModelCommand {
public:
    ReportColorControlDriftCompensation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "drift-compensation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlDriftCompensation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CompensationText
 */
class ReadColorControlCompensationText : public ModelCommand {
public:
    ReadColorControlCompensationText()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "compensation-text");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCompensationText() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCompensationTextWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CompensationText response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CompensationText Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlCompensationText : public ModelCommand {
public:
    ReportColorControlCompensationText()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "compensation-text");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCompensationText() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTemperature
 */
class ReadColorControlColorTemperature : public ModelCommand {
public:
    ReadColorControlColorTemperature()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTemperature response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTemperature Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorTemperature : public ModelCommand {
public:
    ReportColorControlColorTemperature()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorMode
 */
class ReadColorControlColorMode : public ModelCommand {
public:
    ReadColorControlColorMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorMode : public ModelCommand {
public:
    ReportColorControlColorMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorControlOptions
 */
class ReadColorControlColorControlOptions : public ModelCommand {
public:
    ReadColorControlColorControlOptions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-control-options");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorControlOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorControlOptions response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorControlOptions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorControlOptions : public ModelCommand {
public:
    WriteColorControlColorControlOptions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster
            writeAttributeColorControlOptionsWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "ColorControl ColorControlOptions Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorControlOptions : public ModelCommand {
public:
    ReportColorControlColorControlOptions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-control-options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPrimaries
 */
class ReadColorControlNumberOfPrimaries : public ModelCommand {
public:
    ReadColorControlNumberOfPrimaries()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-primaries");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNumberOfPrimariesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.NumberOfPrimaries response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl NumberOfPrimaries Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlNumberOfPrimaries : public ModelCommand {
public:
    ReportColorControlNumberOfPrimaries()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-primaries");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlNumberOfPrimaries() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1X
 */
class ReadColorControlPrimary1X : public ModelCommand {
public:
    ReadColorControlPrimary1X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary1XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1X response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary1X : public ModelCommand {
public:
    ReportColorControlPrimary1X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Y
 */
class ReadColorControlPrimary1Y : public ModelCommand {
public:
    ReadColorControlPrimary1Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary1YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1Y response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary1Y : public ModelCommand {
public:
    ReportColorControlPrimary1Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary1Intensity
 */
class ReadColorControlPrimary1Intensity : public ModelCommand {
public:
    ReadColorControlPrimary1Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary1intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary1IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary1Intensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary1Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary1Intensity : public ModelCommand {
public:
    ReportColorControlPrimary1Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary1intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary1Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2X
 */
class ReadColorControlPrimary2X : public ModelCommand {
public:
    ReadColorControlPrimary2X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary2XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2X response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary2X : public ModelCommand {
public:
    ReportColorControlPrimary2X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Y
 */
class ReadColorControlPrimary2Y : public ModelCommand {
public:
    ReadColorControlPrimary2Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary2YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2Y response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary2Y : public ModelCommand {
public:
    ReportColorControlPrimary2Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary2Intensity
 */
class ReadColorControlPrimary2Intensity : public ModelCommand {
public:
    ReadColorControlPrimary2Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary2intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary2IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary2Intensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary2Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary2Intensity : public ModelCommand {
public:
    ReportColorControlPrimary2Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary2intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary2Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3X
 */
class ReadColorControlPrimary3X : public ModelCommand {
public:
    ReadColorControlPrimary3X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary3XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3X response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary3X : public ModelCommand {
public:
    ReportColorControlPrimary3X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Y
 */
class ReadColorControlPrimary3Y : public ModelCommand {
public:
    ReadColorControlPrimary3Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary3YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3Y response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary3Y : public ModelCommand {
public:
    ReportColorControlPrimary3Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary3Intensity
 */
class ReadColorControlPrimary3Intensity : public ModelCommand {
public:
    ReadColorControlPrimary3Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary3intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary3IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary3Intensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary3Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary3Intensity : public ModelCommand {
public:
    ReportColorControlPrimary3Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary3intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary3Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4X
 */
class ReadColorControlPrimary4X : public ModelCommand {
public:
    ReadColorControlPrimary4X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary4XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4X response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary4X : public ModelCommand {
public:
    ReportColorControlPrimary4X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Y
 */
class ReadColorControlPrimary4Y : public ModelCommand {
public:
    ReadColorControlPrimary4Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary4YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4Y response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary4Y : public ModelCommand {
public:
    ReportColorControlPrimary4Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary4Intensity
 */
class ReadColorControlPrimary4Intensity : public ModelCommand {
public:
    ReadColorControlPrimary4Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary4intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary4IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary4Intensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary4Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary4Intensity : public ModelCommand {
public:
    ReportColorControlPrimary4Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary4intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary4Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5X
 */
class ReadColorControlPrimary5X : public ModelCommand {
public:
    ReadColorControlPrimary5X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary5XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5X response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary5X : public ModelCommand {
public:
    ReportColorControlPrimary5X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Y
 */
class ReadColorControlPrimary5Y : public ModelCommand {
public:
    ReadColorControlPrimary5Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary5YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5Y response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary5Y : public ModelCommand {
public:
    ReportColorControlPrimary5Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary5Intensity
 */
class ReadColorControlPrimary5Intensity : public ModelCommand {
public:
    ReadColorControlPrimary5Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary5intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary5IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary5Intensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary5Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary5Intensity : public ModelCommand {
public:
    ReportColorControlPrimary5Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary5intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary5Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6X
 */
class ReadColorControlPrimary6X : public ModelCommand {
public:
    ReadColorControlPrimary6X()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary6XWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6X response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6X Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary6X : public ModelCommand {
public:
    ReportColorControlPrimary6X()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6X() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Y
 */
class ReadColorControlPrimary6Y : public ModelCommand {
public:
    ReadColorControlPrimary6Y()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary6YWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6Y response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6Y Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary6Y : public ModelCommand {
public:
    ReportColorControlPrimary6Y()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6Y() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Primary6Intensity
 */
class ReadColorControlPrimary6Intensity : public ModelCommand {
public:
    ReadColorControlPrimary6Intensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "primary6intensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePrimary6IntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.Primary6Intensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl Primary6Intensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlPrimary6Intensity : public ModelCommand {
public:
    ReportColorControlPrimary6Intensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "primary6intensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlPrimary6Intensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointX
 */
class ReadColorControlWhitePointX : public ModelCommand {
public:
    ReadColorControlWhitePointX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-x");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeWhitePointXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.WhitePointX response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl WhitePointX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlWhitePointX : public ModelCommand {
public:
    WriteColorControlWhitePointX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeWhitePointXWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "ColorControl WhitePointX Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlWhitePointX : public ModelCommand {
public:
    ReportColorControlWhitePointX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "white-point-x");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWhitePointX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WhitePointY
 */
class ReadColorControlWhitePointY : public ModelCommand {
public:
    ReadColorControlWhitePointY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "white-point-y");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeWhitePointYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.WhitePointY response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl WhitePointY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlWhitePointY : public ModelCommand {
public:
    WriteColorControlWhitePointY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeWhitePointYWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "ColorControl WhitePointY Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlWhitePointY : public ModelCommand {
public:
    ReportColorControlWhitePointY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "white-point-y");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlWhitePointY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRX
 */
class ReadColorControlColorPointRX : public ModelCommand {
public:
    ReadColorControlColorPointRX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointRXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRX response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointRX : public ModelCommand {
public:
    WriteColorControlColorPointRX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeColorPointRXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "ColorControl ColorPointRX Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointRX : public ModelCommand {
public:
    ReportColorControlColorPointRX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-rx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRY
 */
class ReadColorControlColorPointRY : public ModelCommand {
public:
    ReadColorControlColorPointRY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-ry");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointRYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRY response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointRY : public ModelCommand {
public:
    WriteColorControlColorPointRY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeColorPointRYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "ColorControl ColorPointRY Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointRY : public ModelCommand {
public:
    ReportColorControlColorPointRY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-ry");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointRIntensity
 */
class ReadColorControlColorPointRIntensity : public ModelCommand {
public:
    ReadColorControlColorPointRIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-rintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointRIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointRIntensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointRIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointRIntensity : public ModelCommand {
public:
    WriteColorControlColorPointRIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeColorPointRIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               CHIP_ERROR err = CHIP_NO_ERROR;
                                               err = [CHIPError errorToCHIPErrorCode:error];

                                               ChipLogError(
                                                   chipTool, "ColorControl ColorPointRIntensity Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorPointRIntensity : public ModelCommand {
public:
    ReportColorControlColorPointRIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-rintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointRIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGX
 */
class ReadColorControlColorPointGX : public ModelCommand {
public:
    ReadColorControlColorPointGX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointGXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGX response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointGX : public ModelCommand {
public:
    WriteColorControlColorPointGX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeColorPointGXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "ColorControl ColorPointGX Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointGX : public ModelCommand {
public:
    ReportColorControlColorPointGX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGY
 */
class ReadColorControlColorPointGY : public ModelCommand {
public:
    ReadColorControlColorPointGY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gy");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointGYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGY response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointGY : public ModelCommand {
public:
    WriteColorControlColorPointGY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeColorPointGYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "ColorControl ColorPointGY Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointGY : public ModelCommand {
public:
    ReportColorControlColorPointGY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointGIntensity
 */
class ReadColorControlColorPointGIntensity : public ModelCommand {
public:
    ReadColorControlColorPointGIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-gintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointGIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointGIntensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointGIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointGIntensity : public ModelCommand {
public:
    WriteColorControlColorPointGIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeColorPointGIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               CHIP_ERROR err = CHIP_NO_ERROR;
                                               err = [CHIPError errorToCHIPErrorCode:error];

                                               ChipLogError(
                                                   chipTool, "ColorControl ColorPointGIntensity Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorPointGIntensity : public ModelCommand {
public:
    ReportColorControlColorPointGIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-gintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointGIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBX
 */
class ReadColorControlColorPointBX : public ModelCommand {
public:
    ReadColorControlColorPointBX()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bx");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointBXWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBX response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBX Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointBX : public ModelCommand {
public:
    WriteColorControlColorPointBX()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeColorPointBXWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "ColorControl ColorPointBX Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointBX : public ModelCommand {
public:
    ReportColorControlColorPointBX()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-bx");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBX() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBY
 */
class ReadColorControlColorPointBY : public ModelCommand {
public:
    ReadColorControlColorPointBY()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-by");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointBYWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBY response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBY Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointBY : public ModelCommand {
public:
    WriteColorControlColorPointBY()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeColorPointBYWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "ColorControl ColorPointBY Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlColorPointBY : public ModelCommand {
public:
    ReportColorControlColorPointBY()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-by");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBY() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorPointBIntensity
 */
class ReadColorControlColorPointBIntensity : public ModelCommand {
public:
    ReadColorControlColorPointBIntensity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-point-bintensity");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorPointBIntensityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorPointBIntensity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorPointBIntensity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlColorPointBIntensity : public ModelCommand {
public:
    WriteColorControlColorPointBIntensity()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeColorPointBIntensityWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               CHIP_ERROR err = CHIP_NO_ERROR;
                                               err = [CHIPError errorToCHIPErrorCode:error];

                                               ChipLogError(
                                                   chipTool, "ColorControl ColorPointBIntensity Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportColorControlColorPointBIntensity : public ModelCommand {
public:
    ReportColorControlColorPointBIntensity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-point-bintensity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorPointBIntensity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedCurrentHue
 */
class ReadColorControlEnhancedCurrentHue : public ModelCommand {
public:
    ReadColorControlEnhancedCurrentHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEnhancedCurrentHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.EnhancedCurrentHue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl EnhancedCurrentHue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlEnhancedCurrentHue : public ModelCommand {
public:
    ReportColorControlEnhancedCurrentHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enhanced-current-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlEnhancedCurrentHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnhancedColorMode
 */
class ReadColorControlEnhancedColorMode : public ModelCommand {
public:
    ReadColorControlEnhancedColorMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEnhancedColorModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.EnhancedColorMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl EnhancedColorMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlEnhancedColorMode : public ModelCommand {
public:
    ReportColorControlEnhancedColorMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enhanced-color-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlEnhancedColorMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopActive
 */
class ReadColorControlColorLoopActive : public ModelCommand {
public:
    ReadColorControlColorLoopActive()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-active");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorLoopActiveWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopActive response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopActive Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorLoopActive : public ModelCommand {
public:
    ReportColorControlColorLoopActive()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-active");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopActive() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopDirection
 */
class ReadColorControlColorLoopDirection : public ModelCommand {
public:
    ReadColorControlColorLoopDirection()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-direction");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorLoopDirectionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopDirection response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopDirection Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorLoopDirection : public ModelCommand {
public:
    ReportColorControlColorLoopDirection()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-direction");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopDirection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopTime
 */
class ReadColorControlColorLoopTime : public ModelCommand {
public:
    ReadColorControlColorLoopTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-time");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorLoopTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorLoopTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorLoopTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorLoopTime : public ModelCommand {
public:
    ReportColorControlColorLoopTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStartEnhancedHue
 */
class ReadColorControlColorLoopStartEnhancedHue : public ModelCommand {
public:
    ReadColorControlColorLoopStartEnhancedHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeColorLoopStartEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ColorLoopStartEnhancedHue response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ColorLoopStartEnhancedHue Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorLoopStartEnhancedHue : public ModelCommand {
public:
    ReportColorControlColorLoopStartEnhancedHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-start-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopStartEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorLoopStoredEnhancedHue
 */
class ReadColorControlColorLoopStoredEnhancedHue : public ModelCommand {
public:
    ReadColorControlColorLoopStoredEnhancedHue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeColorLoopStoredEnhancedHueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ColorLoopStoredEnhancedHue response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ColorLoopStoredEnhancedHue Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorLoopStoredEnhancedHue : public ModelCommand {
public:
    ReportColorControlColorLoopStoredEnhancedHue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-loop-stored-enhanced-hue");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorLoopStoredEnhancedHue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorCapabilities
 */
class ReadColorControlColorCapabilities : public ModelCommand {
public:
    ReadColorControlColorCapabilities()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-capabilities");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorCapabilitiesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorCapabilities response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorCapabilities Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorCapabilities : public ModelCommand {
public:
    ReportColorControlColorCapabilities()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-capabilities");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorCapabilities() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMin
 */
class ReadColorControlColorTempPhysicalMin : public ModelCommand {
public:
    ReadColorControlColorTempPhysicalMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorTempPhysicalMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTempPhysicalMin response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTempPhysicalMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorTempPhysicalMin : public ModelCommand {
public:
    ReportColorControlColorTempPhysicalMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temp-physical-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTempPhysicalMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ColorTempPhysicalMax
 */
class ReadColorControlColorTempPhysicalMax : public ModelCommand {
public:
    ReadColorControlColorTempPhysicalMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeColorTempPhysicalMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ColorTempPhysicalMax response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ColorTempPhysicalMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlColorTempPhysicalMax : public ModelCommand {
public:
    ReportColorControlColorTempPhysicalMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "color-temp-physical-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlColorTempPhysicalMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CoupleColorTempToLevelMinMireds
 */
class ReadColorControlCoupleColorTempToLevelMinMireds : public ModelCommand {
public:
    ReadColorControlCoupleColorTempToLevelMinMireds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000400D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCoupleColorTempToLevelMinMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.CoupleColorTempToLevelMinMireds response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl CoupleColorTempToLevelMinMireds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlCoupleColorTempToLevelMinMireds : public ModelCommand {
public:
    ReportColorControlCoupleColorTempToLevelMinMireds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "couple-color-temp-to-level-min-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlCoupleColorTempToLevelMinMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000400D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpColorTemperatureMireds
 */
class ReadColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    ReadColorControlStartUpColorTemperatureMireds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x00004010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStartUpColorTemperatureMiredsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.StartUpColorTemperatureMireds response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl StartUpColorTemperatureMireds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    WriteColorControlStartUpColorTemperatureMireds()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) WriteAttribute (0x00004010) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster
            writeAttributeStartUpColorTemperatureMiredsWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                                   err = [CHIPError errorToCHIPErrorCode:error];

                                                   ChipLogError(chipTool, "ColorControl StartUpColorTemperatureMireds Error: %s",
                                                       chip::ErrorStr(err));
                                                   SetCommandExitStatus(err);
                                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportColorControlStartUpColorTemperatureMireds : public ModelCommand {
public:
    ReportColorControlStartUpColorTemperatureMireds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-color-temperature-mireds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlStartUpColorTemperatureMireds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x00004010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadColorControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadColorControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlServerGeneratedCommandList : public ModelCommand {
public:
    ReportColorControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadColorControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadColorControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ColorControl.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ColorControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlClientGeneratedCommandList : public ModelCommand {
public:
    ReportColorControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadColorControlAttributeList : public ModelCommand {
public:
    ReadColorControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlAttributeList : public ModelCommand {
public:
    ReportColorControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadColorControlClusterRevision : public ModelCommand {
public:
    ReadColorControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPColorControl * cluster = [[CHIPColorControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ColorControl.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ColorControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportColorControlClusterRevision : public ModelCommand {
public:
    ReportColorControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportColorControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000300) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ContentLauncher                                             | 0x050A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * LaunchContentRequest                                              |   0x00 |
| * LaunchURLRequest                                                  |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AcceptHeaderList                                                  | 0x0000 |
| * SupportedStreamingProtocols                                       | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command LaunchContentRequest
 */
class ContentLauncherLaunchContentRequest : public ModelCommand {
public:
    ContentLauncherLaunchContentRequest()
        : ModelCommand("launch-content-request")
    {
        AddArgument("AutoPlay", 0, 1, &mAutoPlay);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPContentLauncherClusterLaunchContentRequestParams alloc] init];
        params.autoPlay = [NSNumber numberWithBool:mAutoPlay];
        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        // search Array parsing is not supported yet
        [cluster launchContentRequestWithParams:params
                              completionHandler:^(
                                  CHIPContentLauncherClusterLaunchResponseParams * _Nullable values, NSError * _Nullable error) {
                                  NSLog(@"Values: %@", values);
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    bool mAutoPlay;
    chip::ByteSpan mData;
};

/*
 * Command LaunchURLRequest
 */
class ContentLauncherLaunchURLRequest : public ModelCommand {
public:
    ContentLauncherLaunchURLRequest()
        : ModelCommand("launch-urlrequest")
    {
        AddArgument("ContentURL", &mContentURL);
        AddArgument("DisplayString", &mDisplayString);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPContentLauncherClusterLaunchURLRequestParams alloc] init];
        params.contentURL = [[NSString alloc] initWithBytes:mContentURL.data()
                                                     length:mContentURL.size()
                                                   encoding:NSUTF8StringEncoding];
        params.displayString = [[NSString alloc] initWithBytes:mDisplayString.data()
                                                        length:mDisplayString.size()
                                                      encoding:NSUTF8StringEncoding];
        // brandingInformation Struct parsing is not supported yet
        [cluster launchURLRequestWithParams:params
                          completionHandler:^(
                              CHIPContentLauncherClusterLaunchResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              CHIP_ERROR err = CHIP_NO_ERROR;
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mContentURL;
    chip::ByteSpan mDisplayString;
};

/*
 * Attribute AcceptHeaderList
 */
class ReadContentLauncherAcceptHeaderList : public ModelCommand {
public:
    ReadContentLauncherAcceptHeaderList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "accept-header-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAcceptHeaderList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAcceptHeaderListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AcceptHeaderList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AcceptHeaderList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportContentLauncherAcceptHeaderList : public ModelCommand {
public:
    ReportContentLauncherAcceptHeaderList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "accept-header-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherAcceptHeaderList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedStreamingProtocols
 */
class ReadContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    ReadContentLauncherSupportedStreamingProtocols()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeSupportedStreamingProtocolsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.SupportedStreamingProtocols response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher SupportedStreamingProtocols Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class WriteContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    WriteContentLauncherSupportedStreamingProtocols()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster
            writeAttributeSupportedStreamingProtocolsWithValue:value
                                             completionHandler:^(NSError * _Nullable error) {
                                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                                 err = [CHIPError errorToCHIPErrorCode:error];

                                                 ChipLogError(chipTool, "ContentLauncher SupportedStreamingProtocols Error: %s",
                                                     chip::ErrorStr(err));
                                                 SetCommandExitStatus(err);
                                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportContentLauncherSupportedStreamingProtocols : public ModelCommand {
public:
    ReportContentLauncherSupportedStreamingProtocols()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-streaming-protocols");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherSupportedStreamingProtocols() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadContentLauncherServerGeneratedCommandList : public ModelCommand {
public:
    ReadContentLauncherServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportContentLauncherServerGeneratedCommandList : public ModelCommand {
public:
    ReportContentLauncherServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadContentLauncherClientGeneratedCommandList : public ModelCommand {
public:
    ReadContentLauncherClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ContentLauncher.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ContentLauncher ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportContentLauncherClientGeneratedCommandList : public ModelCommand {
public:
    ReportContentLauncherClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadContentLauncherAttributeList : public ModelCommand {
public:
    ReadContentLauncherAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportContentLauncherAttributeList : public ModelCommand {
public:
    ReportContentLauncherAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadContentLauncherClusterRevision : public ModelCommand {
public:
    ReadContentLauncherClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPContentLauncher * cluster = [[CHIPContentLauncher alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ContentLauncher.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ContentLauncher ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportContentLauncherClusterRevision : public ModelCommand {
public:
    ReportContentLauncherClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportContentLauncherClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050A) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Descriptor                                                  | 0x001D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DeviceList                                                        | 0x0000 |
| * ServerList                                                        | 0x0001 |
| * ClientList                                                        | 0x0002 |
| * PartsList                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute DeviceList
 */
class ReadDescriptorDeviceList : public ModelCommand {
public:
    ReadDescriptorDeviceList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "device-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDeviceListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.DeviceList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor DeviceList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorDeviceList : public ModelCommand {
public:
    ReportDescriptorDeviceList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "device-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorDeviceList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerList
 */
class ReadDescriptorServerList : public ModelCommand {
public:
    ReadDescriptorServerList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeServerListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ServerList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ServerList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorServerList : public ModelCommand {
public:
    ReportDescriptorServerList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorServerList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientList
 */
class ReadDescriptorClientList : public ModelCommand {
public:
    ReadDescriptorClientList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClientListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ClientList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ClientList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorClientList : public ModelCommand {
public:
    ReportDescriptorClientList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorClientList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartsList
 */
class ReadDescriptorPartsList : public ModelCommand {
public:
    ReadDescriptorPartsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "parts-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorPartsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePartsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.PartsList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor PartsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorPartsList : public ModelCommand {
public:
    ReportDescriptorPartsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "parts-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorPartsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadDescriptorServerGeneratedCommandList : public ModelCommand {
public:
    ReadDescriptorServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Descriptor.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Descriptor ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorServerGeneratedCommandList : public ModelCommand {
public:
    ReportDescriptorServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadDescriptorClientGeneratedCommandList : public ModelCommand {
public:
    ReadDescriptorClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Descriptor.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Descriptor ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorClientGeneratedCommandList : public ModelCommand {
public:
    ReportDescriptorClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDescriptorAttributeList : public ModelCommand {
public:
    ReadDescriptorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorAttributeList : public ModelCommand {
public:
    ReportDescriptorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDescriptorClusterRevision : public ModelCommand {
public:
    ReadDescriptorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDescriptor * cluster = [[CHIPDescriptor alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Descriptor.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Descriptor ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDescriptorClusterRevision : public ModelCommand {
public:
    ReportDescriptorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDescriptorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000001D) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DiagnosticLogs                                              | 0x0032 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * RetrieveLogsRequest                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command RetrieveLogsRequest
 */
class DiagnosticLogsRetrieveLogsRequest : public ModelCommand {
public:
    DiagnosticLogsRetrieveLogsRequest()
        : ModelCommand("retrieve-logs-request")
    {
        AddArgument("Intent", 0, UINT8_MAX, &mIntent);
        AddArgument("RequestedProtocol", 0, UINT8_MAX, &mRequestedProtocol);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDiagnosticLogsClusterRetrieveLogsRequestParams alloc] init];
        params.intent = [NSNumber numberWithUnsignedChar:mIntent];
        params.requestedProtocol = [NSNumber numberWithUnsignedChar:mRequestedProtocol];
        params.transferFileDesignator = [[NSData alloc] initWithBytes:mTransferFileDesignator.data()
                                                               length:mTransferFileDesignator.size()];
        [cluster retrieveLogsRequestWithParams:params
                             completionHandler:^(CHIPDiagnosticLogsClusterRetrieveLogsResponseParams * _Nullable values,
                                 NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mIntent;
    uint8_t mRequestedProtocol;
    chip::ByteSpan mTransferFileDesignator;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadDiagnosticLogsServerGeneratedCommandList : public ModelCommand {
public:
    ReadDiagnosticLogsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DiagnosticLogs.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DiagnosticLogs ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDiagnosticLogsServerGeneratedCommandList : public ModelCommand {
public:
    ReportDiagnosticLogsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDiagnosticLogsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadDiagnosticLogsClientGeneratedCommandList : public ModelCommand {
public:
    ReadDiagnosticLogsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DiagnosticLogs.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DiagnosticLogs ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDiagnosticLogsClientGeneratedCommandList : public ModelCommand {
public:
    ReportDiagnosticLogsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDiagnosticLogsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDiagnosticLogsAttributeList : public ModelCommand {
public:
    ReadDiagnosticLogsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDiagnosticLogs * cluster = [[CHIPDiagnosticLogs alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DiagnosticLogs.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DiagnosticLogs AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDiagnosticLogsAttributeList : public ModelCommand {
public:
    ReportDiagnosticLogsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDiagnosticLogsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000032) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster DoorLock                                                    | 0x0101 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearCredential                                                   |   0x26 |
| * ClearUser                                                         |   0x1D |
| * ClearWeekDaySchedule                                              |   0x0D |
| * ClearYearDaySchedule                                              |   0x10 |
| * GetCredentialStatus                                               |   0x24 |
| * GetUser                                                           |   0x1B |
| * GetWeekDaySchedule                                                |   0x0C |
| * GetYearDaySchedule                                                |   0x0F |
| * LockDoor                                                          |   0x00 |
| * SetCredential                                                     |   0x22 |
| * SetUser                                                           |   0x1A |
| * SetWeekDaySchedule                                                |   0x0B |
| * SetYearDaySchedule                                                |   0x0E |
| * UnlockDoor                                                        |   0x01 |
| * UnlockWithTimeout                                                 |   0x03 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LockState                                                         | 0x0000 |
| * LockType                                                          | 0x0001 |
| * ActuatorEnabled                                                   | 0x0002 |
| * DoorState                                                         | 0x0003 |
| * NumberOfTotalUsersSupported                                       | 0x0011 |
| * NumberOfPINUsersSupported                                         | 0x0012 |
| * NumberOfRFIDUsersSupported                                        | 0x0013 |
| * NumberOfWeekDaySchedulesSupportedPerUser                          | 0x0014 |
| * NumberOfYearDaySchedulesSupportedPerUser                          | 0x0015 |
| * MaxPINCodeLength                                                  | 0x0017 |
| * MinPINCodeLength                                                  | 0x0018 |
| * MaxRFIDCodeLength                                                 | 0x0019 |
| * MinRFIDCodeLength                                                 | 0x001A |
| * Language                                                          | 0x0021 |
| * AutoRelockTime                                                    | 0x0023 |
| * SoundVolume                                                       | 0x0024 |
| * OperatingMode                                                     | 0x0025 |
| * SupportedOperatingModes                                           | 0x0026 |
| * EnableOneTouchLocking                                             | 0x0029 |
| * EnablePrivacyModeButton                                           | 0x002B |
| * WrongCodeEntryLimit                                               | 0x0030 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * DoorLockAlarm                                                     | 0x0000 |
| * DoorStateChange                                                   | 0x0001 |
| * LockOperation                                                     | 0x0002 |
| * LockOperationError                                                | 0x0003 |
| * LockUserChange                                                    | 0x0004 |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearCredential
 */
class DoorLockClearCredential : public ModelCommand {
public:
    DoorLockClearCredential()
        : ModelCommand("clear-credential")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterClearCredentialParams alloc] init];
        // credential Struct parsing is not supported yet
        [cluster clearCredentialWithParams:params
                         completionHandler:^(NSError * _Nullable error) {
                             CHIP_ERROR err = CHIP_NO_ERROR;
                             err = [CHIPError errorToCHIPErrorCode:error];

                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command ClearUser
 */
class DoorLockClearUser : public ModelCommand {
public:
    DoorLockClearUser()
        : ModelCommand("clear-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterClearUserParams alloc] init];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearUserWithParams:params
                   completionHandler:^(NSError * _Nullable error) {
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mUserIndex;
};

/*
 * Command ClearWeekDaySchedule
 */
class DoorLockClearWeekDaySchedule : public ModelCommand {
public:
    DoorLockClearWeekDaySchedule()
        : ModelCommand("clear-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterClearWeekDayScheduleParams alloc] init];
        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearWeekDayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command ClearYearDaySchedule
 */
class DoorLockClearYearDaySchedule : public ModelCommand {
public:
    DoorLockClearYearDaySchedule()
        : ModelCommand("clear-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterClearYearDayScheduleParams alloc] init];
        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster clearYearDayScheduleWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command GetCredentialStatus
 */
class DoorLockGetCredentialStatus : public ModelCommand {
public:
    DoorLockGetCredentialStatus()
        : ModelCommand("get-credential-status")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterGetCredentialStatusParams alloc] init];
        // credential Struct parsing is not supported yet
        [cluster getCredentialStatusWithParams:params
                             completionHandler:^(CHIPDoorLockClusterGetCredentialStatusResponseParams * _Nullable values,
                                 NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command GetUser
 */
class DoorLockGetUser : public ModelCommand {
public:
    DoorLockGetUser()
        : ModelCommand("get-user")
    {
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterGetUserParams alloc] init];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getUserWithParams:params
                 completionHandler:^(CHIPDoorLockClusterGetUserResponseParams * _Nullable values, NSError * _Nullable error) {
                     NSLog(@"Values: %@", values);
                     CHIP_ERROR err = CHIP_NO_ERROR;
                     err = [CHIPError errorToCHIPErrorCode:error];

                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mUserIndex;
};

/*
 * Command GetWeekDaySchedule
 */
class DoorLockGetWeekDaySchedule : public ModelCommand {
public:
    DoorLockGetWeekDaySchedule()
        : ModelCommand("get-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterGetWeekDayScheduleParams alloc] init];
        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getWeekDayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetWeekDayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command GetYearDaySchedule
 */
class DoorLockGetYearDaySchedule : public ModelCommand {
public:
    DoorLockGetYearDaySchedule()
        : ModelCommand("get-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterGetYearDayScheduleParams alloc] init];
        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        [cluster getYearDayScheduleWithParams:params
                            completionHandler:^(
                                CHIPDoorLockClusterGetYearDayScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
};

/*
 * Command LockDoor
 */
class DoorLockLockDoor : public ModelCommand {
public:
    DoorLockLockDoor()
        : ModelCommand("lock-door")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterLockDoorParams alloc] init];
        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster lockDoorWithParams:params
                  completionHandler:^(NSError * _Nullable error) {
                      CHIP_ERROR err = CHIP_NO_ERROR;
                      err = [CHIPError errorToCHIPErrorCode:error];

                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mPinCode;
};

/*
 * Command SetCredential
 */
class DoorLockSetCredential : public ModelCommand {
public:
    DoorLockSetCredential()
        : ModelCommand("set-credential")
    {
        AddArgument("OperationType", 0, UINT8_MAX, &mOperationType);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("UserStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("UserType", 0, UINT8_MAX, &mUserType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterSetCredentialParams alloc] init];
        params.operationType = [NSNumber numberWithUnsignedChar:mOperationType];
        // credential Struct parsing is not supported yet
        params.credentialData = [[NSData alloc] initWithBytes:mCredentialData.data() length:mCredentialData.size()];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.userStatus = [NSNumber numberWithUnsignedChar:mUserStatus];
        params.userType = [NSNumber numberWithUnsignedChar:mUserType];
        [cluster setCredentialWithParams:params
                       completionHandler:^(
                           CHIPDoorLockClusterSetCredentialResponseParams * _Nullable values, NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mOperationType;
    chip::ByteSpan mCredentialData;
    uint16_t mUserIndex;
    uint8_t mUserStatus;
    uint8_t mUserType;
};

/*
 * Command SetUser
 */
class DoorLockSetUser : public ModelCommand {
public:
    DoorLockSetUser()
        : ModelCommand("set-user")
    {
        AddArgument("OperationType", 0, UINT8_MAX, &mOperationType);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("UserName", &mUserName);
        AddArgument("UserUniqueId", 0, UINT32_MAX, &mUserUniqueId);
        AddArgument("UserStatus", 0, UINT8_MAX, &mUserStatus);
        AddArgument("UserType", 0, UINT8_MAX, &mUserType);
        AddArgument("CredentialRule", 0, UINT8_MAX, &mCredentialRule);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterSetUserParams alloc] init];
        params.operationType = [NSNumber numberWithUnsignedChar:mOperationType];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.userName = [[NSString alloc] initWithBytes:mUserName.data() length:mUserName.size() encoding:NSUTF8StringEncoding];
        params.userUniqueId = [NSNumber numberWithUnsignedInt:mUserUniqueId];
        params.userStatus = [NSNumber numberWithUnsignedChar:mUserStatus];
        params.userType = [NSNumber numberWithUnsignedChar:mUserType];
        params.credentialRule = [NSNumber numberWithUnsignedChar:mCredentialRule];
        [cluster setUserWithParams:params
                 completionHandler:^(NSError * _Nullable error) {
                     CHIP_ERROR err = CHIP_NO_ERROR;
                     err = [CHIPError errorToCHIPErrorCode:error];

                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                     SetCommandExitStatus(err);
                 }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mOperationType;
    uint16_t mUserIndex;
    chip::ByteSpan mUserName;
    uint32_t mUserUniqueId;
    uint8_t mUserStatus;
    uint8_t mUserType;
    uint8_t mCredentialRule;
};

/*
 * Command SetWeekDaySchedule
 */
class DoorLockSetWeekDaySchedule : public ModelCommand {
public:
    DoorLockSetWeekDaySchedule()
        : ModelCommand("set-week-day-schedule")
    {
        AddArgument("WeekDayIndex", 0, UINT8_MAX, &mWeekDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("DaysMask", 0, UINT8_MAX, &mDaysMask);
        AddArgument("StartHour", 0, UINT8_MAX, &mStartHour);
        AddArgument("StartMinute", 0, UINT8_MAX, &mStartMinute);
        AddArgument("EndHour", 0, UINT8_MAX, &mEndHour);
        AddArgument("EndMinute", 0, UINT8_MAX, &mEndMinute);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterSetWeekDayScheduleParams alloc] init];
        params.weekDayIndex = [NSNumber numberWithUnsignedChar:mWeekDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.daysMask = [NSNumber numberWithUnsignedChar:mDaysMask];
        params.startHour = [NSNumber numberWithUnsignedChar:mStartHour];
        params.startMinute = [NSNumber numberWithUnsignedChar:mStartMinute];
        params.endHour = [NSNumber numberWithUnsignedChar:mEndHour];
        params.endMinute = [NSNumber numberWithUnsignedChar:mEndMinute];
        [cluster setWeekDayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mWeekDayIndex;
    uint16_t mUserIndex;
    uint8_t mDaysMask;
    uint8_t mStartHour;
    uint8_t mStartMinute;
    uint8_t mEndHour;
    uint8_t mEndMinute;
};

/*
 * Command SetYearDaySchedule
 */
class DoorLockSetYearDaySchedule : public ModelCommand {
public:
    DoorLockSetYearDaySchedule()
        : ModelCommand("set-year-day-schedule")
    {
        AddArgument("YearDayIndex", 0, UINT8_MAX, &mYearDayIndex);
        AddArgument("UserIndex", 0, UINT16_MAX, &mUserIndex);
        AddArgument("LocalStartTime", 0, UINT32_MAX, &mLocalStartTime);
        AddArgument("LocalEndTime", 0, UINT32_MAX, &mLocalEndTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterSetYearDayScheduleParams alloc] init];
        params.yearDayIndex = [NSNumber numberWithUnsignedChar:mYearDayIndex];
        params.userIndex = [NSNumber numberWithUnsignedShort:mUserIndex];
        params.localStartTime = [NSNumber numberWithUnsignedInt:mLocalStartTime];
        params.localEndTime = [NSNumber numberWithUnsignedInt:mLocalEndTime];
        [cluster setYearDayScheduleWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mYearDayIndex;
    uint16_t mUserIndex;
    uint32_t mLocalStartTime;
    uint32_t mLocalEndTime;
};

/*
 * Command UnlockDoor
 */
class DoorLockUnlockDoor : public ModelCommand {
public:
    DoorLockUnlockDoor()
        : ModelCommand("unlock-door")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterUnlockDoorParams alloc] init];
        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster unlockDoorWithParams:params
                    completionHandler:^(NSError * _Nullable error) {
                        CHIP_ERROR err = CHIP_NO_ERROR;
                        err = [CHIPError errorToCHIPErrorCode:error];

                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mPinCode;
};

/*
 * Command UnlockWithTimeout
 */
class DoorLockUnlockWithTimeout : public ModelCommand {
public:
    DoorLockUnlockWithTimeout()
        : ModelCommand("unlock-with-timeout")
    {
        AddArgument("Timeout", 0, UINT16_MAX, &mTimeout);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPDoorLockClusterUnlockWithTimeoutParams alloc] init];
        params.timeout = [NSNumber numberWithUnsignedShort:mTimeout];
        params.pinCode = [[NSData alloc] initWithBytes:mPinCode.data() length:mPinCode.size()];
        [cluster unlockWithTimeoutWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               CHIP_ERROR err = CHIP_NO_ERROR;
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mTimeout;
    chip::ByteSpan mPinCode;
};

/*
 * Event DoorLockAlarm
 */
class ReadDoorLockDoorLockAlarm : public ModelCommand {
public:
    ReadDoorLockDoorLockAlarm()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "door-lock-alarm");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorLockAlarm() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportDoorLockDoorLockAlarm : public ModelCommand {
public:
    ReportDoorLockDoorLockAlarm()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "door-lock-alarm");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockDoorLockAlarm() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event DoorStateChange
 */
class ReadDoorLockDoorStateChange : public ModelCommand {
public:
    ReadDoorLockDoorStateChange()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "door-state-change");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorStateChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportDoorLockDoorStateChange : public ModelCommand {
public:
    ReportDoorLockDoorStateChange()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "door-state-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockDoorStateChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LockOperation
 */
class ReadDoorLockLockOperation : public ModelCommand {
public:
    ReadDoorLockLockOperation()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "lock-operation");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportDoorLockLockOperation : public ModelCommand {
public:
    ReportDoorLockLockOperation()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "lock-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LockOperationError
 */
class ReadDoorLockLockOperationError : public ModelCommand {
public:
    ReadDoorLockLockOperationError()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "lock-operation-error");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockOperationError() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportDoorLockLockOperationError : public ModelCommand {
public:
    ReportDoorLockLockOperationError()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "lock-operation-error");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockOperationError() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LockUserChange
 */
class ReadDoorLockLockUserChange : public ModelCommand {
public:
    ReadDoorLockLockUserChange()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "lock-user-change");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockUserChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadEvent (0x00000004) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportDoorLockLockUserChange : public ModelCommand {
public:
    ReportDoorLockLockUserChange()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "lock-user-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockUserChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportEvent (0x00000004) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockState
 */
class ReadDoorLockLockState : public ModelCommand {
public:
    ReadDoorLockLockState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLockStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.LockState response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock LockState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockLockState : public ModelCommand {
public:
    ReportDoorLockLockState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lock-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LockType
 */
class ReadDoorLockLockType : public ModelCommand {
public:
    ReadDoorLockLockType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lock-type");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLockType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLockTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.LockType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock LockType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockLockType : public ModelCommand {
public:
    ReportDoorLockLockType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lock-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLockType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActuatorEnabled
 */
class ReadDoorLockActuatorEnabled : public ModelCommand {
public:
    ReadDoorLockActuatorEnabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "actuator-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeActuatorEnabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.ActuatorEnabled response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock ActuatorEnabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockActuatorEnabled : public ModelCommand {
public:
    ReportDoorLockActuatorEnabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "actuator-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockActuatorEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DoorState
 */
class ReadDoorLockDoorState : public ModelCommand {
public:
    ReadDoorLockDoorState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "door-state");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockDoorState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDoorStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.DoorState response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock DoorState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockDoorState : public ModelCommand {
public:
    ReportDoorLockDoorState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "door-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockDoorState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfTotalUsersSupported
 */
class ReadDoorLockNumberOfTotalUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfTotalUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeNumberOfTotalUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfTotalUsersSupported response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfTotalUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockNumberOfTotalUsersSupported : public ModelCommand {
public:
    ReportDoorLockNumberOfTotalUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-total-users-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockNumberOfTotalUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPINUsersSupported
 */
class ReadDoorLockNumberOfPINUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfPINUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeNumberOfPINUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfPINUsersSupported response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfPINUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockNumberOfPINUsersSupported : public ModelCommand {
public:
    ReportDoorLockNumberOfPINUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-pinusers-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockNumberOfPINUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfRFIDUsersSupported
 */
class ReadDoorLockNumberOfRFIDUsersSupported : public ModelCommand {
public:
    ReadDoorLockNumberOfRFIDUsersSupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-rfidusers-supported");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfRFIDUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeNumberOfRFIDUsersSupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.NumberOfRFIDUsersSupported response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock NumberOfRFIDUsersSupported Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockNumberOfRFIDUsersSupported : public ModelCommand {
public:
    ReportDoorLockNumberOfRFIDUsersSupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-rfidusers-supported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockNumberOfRFIDUsersSupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeekDaySchedulesSupportedPerUser
 */
class ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-week-day-schedules-supported-per-user");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNumberOfWeekDaySchedulesSupportedPerUserWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfWeekDaySchedulesSupportedPerUser response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfWeekDaySchedulesSupportedPerUser Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockNumberOfWeekDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReportDoorLockNumberOfWeekDaySchedulesSupportedPerUser()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-week-day-schedules-supported-per-user");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockNumberOfWeekDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfYearDaySchedulesSupportedPerUser
 */
class ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-year-day-schedules-supported-per-user");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNumberOfYearDaySchedulesSupportedPerUserWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.NumberOfYearDaySchedulesSupportedPerUser response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock NumberOfYearDaySchedulesSupportedPerUser Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockNumberOfYearDaySchedulesSupportedPerUser : public ModelCommand {
public:
    ReportDoorLockNumberOfYearDaySchedulesSupportedPerUser()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-year-day-schedules-supported-per-user");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockNumberOfYearDaySchedulesSupportedPerUser() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxPINCodeLength
 */
class ReadDoorLockMaxPINCodeLength : public ModelCommand {
public:
    ReadDoorLockMaxPINCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxPINCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MaxPINCodeLength response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MaxPINCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockMaxPINCodeLength : public ModelCommand {
public:
    ReportDoorLockMaxPINCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-pincode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockMaxPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinPINCodeLength
 */
class ReadDoorLockMinPINCodeLength : public ModelCommand {
public:
    ReadDoorLockMinPINCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-pincode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinPINCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MinPINCodeLength response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MinPINCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockMinPINCodeLength : public ModelCommand {
public:
    ReportDoorLockMinPINCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-pincode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockMinPINCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxRFIDCodeLength
 */
class ReadDoorLockMaxRFIDCodeLength : public ModelCommand {
public:
    ReadDoorLockMaxRFIDCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-rfidcode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMaxRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxRFIDCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MaxRFIDCodeLength response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MaxRFIDCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockMaxRFIDCodeLength : public ModelCommand {
public:
    ReportDoorLockMaxRFIDCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-rfidcode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockMaxRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinRFIDCodeLength
 */
class ReadDoorLockMinRFIDCodeLength : public ModelCommand {
public:
    ReadDoorLockMinRFIDCodeLength()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-rfidcode-length");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockMinRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinRFIDCodeLengthWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.MinRFIDCodeLength response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock MinRFIDCodeLength Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockMinRFIDCodeLength : public ModelCommand {
public:
    ReportDoorLockMinRFIDCodeLength()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-rfidcode-length");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockMinRFIDCodeLength() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Language
 */
class ReadDoorLockLanguage : public ModelCommand {
public:
    ReadDoorLockLanguage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "language");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLanguageWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.Language response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock Language Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockLanguage : public ModelCommand {
public:
    WriteDoorLockLanguage()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "language");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLanguageWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "DoorLock Language Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportDoorLockLanguage : public ModelCommand {
public:
    ReportDoorLockLanguage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "language");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockLanguage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AutoRelockTime
 */
class ReadDoorLockAutoRelockTime : public ModelCommand {
public:
    ReadDoorLockAutoRelockTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "auto-relock-time");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAutoRelockTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AutoRelockTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AutoRelockTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockAutoRelockTime : public ModelCommand {
public:
    WriteDoorLockAutoRelockTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeAutoRelockTimeWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "DoorLock AutoRelockTime Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportDoorLockAutoRelockTime : public ModelCommand {
public:
    ReportDoorLockAutoRelockTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "auto-relock-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockAutoRelockTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SoundVolume
 */
class ReadDoorLockSoundVolume : public ModelCommand {
public:
    ReadDoorLockSoundVolume()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sound-volume");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSoundVolumeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.SoundVolume response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock SoundVolume Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockSoundVolume : public ModelCommand {
public:
    WriteDoorLockSoundVolume()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeSoundVolumeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "DoorLock SoundVolume Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportDoorLockSoundVolume : public ModelCommand {
public:
    ReportDoorLockSoundVolume()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sound-volume");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockSoundVolume() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperatingMode
 */
class ReadDoorLockOperatingMode : public ModelCommand {
public:
    ReadDoorLockOperatingMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operating-mode");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOperatingModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.OperatingMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock OperatingMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockOperatingMode : public ModelCommand {
public:
    WriteDoorLockOperatingMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeOperatingModeWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(chipTool, "DoorLock OperatingMode Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportDoorLockOperatingMode : public ModelCommand {
public:
    ReportDoorLockOperatingMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operating-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockOperatingMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedOperatingModes
 */
class ReadDoorLockSupportedOperatingModes : public ModelCommand {
public:
    ReadDoorLockSupportedOperatingModes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-operating-modes");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeSupportedOperatingModesWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.SupportedOperatingModes response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock SupportedOperatingModes Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockSupportedOperatingModes : public ModelCommand {
public:
    ReportDoorLockSupportedOperatingModes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-operating-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockSupportedOperatingModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnableOneTouchLocking
 */
class ReadDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    ReadDoorLockEnableOneTouchLocking()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEnableOneTouchLockingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.EnableOneTouchLocking response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock EnableOneTouchLocking Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    WriteDoorLockEnableOneTouchLocking()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster
            writeAttributeEnableOneTouchLockingWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "DoorLock EnableOneTouchLocking Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportDoorLockEnableOneTouchLocking : public ModelCommand {
public:
    ReportDoorLockEnableOneTouchLocking()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enable-one-touch-locking");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockEnableOneTouchLocking() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnablePrivacyModeButton
 */
class ReadDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    ReadDoorLockEnablePrivacyModeButton()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeEnablePrivacyModeButtonWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.EnablePrivacyModeButton response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock EnablePrivacyModeButton Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    WriteDoorLockEnablePrivacyModeButton()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeEnablePrivacyModeButtonWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                                  err = [CHIPError errorToCHIPErrorCode:error];

                                                  ChipLogError(
                                                      chipTool, "DoorLock EnablePrivacyModeButton Error: %s", chip::ErrorStr(err));
                                                  SetCommandExitStatus(err);
                                              }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportDoorLockEnablePrivacyModeButton : public ModelCommand {
public:
    ReportDoorLockEnablePrivacyModeButton()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enable-privacy-mode-button");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockEnablePrivacyModeButton() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WrongCodeEntryLimit
 */
class ReadDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    ReadDoorLockWrongCodeEntryLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeWrongCodeEntryLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.WrongCodeEntryLimit response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock WrongCodeEntryLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    WriteDoorLockWrongCodeEntryLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) WriteAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeWrongCodeEntryLimitWithValue:value
                                          completionHandler:^(NSError * _Nullable error) {
                                              CHIP_ERROR err = CHIP_NO_ERROR;
                                              err = [CHIPError errorToCHIPErrorCode:error];

                                              ChipLogError(chipTool, "DoorLock WrongCodeEntryLimit Error: %s", chip::ErrorStr(err));
                                              SetCommandExitStatus(err);
                                          }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportDoorLockWrongCodeEntryLimit : public ModelCommand {
public:
    ReportDoorLockWrongCodeEntryLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wrong-code-entry-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockWrongCodeEntryLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadDoorLockServerGeneratedCommandList : public ModelCommand {
public:
    ReadDoorLockServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockServerGeneratedCommandList : public ModelCommand {
public:
    ReportDoorLockServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadDoorLockClientGeneratedCommandList : public ModelCommand {
public:
    ReadDoorLockClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"DoorLock.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "DoorLock ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockClientGeneratedCommandList : public ModelCommand {
public:
    ReportDoorLockClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadDoorLockAttributeList : public ModelCommand {
public:
    ReadDoorLockAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockAttributeList : public ModelCommand {
public:
    ReportDoorLockAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadDoorLockClusterRevision : public ModelCommand {
public:
    ReadDoorLockClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPDoorLock * cluster = [[CHIPDoorLock alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"DoorLock.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "DoorLock ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportDoorLockClusterRevision : public ModelCommand {
public:
    ReportDoorLockClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportDoorLockClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000101) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ElectricalMeasurement                                       | 0x0B04 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasurementType                                                   | 0x0000 |
| * TotalActivePower                                                  | 0x0304 |
| * RmsVoltage                                                        | 0x0505 |
| * RmsVoltageMin                                                     | 0x0506 |
| * RmsVoltageMax                                                     | 0x0507 |
| * RmsCurrent                                                        | 0x0508 |
| * RmsCurrentMin                                                     | 0x0509 |
| * RmsCurrentMax                                                     | 0x050A |
| * ActivePower                                                       | 0x050B |
| * ActivePowerMin                                                    | 0x050C |
| * ActivePowerMax                                                    | 0x050D |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasurementType
 */
class ReadElectricalMeasurementMeasurementType : public ModelCommand {
public:
    ReadElectricalMeasurementMeasurementType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measurement-type");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeMeasurementTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.MeasurementType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement MeasurementType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementMeasurementType : public ModelCommand {
public:
    ReportElectricalMeasurementMeasurementType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measurement-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementMeasurementType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalActivePower
 */
class ReadElectricalMeasurementTotalActivePower : public ModelCommand {
public:
    ReadElectricalMeasurementTotalActivePower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "total-active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000304) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeTotalActivePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.TotalActivePower response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement TotalActivePower Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementTotalActivePower : public ModelCommand {
public:
    ReportElectricalMeasurementTotalActivePower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "total-active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementTotalActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000304) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltage
 */
class ReadElectricalMeasurementRmsVoltage : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000505) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeRmsVoltageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltage response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementRmsVoltage : public ModelCommand {
public:
    ReportElectricalMeasurementRmsVoltage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000505) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMin
 */
class ReadElectricalMeasurementRmsVoltageMin : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltageMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000506) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeRmsVoltageMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltageMin response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltageMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementRmsVoltageMin : public ModelCommand {
public:
    ReportElectricalMeasurementRmsVoltageMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltageMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000506) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsVoltageMax
 */
class ReadElectricalMeasurementRmsVoltageMax : public ModelCommand {
public:
    ReadElectricalMeasurementRmsVoltageMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-voltage-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000507) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeRmsVoltageMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsVoltageMax response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsVoltageMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementRmsVoltageMax : public ModelCommand {
public:
    ReportElectricalMeasurementRmsVoltageMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-voltage-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsVoltageMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000507) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrent
 */
class ReadElectricalMeasurementRmsCurrent : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrent()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000508) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeRmsCurrentWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrent response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrent Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementRmsCurrent : public ModelCommand {
public:
    ReportElectricalMeasurementRmsCurrent()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000508) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMin
 */
class ReadElectricalMeasurementRmsCurrentMin : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrentMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x00000509) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeRmsCurrentMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrentMin response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrentMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementRmsCurrentMin : public ModelCommand {
public:
    ReportElectricalMeasurementRmsCurrentMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrentMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x00000509) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RmsCurrentMax
 */
class ReadElectricalMeasurementRmsCurrentMax : public ModelCommand {
public:
    ReadElectricalMeasurementRmsCurrentMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rms-current-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeRmsCurrentMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.RmsCurrentMax response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement RmsCurrentMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementRmsCurrentMax : public ModelCommand {
public:
    ReportElectricalMeasurementRmsCurrentMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rms-current-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementRmsCurrentMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePower
 */
class ReadElectricalMeasurementActivePower : public ModelCommand {
public:
    ReadElectricalMeasurementActivePower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeActivePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePower response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePower Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementActivePower : public ModelCommand {
public:
    ReportElectricalMeasurementActivePower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMin
 */
class ReadElectricalMeasurementActivePowerMin : public ModelCommand {
public:
    ReadElectricalMeasurementActivePowerMin()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-min");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeActivePowerMinWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePowerMin response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePowerMin Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementActivePowerMin : public ModelCommand {
public:
    ReportElectricalMeasurementActivePowerMin()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power-min");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePowerMin() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActivePowerMax
 */
class ReadElectricalMeasurementActivePowerMax : public ModelCommand {
public:
    ReadElectricalMeasurementActivePowerMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-power-max");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000050D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeActivePowerMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ActivePowerMax response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ActivePowerMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementActivePowerMax : public ModelCommand {
public:
    ReportElectricalMeasurementActivePowerMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-power-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementActivePowerMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000050D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadElectricalMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadElectricalMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ElectricalMeasurement.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ElectricalMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReportElectricalMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadElectricalMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadElectricalMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ElectricalMeasurement.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ElectricalMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReportElectricalMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadElectricalMeasurementAttributeList : public ModelCommand {
public:
    ReadElectricalMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementAttributeList : public ModelCommand {
public:
    ReportElectricalMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadElectricalMeasurementClusterRevision : public ModelCommand {
public:
    ReadElectricalMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPElectricalMeasurement * cluster = [[CHIPElectricalMeasurement alloc] initWithDevice:device
                                                                                       endpoint:endpointId
                                                                                          queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ElectricalMeasurement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ElectricalMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportElectricalMeasurementClusterRevision : public ModelCommand {
public:
    ReportElectricalMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportElectricalMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000B04) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster EthernetNetworkDiagnostics                                  | 0x0037 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PHYRate                                                           | 0x0000 |
| * FullDuplex                                                        | 0x0001 |
| * PacketRxCount                                                     | 0x0002 |
| * PacketTxCount                                                     | 0x0003 |
| * TxErrCount                                                        | 0x0004 |
| * CollisionCount                                                    | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * CarrierDetect                                                     | 0x0007 |
| * TimeSinceReset                                                    | 0x0008 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class EthernetNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    EthernetNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute PHYRate
 */
class ReadEthernetNetworkDiagnosticsPHYRate : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPHYRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "phyrate");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributePHYRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PHYRate response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PHYRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsPHYRate : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsPHYRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "phyrate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPHYRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FullDuplex
 */
class ReadEthernetNetworkDiagnosticsFullDuplex : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsFullDuplex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "full-duplex");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeFullDuplexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.FullDuplex response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics FullDuplex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsFullDuplex : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsFullDuplex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "full-duplex");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsFullDuplex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketRxCount
 */
class ReadEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPacketRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributePacketRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PacketRxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PacketRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsPacketRxCount : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsPacketRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPacketRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketTxCount
 */
class ReadEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsPacketTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributePacketTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.PacketTxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics PacketTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsPacketTxCount : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsPacketTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsPacketTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCount
 */
class ReadEthernetNetworkDiagnosticsTxErrCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsTxErrCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeTxErrCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.TxErrCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics TxErrCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsTxErrCount : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsTxErrCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsTxErrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CollisionCount
 */
class ReadEthernetNetworkDiagnosticsCollisionCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsCollisionCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "collision-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeCollisionCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.CollisionCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics CollisionCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsCollisionCount : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsCollisionCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "collision-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsCollisionCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadEthernetNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.OverrunCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CarrierDetect
 */
class ReadEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsCarrierDetect()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "carrier-detect");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeCarrierDetectWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.CarrierDetect response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics CarrierDetect Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsCarrierDetect : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsCarrierDetect()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "carrier-detect");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsCarrierDetect() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimeSinceReset
 */
class ReadEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsTimeSinceReset()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "time-since-reset");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeTimeSinceResetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.TimeSinceReset response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics TimeSinceReset Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsTimeSinceReset : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsTimeSinceReset()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "time-since-reset");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsTimeSinceReset() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadEthernetNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"EthernetNetworkDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "EthernetNetworkDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadEthernetNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"EthernetNetworkDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "EthernetNetworkDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadEthernetNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadEthernetNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadEthernetNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadEthernetNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPEthernetNetworkDiagnostics * cluster = [[CHIPEthernetNetworkDiagnostics alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"EthernetNetworkDiagnostics.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "EthernetNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportEthernetNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReportEthernetNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportEthernetNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000037) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FixedLabel                                                  | 0x0040 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadFixedLabelLabelList : public ModelCommand {
public:
    ReadFixedLabelLabelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLabelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.LabelList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel LabelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFixedLabelLabelList : public ModelCommand {
public:
    ReportFixedLabelLabelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadFixedLabelServerGeneratedCommandList : public ModelCommand {
public:
    ReadFixedLabelServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FixedLabel.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FixedLabel ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportFixedLabelServerGeneratedCommandList : public ModelCommand {
public:
    ReportFixedLabelServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadFixedLabelClientGeneratedCommandList : public ModelCommand {
public:
    ReadFixedLabelClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FixedLabel.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FixedLabel ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportFixedLabelClientGeneratedCommandList : public ModelCommand {
public:
    ReportFixedLabelClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFixedLabelAttributeList : public ModelCommand {
public:
    ReadFixedLabelAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFixedLabelAttributeList : public ModelCommand {
public:
    ReportFixedLabelAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFixedLabelClusterRevision : public ModelCommand {
public:
    ReadFixedLabelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFixedLabel * cluster = [[CHIPFixedLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FixedLabel.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FixedLabel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFixedLabelClusterRevision : public ModelCommand {
public:
    ReportFixedLabelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFixedLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000040) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster FlowMeasurement                                             | 0x0404 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadFlowMeasurementMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementMeasuredValue : public ModelCommand {
public:
    ReportFlowMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadFlowMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MinMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReportFlowMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadFlowMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadFlowMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.MaxMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReportFlowMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadFlowMeasurementTolerance : public ModelCommand {
public:
    ReadFlowMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.Tolerance response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementTolerance : public ModelCommand {
public:
    ReportFlowMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadFlowMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadFlowMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FlowMeasurement.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FlowMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReportFlowMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadFlowMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadFlowMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"FlowMeasurement.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "FlowMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReportFlowMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadFlowMeasurementAttributeList : public ModelCommand {
public:
    ReadFlowMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementAttributeList : public ModelCommand {
public:
    ReportFlowMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadFlowMeasurementClusterRevision : public ModelCommand {
public:
    ReadFlowMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPFlowMeasurement * cluster = [[CHIPFlowMeasurement alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"FlowMeasurement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "FlowMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportFlowMeasurementClusterRevision : public ModelCommand {
public:
    ReportFlowMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportFlowMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000404) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralCommissioning                                        | 0x0030 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ArmFailSafe                                                       |   0x00 |
| * CommissioningComplete                                             |   0x04 |
| * SetRegulatoryConfig                                               |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Breadcrumb                                                        | 0x0000 |
| * BasicCommissioningInfo                                            | 0x0001 |
| * RegulatoryConfig                                                  | 0x0002 |
| * LocationCapability                                                | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ArmFailSafe
 */
class GeneralCommissioningArmFailSafe : public ModelCommand {
public:
    GeneralCommissioningArmFailSafe()
        : ModelCommand("arm-fail-safe")
    {
        AddArgument("ExpiryLengthSeconds", 0, UINT16_MAX, &mExpiryLengthSeconds);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mTimeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPGeneralCommissioningClusterArmFailSafeParams alloc] init];
        params.expiryLengthSeconds = [NSNumber numberWithUnsignedShort:mExpiryLengthSeconds];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        params.timeoutMs = [NSNumber numberWithUnsignedInt:mTimeoutMs];
        [cluster armFailSafeWithParams:params
                     completionHandler:^(
                         CHIPGeneralCommissioningClusterArmFailSafeResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mExpiryLengthSeconds;
    uint64_t mBreadcrumb;
    uint32_t mTimeoutMs;
};

/*
 * Command CommissioningComplete
 */
class GeneralCommissioningCommissioningComplete : public ModelCommand {
public:
    GeneralCommissioningCommissioningComplete()
        : ModelCommand("commissioning-complete")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster commissioningCompleteWithCompletionHandler:^(
            CHIPGeneralCommissioningClusterCommissioningCompleteResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command SetRegulatoryConfig
 */
class GeneralCommissioningSetRegulatoryConfig : public ModelCommand {
public:
    GeneralCommissioningSetRegulatoryConfig()
        : ModelCommand("set-regulatory-config")
    {
        AddArgument("Location", 0, UINT8_MAX, &mLocation);
        AddArgument("CountryCode", &mCountryCode);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        AddArgument("TimeoutMs", 0, UINT32_MAX, &mTimeoutMs);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPGeneralCommissioningClusterSetRegulatoryConfigParams alloc] init];
        params.location = [NSNumber numberWithUnsignedChar:mLocation];
        params.countryCode = [[NSString alloc] initWithBytes:mCountryCode.data()
                                                      length:mCountryCode.size()
                                                    encoding:NSUTF8StringEncoding];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        params.timeoutMs = [NSNumber numberWithUnsignedInt:mTimeoutMs];
        [cluster
            setRegulatoryConfigWithParams:params
                        completionHandler:^(CHIPGeneralCommissioningClusterSetRegulatoryConfigResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mLocation;
    chip::ByteSpan mCountryCode;
    uint64_t mBreadcrumb;
    uint32_t mTimeoutMs;
};

/*
 * Attribute Breadcrumb
 */
class ReadGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    ReadGeneralCommissioningBreadcrumb()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "breadcrumb");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeBreadcrumbWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.Breadcrumb response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning Breadcrumb Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    WriteGeneralCommissioningBreadcrumb()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeBreadcrumbWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogError(chipTool, "GeneralCommissioning Breadcrumb Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportGeneralCommissioningBreadcrumb : public ModelCommand {
public:
    ReportGeneralCommissioningBreadcrumb()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "breadcrumb");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningBreadcrumb() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RegulatoryConfig
 */
class ReadGeneralCommissioningRegulatoryConfig : public ModelCommand {
public:
    ReadGeneralCommissioningRegulatoryConfig()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "regulatory-config");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeRegulatoryConfigWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.RegulatoryConfig response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning RegulatoryConfig Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningRegulatoryConfig : public ModelCommand {
public:
    ReportGeneralCommissioningRegulatoryConfig()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "regulatory-config");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningRegulatoryConfig() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LocationCapability
 */
class ReadGeneralCommissioningLocationCapability : public ModelCommand {
public:
    ReadGeneralCommissioningLocationCapability()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "location-capability");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeLocationCapabilityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.LocationCapability response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning LocationCapability Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningLocationCapability : public ModelCommand {
public:
    ReportGeneralCommissioningLocationCapability()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "location-capability");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningLocationCapability() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGeneralCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralCommissioningServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralCommissioning.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralCommissioning ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReportGeneralCommissioningServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGeneralCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralCommissioningClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralCommissioning.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralCommissioning ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReportGeneralCommissioningClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralCommissioningAttributeList : public ModelCommand {
public:
    ReadGeneralCommissioningAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningAttributeList : public ModelCommand {
public:
    ReportGeneralCommissioningAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralCommissioningClusterRevision : public ModelCommand {
public:
    ReadGeneralCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralCommissioning * cluster = [[CHIPGeneralCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralCommissioning.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralCommissioningClusterRevision : public ModelCommand {
public:
    ReportGeneralCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000030) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GeneralDiagnostics                                          | 0x0033 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NetworkInterfaces                                                 | 0x0000 |
| * RebootCount                                                       | 0x0001 |
| * UpTime                                                            | 0x0002 |
| * TotalOperationalHours                                             | 0x0003 |
| * BootReasons                                                       | 0x0004 |
| * ActiveHardwareFaults                                              | 0x0005 |
| * ActiveRadioFaults                                                 | 0x0006 |
| * ActiveNetworkFaults                                               | 0x0007 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * HardwareFaultChange                                               | 0x0000 |
| * RadioFaultChange                                                  | 0x0001 |
| * NetworkFaultChange                                                | 0x0002 |
| * BootReason                                                        | 0x0003 |
\*----------------------------------------------------------------------------*/

/*
 * Event HardwareFaultChange
 */
class ReadGeneralDiagnosticsHardwareFaultChange : public ModelCommand {
public:
    ReadGeneralDiagnosticsHardwareFaultChange()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "hardware-fault-change");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsHardwareFaultChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportGeneralDiagnosticsHardwareFaultChange : public ModelCommand {
public:
    ReportGeneralDiagnosticsHardwareFaultChange()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "hardware-fault-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsHardwareFaultChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event RadioFaultChange
 */
class ReadGeneralDiagnosticsRadioFaultChange : public ModelCommand {
public:
    ReadGeneralDiagnosticsRadioFaultChange()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "radio-fault-change");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRadioFaultChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportGeneralDiagnosticsRadioFaultChange : public ModelCommand {
public:
    ReportGeneralDiagnosticsRadioFaultChange()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "radio-fault-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsRadioFaultChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event NetworkFaultChange
 */
class ReadGeneralDiagnosticsNetworkFaultChange : public ModelCommand {
public:
    ReadGeneralDiagnosticsNetworkFaultChange()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "network-fault-change");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkFaultChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportGeneralDiagnosticsNetworkFaultChange : public ModelCommand {
public:
    ReportGeneralDiagnosticsNetworkFaultChange()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "network-fault-change");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsNetworkFaultChange() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event BootReason
 */
class ReadGeneralDiagnosticsBootReason : public ModelCommand {
public:
    ReadGeneralDiagnosticsBootReason()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "boot-reason");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReason() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportGeneralDiagnosticsBootReason : public ModelCommand {
public:
    ReportGeneralDiagnosticsBootReason()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "boot-reason");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsBootReason() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkInterfaces
 */
class ReadGeneralDiagnosticsNetworkInterfaces : public ModelCommand {
public:
    ReadGeneralDiagnosticsNetworkInterfaces()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "network-interfaces");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeNetworkInterfacesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.NetworkInterfaces response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics NetworkInterfaces Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsNetworkInterfaces : public ModelCommand {
public:
    ReportGeneralDiagnosticsNetworkInterfaces()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "network-interfaces");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsNetworkInterfaces() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RebootCount
 */
class ReadGeneralDiagnosticsRebootCount : public ModelCommand {
public:
    ReadGeneralDiagnosticsRebootCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "reboot-count");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeRebootCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.RebootCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics RebootCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsRebootCount : public ModelCommand {
public:
    ReportGeneralDiagnosticsRebootCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "reboot-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsRebootCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpTime
 */
class ReadGeneralDiagnosticsUpTime : public ModelCommand {
public:
    ReadGeneralDiagnosticsUpTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "up-time");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeUpTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.UpTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics UpTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsUpTime : public ModelCommand {
public:
    ReportGeneralDiagnosticsUpTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "up-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsUpTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TotalOperationalHours
 */
class ReadGeneralDiagnosticsTotalOperationalHours : public ModelCommand {
public:
    ReadGeneralDiagnosticsTotalOperationalHours()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "total-operational-hours");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeTotalOperationalHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.TotalOperationalHours response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics TotalOperationalHours Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsTotalOperationalHours : public ModelCommand {
public:
    ReportGeneralDiagnosticsTotalOperationalHours()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "total-operational-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsTotalOperationalHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BootReasons
 */
class ReadGeneralDiagnosticsBootReasons : public ModelCommand {
public:
    ReadGeneralDiagnosticsBootReasons()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "boot-reasons");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeBootReasonsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.BootReasons response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics BootReasons Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsBootReasons : public ModelCommand {
public:
    ReportGeneralDiagnosticsBootReasons()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "boot-reasons");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsBootReasons() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveHardwareFaults
 */
class ReadGeneralDiagnosticsActiveHardwareFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveHardwareFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-hardware-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeActiveHardwareFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveHardwareFaults response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveHardwareFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsActiveHardwareFaults : public ModelCommand {
public:
    ReportGeneralDiagnosticsActiveHardwareFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-hardware-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsActiveHardwareFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveRadioFaults
 */
class ReadGeneralDiagnosticsActiveRadioFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveRadioFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-radio-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeActiveRadioFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveRadioFaults response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveRadioFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsActiveRadioFaults : public ModelCommand {
public:
    ReportGeneralDiagnosticsActiveRadioFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-radio-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsActiveRadioFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaults
 */
class ReadGeneralDiagnosticsActiveNetworkFaults : public ModelCommand {
public:
    ReadGeneralDiagnosticsActiveNetworkFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeActiveNetworkFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ActiveNetworkFaults response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ActiveNetworkFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsActiveNetworkFaults : public ModelCommand {
public:
    ReportGeneralDiagnosticsActiveNetworkFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-network-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsActiveNetworkFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGeneralDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReportGeneralDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGeneralDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadGeneralDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GeneralDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GeneralDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReportGeneralDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGeneralDiagnosticsAttributeList : public ModelCommand {
public:
    ReadGeneralDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsAttributeList : public ModelCommand {
public:
    ReportGeneralDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGeneralDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadGeneralDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGeneralDiagnostics * cluster = [[CHIPGeneralDiagnostics alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GeneralDiagnostics.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GeneralDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGeneralDiagnosticsClusterRevision : public ModelCommand {
public:
    ReportGeneralDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGeneralDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000033) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster GroupKeyManagement                                          | 0x003F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * KeySetRead                                                        |   0x01 |
| * KeySetReadAllIndices                                              |   0x04 |
| * KeySetRemove                                                      |   0x03 |
| * KeySetWrite                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * GroupKeyMap                                                       | 0x0000 |
| * GroupTable                                                        | 0x0001 |
| * MaxGroupsPerFabric                                                | 0x0002 |
| * MaxGroupKeysPerFabric                                             | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command KeySetRead
 */
class GroupKeyManagementKeySetRead : public ModelCommand {
public:
    GroupKeyManagementKeySetRead()
        : ModelCommand("key-set-read")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mGroupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:mGroupKeySetID];
        [cluster keySetReadWithParams:params
                    completionHandler:^(
                        CHIPGroupKeyManagementClusterKeySetReadResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        CHIP_ERROR err = CHIP_NO_ERROR;
                        err = [CHIPError errorToCHIPErrorCode:error];

                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupKeySetID;
};

/*
 * Command KeySetReadAllIndices
 */
class GroupKeyManagementKeySetReadAllIndices : public ModelCommand {
public:
    GroupKeyManagementKeySetReadAllIndices()
        : ModelCommand("key-set-read-all-indices")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetReadAllIndicesParams alloc] init];
        // GroupKeySetIDs Array parsing is not supported yet
        [cluster
            keySetReadAllIndicesWithParams:params
                         completionHandler:^(CHIPGroupKeyManagementClusterKeySetReadAllIndicesResponseParams * _Nullable values,
                             NSError * _Nullable error) {
                             NSLog(@"Values: %@", values);
                             CHIP_ERROR err = CHIP_NO_ERROR;
                             err = [CHIPError errorToCHIPErrorCode:error];

                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command KeySetRemove
 */
class GroupKeyManagementKeySetRemove : public ModelCommand {
public:
    GroupKeyManagementKeySetRemove()
        : ModelCommand("key-set-remove")
    {
        AddArgument("GroupKeySetID", 0, UINT16_MAX, &mGroupKeySetID);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetRemoveParams alloc] init];
        params.groupKeySetID = [NSNumber numberWithUnsignedShort:mGroupKeySetID];
        [cluster keySetRemoveWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupKeySetID;
};

/*
 * Command KeySetWrite
 */
class GroupKeyManagementKeySetWrite : public ModelCommand {
public:
    GroupKeyManagementKeySetWrite()
        : ModelCommand("key-set-write")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPGroupKeyManagementClusterKeySetWriteParams alloc] init];
        // GroupKeySet Struct parsing is not supported yet
        [cluster keySetWriteWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute GroupKeyMap
 */
class ReadGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    ReadGroupKeyManagementGroupKeyMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "group-key-map");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeGroupKeyMapWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.GroupKeyMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement GroupKeyMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementGroupKeyMap : public ModelCommand {
public:
    ReportGroupKeyManagementGroupKeyMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "group-key-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementGroupKeyMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GroupTable
 */
class ReadGroupKeyManagementGroupTable : public ModelCommand {
public:
    ReadGroupKeyManagementGroupTable()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "group-table");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeGroupTableWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.GroupTable response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement GroupTable Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementGroupTable : public ModelCommand {
public:
    ReportGroupKeyManagementGroupTable()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "group-table");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementGroupTable() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupsPerFabric
 */
class ReadGroupKeyManagementMaxGroupsPerFabric : public ModelCommand {
public:
    ReadGroupKeyManagementMaxGroupsPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeMaxGroupsPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.MaxGroupsPerFabric response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement MaxGroupsPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementMaxGroupsPerFabric : public ModelCommand {
public:
    ReportGroupKeyManagementMaxGroupsPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-groups-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementMaxGroupsPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxGroupKeysPerFabric
 */
class ReadGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand {
public:
    ReadGroupKeyManagementMaxGroupKeysPerFabric()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeMaxGroupKeysPerFabricWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.MaxGroupKeysPerFabric response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement MaxGroupKeysPerFabric Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementMaxGroupKeysPerFabric : public ModelCommand {
public:
    ReportGroupKeyManagementMaxGroupKeysPerFabric()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-group-keys-per-fabric");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementMaxGroupKeysPerFabric() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGroupKeyManagementServerGeneratedCommandList : public ModelCommand {
public:
    ReadGroupKeyManagementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GroupKeyManagement.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GroupKeyManagement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementServerGeneratedCommandList : public ModelCommand {
public:
    ReportGroupKeyManagementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGroupKeyManagementClientGeneratedCommandList : public ModelCommand {
public:
    ReadGroupKeyManagementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"GroupKeyManagement.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "GroupKeyManagement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementClientGeneratedCommandList : public ModelCommand {
public:
    ReportGroupKeyManagementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupKeyManagementAttributeList : public ModelCommand {
public:
    ReadGroupKeyManagementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementAttributeList : public ModelCommand {
public:
    ReportGroupKeyManagementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupKeyManagementClusterRevision : public ModelCommand {
public:
    ReadGroupKeyManagementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroupKeyManagement * cluster = [[CHIPGroupKeyManagement alloc] initWithDevice:device
                                                                                 endpoint:endpointId
                                                                                    queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"GroupKeyManagement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "GroupKeyManagement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupKeyManagementClusterRevision : public ModelCommand {
public:
    ReportGroupKeyManagementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupKeyManagementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Groups                                                      | 0x0004 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddGroup                                                          |   0x00 |
| * AddGroupIfIdentifying                                             |   0x05 |
| * GetGroupMembership                                                |   0x02 |
| * RemoveAllGroups                                                   |   0x04 |
| * RemoveGroup                                                       |   0x03 |
| * ViewGroup                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NameSupport                                                       | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddGroup
 */
class GroupsAddGroup : public ModelCommand {
public:
    GroupsAddGroup()
        : ModelCommand("add-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("GroupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPGroupsClusterAddGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.groupName = [[NSString alloc] initWithBytes:mGroupName.data()
                                                    length:mGroupName.size()
                                                  encoding:NSUTF8StringEncoding];
        [cluster addGroupWithParams:params
                  completionHandler:^(CHIPGroupsClusterAddGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      CHIP_ERROR err = CHIP_NO_ERROR;
                      err = [CHIPError errorToCHIPErrorCode:error];

                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    chip::ByteSpan mGroupName;
};

/*
 * Command AddGroupIfIdentifying
 */
class GroupsAddGroupIfIdentifying : public ModelCommand {
public:
    GroupsAddGroupIfIdentifying()
        : ModelCommand("add-group-if-identifying")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("GroupName", &mGroupName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPGroupsClusterAddGroupIfIdentifyingParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.groupName = [[NSString alloc] initWithBytes:mGroupName.data()
                                                    length:mGroupName.size()
                                                  encoding:NSUTF8StringEncoding];
        [cluster addGroupIfIdentifyingWithParams:params
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    chip::ByteSpan mGroupName;
};

/*
 * Command GetGroupMembership
 */
class GroupsGetGroupMembership : public ModelCommand {
public:
    GroupsGetGroupMembership()
        : ModelCommand("get-group-membership")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPGroupsClusterGetGroupMembershipParams alloc] init];
        // groupList Array parsing is not supported yet
        [cluster getGroupMembershipWithParams:params
                            completionHandler:^(
                                CHIPGroupsClusterGetGroupMembershipResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command RemoveAllGroups
 */
class GroupsRemoveAllGroups : public ModelCommand {
public:
    GroupsRemoveAllGroups()
        : ModelCommand("remove-all-groups")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster removeAllGroupsWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command RemoveGroup
 */
class GroupsRemoveGroup : public ModelCommand {
public:
    GroupsRemoveGroup()
        : ModelCommand("remove-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPGroupsClusterRemoveGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster removeGroupWithParams:params
                     completionHandler:^(CHIPGroupsClusterRemoveGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command ViewGroup
 */
class GroupsViewGroup : public ModelCommand {
public:
    GroupsViewGroup()
        : ModelCommand("view-group")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPGroupsClusterViewGroupParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster viewGroupWithParams:params
                   completionHandler:^(CHIPGroupsClusterViewGroupResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
};

/*
 * Attribute NameSupport
 */
class ReadGroupsNameSupport : public ModelCommand {
public:
    ReadGroupsNameSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNameSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.NameSupport response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups NameSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupsNameSupport : public ModelCommand {
public:
    ReportGroupsNameSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadGroupsServerGeneratedCommandList : public ModelCommand {
public:
    ReadGroupsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Groups.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Groups ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupsServerGeneratedCommandList : public ModelCommand {
public:
    ReportGroupsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadGroupsClientGeneratedCommandList : public ModelCommand {
public:
    ReadGroupsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Groups.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Groups ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupsClientGeneratedCommandList : public ModelCommand {
public:
    ReportGroupsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadGroupsAttributeList : public ModelCommand {
public:
    ReadGroupsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupsAttributeList : public ModelCommand {
public:
    ReportGroupsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadGroupsClusterRevision : public ModelCommand {
public:
    ReadGroupsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPGroups * cluster = [[CHIPGroups alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Groups.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Groups ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportGroupsClusterRevision : public ModelCommand {
public:
    ReportGroupsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportGroupsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000004) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Identify                                                    | 0x0003 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Identify                                                          |   0x00 |
| * IdentifyQuery                                                     |   0x01 |
| * TriggerEffect                                                     |   0x40 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * IdentifyTime                                                      | 0x0000 |
| * IdentifyType                                                      | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Identify
 */
class IdentifyIdentify : public ModelCommand {
public:
    IdentifyIdentify()
        : ModelCommand("identify")
    {
        AddArgument("IdentifyTime", 0, UINT16_MAX, &mIdentifyTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPIdentifyClusterIdentifyParams alloc] init];
        params.identifyTime = [NSNumber numberWithUnsignedShort:mIdentifyTime];
        [cluster identifyWithParams:params
                  completionHandler:^(NSError * _Nullable error) {
                      CHIP_ERROR err = CHIP_NO_ERROR;
                      err = [CHIPError errorToCHIPErrorCode:error];

                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mIdentifyTime;
};

/*
 * Command IdentifyQuery
 */
class IdentifyIdentifyQuery : public ModelCommand {
public:
    IdentifyIdentifyQuery()
        : ModelCommand("identify-query")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster identifyQueryWithCompletionHandler:^(
            CHIPIdentifyClusterIdentifyQueryResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TriggerEffect
 */
class IdentifyTriggerEffect : public ModelCommand {
public:
    IdentifyTriggerEffect()
        : ModelCommand("trigger-effect")
    {
        AddArgument("EffectIdentifier", 0, UINT8_MAX, &mEffectIdentifier);
        AddArgument("EffectVariant", 0, UINT8_MAX, &mEffectVariant);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) command (0x00000040) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPIdentifyClusterTriggerEffectParams alloc] init];
        params.effectIdentifier = [NSNumber numberWithUnsignedChar:mEffectIdentifier];
        params.effectVariant = [NSNumber numberWithUnsignedChar:mEffectVariant];
        [cluster triggerEffectWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mEffectIdentifier;
    uint8_t mEffectVariant;
};

/*
 * Attribute IdentifyTime
 */
class ReadIdentifyIdentifyTime : public ModelCommand {
public:
    ReadIdentifyIdentifyTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-time");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeIdentifyTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.IdentifyTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify IdentifyTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteIdentifyIdentifyTime : public ModelCommand {
public:
    WriteIdentifyIdentifyTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeIdentifyTimeWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "Identify IdentifyTime Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportIdentifyIdentifyTime : public ModelCommand {
public:
    ReportIdentifyIdentifyTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "identify-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyIdentifyTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute IdentifyType
 */
class ReadIdentifyIdentifyType : public ModelCommand {
public:
    ReadIdentifyIdentifyType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "identify-type");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeIdentifyTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.IdentifyType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify IdentifyType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIdentifyIdentifyType : public ModelCommand {
public:
    ReportIdentifyIdentifyType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "identify-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyIdentifyType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadIdentifyServerGeneratedCommandList : public ModelCommand {
public:
    ReadIdentifyServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Identify.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Identify ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportIdentifyServerGeneratedCommandList : public ModelCommand {
public:
    ReportIdentifyServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadIdentifyClientGeneratedCommandList : public ModelCommand {
public:
    ReadIdentifyClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Identify.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Identify ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportIdentifyClientGeneratedCommandList : public ModelCommand {
public:
    ReportIdentifyClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIdentifyAttributeList : public ModelCommand {
public:
    ReadIdentifyAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIdentifyAttributeList : public ModelCommand {
public:
    ReportIdentifyAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIdentifyClusterRevision : public ModelCommand {
public:
    ReadIdentifyClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIdentify * cluster = [[CHIPIdentify alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Identify.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Identify ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIdentifyClusterRevision : public ModelCommand {
public:
    ReportIdentifyClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIdentifyClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000003) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster IlluminanceMeasurement                                      | 0x0400 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * LightSensorType                                                   | 0x0004 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadIlluminanceMeasurementMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementMeasuredValue : public ModelCommand {
public:
    ReportIlluminanceMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadIlluminanceMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MinMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReportIlluminanceMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadIlluminanceMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadIlluminanceMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.MaxMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReportIlluminanceMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadIlluminanceMeasurementTolerance : public ModelCommand {
public:
    ReadIlluminanceMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.Tolerance response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementTolerance : public ModelCommand {
public:
    ReportIlluminanceMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LightSensorType
 */
class ReadIlluminanceMeasurementLightSensorType : public ModelCommand {
public:
    ReadIlluminanceMeasurementLightSensorType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "light-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeLightSensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.LightSensorType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement LightSensorType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementLightSensorType : public ModelCommand {
public:
    ReportIlluminanceMeasurementLightSensorType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "light-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementLightSensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadIlluminanceMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadIlluminanceMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"IlluminanceMeasurement.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "IlluminanceMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReportIlluminanceMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadIlluminanceMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadIlluminanceMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"IlluminanceMeasurement.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "IlluminanceMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReportIlluminanceMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadIlluminanceMeasurementAttributeList : public ModelCommand {
public:
    ReadIlluminanceMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementAttributeList : public ModelCommand {
public:
    ReportIlluminanceMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadIlluminanceMeasurementClusterRevision : public ModelCommand {
public:
    ReadIlluminanceMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPIlluminanceMeasurement * cluster = [[CHIPIlluminanceMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"IlluminanceMeasurement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "IlluminanceMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportIlluminanceMeasurementClusterRevision : public ModelCommand {
public:
    ReportIlluminanceMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportIlluminanceMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000400) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster KeypadInput                                                 | 0x0509 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SendKeyRequest                                                    |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command SendKeyRequest
 */
class KeypadInputSendKeyRequest : public ModelCommand {
public:
    KeypadInputSendKeyRequest()
        : ModelCommand("send-key-request")
    {
        AddArgument("KeyCode", 0, UINT8_MAX, &mKeyCode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPKeypadInputClusterSendKeyRequestParams alloc] init];
        params.keyCode = [NSNumber numberWithUnsignedChar:mKeyCode];
        [cluster
            sendKeyRequestWithParams:params
                   completionHandler:^(CHIPKeypadInputClusterSendKeyResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mKeyCode;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadKeypadInputServerGeneratedCommandList : public ModelCommand {
public:
    ReadKeypadInputServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"KeypadInput.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "KeypadInput ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportKeypadInputServerGeneratedCommandList : public ModelCommand {
public:
    ReportKeypadInputServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadKeypadInputClientGeneratedCommandList : public ModelCommand {
public:
    ReadKeypadInputClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"KeypadInput.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "KeypadInput ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportKeypadInputClientGeneratedCommandList : public ModelCommand {
public:
    ReportKeypadInputClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadKeypadInputAttributeList : public ModelCommand {
public:
    ReadKeypadInputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportKeypadInputAttributeList : public ModelCommand {
public:
    ReportKeypadInputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadKeypadInputClusterRevision : public ModelCommand {
public:
    ReadKeypadInputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPKeypadInput * cluster = [[CHIPKeypadInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"KeypadInput.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "KeypadInput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportKeypadInputClusterRevision : public ModelCommand {
public:
    ReportKeypadInputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportKeypadInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000509) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LevelControl                                                | 0x0008 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Move                                                              |   0x01 |
| * MoveToLevel                                                       |   0x00 |
| * MoveToLevelWithOnOff                                              |   0x04 |
| * MoveWithOnOff                                                     |   0x05 |
| * Step                                                              |   0x02 |
| * StepWithOnOff                                                     |   0x06 |
| * Stop                                                              |   0x03 |
| * StopWithOnOff                                                     |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentLevel                                                      | 0x0000 |
| * RemainingTime                                                     | 0x0001 |
| * MinLevel                                                          | 0x0002 |
| * MaxLevel                                                          | 0x0003 |
| * CurrentFrequency                                                  | 0x0004 |
| * MinFrequency                                                      | 0x0005 |
| * MaxFrequency                                                      | 0x0006 |
| * Options                                                           | 0x000F |
| * OnOffTransitionTime                                               | 0x0010 |
| * OnLevel                                                           | 0x0011 |
| * OnTransitionTime                                                  | 0x0012 |
| * OffTransitionTime                                                 | 0x0013 |
| * DefaultMoveRate                                                   | 0x0014 |
| * StartUpCurrentLevel                                               | 0x4000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Move
 */
class LevelControlMove : public ModelCommand {
public:
    LevelControlMove()
        : ModelCommand("move")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterMoveParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster moveWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  CHIP_ERROR err = CHIP_NO_ERROR;
                  err = [CHIPError errorToCHIPErrorCode:error];

                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command MoveToLevel
 */
class LevelControlMoveToLevel : public ModelCommand {
public:
    LevelControlMoveToLevel()
        : ModelCommand("move-to-level")
    {
        AddArgument("Level", 0, UINT8_MAX, &mLevel);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:mLevel];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster moveToLevelWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command MoveToLevelWithOnOff
 */
class LevelControlMoveToLevelWithOnOff : public ModelCommand {
public:
    LevelControlMoveToLevelWithOnOff()
        : ModelCommand("move-to-level-with-on-off")
    {
        AddArgument("Level", 0, UINT8_MAX, &mLevel);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterMoveToLevelWithOnOffParams alloc] init];
        params.level = [NSNumber numberWithUnsignedChar:mLevel];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster moveToLevelWithOnOffWithParams:params
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mLevel;
    uint16_t mTransitionTime;
};

/*
 * Command MoveWithOnOff
 */
class LevelControlMoveWithOnOff : public ModelCommand {
public:
    LevelControlMoveWithOnOff()
        : ModelCommand("move-with-on-off")
    {
        AddArgument("MoveMode", 0, UINT8_MAX, &mMoveMode);
        AddArgument("Rate", 0, UINT8_MAX, &mRate);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterMoveWithOnOffParams alloc] init];
        params.moveMode = [NSNumber numberWithUnsignedChar:mMoveMode];
        params.rate = [NSNumber numberWithUnsignedChar:mRate];
        [cluster moveWithOnOffWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMoveMode;
    uint8_t mRate;
};

/*
 * Command Step
 */
class LevelControlStep : public ModelCommand {
public:
    LevelControlStep()
        : ModelCommand("step")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterStepParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster stepWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  CHIP_ERROR err = CHIP_NO_ERROR;
                  err = [CHIPError errorToCHIPErrorCode:error];

                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command StepWithOnOff
 */
class LevelControlStepWithOnOff : public ModelCommand {
public:
    LevelControlStepWithOnOff()
        : ModelCommand("step-with-on-off")
    {
        AddArgument("StepMode", 0, UINT8_MAX, &mStepMode);
        AddArgument("StepSize", 0, UINT8_MAX, &mStepSize);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterStepWithOnOffParams alloc] init];
        params.stepMode = [NSNumber numberWithUnsignedChar:mStepMode];
        params.stepSize = [NSNumber numberWithUnsignedChar:mStepSize];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster stepWithOnOffWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mStepMode;
    uint8_t mStepSize;
    uint16_t mTransitionTime;
};

/*
 * Command Stop
 */
class LevelControlStop : public ModelCommand {
public:
    LevelControlStop()
        : ModelCommand("stop")
    {
        AddArgument("OptionMask", 0, UINT8_MAX, &mOptionMask);
        AddArgument("OptionOverride", 0, UINT8_MAX, &mOptionOverride);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPLevelControlClusterStopParams alloc] init];
        params.optionMask = [NSNumber numberWithUnsignedChar:mOptionMask];
        params.optionOverride = [NSNumber numberWithUnsignedChar:mOptionOverride];
        [cluster stopWithParams:params
              completionHandler:^(NSError * _Nullable error) {
                  CHIP_ERROR err = CHIP_NO_ERROR;
                  err = [CHIPError errorToCHIPErrorCode:error];

                  ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                  SetCommandExitStatus(err);
              }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mOptionMask;
    uint8_t mOptionOverride;
};

/*
 * Command StopWithOnOff
 */
class LevelControlStopWithOnOff : public ModelCommand {
public:
    LevelControlStopWithOnOff()
        : ModelCommand("stop-with-on-off")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster stopWithOnOffWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute CurrentLevel
 */
class ReadLevelControlCurrentLevel : public ModelCommand {
public:
    ReadLevelControlCurrentLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.CurrentLevel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl CurrentLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlCurrentLevel : public ModelCommand {
public:
    ReportLevelControlCurrentLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RemainingTime
 */
class ReadLevelControlRemainingTime : public ModelCommand {
public:
    ReadLevelControlRemainingTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "remaining-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeRemainingTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.RemainingTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl RemainingTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlRemainingTime : public ModelCommand {
public:
    ReportLevelControlRemainingTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "remaining-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlRemainingTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinLevel
 */
class ReadLevelControlMinLevel : public ModelCommand {
public:
    ReadLevelControlMinLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MinLevel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MinLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlMinLevel : public ModelCommand {
public:
    ReportLevelControlMinLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMinLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxLevel
 */
class ReadLevelControlMaxLevel : public ModelCommand {
public:
    ReadLevelControlMaxLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MaxLevel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MaxLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlMaxLevel : public ModelCommand {
public:
    ReportLevelControlMaxLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMaxLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFrequency
 */
class ReadLevelControlCurrentFrequency : public ModelCommand {
public:
    ReadLevelControlCurrentFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.CurrentFrequency response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl CurrentFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlCurrentFrequency : public ModelCommand {
public:
    ReportLevelControlCurrentFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlCurrentFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinFrequency
 */
class ReadLevelControlMinFrequency : public ModelCommand {
public:
    ReadLevelControlMinFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MinFrequency response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MinFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlMinFrequency : public ModelCommand {
public:
    ReportLevelControlMinFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMinFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFrequency
 */
class ReadLevelControlMaxFrequency : public ModelCommand {
public:
    ReadLevelControlMaxFrequency()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-frequency");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxFrequencyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.MaxFrequency response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl MaxFrequency Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlMaxFrequency : public ModelCommand {
public:
    ReportLevelControlMaxFrequency()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-frequency");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlMaxFrequency() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Options
 */
class ReadLevelControlOptions : public ModelCommand {
public:
    ReadLevelControlOptions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "options");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOptionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.Options response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl Options Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlOptions : public ModelCommand {
public:
    WriteLevelControlOptions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "options");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeOptionsWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "LevelControl Options Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportLevelControlOptions : public ModelCommand {
public:
    ReportLevelControlOptions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "options");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOptions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnOffTransitionTime
 */
class ReadLevelControlOnOffTransitionTime : public ModelCommand {
public:
    ReadLevelControlOnOffTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOnOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnOffTransitionTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnOffTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlOnOffTransitionTime : public ModelCommand {
public:
    WriteLevelControlOnOffTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster
            writeAttributeOnOffTransitionTimeWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "LevelControl OnOffTransitionTime Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportLevelControlOnOffTransitionTime : public ModelCommand {
public:
    ReportLevelControlOnOffTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnLevel
 */
class ReadLevelControlOnLevel : public ModelCommand {
public:
    ReadLevelControlOnLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOnLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnLevel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlOnLevel : public ModelCommand {
public:
    WriteLevelControlOnLevel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeOnLevelWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "LevelControl OnLevel Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportLevelControlOnLevel : public ModelCommand {
public:
    ReportLevelControlOnLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTransitionTime
 */
class ReadLevelControlOnTransitionTime : public ModelCommand {
public:
    ReadLevelControlOnTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOnTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OnTransitionTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OnTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlOnTransitionTime : public ModelCommand {
public:
    WriteLevelControlOnTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeOnTransitionTimeWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "LevelControl OnTransitionTime Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportLevelControlOnTransitionTime : public ModelCommand {
public:
    ReportLevelControlOnTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOnTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffTransitionTime
 */
class ReadLevelControlOffTransitionTime : public ModelCommand {
public:
    ReadLevelControlOffTransitionTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "off-transition-time");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOffTransitionTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.OffTransitionTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl OffTransitionTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlOffTransitionTime : public ModelCommand {
public:
    WriteLevelControlOffTransitionTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeOffTransitionTimeWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            CHIP_ERROR err = CHIP_NO_ERROR;
                                            err = [CHIPError errorToCHIPErrorCode:error];

                                            ChipLogError(chipTool, "LevelControl OffTransitionTime Error: %s", chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportLevelControlOffTransitionTime : public ModelCommand {
public:
    ReportLevelControlOffTransitionTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "off-transition-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlOffTransitionTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultMoveRate
 */
class ReadLevelControlDefaultMoveRate : public ModelCommand {
public:
    ReadLevelControlDefaultMoveRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "default-move-rate");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDefaultMoveRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.DefaultMoveRate response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl DefaultMoveRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlDefaultMoveRate : public ModelCommand {
public:
    WriteLevelControlDefaultMoveRate()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeDefaultMoveRateWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "LevelControl DefaultMoveRate Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportLevelControlDefaultMoveRate : public ModelCommand {
public:
    ReportLevelControlDefaultMoveRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "default-move-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlDefaultMoveRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpCurrentLevel
 */
class ReadLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    ReadLevelControlStartUpCurrentLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-current-level");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStartUpCurrentLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.StartUpCurrentLevel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl StartUpCurrentLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    WriteLevelControlStartUpCurrentLevel()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) WriteAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster
            writeAttributeStartUpCurrentLevelWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "LevelControl StartUpCurrentLevel Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportLevelControlStartUpCurrentLevel : public ModelCommand {
public:
    ReportLevelControlStartUpCurrentLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-current-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlStartUpCurrentLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadLevelControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadLevelControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LevelControl.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LevelControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlServerGeneratedCommandList : public ModelCommand {
public:
    ReportLevelControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadLevelControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadLevelControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LevelControl.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LevelControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlClientGeneratedCommandList : public ModelCommand {
public:
    ReportLevelControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLevelControlAttributeList : public ModelCommand {
public:
    ReadLevelControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlAttributeList : public ModelCommand {
public:
    ReportLevelControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadLevelControlFeatureMap : public ModelCommand {
public:
    ReadLevelControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlFeatureMap : public ModelCommand {
public:
    ReportLevelControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLevelControlClusterRevision : public ModelCommand {
public:
    ReadLevelControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLevelControl * cluster = [[CHIPLevelControl alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LevelControl.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LevelControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLevelControlClusterRevision : public ModelCommand {
public:
    ReportLevelControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLevelControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000008) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LocalizationConfiguration                                   | 0x002B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ActiveLocale                                                      | 0x0001 |
| * SupportedLocales                                                  | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute ActiveLocale
 */
class ReadLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    ReadLocalizationConfigurationActiveLocale()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-locale");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster readAttributeActiveLocaleWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.ActiveLocale response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration ActiveLocale Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    WriteLocalizationConfigurationActiveLocale()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster
            writeAttributeActiveLocaleWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "LocalizationConfiguration ActiveLocale Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportLocalizationConfigurationActiveLocale : public ModelCommand {
public:
    ReportLocalizationConfigurationActiveLocale()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-locale");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLocalizationConfigurationActiveLocale() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedLocales
 */
class ReadLocalizationConfigurationSupportedLocales : public ModelCommand {
public:
    ReadLocalizationConfigurationSupportedLocales()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-locales");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster readAttributeSupportedLocalesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.SupportedLocales response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration SupportedLocales Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLocalizationConfigurationSupportedLocales : public ModelCommand {
public:
    ReportLocalizationConfigurationSupportedLocales()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-locales");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLocalizationConfigurationSupportedLocales() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadLocalizationConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadLocalizationConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LocalizationConfiguration.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LocalizationConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportLocalizationConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReportLocalizationConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLocalizationConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadLocalizationConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadLocalizationConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LocalizationConfiguration.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LocalizationConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportLocalizationConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReportLocalizationConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLocalizationConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLocalizationConfigurationClusterRevision : public ModelCommand {
public:
    ReadLocalizationConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLocalizationConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLocalizationConfiguration * cluster = [[CHIPLocalizationConfiguration alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LocalizationConfiguration.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LocalizationConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLocalizationConfigurationClusterRevision : public ModelCommand {
public:
    ReportLocalizationConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLocalizationConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002B) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster LowPower                                                    | 0x0508 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Sleep                                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Sleep
 */
class LowPowerSleep : public ModelCommand {
public:
    LowPowerSleep()
        : ModelCommand("sleep")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster sleepWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadLowPowerServerGeneratedCommandList : public ModelCommand {
public:
    ReadLowPowerServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LowPower.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LowPower ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportLowPowerServerGeneratedCommandList : public ModelCommand {
public:
    ReportLowPowerServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadLowPowerClientGeneratedCommandList : public ModelCommand {
public:
    ReadLowPowerClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"LowPower.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "LowPower ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportLowPowerClientGeneratedCommandList : public ModelCommand {
public:
    ReportLowPowerClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadLowPowerAttributeList : public ModelCommand {
public:
    ReadLowPowerAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLowPowerAttributeList : public ModelCommand {
public:
    ReportLowPowerAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadLowPowerClusterRevision : public ModelCommand {
public:
    ReadLowPowerClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPLowPower * cluster = [[CHIPLowPower alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"LowPower.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "LowPower ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportLowPowerClusterRevision : public ModelCommand {
public:
    ReportLowPowerClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportLowPowerClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000508) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaInput                                                  | 0x0507 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * HideInputStatusRequest                                            |   0x02 |
| * RenameInputRequest                                                |   0x03 |
| * SelectInputRequest                                                |   0x00 |
| * ShowInputStatusRequest                                            |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MediaInputList                                                    | 0x0000 |
| * CurrentMediaInput                                                 | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command HideInputStatusRequest
 */
class MediaInputHideInputStatusRequest : public ModelCommand {
public:
    MediaInputHideInputStatusRequest()
        : ModelCommand("hide-input-status-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster hideInputStatusRequestWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command RenameInputRequest
 */
class MediaInputRenameInputRequest : public ModelCommand {
public:
    MediaInputRenameInputRequest()
        : ModelCommand("rename-input-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        AddArgument("Name", &mName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPMediaInputClusterRenameInputRequestParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        params.name = [[NSString alloc] initWithBytes:mName.data() length:mName.size() encoding:NSUTF8StringEncoding];
        [cluster renameInputRequestWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mIndex;
    chip::ByteSpan mName;
};

/*
 * Command SelectInputRequest
 */
class MediaInputSelectInputRequest : public ModelCommand {
public:
    MediaInputSelectInputRequest()
        : ModelCommand("select-input-request")
    {
        AddArgument("Index", 0, UINT8_MAX, &mIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPMediaInputClusterSelectInputRequestParams alloc] init];
        params.index = [NSNumber numberWithUnsignedChar:mIndex];
        [cluster selectInputRequestWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mIndex;
};

/*
 * Command ShowInputStatusRequest
 */
class MediaInputShowInputStatusRequest : public ModelCommand {
public:
    MediaInputShowInputStatusRequest()
        : ModelCommand("show-input-status-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster showInputStatusRequestWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute MediaInputList
 */
class ReadMediaInputMediaInputList : public ModelCommand {
public:
    ReadMediaInputMediaInputList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "media-input-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputMediaInputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMediaInputListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.MediaInputList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput MediaInputList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputMediaInputList : public ModelCommand {
public:
    ReportMediaInputMediaInputList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "media-input-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputMediaInputList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMediaInput
 */
class ReadMediaInputCurrentMediaInput : public ModelCommand {
public:
    ReadMediaInputCurrentMediaInput()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-media-input");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputCurrentMediaInput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentMediaInputWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.CurrentMediaInput response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput CurrentMediaInput Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputCurrentMediaInput : public ModelCommand {
public:
    ReportMediaInputCurrentMediaInput()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-media-input");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputCurrentMediaInput() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadMediaInputServerGeneratedCommandList : public ModelCommand {
public:
    ReadMediaInputServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaInput.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaInput ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputServerGeneratedCommandList : public ModelCommand {
public:
    ReportMediaInputServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadMediaInputClientGeneratedCommandList : public ModelCommand {
public:
    ReadMediaInputClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaInput.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaInput ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputClientGeneratedCommandList : public ModelCommand {
public:
    ReportMediaInputClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaInputAttributeList : public ModelCommand {
public:
    ReadMediaInputAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputAttributeList : public ModelCommand {
public:
    ReportMediaInputAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaInputClusterRevision : public ModelCommand {
public:
    ReadMediaInputClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaInput * cluster = [[CHIPMediaInput alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaInput.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaInput ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaInputClusterRevision : public ModelCommand {
public:
    ReportMediaInputClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaInputClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000507) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster MediaPlayback                                               | 0x0506 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * FastForwardRequest                                                |   0x07 |
| * NextRequest                                                       |   0x05 |
| * PauseRequest                                                      |   0x01 |
| * PlayRequest                                                       |   0x00 |
| * PreviousRequest                                                   |   0x04 |
| * RewindRequest                                                     |   0x06 |
| * SeekRequest                                                       |   0x0B |
| * SkipBackwardRequest                                               |   0x09 |
| * SkipForwardRequest                                                |   0x08 |
| * StartOverRequest                                                  |   0x03 |
| * StopRequest                                                       |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * PlaybackState                                                     | 0x0000 |
| * StartTime                                                         | 0x0001 |
| * Duration                                                          | 0x0002 |
| * PlaybackSpeed                                                     | 0x0004 |
| * SeekRangeEnd                                                      | 0x0005 |
| * SeekRangeStart                                                    | 0x0006 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command FastForwardRequest
 */
class MediaPlaybackFastForwardRequest : public ModelCommand {
public:
    MediaPlaybackFastForwardRequest()
        : ModelCommand("fast-forward-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster fastForwardRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command NextRequest
 */
class MediaPlaybackNextRequest : public ModelCommand {
public:
    MediaPlaybackNextRequest()
        : ModelCommand("next-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster nextRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command PauseRequest
 */
class MediaPlaybackPauseRequest : public ModelCommand {
public:
    MediaPlaybackPauseRequest()
        : ModelCommand("pause-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster pauseRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command PlayRequest
 */
class MediaPlaybackPlayRequest : public ModelCommand {
public:
    MediaPlaybackPlayRequest()
        : ModelCommand("play-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster playRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command PreviousRequest
 */
class MediaPlaybackPreviousRequest : public ModelCommand {
public:
    MediaPlaybackPreviousRequest()
        : ModelCommand("previous-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster previousRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command RewindRequest
 */
class MediaPlaybackRewindRequest : public ModelCommand {
public:
    MediaPlaybackRewindRequest()
        : ModelCommand("rewind-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster rewindRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command SeekRequest
 */
class MediaPlaybackSeekRequest : public ModelCommand {
public:
    MediaPlaybackSeekRequest()
        : ModelCommand("seek-request")
    {
        AddArgument("Position", 0, UINT64_MAX, &mPosition);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPMediaPlaybackClusterSeekRequestParams alloc] init];
        params.position = [NSNumber numberWithUnsignedLongLong:mPosition];
        [cluster
            seekRequestWithParams:params
                completionHandler:^(CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                    NSLog(@"Values: %@", values);
                    CHIP_ERROR err = CHIP_NO_ERROR;
                    err = [CHIPError errorToCHIPErrorCode:error];

                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                    SetCommandExitStatus(err);
                }];

        return CHIP_NO_ERROR;
    }

private:
    uint64_t mPosition;
};

/*
 * Command SkipBackwardRequest
 */
class MediaPlaybackSkipBackwardRequest : public ModelCommand {
public:
    MediaPlaybackSkipBackwardRequest()
        : ModelCommand("skip-backward-request")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mDeltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPMediaPlaybackClusterSkipBackwardRequestParams alloc] init];
        params.deltaPositionMilliseconds = [NSNumber numberWithUnsignedLongLong:mDeltaPositionMilliseconds];
        [cluster skipBackwardRequestWithParams:params
                             completionHandler:^(
                                 CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                                 NSLog(@"Values: %@", values);
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
    uint64_t mDeltaPositionMilliseconds;
};

/*
 * Command SkipForwardRequest
 */
class MediaPlaybackSkipForwardRequest : public ModelCommand {
public:
    MediaPlaybackSkipForwardRequest()
        : ModelCommand("skip-forward-request")
    {
        AddArgument("DeltaPositionMilliseconds", 0, UINT64_MAX, &mDeltaPositionMilliseconds);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPMediaPlaybackClusterSkipForwardRequestParams alloc] init];
        params.deltaPositionMilliseconds = [NSNumber numberWithUnsignedLongLong:mDeltaPositionMilliseconds];
        [cluster skipForwardRequestWithParams:params
                            completionHandler:^(
                                CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint64_t mDeltaPositionMilliseconds;
};

/*
 * Command StartOverRequest
 */
class MediaPlaybackStartOverRequest : public ModelCommand {
public:
    MediaPlaybackStartOverRequest()
        : ModelCommand("start-over-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster startOverRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command StopRequest
 */
class MediaPlaybackStopRequest : public ModelCommand {
public:
    MediaPlaybackStopRequest()
        : ModelCommand("stop-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster stopRequestWithCompletionHandler:^(
            CHIPMediaPlaybackClusterPlaybackResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute PlaybackState
 */
class ReadMediaPlaybackPlaybackState : public ModelCommand {
public:
    ReadMediaPlaybackPlaybackState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-state");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePlaybackStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.PlaybackState response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback PlaybackState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackPlaybackState : public ModelCommand {
public:
    ReportMediaPlaybackPlaybackState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "playback-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPlaybackState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartTime
 */
class ReadMediaPlaybackStartTime : public ModelCommand {
public:
    ReadMediaPlaybackStartTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-time");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStartTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.StartTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback StartTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackStartTime : public ModelCommand {
public:
    ReportMediaPlaybackStartTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackStartTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Duration
 */
class ReadMediaPlaybackDuration : public ModelCommand {
public:
    ReadMediaPlaybackDuration()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "duration");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDurationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.Duration response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback Duration Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackDuration : public ModelCommand {
public:
    ReportMediaPlaybackDuration()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "duration");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackDuration() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PlaybackSpeed
 */
class ReadMediaPlaybackPlaybackSpeed : public ModelCommand {
public:
    ReadMediaPlaybackPlaybackSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "playback-speed");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributePlaybackSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.PlaybackSpeed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback PlaybackSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackPlaybackSpeed : public ModelCommand {
public:
    ReportMediaPlaybackPlaybackSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "playback-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackPlaybackSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeEnd
 */
class ReadMediaPlaybackSeekRangeEnd : public ModelCommand {
public:
    ReadMediaPlaybackSeekRangeEnd()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-end");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSeekRangeEndWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SeekRangeEnd response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SeekRangeEnd Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackSeekRangeEnd : public ModelCommand {
public:
    ReportMediaPlaybackSeekRangeEnd()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "seek-range-end");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackSeekRangeEnd() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SeekRangeStart
 */
class ReadMediaPlaybackSeekRangeStart : public ModelCommand {
public:
    ReadMediaPlaybackSeekRangeStart()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "seek-range-start");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSeekRangeStartWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.SeekRangeStart response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback SeekRangeStart Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackSeekRangeStart : public ModelCommand {
public:
    ReportMediaPlaybackSeekRangeStart()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "seek-range-start");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackSeekRangeStart() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadMediaPlaybackServerGeneratedCommandList : public ModelCommand {
public:
    ReadMediaPlaybackServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaPlayback.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaPlayback ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackServerGeneratedCommandList : public ModelCommand {
public:
    ReportMediaPlaybackServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadMediaPlaybackClientGeneratedCommandList : public ModelCommand {
public:
    ReadMediaPlaybackClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"MediaPlayback.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "MediaPlayback ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackClientGeneratedCommandList : public ModelCommand {
public:
    ReportMediaPlaybackClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadMediaPlaybackAttributeList : public ModelCommand {
public:
    ReadMediaPlaybackAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackAttributeList : public ModelCommand {
public:
    ReportMediaPlaybackAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadMediaPlaybackClusterRevision : public ModelCommand {
public:
    ReadMediaPlaybackClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPMediaPlayback * cluster = [[CHIPMediaPlayback alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"MediaPlayback.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "MediaPlayback ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportMediaPlaybackClusterRevision : public ModelCommand {
public:
    ReportMediaPlaybackClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportMediaPlaybackClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000506) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ModeSelect                                                  | 0x0050 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ChangeToMode                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * CurrentMode                                                       | 0x0000 |
| * SupportedModes                                                    | 0x0001 |
| * OnMode                                                            | 0x0002 |
| * StartUpMode                                                       | 0x0003 |
| * Description                                                       | 0x0004 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ChangeToMode
 */
class ModeSelectChangeToMode : public ModelCommand {
public:
    ModeSelectChangeToMode()
        : ModelCommand("change-to-mode")
    {
        AddArgument("NewMode", 0, UINT8_MAX, &mNewMode);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPModeSelectClusterChangeToModeParams alloc] init];
        params.newMode = [NSNumber numberWithUnsignedChar:mNewMode];
        [cluster changeToModeWithParams:params
                      completionHandler:^(NSError * _Nullable error) {
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mNewMode;
};

/*
 * Attribute CurrentMode
 */
class ReadModeSelectCurrentMode : public ModelCommand {
public:
    ReadModeSelectCurrentMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.CurrentMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect CurrentMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectCurrentMode : public ModelCommand {
public:
    ReportModeSelectCurrentMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectCurrentMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedModes
 */
class ReadModeSelectSupportedModes : public ModelCommand {
public:
    ReadModeSelectSupportedModes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-modes");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSupportedModesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.SupportedModes response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect SupportedModes Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectSupportedModes : public ModelCommand {
public:
    ReportModeSelectSupportedModes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-modes");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectSupportedModes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnMode
 */
class ReadModeSelectOnMode : public ModelCommand {
public:
    ReadModeSelectOnMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOnModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.OnMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect OnMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteModeSelectOnMode : public ModelCommand {
public:
    WriteModeSelectOnMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) WriteAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeOnModeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "ModeSelect OnMode Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportModeSelectOnMode : public ModelCommand {
public:
    ReportModeSelectOnMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectOnMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpMode
 */
class ReadModeSelectStartUpMode : public ModelCommand {
public:
    ReadModeSelectStartUpMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-mode");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStartUpModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.StartUpMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect StartUpMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectStartUpMode : public ModelCommand {
public:
    ReportModeSelectStartUpMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectStartUpMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadModeSelectDescription : public ModelCommand {
public:
    ReadModeSelectDescription()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDescriptionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.Description response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect Description Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectDescription : public ModelCommand {
public:
    ReportModeSelectDescription()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadModeSelectServerGeneratedCommandList : public ModelCommand {
public:
    ReadModeSelectServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ModeSelect.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ModeSelect ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectServerGeneratedCommandList : public ModelCommand {
public:
    ReportModeSelectServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadModeSelectClientGeneratedCommandList : public ModelCommand {
public:
    ReadModeSelectClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ModeSelect.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ModeSelect ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectClientGeneratedCommandList : public ModelCommand {
public:
    ReportModeSelectClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadModeSelectAttributeList : public ModelCommand {
public:
    ReadModeSelectAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectAttributeList : public ModelCommand {
public:
    ReportModeSelectAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadModeSelectClusterRevision : public ModelCommand {
public:
    ReadModeSelectClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPModeSelect * cluster = [[CHIPModeSelect alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ModeSelect.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ModeSelect ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportModeSelectClusterRevision : public ModelCommand {
public:
    ReportModeSelectClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportModeSelectClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000050) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster NetworkCommissioning                                        | 0x0031 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddOrUpdateThreadNetwork                                          |   0x03 |
| * AddOrUpdateWiFiNetwork                                            |   0x02 |
| * ConnectNetwork                                                    |   0x06 |
| * RemoveNetwork                                                     |   0x04 |
| * ReorderNetwork                                                    |   0x08 |
| * ScanNetworks                                                      |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxNetworks                                                       | 0x0000 |
| * Networks                                                          | 0x0001 |
| * ScanMaxTimeSeconds                                                | 0x0002 |
| * ConnectMaxTimeSeconds                                             | 0x0003 |
| * InterfaceEnabled                                                  | 0x0004 |
| * LastNetworkingStatus                                              | 0x0005 |
| * LastNetworkID                                                     | 0x0006 |
| * LastConnectErrorValue                                             | 0x0007 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddOrUpdateThreadNetwork
 */
class NetworkCommissioningAddOrUpdateThreadNetwork : public ModelCommand {
public:
    NetworkCommissioningAddOrUpdateThreadNetwork()
        : ModelCommand("add-or-update-thread-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPNetworkCommissioningClusterAddOrUpdateThreadNetworkParams alloc] init];
        params.operationalDataset = [[NSData alloc] initWithBytes:mOperationalDataset.data() length:mOperationalDataset.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster addOrUpdateThreadNetworkWithParams:params
                                  completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                                      NSError * _Nullable error) {
                                      NSLog(@"Values: %@", values);
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mOperationalDataset;
    uint64_t mBreadcrumb;
};

/*
 * Command AddOrUpdateWiFiNetwork
 */
class NetworkCommissioningAddOrUpdateWiFiNetwork : public ModelCommand {
public:
    NetworkCommissioningAddOrUpdateWiFiNetwork()
        : ModelCommand("add-or-update-wi-fi-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPNetworkCommissioningClusterAddOrUpdateWiFiNetworkParams alloc] init];
        params.ssid = [[NSData alloc] initWithBytes:mSsid.data() length:mSsid.size()];
        params.credentials = [[NSData alloc] initWithBytes:mCredentials.data() length:mCredentials.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster addOrUpdateWiFiNetworkWithParams:params
                                completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mSsid;
    chip::ByteSpan mCredentials;
    uint64_t mBreadcrumb;
};

/*
 * Command ConnectNetwork
 */
class NetworkCommissioningConnectNetwork : public ModelCommand {
public:
    NetworkCommissioningConnectNetwork()
        : ModelCommand("connect-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPNetworkCommissioningClusterConnectNetworkParams alloc] init];
        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster connectNetworkWithParams:params
                        completionHandler:^(CHIPNetworkCommissioningClusterConnectNetworkResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mNetworkID;
    uint64_t mBreadcrumb;
};

/*
 * Command RemoveNetwork
 */
class NetworkCommissioningRemoveNetwork : public ModelCommand {
public:
    NetworkCommissioningRemoveNetwork()
        : ModelCommand("remove-network")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPNetworkCommissioningClusterRemoveNetworkParams alloc] init];
        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster removeNetworkWithParams:params
                       completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                           NSError * _Nullable error) {
                           NSLog(@"Values: %@", values);
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mNetworkID;
    uint64_t mBreadcrumb;
};

/*
 * Command ReorderNetwork
 */
class NetworkCommissioningReorderNetwork : public ModelCommand {
public:
    NetworkCommissioningReorderNetwork()
        : ModelCommand("reorder-network")
    {
        AddArgument("NetworkIndex", 0, UINT8_MAX, &mNetworkIndex);
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPNetworkCommissioningClusterReorderNetworkParams alloc] init];
        params.networkID = [[NSData alloc] initWithBytes:mNetworkID.data() length:mNetworkID.size()];
        params.networkIndex = [NSNumber numberWithUnsignedChar:mNetworkIndex];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster reorderNetworkWithParams:params
                        completionHandler:^(CHIPNetworkCommissioningClusterNetworkConfigResponseParams * _Nullable values,
                            NSError * _Nullable error) {
                            NSLog(@"Values: %@", values);
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mNetworkID;
    uint8_t mNetworkIndex;
    uint64_t mBreadcrumb;
};

/*
 * Command ScanNetworks
 */
class NetworkCommissioningScanNetworks : public ModelCommand {
public:
    NetworkCommissioningScanNetworks()
        : ModelCommand("scan-networks")
    {
        AddArgument("Breadcrumb", 0, UINT64_MAX, &mBreadcrumb);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        __auto_type * params = [[CHIPNetworkCommissioningClusterScanNetworksParams alloc] init];
        params.ssid = [[NSData alloc] initWithBytes:mSsid.data() length:mSsid.size()];
        params.breadcrumb = [NSNumber numberWithUnsignedLongLong:mBreadcrumb];
        [cluster scanNetworksWithParams:params
                      completionHandler:^(
                          CHIPNetworkCommissioningClusterScanNetworksResponseParams * _Nullable values, NSError * _Nullable error) {
                          NSLog(@"Values: %@", values);
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mSsid;
    uint64_t mBreadcrumb;
};

/*
 * Attribute MaxNetworks
 */
class ReadNetworkCommissioningMaxNetworks : public ModelCommand {
public:
    ReadNetworkCommissioningMaxNetworks()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeMaxNetworksWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.MaxNetworks response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning MaxNetworks Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningMaxNetworks : public ModelCommand {
public:
    ReportNetworkCommissioningMaxNetworks()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-networks");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningMaxNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Networks
 */
class ReadNetworkCommissioningNetworks : public ModelCommand {
public:
    ReadNetworkCommissioningNetworks()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "networks");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeNetworksWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.Networks response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning Networks Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningNetworks : public ModelCommand {
public:
    ReportNetworkCommissioningNetworks()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "networks");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningNetworks() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScanMaxTimeSeconds
 */
class ReadNetworkCommissioningScanMaxTimeSeconds : public ModelCommand {
public:
    ReadNetworkCommissioningScanMaxTimeSeconds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeScanMaxTimeSecondsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ScanMaxTimeSeconds response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ScanMaxTimeSeconds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningScanMaxTimeSeconds : public ModelCommand {
public:
    ReportNetworkCommissioningScanMaxTimeSeconds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scan-max-time-seconds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningScanMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConnectMaxTimeSeconds
 */
class ReadNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand {
public:
    ReadNetworkCommissioningConnectMaxTimeSeconds()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeConnectMaxTimeSecondsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ConnectMaxTimeSeconds response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ConnectMaxTimeSeconds Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningConnectMaxTimeSeconds : public ModelCommand {
public:
    ReportNetworkCommissioningConnectMaxTimeSeconds()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "connect-max-time-seconds");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningConnectMaxTimeSeconds() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InterfaceEnabled
 */
class ReadNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    ReadNetworkCommissioningInterfaceEnabled()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "interface-enabled");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeInterfaceEnabledWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.InterfaceEnabled response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning InterfaceEnabled Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    WriteNetworkCommissioningInterfaceEnabled()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) WriteAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeInterfaceEnabledWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(
                                               chipTool, "NetworkCommissioning InterfaceEnabled Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportNetworkCommissioningInterfaceEnabled : public ModelCommand {
public:
    ReportNetworkCommissioningInterfaceEnabled()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "interface-enabled");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningInterfaceEnabled() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastNetworkingStatus
 */
class ReadNetworkCommissioningLastNetworkingStatus : public ModelCommand {
public:
    ReadNetworkCommissioningLastNetworkingStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-networking-status");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeLastNetworkingStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastNetworkingStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastNetworkingStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningLastNetworkingStatus : public ModelCommand {
public:
    ReportNetworkCommissioningLastNetworkingStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-networking-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningLastNetworkingStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastNetworkID
 */
class ReadNetworkCommissioningLastNetworkID : public ModelCommand {
public:
    ReadNetworkCommissioningLastNetworkID()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-network-id");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeLastNetworkIDWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastNetworkID response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastNetworkID Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningLastNetworkID : public ModelCommand {
public:
    ReportNetworkCommissioningLastNetworkID()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-network-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningLastNetworkID() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LastConnectErrorValue
 */
class ReadNetworkCommissioningLastConnectErrorValue : public ModelCommand {
public:
    ReadNetworkCommissioningLastConnectErrorValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "last-connect-error-value");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeLastConnectErrorValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.LastConnectErrorValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning LastConnectErrorValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningLastConnectErrorValue : public ModelCommand {
public:
    ReportNetworkCommissioningLastConnectErrorValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "last-connect-error-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningLastConnectErrorValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadNetworkCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReadNetworkCommissioningServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"NetworkCommissioning.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "NetworkCommissioning ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningServerGeneratedCommandList : public ModelCommand {
public:
    ReportNetworkCommissioningServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadNetworkCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReadNetworkCommissioningClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"NetworkCommissioning.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "NetworkCommissioning ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningClientGeneratedCommandList : public ModelCommand {
public:
    ReportNetworkCommissioningClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadNetworkCommissioningFeatureMap : public ModelCommand {
public:
    ReadNetworkCommissioningFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningFeatureMap : public ModelCommand {
public:
    ReportNetworkCommissioningFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadNetworkCommissioningClusterRevision : public ModelCommand {
public:
    ReadNetworkCommissioningClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPNetworkCommissioning * cluster = [[CHIPNetworkCommissioning alloc] initWithDevice:device
                                                                                     endpoint:endpointId
                                                                                        queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"NetworkCommissioning.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "NetworkCommissioning ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportNetworkCommissioningClusterRevision : public ModelCommand {
public:
    ReportNetworkCommissioningClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportNetworkCommissioningClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000031) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateProvider                                   | 0x0029 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ApplyUpdateRequest                                                |   0x02 |
| * NotifyUpdateApplied                                               |   0x04 |
| * QueryImage                                                        |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ApplyUpdateRequest
 */
class OtaSoftwareUpdateProviderApplyUpdateRequest : public ModelCommand {
public:
    OtaSoftwareUpdateProviderApplyUpdateRequest()
        : ModelCommand("apply-update-request")
    {
        AddArgument("NewVersion", 0, UINT32_MAX, &mNewVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterApplyUpdateRequestParams alloc] init];
        params.updateToken = [[NSData alloc] initWithBytes:mUpdateToken.data() length:mUpdateToken.size()];
        params.newVersion = [NSNumber numberWithUnsignedInt:mNewVersion];
        [cluster applyUpdateRequestWithParams:params
                            completionHandler:^(CHIPOtaSoftwareUpdateProviderClusterApplyUpdateResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mUpdateToken;
    uint32_t mNewVersion;
};

/*
 * Command NotifyUpdateApplied
 */
class OtaSoftwareUpdateProviderNotifyUpdateApplied : public ModelCommand {
public:
    OtaSoftwareUpdateProviderNotifyUpdateApplied()
        : ModelCommand("notify-update-applied")
    {
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mSoftwareVersion);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterNotifyUpdateAppliedParams alloc] init];
        params.updateToken = [[NSData alloc] initWithBytes:mUpdateToken.data() length:mUpdateToken.size()];
        params.softwareVersion = [NSNumber numberWithUnsignedInt:mSoftwareVersion];
        [cluster notifyUpdateAppliedWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mUpdateToken;
    uint32_t mSoftwareVersion;
};

/*
 * Command QueryImage
 */
class OtaSoftwareUpdateProviderQueryImage : public ModelCommand {
public:
    OtaSoftwareUpdateProviderQueryImage()
        : ModelCommand("query-image")
    {
        AddArgument("VendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("ProductId", 0, UINT16_MAX, &mProductId);
        AddArgument("SoftwareVersion", 0, UINT32_MAX, &mSoftwareVersion);
        AddArgument("HardwareVersion", 0, UINT16_MAX, &mHardwareVersion);
        AddArgument("Location", &mLocation);
        AddArgument("RequestorCanConsent", 0, 1, &mRequestorCanConsent);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        __auto_type * params = [[CHIPOtaSoftwareUpdateProviderClusterQueryImageParams alloc] init];
        params.vendorId = [NSNumber numberWithUnsignedShort:mVendorId];
        params.productId = [NSNumber numberWithUnsignedShort:mProductId];
        params.softwareVersion = [NSNumber numberWithUnsignedInt:mSoftwareVersion];
        // protocolsSupported Array parsing is not supported yet
        params.hardwareVersion = [NSNumber numberWithUnsignedShort:mHardwareVersion];
        params.location = [[NSString alloc] initWithBytes:mLocation.data() length:mLocation.size() encoding:NSUTF8StringEncoding];
        params.requestorCanConsent = [NSNumber numberWithBool:mRequestorCanConsent];
        params.metadataForProvider = [[NSData alloc] initWithBytes:mMetadataForProvider.data() length:mMetadataForProvider.size()];
        [cluster queryImageWithParams:params
                    completionHandler:^(CHIPOtaSoftwareUpdateProviderClusterQueryImageResponseParams * _Nullable values,
                        NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        CHIP_ERROR err = CHIP_NO_ERROR;
                        err = [CHIPError errorToCHIPErrorCode:error];

                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];

        return CHIP_NO_ERROR;
    }

private:
    chip::VendorId mVendorId;
    uint16_t mProductId;
    uint32_t mSoftwareVersion;
    uint16_t mHardwareVersion;
    chip::ByteSpan mLocation;
    bool mRequestorCanConsent;
    chip::ByteSpan mMetadataForProvider;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateProviderAttributeList : public ModelCommand {
public:
    ReadOtaSoftwareUpdateProviderAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateProvider.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateProvider AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateProviderAttributeList : public ModelCommand {
public:
    ReportOtaSoftwareUpdateProviderAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateProviderAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateProviderClusterRevision : public ModelCommand {
public:
    ReadOtaSoftwareUpdateProviderClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateProvider * cluster = [[CHIPOtaSoftwareUpdateProvider alloc] initWithDevice:device
                                                                                               endpoint:endpointId
                                                                                                  queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateProvider.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateProvider ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateProviderClusterRevision : public ModelCommand {
public:
    ReportOtaSoftwareUpdateProviderClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateProviderClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000029) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OtaSoftwareUpdateRequestor                                  | 0x002A |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AnnounceOtaProvider                                               |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * DefaultOtaProviders                                               | 0x0000 |
| * UpdatePossible                                                    | 0x0001 |
| * UpdateState                                                       | 0x0002 |
| * UpdateStateProgress                                               | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * StateTransition                                                   | 0x0000 |
| * VersionApplied                                                    | 0x0001 |
| * DownloadError                                                     | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command AnnounceOtaProvider
 */
class OtaSoftwareUpdateRequestorAnnounceOtaProvider : public ModelCommand {
public:
    OtaSoftwareUpdateRequestorAnnounceOtaProvider()
        : ModelCommand("announce-ota-provider")
    {
        AddArgument("ProviderNodeId", 0, UINT64_MAX, &mProviderNodeId);
        AddArgument("VendorId", 0, UINT16_MAX, &mVendorId);
        AddArgument("AnnouncementReason", 0, UINT8_MAX, &mAnnouncementReason);
        AddArgument("Endpoint", 0, UINT16_MAX, &mEndpoint);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        __auto_type * params = [[CHIPOtaSoftwareUpdateRequestorClusterAnnounceOtaProviderParams alloc] init];
        params.providerNodeId = [NSNumber numberWithUnsignedLongLong:mProviderNodeId];
        params.vendorId = [NSNumber numberWithUnsignedShort:mVendorId];
        params.announcementReason = [NSNumber numberWithUnsignedChar:mAnnouncementReason];
        params.metadataForNode = [[NSData alloc] initWithBytes:mMetadataForNode.data() length:mMetadataForNode.size()];
        params.endpoint = [NSNumber numberWithUnsignedShort:mEndpoint];
        [cluster announceOtaProviderWithParams:params
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];

        return CHIP_NO_ERROR;
    }

private:
    chip::NodeId mProviderNodeId;
    chip::VendorId mVendorId;
    uint8_t mAnnouncementReason;
    chip::ByteSpan mMetadataForNode;
    chip::EndpointId mEndpoint;
};

/*
 * Event StateTransition
 */
class ReadOtaSoftwareUpdateRequestorStateTransition : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorStateTransition()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "state-transition");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorStateTransition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportOtaSoftwareUpdateRequestorStateTransition : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorStateTransition()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "state-transition");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorStateTransition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event VersionApplied
 */
class ReadOtaSoftwareUpdateRequestorVersionApplied : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorVersionApplied()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "version-applied");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorVersionApplied() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportOtaSoftwareUpdateRequestorVersionApplied : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorVersionApplied()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "version-applied");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorVersionApplied() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event DownloadError
 */
class ReadOtaSoftwareUpdateRequestorDownloadError : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorDownloadError()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "download-error");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDownloadError() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportOtaSoftwareUpdateRequestorDownloadError : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorDownloadError()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "download-error");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorDownloadError() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DefaultOtaProviders
 */
class ReadOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "default-ota-providers");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeDefaultOtaProvidersWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.DefaultOtaProviders response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor DefaultOtaProviders Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorDefaultOtaProviders : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorDefaultOtaProviders()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "default-ota-providers");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorDefaultOtaProviders() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdatePossible
 */
class ReadOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdatePossible()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-possible");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeUpdatePossibleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdatePossible response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdatePossible Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorUpdatePossible : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorUpdatePossible()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-possible");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdatePossible() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateState
 */
class ReadOtaSoftwareUpdateRequestorUpdateState : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdateState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeUpdateStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdateState response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdateState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorUpdateState : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorUpdateState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdateState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute UpdateStateProgress
 */
class ReadOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorUpdateStateProgress()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "update-state-progress");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeUpdateStateProgressWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.UpdateStateProgress response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor UpdateStateProgress Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorUpdateStateProgress : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorUpdateStateProgress()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "update-state-progress");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorUpdateStateProgress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOtaSoftwareUpdateRequestorAttributeList : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorAttributeList : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand {
public:
    ReadOtaSoftwareUpdateRequestorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOtaSoftwareUpdateRequestor * cluster = [[CHIPOtaSoftwareUpdateRequestor alloc] initWithDevice:device
                                                                                                 endpoint:endpointId
                                                                                                    queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OtaSoftwareUpdateRequestor.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OtaSoftwareUpdateRequestor ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOtaSoftwareUpdateRequestorClusterRevision : public ModelCommand {
public:
    ReportOtaSoftwareUpdateRequestorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOtaSoftwareUpdateRequestorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002A) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OccupancySensing                                            | 0x0406 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Occupancy                                                         | 0x0000 |
| * OccupancySensorType                                               | 0x0001 |
| * OccupancySensorTypeBitmap                                         | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Occupancy
 */
class ReadOccupancySensingOccupancy : public ModelCommand {
public:
    ReadOccupancySensingOccupancy()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeOccupancyWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.Occupancy response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing Occupancy Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingOccupancy : public ModelCommand {
public:
    ReportOccupancySensingOccupancy()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorType
 */
class ReadOccupancySensingOccupancySensorType : public ModelCommand {
public:
    ReadOccupancySensingOccupancySensorType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeOccupancySensorTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.OccupancySensorType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing OccupancySensorType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingOccupancySensorType : public ModelCommand {
public:
    ReportOccupancySensingOccupancySensorType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy-sensor-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancySensorType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupancySensorTypeBitmap
 */
class ReadOccupancySensingOccupancySensorTypeBitmap : public ModelCommand {
public:
    ReadOccupancySensingOccupancySensorTypeBitmap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeOccupancySensorTypeBitmapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.OccupancySensorTypeBitmap response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing OccupancySensorTypeBitmap Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingOccupancySensorTypeBitmap : public ModelCommand {
public:
    ReportOccupancySensingOccupancySensorTypeBitmap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupancy-sensor-type-bitmap");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingOccupancySensorTypeBitmap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOccupancySensingServerGeneratedCommandList : public ModelCommand {
public:
    ReadOccupancySensingServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingServerGeneratedCommandList : public ModelCommand {
public:
    ReportOccupancySensingServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOccupancySensingClientGeneratedCommandList : public ModelCommand {
public:
    ReadOccupancySensingClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OccupancySensing.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OccupancySensing ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingClientGeneratedCommandList : public ModelCommand {
public:
    ReportOccupancySensingClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOccupancySensingAttributeList : public ModelCommand {
public:
    ReadOccupancySensingAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingAttributeList : public ModelCommand {
public:
    ReportOccupancySensingAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOccupancySensingClusterRevision : public ModelCommand {
public:
    ReadOccupancySensingClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOccupancySensing * cluster = [[CHIPOccupancySensing alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OccupancySensing.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OccupancySensing ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOccupancySensingClusterRevision : public ModelCommand {
public:
    ReportOccupancySensingClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOccupancySensingClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000406) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOff                                                       | 0x0006 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * Off                                                               |   0x00 |
| * OffWithEffect                                                     |   0x40 |
| * On                                                                |   0x01 |
| * OnWithRecallGlobalScene                                           |   0x41 |
| * OnWithTimedOff                                                    |   0x42 |
| * Toggle                                                            |   0x02 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * OnOff                                                             | 0x0000 |
| * GlobalSceneControl                                                | 0x4000 |
| * OnTime                                                            | 0x4001 |
| * OffWaitTime                                                       | 0x4002 |
| * StartUpOnOff                                                      | 0x4003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command Off
 */
class OnOffOff : public ModelCommand {
public:
    OnOffOff()
        : ModelCommand("off")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster offWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command OffWithEffect
 */
class OnOffOffWithEffect : public ModelCommand {
public:
    OnOffOffWithEffect()
        : ModelCommand("off-with-effect")
    {
        AddArgument("EffectId", 0, UINT8_MAX, &mEffectId);
        AddArgument("EffectVariant", 0, UINT8_MAX, &mEffectVariant);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000040) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPOnOffClusterOffWithEffectParams alloc] init];
        params.effectId = [NSNumber numberWithUnsignedChar:mEffectId];
        params.effectVariant = [NSNumber numberWithUnsignedChar:mEffectVariant];
        [cluster offWithEffectWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mEffectId;
    uint8_t mEffectVariant;
};

/*
 * Command On
 */
class OnOffOn : public ModelCommand {
public:
    OnOffOn()
        : ModelCommand("on")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster onWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command OnWithRecallGlobalScene
 */
class OnOffOnWithRecallGlobalScene : public ModelCommand {
public:
    OnOffOnWithRecallGlobalScene()
        : ModelCommand("on-with-recall-global-scene")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000041) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster onWithRecallGlobalSceneWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command OnWithTimedOff
 */
class OnOffOnWithTimedOff : public ModelCommand {
public:
    OnOffOnWithTimedOff()
        : ModelCommand("on-with-timed-off")
    {
        AddArgument("OnOffControl", 0, UINT8_MAX, &mOnOffControl);
        AddArgument("OnTime", 0, UINT16_MAX, &mOnTime);
        AddArgument("OffWaitTime", 0, UINT16_MAX, &mOffWaitTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000042) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPOnOffClusterOnWithTimedOffParams alloc] init];
        params.onOffControl = [NSNumber numberWithUnsignedChar:mOnOffControl];
        params.onTime = [NSNumber numberWithUnsignedShort:mOnTime];
        params.offWaitTime = [NSNumber numberWithUnsignedShort:mOffWaitTime];
        [cluster onWithTimedOffWithParams:params
                        completionHandler:^(NSError * _Nullable error) {
                            CHIP_ERROR err = CHIP_NO_ERROR;
                            err = [CHIPError errorToCHIPErrorCode:error];

                            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                            SetCommandExitStatus(err);
                        }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mOnOffControl;
    uint16_t mOnTime;
    uint16_t mOffWaitTime;
};

/*
 * Command Toggle
 */
class OnOffToggle : public ModelCommand {
public:
    OnOffToggle()
        : ModelCommand("toggle")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster toggleWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute OnOff
 */
class ReadOnOffOnOff : public ModelCommand {
public:
    ReadOnOffOnOff()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OnOff response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OnOff Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffOnOff : public ModelCommand {
public:
    ReportOnOffOnOff()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GlobalSceneControl
 */
class ReadOnOffGlobalSceneControl : public ModelCommand {
public:
    ReadOnOffGlobalSceneControl()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "global-scene-control");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeGlobalSceneControlWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.GlobalSceneControl response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff GlobalSceneControl Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffGlobalSceneControl : public ModelCommand {
public:
    ReportOnOffGlobalSceneControl()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "global-scene-control");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffGlobalSceneControl() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OnTime
 */
class ReadOnOffOnTime : public ModelCommand {
public:
    ReadOnOffOnTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "on-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOnTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OnTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OnTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteOnOffOnTime : public ModelCommand {
public:
    WriteOnOffOnTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeOnTimeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "OnOff OnTime Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportOnOffOnTime : public ModelCommand {
public:
    ReportOnOffOnTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "on-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOnTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OffWaitTime
 */
class ReadOnOffOffWaitTime : public ModelCommand {
public:
    ReadOnOffOffWaitTime()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "off-wait-time");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOffWaitTimeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.OffWaitTime response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff OffWaitTime Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteOnOffOffWaitTime : public ModelCommand {
public:
    WriteOnOffOffWaitTime()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeOffWaitTimeWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "OnOff OffWaitTime Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportOnOffOffWaitTime : public ModelCommand {
public:
    ReportOnOffOffWaitTime()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "off-wait-time");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffOffWaitTime() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartUpOnOff
 */
class ReadOnOffStartUpOnOff : public ModelCommand {
public:
    ReadOnOffStartUpOnOff()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-up-on-off");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStartUpOnOffWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.StartUpOnOff response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff StartUpOnOff Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteOnOffStartUpOnOff : public ModelCommand {
public:
    WriteOnOffStartUpOnOff()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) WriteAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeStartUpOnOffWithValue:value
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogError(chipTool, "OnOff StartUpOnOff Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportOnOffStartUpOnOff : public ModelCommand {
public:
    ReportOnOffStartUpOnOff()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-up-on-off");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffStartUpOnOff() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x00004003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOnOffServerGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOff.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOff ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffServerGeneratedCommandList : public ModelCommand {
public:
    ReportOnOffServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOnOffClientGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOff.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOff ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffClientGeneratedCommandList : public ModelCommand {
public:
    ReportOnOffClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffAttributeList : public ModelCommand {
public:
    ReadOnOffAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffAttributeList : public ModelCommand {
public:
    ReportOnOffAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadOnOffFeatureMap : public ModelCommand {
public:
    ReadOnOffFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffFeatureMap : public ModelCommand {
public:
    ReportOnOffFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffClusterRevision : public ModelCommand {
public:
    ReadOnOffClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOff * cluster = [[CHIPOnOff alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOff.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOff ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffClusterRevision : public ModelCommand {
public:
    ReportOnOffClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000006) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OnOffSwitchConfiguration                                    | 0x0007 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SwitchType                                                        | 0x0000 |
| * SwitchActions                                                     | 0x0010 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute SwitchType
 */
class ReadOnOffSwitchConfigurationSwitchType : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationSwitchType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-type");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeSwitchTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.SwitchType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffSwitchConfigurationSwitchType : public ModelCommand {
public:
    ReportOnOffSwitchConfigurationSwitchType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "switch-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationSwitchType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SwitchActions
 */
class ReadOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "switch-actions");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeSwitchActionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.SwitchActions response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchActions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    WriteOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster
            writeAttributeSwitchActionsWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "OnOffSwitchConfiguration SwitchActions Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportOnOffSwitchConfigurationSwitchActions : public ModelCommand {
public:
    ReportOnOffSwitchConfigurationSwitchActions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "switch-actions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationSwitchActions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOnOffSwitchConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOffSwitchConfiguration.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOffSwitchConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffSwitchConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReportOnOffSwitchConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOnOffSwitchConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OnOffSwitchConfiguration.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OnOffSwitchConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffSwitchConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReportOnOffSwitchConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOnOffSwitchConfigurationAttributeList : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffSwitchConfigurationAttributeList : public ModelCommand {
public:
    ReportOnOffSwitchConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOnOffSwitchConfigurationClusterRevision : public ModelCommand {
public:
    ReadOnOffSwitchConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOnOffSwitchConfiguration * cluster = [[CHIPOnOffSwitchConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OnOffSwitchConfiguration.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OnOffSwitchConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOnOffSwitchConfigurationClusterRevision : public ModelCommand {
public:
    ReportOnOffSwitchConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOnOffSwitchConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000007) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster OperationalCredentials                                      | 0x003E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddNOC                                                            |   0x06 |
| * AddTrustedRootCertificate                                         |   0x0B |
| * AttestationRequest                                                |   0x00 |
| * CSRRequest                                                        |   0x04 |
| * CertificateChainRequest                                           |   0x02 |
| * RemoveFabric                                                      |   0x0A |
| * RemoveTrustedRootCertificate                                      |   0x0C |
| * UpdateFabricLabel                                                 |   0x09 |
| * UpdateNOC                                                         |   0x07 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NOCs                                                              | 0x0000 |
| * FabricsList                                                       | 0x0001 |
| * SupportedFabrics                                                  | 0x0002 |
| * CommissionedFabrics                                               | 0x0003 |
| * TrustedRootCertificates                                           | 0x0004 |
| * CurrentFabricIndex                                                | 0x0005 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddNOC
 */
class OperationalCredentialsAddNOC : public ModelCommand {
public:
    OperationalCredentialsAddNOC()
        : ModelCommand("add-noc")
    {
        AddArgument("CaseAdminNode", 0, UINT64_MAX, &mCaseAdminNode);
        AddArgument("AdminVendorId", 0, UINT16_MAX, &mAdminVendorId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterAddNOCParams alloc] init];
        params.nocValue = [[NSData alloc] initWithBytes:mNOCValue.data() length:mNOCValue.size()];
        params.icacValue = [[NSData alloc] initWithBytes:mICACValue.data() length:mICACValue.size()];
        params.ipkValue = [[NSData alloc] initWithBytes:mIPKValue.data() length:mIPKValue.size()];
        params.caseAdminNode = [NSNumber numberWithUnsignedLongLong:mCaseAdminNode];
        params.adminVendorId = [NSNumber numberWithUnsignedShort:mAdminVendorId];
        [cluster
             addNOCWithParams:params
            completionHandler:^(CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                NSLog(@"Values: %@", values);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mNOCValue;
    chip::ByteSpan mICACValue;
    chip::ByteSpan mIPKValue;
    chip::NodeId mCaseAdminNode;
    uint16_t mAdminVendorId;
};

/*
 * Command AddTrustedRootCertificate
 */
class OperationalCredentialsAddTrustedRootCertificate : public ModelCommand {
public:
    OperationalCredentialsAddTrustedRootCertificate()
        : ModelCommand("add-trusted-root-certificate")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterAddTrustedRootCertificateParams alloc] init];
        params.rootCertificate = [[NSData alloc] initWithBytes:mRootCertificate.data() length:mRootCertificate.size()];
        [cluster addTrustedRootCertificateWithParams:params
                                   completionHandler:^(NSError * _Nullable error) {
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mRootCertificate;
};

/*
 * Command AttestationRequest
 */
class OperationalCredentialsAttestationRequest : public ModelCommand {
public:
    OperationalCredentialsAttestationRequest()
        : ModelCommand("attestation-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterAttestationRequestParams alloc] init];
        params.attestationNonce = [[NSData alloc] initWithBytes:mAttestationNonce.data() length:mAttestationNonce.size()];
        [cluster attestationRequestWithParams:params
                            completionHandler:^(CHIPOperationalCredentialsClusterAttestationResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mAttestationNonce;
};

/*
 * Command CSRRequest
 */
class OperationalCredentialsCSRRequest : public ModelCommand {
public:
    OperationalCredentialsCSRRequest()
        : ModelCommand("csrrequest")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterCSRRequestParams alloc] init];
        params.csrNonce = [[NSData alloc] initWithBytes:mCSRNonce.data() length:mCSRNonce.size()];
        [cluster CSRRequestWithParams:params
                    completionHandler:^(
                        CHIPOperationalCredentialsClusterCSRResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        CHIP_ERROR err = CHIP_NO_ERROR;
                        err = [CHIPError errorToCHIPErrorCode:error];

                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mCSRNonce;
};

/*
 * Command CertificateChainRequest
 */
class OperationalCredentialsCertificateChainRequest : public ModelCommand {
public:
    OperationalCredentialsCertificateChainRequest()
        : ModelCommand("certificate-chain-request")
    {
        AddArgument("CertificateType", 0, UINT8_MAX, &mCertificateType);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterCertificateChainRequestParams alloc] init];
        params.certificateType = [NSNumber numberWithUnsignedChar:mCertificateType];
        [cluster
            certificateChainRequestWithParams:params
                            completionHandler:^(CHIPOperationalCredentialsClusterCertificateChainResponseParams * _Nullable values,
                                NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mCertificateType;
};

/*
 * Command RemoveFabric
 */
class OperationalCredentialsRemoveFabric : public ModelCommand {
public:
    OperationalCredentialsRemoveFabric()
        : ModelCommand("remove-fabric")
    {
        AddArgument("FabricIndex", 0, UINT8_MAX, &mFabricIndex);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveFabricParams alloc] init];
        params.fabricIndex = [NSNumber numberWithUnsignedChar:mFabricIndex];
        [cluster removeFabricWithParams:params
                      completionHandler:^(
                          CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                          NSLog(@"Values: %@", values);
                          CHIP_ERROR err = CHIP_NO_ERROR;
                          err = [CHIPError errorToCHIPErrorCode:error];

                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                          SetCommandExitStatus(err);
                      }];

        return CHIP_NO_ERROR;
    }

private:
    chip::FabricIndex mFabricIndex;
};

/*
 * Command RemoveTrustedRootCertificate
 */
class OperationalCredentialsRemoveTrustedRootCertificate : public ModelCommand {
public:
    OperationalCredentialsRemoveTrustedRootCertificate()
        : ModelCommand("remove-trusted-root-certificate")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterRemoveTrustedRootCertificateParams alloc] init];
        params.trustedRootIdentifier = [[NSData alloc] initWithBytes:mTrustedRootIdentifier.data()
                                                              length:mTrustedRootIdentifier.size()];
        [cluster removeTrustedRootCertificateWithParams:params
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mTrustedRootIdentifier;
};

/*
 * Command UpdateFabricLabel
 */
class OperationalCredentialsUpdateFabricLabel : public ModelCommand {
public:
    OperationalCredentialsUpdateFabricLabel()
        : ModelCommand("update-fabric-label")
    {
        AddArgument("Label", &mLabel);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateFabricLabelParams alloc] init];
        params.label = [[NSString alloc] initWithBytes:mLabel.data() length:mLabel.size() encoding:NSUTF8StringEncoding];
        [cluster updateFabricLabelWithParams:params
                           completionHandler:^(
                               CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                               NSLog(@"Values: %@", values);
                               CHIP_ERROR err = CHIP_NO_ERROR;
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mLabel;
};

/*
 * Command UpdateNOC
 */
class OperationalCredentialsUpdateNOC : public ModelCommand {
public:
    OperationalCredentialsUpdateNOC()
        : ModelCommand("update-noc")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        __auto_type * params = [[CHIPOperationalCredentialsClusterUpdateNOCParams alloc] init];
        params.nocValue = [[NSData alloc] initWithBytes:mNOCValue.data() length:mNOCValue.size()];
        params.icacValue = [[NSData alloc] initWithBytes:mICACValue.data() length:mICACValue.size()];
        [cluster updateNOCWithParams:params
                   completionHandler:^(
                       CHIPOperationalCredentialsClusterNOCResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mNOCValue;
    chip::ByteSpan mICACValue;
};

/*
 * Attribute NOCs
 */
class ReadOperationalCredentialsNOCs : public ModelCommand {
public:
    ReadOperationalCredentialsNOCs()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nocs");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsNOCs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeNOCsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.NOCs response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials NOCs Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsNOCs : public ModelCommand {
public:
    ReportOperationalCredentialsNOCs()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nocs");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsNOCs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FabricsList
 */
class ReadOperationalCredentialsFabricsList : public ModelCommand {
public:
    ReadOperationalCredentialsFabricsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "fabrics-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsFabricsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeFabricsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.FabricsList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials FabricsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsFabricsList : public ModelCommand {
public:
    ReportOperationalCredentialsFabricsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "fabrics-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsFabricsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedFabrics
 */
class ReadOperationalCredentialsSupportedFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsSupportedFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeSupportedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.SupportedFabrics response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials SupportedFabrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsSupportedFabrics : public ModelCommand {
public:
    ReportOperationalCredentialsSupportedFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsSupportedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CommissionedFabrics
 */
class ReadOperationalCredentialsCommissionedFabrics : public ModelCommand {
public:
    ReadOperationalCredentialsCommissionedFabrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeCommissionedFabricsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.CommissionedFabrics response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials CommissionedFabrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsCommissionedFabrics : public ModelCommand {
public:
    ReportOperationalCredentialsCommissionedFabrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "commissioned-fabrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsCommissionedFabrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TrustedRootCertificates
 */
class ReadOperationalCredentialsTrustedRootCertificates : public ModelCommand {
public:
    ReadOperationalCredentialsTrustedRootCertificates()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeTrustedRootCertificatesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.TrustedRootCertificates response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials TrustedRootCertificates Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsTrustedRootCertificates : public ModelCommand {
public:
    ReportOperationalCredentialsTrustedRootCertificates()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "trusted-root-certificates");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsTrustedRootCertificates() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentFabricIndex
 */
class ReadOperationalCredentialsCurrentFabricIndex : public ModelCommand {
public:
    ReadOperationalCredentialsCurrentFabricIndex()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-fabric-index");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeCurrentFabricIndexWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.CurrentFabricIndex response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials CurrentFabricIndex Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsCurrentFabricIndex : public ModelCommand {
public:
    ReportOperationalCredentialsCurrentFabricIndex()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-fabric-index");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsCurrentFabricIndex() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadOperationalCredentialsServerGeneratedCommandList : public ModelCommand {
public:
    ReadOperationalCredentialsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OperationalCredentials.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OperationalCredentials ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsServerGeneratedCommandList : public ModelCommand {
public:
    ReportOperationalCredentialsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadOperationalCredentialsClientGeneratedCommandList : public ModelCommand {
public:
    ReadOperationalCredentialsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"OperationalCredentials.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "OperationalCredentials ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsClientGeneratedCommandList : public ModelCommand {
public:
    ReportOperationalCredentialsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadOperationalCredentialsAttributeList : public ModelCommand {
public:
    ReadOperationalCredentialsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsAttributeList : public ModelCommand {
public:
    ReportOperationalCredentialsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadOperationalCredentialsClusterRevision : public ModelCommand {
public:
    ReadOperationalCredentialsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPOperationalCredentials * cluster = [[CHIPOperationalCredentials alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"OperationalCredentials.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "OperationalCredentials ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportOperationalCredentialsClusterRevision : public ModelCommand {
public:
    ReportOperationalCredentialsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportOperationalCredentialsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSource                                                 | 0x002F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Status                                                            | 0x0000 |
| * Order                                                             | 0x0001 |
| * Description                                                       | 0x0002 |
| * BatteryVoltage                                                    | 0x000B |
| * BatteryPercentRemaining                                           | 0x000C |
| * BatteryTimeRemaining                                              | 0x000D |
| * BatteryChargeLevel                                                | 0x000E |
| * ActiveBatteryFaults                                               | 0x0012 |
| * BatteryChargeState                                                | 0x001A |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Status
 */
class ReadPowerSourceStatus : public ModelCommand {
public:
    ReadPowerSourceStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "status");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Status response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Status Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceStatus : public ModelCommand {
public:
    ReportPowerSourceStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Order
 */
class ReadPowerSourceOrder : public ModelCommand {
public:
    ReadPowerSourceOrder()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "order");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceOrder() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOrderWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Order response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Order Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceOrder : public ModelCommand {
public:
    ReportPowerSourceOrder()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "order");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceOrder() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Description
 */
class ReadPowerSourceDescription : public ModelCommand {
public:
    ReadPowerSourceDescription()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "description");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeDescriptionWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.Description response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource Description Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceDescription : public ModelCommand {
public:
    ReportPowerSourceDescription()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "description");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceDescription() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryVoltage
 */
class ReadPowerSourceBatteryVoltage : public ModelCommand {
public:
    ReadPowerSourceBatteryVoltage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-voltage");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBatteryVoltageWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryVoltage response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryVoltage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceBatteryVoltage : public ModelCommand {
public:
    ReportPowerSourceBatteryVoltage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-voltage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryVoltage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryPercentRemaining
 */
class ReadPowerSourceBatteryPercentRemaining : public ModelCommand {
public:
    ReadPowerSourceBatteryPercentRemaining()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeBatteryPercentRemainingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.BatteryPercentRemaining response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource BatteryPercentRemaining Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceBatteryPercentRemaining : public ModelCommand {
public:
    ReportPowerSourceBatteryPercentRemaining()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-percent-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryPercentRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryTimeRemaining
 */
class ReadPowerSourceBatteryTimeRemaining : public ModelCommand {
public:
    ReadPowerSourceBatteryTimeRemaining()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-time-remaining");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBatteryTimeRemainingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryTimeRemaining response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryTimeRemaining Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceBatteryTimeRemaining : public ModelCommand {
public:
    ReportPowerSourceBatteryTimeRemaining()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-time-remaining");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryTimeRemaining() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeLevel
 */
class ReadPowerSourceBatteryChargeLevel : public ModelCommand {
public:
    ReadPowerSourceBatteryChargeLevel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-level");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBatteryChargeLevelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryChargeLevel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryChargeLevel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceBatteryChargeLevel : public ModelCommand {
public:
    ReportPowerSourceBatteryChargeLevel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-charge-level");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryChargeLevel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveBatteryFaults
 */
class ReadPowerSourceActiveBatteryFaults : public ModelCommand {
public:
    ReadPowerSourceActiveBatteryFaults()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-battery-faults");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeActiveBatteryFaultsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.ActiveBatteryFaults response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource ActiveBatteryFaults Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceActiveBatteryFaults : public ModelCommand {
public:
    ReportPowerSourceActiveBatteryFaults()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-battery-faults");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceActiveBatteryFaults() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BatteryChargeState
 */
class ReadPowerSourceBatteryChargeState : public ModelCommand {
public:
    ReadPowerSourceBatteryChargeState()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "battery-charge-state");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBatteryChargeStateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.BatteryChargeState response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource BatteryChargeState Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceBatteryChargeState : public ModelCommand {
public:
    ReportPowerSourceBatteryChargeState()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "battery-charge-state");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceBatteryChargeState() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadPowerSourceServerGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceServerGeneratedCommandList : public ModelCommand {
public:
    ReportPowerSourceServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadPowerSourceClientGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSource.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSource ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceClientGeneratedCommandList : public ModelCommand {
public:
    ReportPowerSourceClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceAttributeList : public ModelCommand {
public:
    ReadPowerSourceAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceAttributeList : public ModelCommand {
public:
    ReportPowerSourceAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPowerSourceFeatureMap : public ModelCommand {
public:
    ReadPowerSourceFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceFeatureMap : public ModelCommand {
public:
    ReportPowerSourceFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceClusterRevision : public ModelCommand {
public:
    ReadPowerSourceClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSource * cluster = [[CHIPPowerSource alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSource.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSource ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceClusterRevision : public ModelCommand {
public:
    ReportPowerSourceClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PowerSourceConfiguration                                    | 0x002E |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Sources                                                           | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute Sources
 */
class ReadPowerSourceConfigurationSources : public ModelCommand {
public:
    ReadPowerSourceConfigurationSources()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "sources");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeSourcesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.Sources response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration Sources Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceConfigurationSources : public ModelCommand {
public:
    ReportPowerSourceConfigurationSources()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "sources");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceConfigurationSources() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadPowerSourceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSourceConfiguration.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSourceConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReportPowerSourceConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadPowerSourceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadPowerSourceConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PowerSourceConfiguration.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PowerSourceConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReportPowerSourceConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPowerSourceConfigurationAttributeList : public ModelCommand {
public:
    ReadPowerSourceConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceConfigurationAttributeList : public ModelCommand {
public:
    ReportPowerSourceConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPowerSourceConfigurationClusterRevision : public ModelCommand {
public:
    ReadPowerSourceConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPowerSourceConfiguration * cluster = [[CHIPPowerSourceConfiguration alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PowerSourceConfiguration.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PowerSourceConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPowerSourceConfigurationClusterRevision : public ModelCommand {
public:
    ReportPowerSourceConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPowerSourceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002E) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PressureMeasurement                                         | 0x0403 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadPressureMeasurementMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPressureMeasurementMeasuredValue : public ModelCommand {
public:
    ReportPressureMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadPressureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MinMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPressureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReportPressureMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadPressureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadPressureMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.MaxMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPressureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReportPressureMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPressureMeasurementAttributeList : public ModelCommand {
public:
    ReadPressureMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPressureMeasurementAttributeList : public ModelCommand {
public:
    ReportPressureMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPressureMeasurementClusterRevision : public ModelCommand {
public:
    ReadPressureMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPressureMeasurement * cluster = [[CHIPPressureMeasurement alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PressureMeasurement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PressureMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPressureMeasurementClusterRevision : public ModelCommand {
public:
    ReportPressureMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPressureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000403) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster PumpConfigurationAndControl                                 | 0x0200 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MaxPressure                                                       | 0x0000 |
| * MaxSpeed                                                          | 0x0001 |
| * MaxFlow                                                           | 0x0002 |
| * MinConstPressure                                                  | 0x0003 |
| * MaxConstPressure                                                  | 0x0004 |
| * MinCompPressure                                                   | 0x0005 |
| * MaxCompPressure                                                   | 0x0006 |
| * MinConstSpeed                                                     | 0x0007 |
| * MaxConstSpeed                                                     | 0x0008 |
| * MinConstFlow                                                      | 0x0009 |
| * MaxConstFlow                                                      | 0x000A |
| * MinConstTemp                                                      | 0x000B |
| * MaxConstTemp                                                      | 0x000C |
| * PumpStatus                                                        | 0x0010 |
| * EffectiveOperationMode                                            | 0x0011 |
| * EffectiveControlMode                                              | 0x0012 |
| * Capacity                                                          | 0x0013 |
| * Speed                                                             | 0x0014 |
| * LifetimeRunningHours                                              | 0x0015 |
| * Power                                                             | 0x0016 |
| * LifetimeEnergyConsumed                                            | 0x0017 |
| * OperationMode                                                     | 0x0020 |
| * ControlMode                                                       | 0x0021 |
| * AlarmMask                                                         | 0x0022 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SupplyVoltageLow                                                  | 0x0000 |
| * SupplyVoltageHigh                                                 | 0x0001 |
| * PowerMissingPhase                                                 | 0x0002 |
| * SystemPressureLow                                                 | 0x0003 |
| * SystemPressureHigh                                                | 0x0004 |
| * DryRunning                                                        | 0x0005 |
| * MotorTemperatureHigh                                              | 0x0006 |
| * PumpMotorFatalFailure                                             | 0x0007 |
| * ElectronicTemperatureHigh                                         | 0x0008 |
| * PumpBlocked                                                       | 0x0009 |
| * SensorFailure                                                     | 0x000A |
| * ElectronicNonFatalFailure                                         | 0x000B |
| * ElectronicFatalFailure                                            | 0x000C |
| * GeneralFault                                                      | 0x000D |
| * Leakage                                                           | 0x000E |
| * AirDetection                                                      | 0x000F |
| * TurbineOperation                                                  | 0x0010 |
\*----------------------------------------------------------------------------*/

/*
 * Event SupplyVoltageLow
 */
class ReadPumpConfigurationAndControlSupplyVoltageLow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSupplyVoltageLow()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "supply-voltage-low");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSupplyVoltageLow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlSupplyVoltageLow : public ModelCommand {
public:
    ReportPumpConfigurationAndControlSupplyVoltageLow()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "supply-voltage-low");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSupplyVoltageLow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SupplyVoltageHigh
 */
class ReadPumpConfigurationAndControlSupplyVoltageHigh : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSupplyVoltageHigh()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "supply-voltage-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSupplyVoltageHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlSupplyVoltageHigh : public ModelCommand {
public:
    ReportPumpConfigurationAndControlSupplyVoltageHigh()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "supply-voltage-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSupplyVoltageHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event PowerMissingPhase
 */
class ReadPumpConfigurationAndControlPowerMissingPhase : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPowerMissingPhase()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "power-missing-phase");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPowerMissingPhase() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlPowerMissingPhase : public ModelCommand {
public:
    ReportPumpConfigurationAndControlPowerMissingPhase()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "power-missing-phase");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPowerMissingPhase() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SystemPressureLow
 */
class ReadPumpConfigurationAndControlSystemPressureLow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSystemPressureLow()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "system-pressure-low");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSystemPressureLow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlSystemPressureLow : public ModelCommand {
public:
    ReportPumpConfigurationAndControlSystemPressureLow()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "system-pressure-low");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSystemPressureLow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SystemPressureHigh
 */
class ReadPumpConfigurationAndControlSystemPressureHigh : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSystemPressureHigh()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "system-pressure-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSystemPressureHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000004) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlSystemPressureHigh : public ModelCommand {
public:
    ReportPumpConfigurationAndControlSystemPressureHigh()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "system-pressure-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSystemPressureHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000004) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event DryRunning
 */
class ReadPumpConfigurationAndControlDryRunning : public ModelCommand {
public:
    ReadPumpConfigurationAndControlDryRunning()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "dry-running");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlDryRunning() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000005) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlDryRunning : public ModelCommand {
public:
    ReportPumpConfigurationAndControlDryRunning()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "dry-running");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlDryRunning() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000005) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event MotorTemperatureHigh
 */
class ReadPumpConfigurationAndControlMotorTemperatureHigh : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMotorTemperatureHigh()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "motor-temperature-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMotorTemperatureHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000006) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlMotorTemperatureHigh : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMotorTemperatureHigh()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "motor-temperature-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMotorTemperatureHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000006) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event PumpMotorFatalFailure
 */
class ReadPumpConfigurationAndControlPumpMotorFatalFailure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPumpMotorFatalFailure()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "pump-motor-fatal-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpMotorFatalFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000007) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlPumpMotorFatalFailure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlPumpMotorFatalFailure()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "pump-motor-fatal-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpMotorFatalFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000007) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ElectronicTemperatureHigh
 */
class ReadPumpConfigurationAndControlElectronicTemperatureHigh : public ModelCommand {
public:
    ReadPumpConfigurationAndControlElectronicTemperatureHigh()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "electronic-temperature-high");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlElectronicTemperatureHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000008) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlElectronicTemperatureHigh : public ModelCommand {
public:
    ReportPumpConfigurationAndControlElectronicTemperatureHigh()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "electronic-temperature-high");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlElectronicTemperatureHigh() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000008) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event PumpBlocked
 */
class ReadPumpConfigurationAndControlPumpBlocked : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPumpBlocked()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "pump-blocked");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpBlocked() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000009) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlPumpBlocked : public ModelCommand {
public:
    ReportPumpConfigurationAndControlPumpBlocked()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "pump-blocked");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpBlocked() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000009) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event SensorFailure
 */
class ReadPumpConfigurationAndControlSensorFailure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSensorFailure()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "sensor-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSensorFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x0000000A) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlSensorFailure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlSensorFailure()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "sensor-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSensorFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x0000000A) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ElectronicNonFatalFailure
 */
class ReadPumpConfigurationAndControlElectronicNonFatalFailure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlElectronicNonFatalFailure()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "electronic-non-fatal-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlElectronicNonFatalFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x0000000B) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlElectronicNonFatalFailure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlElectronicNonFatalFailure()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "electronic-non-fatal-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlElectronicNonFatalFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x0000000B) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ElectronicFatalFailure
 */
class ReadPumpConfigurationAndControlElectronicFatalFailure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlElectronicFatalFailure()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "electronic-fatal-failure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlElectronicFatalFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x0000000C) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlElectronicFatalFailure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlElectronicFatalFailure()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "electronic-fatal-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlElectronicFatalFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x0000000C) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event GeneralFault
 */
class ReadPumpConfigurationAndControlGeneralFault : public ModelCommand {
public:
    ReadPumpConfigurationAndControlGeneralFault()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "general-fault");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlGeneralFault() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x0000000D) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlGeneralFault : public ModelCommand {
public:
    ReportPumpConfigurationAndControlGeneralFault()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "general-fault");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlGeneralFault() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x0000000D) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event Leakage
 */
class ReadPumpConfigurationAndControlLeakage : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLeakage()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "leakage");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLeakage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x0000000E) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlLeakage : public ModelCommand {
public:
    ReportPumpConfigurationAndControlLeakage()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "leakage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLeakage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x0000000E) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event AirDetection
 */
class ReadPumpConfigurationAndControlAirDetection : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAirDetection()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "air-detection");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAirDetection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x0000000F) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlAirDetection : public ModelCommand {
public:
    ReportPumpConfigurationAndControlAirDetection()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "air-detection");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlAirDetection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x0000000F) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event TurbineOperation
 */
class ReadPumpConfigurationAndControlTurbineOperation : public ModelCommand {
public:
    ReadPumpConfigurationAndControlTurbineOperation()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "turbine-operation");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlTurbineOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadEvent (0x00000010) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportPumpConfigurationAndControlTurbineOperation : public ModelCommand {
public:
    ReportPumpConfigurationAndControlTurbineOperation()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "turbine-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlTurbineOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportEvent (0x00000010) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxPressure
 */
class ReadPumpConfigurationAndControlMaxPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxPressure response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxPressure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxSpeed
 */
class ReadPumpConfigurationAndControlMaxSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxSpeed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxSpeed : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxFlow
 */
class ReadPumpConfigurationAndControlMaxFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxFlow response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxFlow : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstPressure
 */
class ReadPumpConfigurationAndControlMinConstPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMinConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstPressure response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMinConstPressure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMinConstPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstPressure
 */
class ReadPumpConfigurationAndControlMaxConstPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxConstPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstPressure response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxConstPressure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxConstPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCompPressure
 */
class ReadPumpConfigurationAndControlMinCompPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinCompPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMinCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinCompPressure response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinCompPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMinCompPressure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMinCompPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCompPressure
 */
class ReadPumpConfigurationAndControlMaxCompPressure : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxCompPressure()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-comp-pressure");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxCompPressureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxCompPressure response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxCompPressure Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxCompPressure : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxCompPressure()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-comp-pressure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxCompPressure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstSpeed
 */
class ReadPumpConfigurationAndControlMinConstSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMinConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstSpeed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMinConstSpeed : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMinConstSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstSpeed
 */
class ReadPumpConfigurationAndControlMaxConstSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxConstSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstSpeed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstSpeed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxConstSpeed : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxConstSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstFlow
 */
class ReadPumpConfigurationAndControlMinConstFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMinConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstFlow response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMinConstFlow : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMinConstFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstFlow
 */
class ReadPumpConfigurationAndControlMaxConstFlow : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstFlow()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-flow");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxConstFlowWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstFlow response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstFlow Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxConstFlow : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxConstFlow()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-flow");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstFlow() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinConstTemp
 */
class ReadPumpConfigurationAndControlMinConstTemp : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMinConstTemp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMinConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MinConstTemp response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MinConstTemp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMinConstTemp : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMinConstTemp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMinConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxConstTemp
 */
class ReadPumpConfigurationAndControlMaxConstTemp : public ModelCommand {
public:
    ReadPumpConfigurationAndControlMaxConstTemp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-const-temp");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxConstTempWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.MaxConstTemp response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl MaxConstTemp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlMaxConstTemp : public ModelCommand {
public:
    ReportPumpConfigurationAndControlMaxConstTemp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-const-temp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlMaxConstTemp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PumpStatus
 */
class ReadPumpConfigurationAndControlPumpStatus : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPumpStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pump-status");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributePumpStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.PumpStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl PumpStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlPumpStatus : public ModelCommand {
public:
    ReportPumpConfigurationAndControlPumpStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pump-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPumpStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveOperationMode
 */
class ReadPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlEffectiveOperationMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeEffectiveOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.EffectiveOperationMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl EffectiveOperationMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlEffectiveOperationMode : public ModelCommand {
public:
    ReportPumpConfigurationAndControlEffectiveOperationMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "effective-operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlEffectiveOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EffectiveControlMode
 */
class ReadPumpConfigurationAndControlEffectiveControlMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlEffectiveControlMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "effective-control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeEffectiveControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.EffectiveControlMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl EffectiveControlMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlEffectiveControlMode : public ModelCommand {
public:
    ReportPumpConfigurationAndControlEffectiveControlMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "effective-control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlEffectiveControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Capacity
 */
class ReadPumpConfigurationAndControlCapacity : public ModelCommand {
public:
    ReadPumpConfigurationAndControlCapacity()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "capacity");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeCapacityWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Capacity response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Capacity Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlCapacity : public ModelCommand {
public:
    ReportPumpConfigurationAndControlCapacity()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "capacity");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlCapacity() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Speed
 */
class ReadPumpConfigurationAndControlSpeed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlSpeed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "speed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeSpeedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Speed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Speed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlSpeed : public ModelCommand {
public:
    ReportPumpConfigurationAndControlSpeed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "speed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlSpeed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeRunningHours
 */
class ReadPumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeLifetimeRunningHoursWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.LifetimeRunningHours response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeRunningHours Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WritePumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    WritePumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeLifetimeRunningHoursWithValue:value
                                           completionHandler:^(NSError * _Nullable error) {
                                               CHIP_ERROR err = CHIP_NO_ERROR;
                                               err = [CHIPError errorToCHIPErrorCode:error];

                                               ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeRunningHours Error: %s",
                                                   chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportPumpConfigurationAndControlLifetimeRunningHours : public ModelCommand {
public:
    ReportPumpConfigurationAndControlLifetimeRunningHours()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lifetime-running-hours");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLifetimeRunningHours() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Power
 */
class ReadPumpConfigurationAndControlPower : public ModelCommand {
public:
    ReadPumpConfigurationAndControlPower()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "power");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributePowerWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.Power response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl Power Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlPower : public ModelCommand {
public:
    ReportPumpConfigurationAndControlPower()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "power");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlPower() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LifetimeEnergyConsumed
 */
class ReadPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    ReadPumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeLifetimeEnergyConsumedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.LifetimeEnergyConsumed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeEnergyConsumed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WritePumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    WritePumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster
            writeAttributeLifetimeEnergyConsumedWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            CHIP_ERROR err = CHIP_NO_ERROR;
                                            err = [CHIPError errorToCHIPErrorCode:error];

                                            ChipLogError(chipTool, "PumpConfigurationAndControl LifetimeEnergyConsumed Error: %s",
                                                chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportPumpConfigurationAndControlLifetimeEnergyConsumed : public ModelCommand {
public:
    ReportPumpConfigurationAndControlLifetimeEnergyConsumed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "lifetime-energy-consumed");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlLifetimeEnergyConsumed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationMode
 */
class ReadPumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlOperationMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operation-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeOperationModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.OperationMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl OperationMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WritePumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    WritePumpConfigurationAndControlOperationMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeOperationModeWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(
                                            chipTool, "PumpConfigurationAndControl OperationMode Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportPumpConfigurationAndControlOperationMode : public ModelCommand {
public:
    ReportPumpConfigurationAndControlOperationMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operation-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlOperationMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlMode
 */
class ReadPumpConfigurationAndControlControlMode : public ModelCommand {
public:
    ReadPumpConfigurationAndControlControlMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "control-mode");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeControlModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.ControlMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl ControlMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WritePumpConfigurationAndControlControlMode : public ModelCommand {
public:
    WritePumpConfigurationAndControlControlMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WritePumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) WriteAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster
            writeAttributeControlModeWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "PumpConfigurationAndControl ControlMode Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportPumpConfigurationAndControlControlMode : public ModelCommand {
public:
    ReportPumpConfigurationAndControlControlMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "control-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlControlMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AlarmMask
 */
class ReadPumpConfigurationAndControlAlarmMask : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAlarmMask()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "alarm-mask");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeAlarmMaskWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AlarmMask response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AlarmMask Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlAlarmMask : public ModelCommand {
public:
    ReportPumpConfigurationAndControlAlarmMask()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "alarm-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlAlarmMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadPumpConfigurationAndControlServerGeneratedCommandList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PumpConfigurationAndControl.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PumpConfigurationAndControl ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlServerGeneratedCommandList : public ModelCommand {
public:
    ReportPumpConfigurationAndControlServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadPumpConfigurationAndControlClientGeneratedCommandList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"PumpConfigurationAndControl.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "PumpConfigurationAndControl ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlClientGeneratedCommandList : public ModelCommand {
public:
    ReportPumpConfigurationAndControlClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadPumpConfigurationAndControlAttributeList : public ModelCommand {
public:
    ReadPumpConfigurationAndControlAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlAttributeList : public ModelCommand {
public:
    ReportPumpConfigurationAndControlAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadPumpConfigurationAndControlFeatureMap : public ModelCommand {
public:
    ReadPumpConfigurationAndControlFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlFeatureMap : public ModelCommand {
public:
    ReportPumpConfigurationAndControlFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadPumpConfigurationAndControlClusterRevision : public ModelCommand {
public:
    ReadPumpConfigurationAndControlClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadPumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPPumpConfigurationAndControl * cluster = [[CHIPPumpConfigurationAndControl alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"PumpConfigurationAndControl.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "PumpConfigurationAndControl ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportPumpConfigurationAndControlClusterRevision : public ModelCommand {
public:
    ReportPumpConfigurationAndControlClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportPumpConfigurationAndControlClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000200) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster RelativeHumidityMeasurement                                 | 0x0405 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadRelativeHumidityMeasurementMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementMeasuredValue : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MinMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.MaxMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadRelativeHumidityMeasurementTolerance : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.Tolerance response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementTolerance : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadRelativeHumidityMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"RelativeHumidityMeasurement.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "RelativeHumidityMeasurement ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementServerGeneratedCommandList : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadRelativeHumidityMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"RelativeHumidityMeasurement.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "RelativeHumidityMeasurement ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementClientGeneratedCommandList : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadRelativeHumidityMeasurementAttributeList : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementAttributeList : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadRelativeHumidityMeasurementClusterRevision : public ModelCommand {
public:
    ReadRelativeHumidityMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPRelativeHumidityMeasurement * cluster = [[CHIPRelativeHumidityMeasurement alloc] initWithDevice:device
                                                                                                   endpoint:endpointId
                                                                                                      queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"RelativeHumidityMeasurement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "RelativeHumidityMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportRelativeHumidityMeasurementClusterRevision : public ModelCommand {
public:
    ReportRelativeHumidityMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportRelativeHumidityMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000405) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Scenes                                                      | 0x0005 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * AddScene                                                          |   0x00 |
| * GetSceneMembership                                                |   0x06 |
| * RecallScene                                                       |   0x05 |
| * RemoveAllScenes                                                   |   0x03 |
| * RemoveScene                                                       |   0x02 |
| * StoreScene                                                        |   0x04 |
| * ViewScene                                                         |   0x01 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * SceneCount                                                        | 0x0000 |
| * CurrentScene                                                      | 0x0001 |
| * CurrentGroup                                                      | 0x0002 |
| * SceneValid                                                        | 0x0003 |
| * NameSupport                                                       | 0x0004 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command AddScene
 */
class ScenesAddScene : public ModelCommand {
public:
    ScenesAddScene()
        : ModelCommand("add-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        AddArgument("SceneName", &mSceneName);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterAddSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        params.sceneName = [[NSString alloc] initWithBytes:mSceneName.data()
                                                    length:mSceneName.size()
                                                  encoding:NSUTF8StringEncoding];
        // extensionFieldSets Array parsing is not supported yet
        [cluster addSceneWithParams:params
                  completionHandler:^(CHIPScenesClusterAddSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                      NSLog(@"Values: %@", values);
                      CHIP_ERROR err = CHIP_NO_ERROR;
                      err = [CHIPError errorToCHIPErrorCode:error];

                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                      SetCommandExitStatus(err);
                  }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
    uint16_t mTransitionTime;
    chip::ByteSpan mSceneName;
};

/*
 * Command GetSceneMembership
 */
class ScenesGetSceneMembership : public ModelCommand {
public:
    ScenesGetSceneMembership()
        : ModelCommand("get-scene-membership")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterGetSceneMembershipParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster getSceneMembershipWithParams:params
                            completionHandler:^(
                                CHIPScenesClusterGetSceneMembershipResponseParams * _Nullable values, NSError * _Nullable error) {
                                NSLog(@"Values: %@", values);
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command RecallScene
 */
class ScenesRecallScene : public ModelCommand {
public:
    ScenesRecallScene()
        : ModelCommand("recall-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        AddArgument("TransitionTime", 0, UINT16_MAX, &mTransitionTime);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterRecallSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        params.transitionTime = [NSNumber numberWithUnsignedShort:mTransitionTime];
        [cluster recallSceneWithParams:params
                     completionHandler:^(NSError * _Nullable error) {
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
    uint16_t mTransitionTime;
};

/*
 * Command RemoveAllScenes
 */
class ScenesRemoveAllScenes : public ModelCommand {
public:
    ScenesRemoveAllScenes()
        : ModelCommand("remove-all-scenes")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterRemoveAllScenesParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        [cluster removeAllScenesWithParams:params
                         completionHandler:^(
                             CHIPScenesClusterRemoveAllScenesResponseParams * _Nullable values, NSError * _Nullable error) {
                             NSLog(@"Values: %@", values);
                             CHIP_ERROR err = CHIP_NO_ERROR;
                             err = [CHIPError errorToCHIPErrorCode:error];

                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                             SetCommandExitStatus(err);
                         }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
};

/*
 * Command RemoveScene
 */
class ScenesRemoveScene : public ModelCommand {
public:
    ScenesRemoveScene()
        : ModelCommand("remove-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterRemoveSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster removeSceneWithParams:params
                     completionHandler:^(CHIPScenesClusterRemoveSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                         NSLog(@"Values: %@", values);
                         CHIP_ERROR err = CHIP_NO_ERROR;
                         err = [CHIPError errorToCHIPErrorCode:error];

                         ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                         SetCommandExitStatus(err);
                     }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Command StoreScene
 */
class ScenesStoreScene : public ModelCommand {
public:
    ScenesStoreScene()
        : ModelCommand("store-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterStoreSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster storeSceneWithParams:params
                    completionHandler:^(CHIPScenesClusterStoreSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                        NSLog(@"Values: %@", values);
                        CHIP_ERROR err = CHIP_NO_ERROR;
                        err = [CHIPError errorToCHIPErrorCode:error];

                        ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                        SetCommandExitStatus(err);
                    }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Command ViewScene
 */
class ScenesViewScene : public ModelCommand {
public:
    ScenesViewScene()
        : ModelCommand("view-scene")
    {
        AddArgument("GroupId", 0, UINT16_MAX, &mGroupId);
        AddArgument("SceneId", 0, UINT8_MAX, &mSceneId);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPScenesClusterViewSceneParams alloc] init];
        params.groupId = [NSNumber numberWithUnsignedShort:mGroupId];
        params.sceneId = [NSNumber numberWithUnsignedChar:mSceneId];
        [cluster viewSceneWithParams:params
                   completionHandler:^(CHIPScenesClusterViewSceneResponseParams * _Nullable values, NSError * _Nullable error) {
                       NSLog(@"Values: %@", values);
                       CHIP_ERROR err = CHIP_NO_ERROR;
                       err = [CHIPError errorToCHIPErrorCode:error];

                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                       SetCommandExitStatus(err);
                   }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mGroupId;
    uint8_t mSceneId;
};

/*
 * Attribute SceneCount
 */
class ReadScenesSceneCount : public ModelCommand {
public:
    ReadScenesSceneCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-count");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSceneCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.SceneCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes SceneCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesSceneCount : public ModelCommand {
public:
    ReportScenesSceneCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scene-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesSceneCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentScene
 */
class ReadScenesCurrentScene : public ModelCommand {
public:
    ReadScenesCurrentScene()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-scene");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentScene() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentSceneWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.CurrentScene response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes CurrentScene Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesCurrentScene : public ModelCommand {
public:
    ReportScenesCurrentScene()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-scene");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesCurrentScene() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentGroup
 */
class ReadScenesCurrentGroup : public ModelCommand {
public:
    ReadScenesCurrentGroup()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-group");
        ModelCommand::AddArguments();
    }

    ~ReadScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentGroupWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.CurrentGroup response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes CurrentGroup Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesCurrentGroup : public ModelCommand {
public:
    ReportScenesCurrentGroup()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-group");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesCurrentGroup() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SceneValid
 */
class ReadScenesSceneValid : public ModelCommand {
public:
    ReadScenesSceneValid()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "scene-valid");
        ModelCommand::AddArguments();
    }

    ~ReadScenesSceneValid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSceneValidWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.SceneValid response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes SceneValid Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesSceneValid : public ModelCommand {
public:
    ReportScenesSceneValid()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "scene-valid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesSceneValid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NameSupport
 */
class ReadScenesNameSupport : public ModelCommand {
public:
    ReadScenesNameSupport()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "name-support");
        ModelCommand::AddArguments();
    }

    ~ReadScenesNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNameSupportWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.NameSupport response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes NameSupport Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesNameSupport : public ModelCommand {
public:
    ReportScenesNameSupport()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "name-support");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesNameSupport() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadScenesServerGeneratedCommandList : public ModelCommand {
public:
    ReadScenesServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Scenes.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Scenes ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesServerGeneratedCommandList : public ModelCommand {
public:
    ReportScenesServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadScenesClientGeneratedCommandList : public ModelCommand {
public:
    ReadScenesClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Scenes.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Scenes ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesClientGeneratedCommandList : public ModelCommand {
public:
    ReportScenesClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadScenesAttributeList : public ModelCommand {
public:
    ReadScenesAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadScenesAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesAttributeList : public ModelCommand {
public:
    ReportScenesAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadScenesClusterRevision : public ModelCommand {
public:
    ReadScenesClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadScenesClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPScenes * cluster = [[CHIPScenes alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Scenes.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Scenes ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportScenesClusterRevision : public ModelCommand {
public:
    ReportScenesClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportScenesClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000005) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster SoftwareDiagnostics                                         | 0x0034 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetWatermarks                                                   |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * ThreadMetrics                                                     | 0x0000 |
| * CurrentHeapFree                                                   | 0x0001 |
| * CurrentHeapUsed                                                   | 0x0002 |
| * CurrentHeapHighWatermark                                          | 0x0003 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SoftwareFault                                                     | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetWatermarks
 */
class SoftwareDiagnosticsResetWatermarks : public ModelCommand {
public:
    SoftwareDiagnosticsResetWatermarks()
        : ModelCommand("reset-watermarks")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster resetWatermarksWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Event SoftwareFault
 */
class ReadSoftwareDiagnosticsSoftwareFault : public ModelCommand {
public:
    ReadSoftwareDiagnosticsSoftwareFault()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "software-fault");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsSoftwareFault() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSoftwareDiagnosticsSoftwareFault : public ModelCommand {
public:
    ReportSoftwareDiagnosticsSoftwareFault()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "software-fault");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsSoftwareFault() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ThreadMetrics
 */
class ReadSoftwareDiagnosticsThreadMetrics : public ModelCommand {
public:
    ReadSoftwareDiagnosticsThreadMetrics()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "thread-metrics");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeThreadMetricsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.ThreadMetrics response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics ThreadMetrics Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsThreadMetrics : public ModelCommand {
public:
    ReportSoftwareDiagnosticsThreadMetrics()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "thread-metrics");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsThreadMetrics() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapFree
 */
class ReadSoftwareDiagnosticsCurrentHeapFree : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapFree()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-free");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeCurrentHeapFreeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.CurrentHeapFree response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapFree Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsCurrentHeapFree : public ModelCommand {
public:
    ReportSoftwareDiagnosticsCurrentHeapFree()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-free");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapFree() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapUsed
 */
class ReadSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapUsed()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-used");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeCurrentHeapUsedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.CurrentHeapUsed response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapUsed Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsCurrentHeapUsed : public ModelCommand {
public:
    ReportSoftwareDiagnosticsCurrentHeapUsed()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-used");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapUsed() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentHeapHighWatermark
 */
class ReadSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand {
public:
    ReadSoftwareDiagnosticsCurrentHeapHighWatermark()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster
            readAttributeCurrentHeapHighWatermarkWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.CurrentHeapHighWatermark response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics CurrentHeapHighWatermark Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsCurrentHeapHighWatermark : public ModelCommand {
public:
    ReportSoftwareDiagnosticsCurrentHeapHighWatermark()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-heap-high-watermark");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsCurrentHeapHighWatermark() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadSoftwareDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReportSoftwareDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadSoftwareDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"SoftwareDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "SoftwareDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReportSoftwareDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSoftwareDiagnosticsAttributeList : public ModelCommand {
public:
    ReadSoftwareDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsAttributeList : public ModelCommand {
public:
    ReportSoftwareDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSoftwareDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadSoftwareDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsFeatureMap : public ModelCommand {
public:
    ReportSoftwareDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSoftwareDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadSoftwareDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSoftwareDiagnostics * cluster = [[CHIPSoftwareDiagnostics alloc] initWithDevice:device
                                                                                   endpoint:endpointId
                                                                                      queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"SoftwareDiagnostics.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "SoftwareDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSoftwareDiagnosticsClusterRevision : public ModelCommand {
public:
    ReportSoftwareDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSoftwareDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000034) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Switch                                                      | 0x003B |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * NumberOfPositions                                                 | 0x0000 |
| * CurrentPosition                                                   | 0x0001 |
| * MultiPressMax                                                     | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * SwitchLatched                                                     | 0x0000 |
| * InitialPress                                                      | 0x0001 |
| * LongPress                                                         | 0x0002 |
| * ShortRelease                                                      | 0x0003 |
| * LongRelease                                                       | 0x0004 |
| * MultiPressOngoing                                                 | 0x0005 |
| * MultiPressComplete                                                | 0x0006 |
\*----------------------------------------------------------------------------*/

/*
 * Event SwitchLatched
 */
class ReadSwitchSwitchLatched : public ModelCommand {
public:
    ReadSwitchSwitchLatched()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "switch-latched");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchSwitchLatched() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchSwitchLatched : public ModelCommand {
public:
    ReportSwitchSwitchLatched()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "switch-latched");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchSwitchLatched() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event InitialPress
 */
class ReadSwitchInitialPress : public ModelCommand {
public:
    ReadSwitchInitialPress()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "initial-press");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchInitialPress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchInitialPress : public ModelCommand {
public:
    ReportSwitchInitialPress()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "initial-press");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchInitialPress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LongPress
 */
class ReadSwitchLongPress : public ModelCommand {
public:
    ReadSwitchLongPress()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "long-press");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchLongPress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchLongPress : public ModelCommand {
public:
    ReportSwitchLongPress()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "long-press");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchLongPress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ShortRelease
 */
class ReadSwitchShortRelease : public ModelCommand {
public:
    ReadSwitchShortRelease()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "short-release");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchShortRelease() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchShortRelease : public ModelCommand {
public:
    ReportSwitchShortRelease()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "short-release");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchShortRelease() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000003) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event LongRelease
 */
class ReadSwitchLongRelease : public ModelCommand {
public:
    ReadSwitchLongRelease()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "long-release");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchLongRelease() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000004) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchLongRelease : public ModelCommand {
public:
    ReportSwitchLongRelease()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "long-release");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchLongRelease() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000004) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event MultiPressOngoing
 */
class ReadSwitchMultiPressOngoing : public ModelCommand {
public:
    ReadSwitchMultiPressOngoing()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "multi-press-ongoing");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressOngoing() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000005) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchMultiPressOngoing : public ModelCommand {
public:
    ReportSwitchMultiPressOngoing()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "multi-press-ongoing");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressOngoing() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000005) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event MultiPressComplete
 */
class ReadSwitchMultiPressComplete : public ModelCommand {
public:
    ReadSwitchMultiPressComplete()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "multi-press-complete");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressComplete() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadEvent (0x00000006) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportSwitchMultiPressComplete : public ModelCommand {
public:
    ReportSwitchMultiPressComplete()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "multi-press-complete");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressComplete() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportEvent (0x00000006) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfPositions
 */
class ReadSwitchNumberOfPositions : public ModelCommand {
public:
    ReadSwitchNumberOfPositions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-positions");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNumberOfPositionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.NumberOfPositions response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch NumberOfPositions Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchNumberOfPositions : public ModelCommand {
public:
    ReportSwitchNumberOfPositions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-positions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchNumberOfPositions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPosition
 */
class ReadSwitchCurrentPosition : public ModelCommand {
public:
    ReadSwitchCurrentPosition()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.CurrentPosition response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch CurrentPosition Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchCurrentPosition : public ModelCommand {
public:
    ReportSwitchCurrentPosition()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchCurrentPosition() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MultiPressMax
 */
class ReadSwitchMultiPressMax : public ModelCommand {
public:
    ReadSwitchMultiPressMax()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "multi-press-max");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMultiPressMaxWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.MultiPressMax response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch MultiPressMax Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchMultiPressMax : public ModelCommand {
public:
    ReportSwitchMultiPressMax()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "multi-press-max");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchMultiPressMax() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadSwitchServerGeneratedCommandList : public ModelCommand {
public:
    ReadSwitchServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Switch.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Switch ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchServerGeneratedCommandList : public ModelCommand {
public:
    ReportSwitchServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadSwitchClientGeneratedCommandList : public ModelCommand {
public:
    ReadSwitchClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Switch.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Switch ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchClientGeneratedCommandList : public ModelCommand {
public:
    ReportSwitchClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadSwitchAttributeList : public ModelCommand {
public:
    ReadSwitchAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchAttributeList : public ModelCommand {
public:
    ReportSwitchAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadSwitchFeatureMap : public ModelCommand {
public:
    ReadSwitchFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchFeatureMap : public ModelCommand {
public:
    ReportSwitchFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadSwitchClusterRevision : public ModelCommand {
public:
    ReadSwitchClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPSwitch * cluster = [[CHIPSwitch alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Switch.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Switch ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportSwitchClusterRevision : public ModelCommand {
public:
    ReportSwitchClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportSwitchClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000003B) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TargetNavigator                                             | 0x0505 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * NavigateTargetRequest                                             |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TargetNavigatorList                                               | 0x0000 |
| * CurrentNavigatorTarget                                            | 0x0001 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command NavigateTargetRequest
 */
class TargetNavigatorNavigateTargetRequest : public ModelCommand {
public:
    TargetNavigatorNavigateTargetRequest()
        : ModelCommand("navigate-target-request")
    {
        AddArgument("Target", 0, UINT8_MAX, &mTarget);
        AddArgument("Data", &mData);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTargetNavigatorClusterNavigateTargetRequestParams alloc] init];
        params.target = [NSNumber numberWithUnsignedChar:mTarget];
        params.data = [[NSString alloc] initWithBytes:mData.data() length:mData.size() encoding:NSUTF8StringEncoding];
        [cluster navigateTargetRequestWithParams:params
                               completionHandler:^(CHIPTargetNavigatorClusterNavigateTargetResponseParams * _Nullable values,
                                   NSError * _Nullable error) {
                                   NSLog(@"Values: %@", values);
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mTarget;
    chip::ByteSpan mData;
};

/*
 * Attribute TargetNavigatorList
 */
class ReadTargetNavigatorTargetNavigatorList : public ModelCommand {
public:
    ReadTargetNavigatorTargetNavigatorList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-navigator-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorTargetNavigatorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeTargetNavigatorListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.TargetNavigatorList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator TargetNavigatorList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorTargetNavigatorList : public ModelCommand {
public:
    ReportTargetNavigatorTargetNavigatorList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-navigator-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorTargetNavigatorList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentNavigatorTarget
 */
class ReadTargetNavigatorCurrentNavigatorTarget : public ModelCommand {
public:
    ReadTargetNavigatorCurrentNavigatorTarget()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-navigator-target");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorCurrentNavigatorTarget() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentNavigatorTargetWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.CurrentNavigatorTarget response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator CurrentNavigatorTarget Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorCurrentNavigatorTarget : public ModelCommand {
public:
    ReportTargetNavigatorCurrentNavigatorTarget()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-navigator-target");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorCurrentNavigatorTarget() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadTargetNavigatorServerGeneratedCommandList : public ModelCommand {
public:
    ReadTargetNavigatorServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TargetNavigator.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TargetNavigator ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorServerGeneratedCommandList : public ModelCommand {
public:
    ReportTargetNavigatorServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadTargetNavigatorClientGeneratedCommandList : public ModelCommand {
public:
    ReadTargetNavigatorClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TargetNavigator.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TargetNavigator ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorClientGeneratedCommandList : public ModelCommand {
public:
    ReportTargetNavigatorClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTargetNavigatorAttributeList : public ModelCommand {
public:
    ReadTargetNavigatorAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorAttributeList : public ModelCommand {
public:
    ReportTargetNavigatorAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTargetNavigatorClusterRevision : public ModelCommand {
public:
    ReadTargetNavigatorClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTargetNavigator * cluster = [[CHIPTargetNavigator alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TargetNavigator.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TargetNavigator ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTargetNavigatorClusterRevision : public ModelCommand {
public:
    ReportTargetNavigatorClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTargetNavigatorClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000505) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TemperatureMeasurement                                      | 0x0402 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * MeasuredValue                                                     | 0x0000 |
| * MinMeasuredValue                                                  | 0x0001 |
| * MaxMeasuredValue                                                  | 0x0002 |
| * Tolerance                                                         | 0x0003 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute MeasuredValue
 */
class ReadTemperatureMeasurementMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementMeasuredValue : public ModelCommand {
public:
    ReportTemperatureMeasurementMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinMeasuredValue
 */
class ReadTemperatureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMinMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeMinMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MinMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MinMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementMinMeasuredValue : public ModelCommand {
public:
    ReportTemperatureMeasurementMinMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMinMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxMeasuredValue
 */
class ReadTemperatureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReadTemperatureMeasurementMaxMeasuredValue()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-measured-value");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeMaxMeasuredValueWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.MaxMeasuredValue response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement MaxMeasuredValue Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementMaxMeasuredValue : public ModelCommand {
public:
    ReportTemperatureMeasurementMaxMeasuredValue()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-measured-value");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementMaxMeasuredValue() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Tolerance
 */
class ReadTemperatureMeasurementTolerance : public ModelCommand {
public:
    ReadTemperatureMeasurementTolerance()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tolerance");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeToleranceWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.Tolerance response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement Tolerance Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementTolerance : public ModelCommand {
public:
    ReportTemperatureMeasurementTolerance()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tolerance");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementTolerance() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTemperatureMeasurementAttributeList : public ModelCommand {
public:
    ReadTemperatureMeasurementAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementAttributeList : public ModelCommand {
public:
    ReportTemperatureMeasurementAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTemperatureMeasurementClusterRevision : public ModelCommand {
public:
    ReadTemperatureMeasurementClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTemperatureMeasurement * cluster = [[CHIPTemperatureMeasurement alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TemperatureMeasurement.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TemperatureMeasurement ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTemperatureMeasurementClusterRevision : public ModelCommand {
public:
    ReportTemperatureMeasurementClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTemperatureMeasurementClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000402) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TestCluster                                                 | 0x050F |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * SimpleStructEchoRequest                                           |   0x11 |
| * Test                                                              |   0x00 |
| * TestAddArguments                                                  |   0x04 |
| * TestEmitTestEventRequest                                          |   0x14 |
| * TestEnumsRequest                                                  |   0x0E |
| * TestListInt8UArgumentRequest                                      |   0x0A |
| * TestListInt8UReverseRequest                                       |   0x0D |
| * TestListNestedStructListArgumentRequest                           |   0x0C |
| * TestListStructArgumentRequest                                     |   0x09 |
| * TestNestedStructArgumentRequest                                   |   0x08 |
| * TestNestedStructListArgumentRequest                               |   0x0B |
| * TestNotHandled                                                    |   0x01 |
| * TestNullableOptionalRequest                                       |   0x0F |
| * TestSimpleOptionalArgumentRequest                                 |   0x13 |
| * TestSpecific                                                      |   0x02 |
| * TestStructArgumentRequest                                         |   0x07 |
| * TestUnknownCommand                                                |   0x03 |
| * TimedInvokeRequest                                                |   0x12 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Boolean                                                           | 0x0000 |
| * Bitmap8                                                           | 0x0001 |
| * Bitmap16                                                          | 0x0002 |
| * Bitmap32                                                          | 0x0003 |
| * Bitmap64                                                          | 0x0004 |
| * Int8u                                                             | 0x0005 |
| * Int16u                                                            | 0x0006 |
| * Int24u                                                            | 0x0007 |
| * Int32u                                                            | 0x0008 |
| * Int40u                                                            | 0x0009 |
| * Int48u                                                            | 0x000A |
| * Int56u                                                            | 0x000B |
| * Int64u                                                            | 0x000C |
| * Int8s                                                             | 0x000D |
| * Int16s                                                            | 0x000E |
| * Int24s                                                            | 0x000F |
| * Int32s                                                            | 0x0010 |
| * Int40s                                                            | 0x0011 |
| * Int48s                                                            | 0x0012 |
| * Int56s                                                            | 0x0013 |
| * Int64s                                                            | 0x0014 |
| * Enum8                                                             | 0x0015 |
| * Enum16                                                            | 0x0016 |
| * FloatSingle                                                       | 0x0017 |
| * FloatDouble                                                       | 0x0018 |
| * OctetString                                                       | 0x0019 |
| * ListInt8u                                                         | 0x001A |
| * ListOctetString                                                   | 0x001B |
| * ListStructOctetString                                             | 0x001C |
| * LongOctetString                                                   | 0x001D |
| * CharString                                                        | 0x001E |
| * LongCharString                                                    | 0x001F |
| * EpochUs                                                           | 0x0020 |
| * EpochS                                                            | 0x0021 |
| * VendorId                                                          | 0x0022 |
| * ListNullablesAndOptionalsStruct                                   | 0x0023 |
| * EnumAttr                                                          | 0x0024 |
| * StructAttr                                                        | 0x0025 |
| * RangeRestrictedInt8u                                              | 0x0026 |
| * RangeRestrictedInt8s                                              | 0x0027 |
| * RangeRestrictedInt16u                                             | 0x0028 |
| * RangeRestrictedInt16s                                             | 0x0029 |
| * ListLongOctetString                                               | 0x002A |
| * TimedWriteBoolean                                                 | 0x0030 |
| * GeneralErrorBoolean                                               | 0x0031 |
| * ClusterErrorBoolean                                               | 0x0032 |
| * Unsupported                                                       | 0x00FF |
| * NullableBoolean                                                   | 0x8000 |
| * NullableBitmap8                                                   | 0x8001 |
| * NullableBitmap16                                                  | 0x8002 |
| * NullableBitmap32                                                  | 0x8003 |
| * NullableBitmap64                                                  | 0x8004 |
| * NullableInt8u                                                     | 0x8005 |
| * NullableInt16u                                                    | 0x8006 |
| * NullableInt24u                                                    | 0x8007 |
| * NullableInt32u                                                    | 0x8008 |
| * NullableInt40u                                                    | 0x8009 |
| * NullableInt48u                                                    | 0x800A |
| * NullableInt56u                                                    | 0x800B |
| * NullableInt64u                                                    | 0x800C |
| * NullableInt8s                                                     | 0x800D |
| * NullableInt16s                                                    | 0x800E |
| * NullableInt24s                                                    | 0x800F |
| * NullableInt32s                                                    | 0x8010 |
| * NullableInt40s                                                    | 0x8011 |
| * NullableInt48s                                                    | 0x8012 |
| * NullableInt56s                                                    | 0x8013 |
| * NullableInt64s                                                    | 0x8014 |
| * NullableEnum8                                                     | 0x8015 |
| * NullableEnum16                                                    | 0x8016 |
| * NullableFloatSingle                                               | 0x8017 |
| * NullableFloatDouble                                               | 0x8018 |
| * NullableOctetString                                               | 0x8019 |
| * NullableCharString                                                | 0x801E |
| * NullableEnumAttr                                                  | 0x8024 |
| * NullableStruct                                                    | 0x8025 |
| * NullableRangeRestrictedInt8u                                      | 0x8026 |
| * NullableRangeRestrictedInt8s                                      | 0x8027 |
| * NullableRangeRestrictedInt16u                                     | 0x8028 |
| * NullableRangeRestrictedInt16s                                     | 0x8029 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * TestEvent                                                         | 0x0001 |
| * TestFabricScopedEvent                                             | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command SimpleStructEchoRequest
 */
class TestClusterSimpleStructEchoRequest : public ModelCommand {
public:
    TestClusterSimpleStructEchoRequest()
        : ModelCommand("simple-struct-echo-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterSimpleStructEchoRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster simpleStructEchoRequestWithParams:params
                                 completionHandler:^(CHIPTestClusterClusterSimpleStructResponseParams * _Nullable values,
                                     NSError * _Nullable error) {
                                     NSLog(@"Values: %@", values);
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command Test
 */
class TestClusterTest : public ModelCommand {
public:
    TestClusterTest()
        : ModelCommand("test")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster testWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestAddArguments
 */
class TestClusterTestAddArguments : public ModelCommand {
public:
    TestClusterTestAddArguments()
        : ModelCommand("test-add-arguments")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestAddArgumentsParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        [cluster testAddArgumentsWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestAddArgumentsResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              CHIP_ERROR err = CHIP_NO_ERROR;
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mArg1;
    uint8_t mArg2;
};

/*
 * Command TestEmitTestEventRequest
 */
class TestClusterTestEmitTestEventRequest : public ModelCommand {
public:
    TestClusterTestEmitTestEventRequest()
        : ModelCommand("test-emit-test-event-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        AddArgument("Arg3", 0, 1, &mArg3);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestEmitTestEventRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        params.arg3 = [NSNumber numberWithBool:mArg3];
        [cluster testEmitTestEventRequestWithParams:params
                                  completionHandler:^(CHIPTestClusterClusterTestEmitTestEventResponseParams * _Nullable values,
                                      NSError * _Nullable error) {
                                      NSLog(@"Values: %@", values);
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mArg1;
    uint8_t mArg2;
    bool mArg3;
};

/*
 * Command TestEnumsRequest
 */
class TestClusterTestEnumsRequest : public ModelCommand {
public:
    TestClusterTestEnumsRequest()
        : ModelCommand("test-enums-request")
    {
        AddArgument("Arg1", 0, UINT16_MAX, &mArg1);
        AddArgument("Arg2", 0, UINT8_MAX, &mArg2);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestEnumsRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedShort:mArg1];
        params.arg2 = [NSNumber numberWithUnsignedChar:mArg2];
        [cluster testEnumsRequestWithParams:params
                          completionHandler:^(
                              CHIPTestClusterClusterTestEnumsResponseParams * _Nullable values, NSError * _Nullable error) {
                              NSLog(@"Values: %@", values);
                              CHIP_ERROR err = CHIP_NO_ERROR;
                              err = [CHIPError errorToCHIPErrorCode:error];

                              ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                              SetCommandExitStatus(err);
                          }];

        return CHIP_NO_ERROR;
    }

private:
    chip::VendorId mArg1;
    uint8_t mArg2;
};

/*
 * Command TestListInt8UArgumentRequest
 */
class TestClusterTestListInt8UArgumentRequest : public ModelCommand {
public:
    TestClusterTestListInt8UArgumentRequest()
        : ModelCommand("test-list-int8uargument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UArgumentRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster testListInt8UArgumentRequestWithParams:params
                                      completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                          NSError * _Nullable error) {
                                          NSLog(@"Values: %@", values);
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestListInt8UReverseRequest
 */
class TestClusterTestListInt8UReverseRequest : public ModelCommand {
public:
    TestClusterTestListInt8UReverseRequest()
        : ModelCommand("test-list-int8ureverse-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestListInt8UReverseRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster
            testListInt8UReverseRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestListInt8UReverseResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestListNestedStructListArgumentRequest
 */
class TestClusterTestListNestedStructListArgumentRequest : public ModelCommand {
public:
    TestClusterTestListNestedStructListArgumentRequest()
        : ModelCommand("test-list-nested-struct-list-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestListNestedStructListArgumentRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster testListNestedStructListArgumentRequestWithParams:params
                                                 completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                     NSError * _Nullable error) {
                                                     NSLog(@"Values: %@", values);
                                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                                     err = [CHIPError errorToCHIPErrorCode:error];

                                                     ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                                     SetCommandExitStatus(err);
                                                 }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestListStructArgumentRequest
 */
class TestClusterTestListStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestListStructArgumentRequest()
        : ModelCommand("test-list-struct-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestListStructArgumentRequestParams alloc] init];
        // arg1 Array parsing is not supported yet
        [cluster testListStructArgumentRequestWithParams:params
                                       completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                           NSError * _Nullable error) {
                                           NSLog(@"Values: %@", values);
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestNestedStructArgumentRequest
 */
class TestClusterTestNestedStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestNestedStructArgumentRequest()
        : ModelCommand("test-nested-struct-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructArgumentRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster testNestedStructArgumentRequestWithParams:params
                                         completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                             NSError * _Nullable error) {
                                             NSLog(@"Values: %@", values);
                                             CHIP_ERROR err = CHIP_NO_ERROR;
                                             err = [CHIPError errorToCHIPErrorCode:error];

                                             ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                             SetCommandExitStatus(err);
                                         }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestNestedStructListArgumentRequest
 */
class TestClusterTestNestedStructListArgumentRequest : public ModelCommand {
public:
    TestClusterTestNestedStructListArgumentRequest()
        : ModelCommand("test-nested-struct-list-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestNestedStructListArgumentRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster testNestedStructListArgumentRequestWithParams:params
                                             completionHandler:^(CHIPTestClusterClusterBooleanResponseParams * _Nullable values,
                                                 NSError * _Nullable error) {
                                                 NSLog(@"Values: %@", values);
                                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                                 err = [CHIPError errorToCHIPErrorCode:error];

                                                 ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                                 SetCommandExitStatus(err);
                                             }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestNotHandled
 */
class TestClusterTestNotHandled : public ModelCommand {
public:
    TestClusterTestNotHandled()
        : ModelCommand("test-not-handled")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster testNotHandledWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestNullableOptionalRequest
 */
class TestClusterTestNullableOptionalRequest : public ModelCommand {
public:
    TestClusterTestNullableOptionalRequest()
        : ModelCommand("test-nullable-optional-request")
    {
        AddArgument("Arg1", 0, UINT8_MAX, &mArg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestNullableOptionalRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithUnsignedChar:mArg1];
        [cluster
            testNullableOptionalRequestWithParams:params
                                completionHandler:^(CHIPTestClusterClusterTestNullableOptionalResponseParams * _Nullable values,
                                    NSError * _Nullable error) {
                                    NSLog(@"Values: %@", values);
                                    CHIP_ERROR err = CHIP_NO_ERROR;
                                    err = [CHIPError errorToCHIPErrorCode:error];

                                    ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                    SetCommandExitStatus(err);
                                }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mArg1;
};

/*
 * Command TestSimpleOptionalArgumentRequest
 */
class TestClusterTestSimpleOptionalArgumentRequest : public ModelCommand {
public:
    TestClusterTestSimpleOptionalArgumentRequest()
        : ModelCommand("test-simple-optional-argument-request")
    {
        AddArgument("Arg1", 0, 1, &mArg1);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestSimpleOptionalArgumentRequestParams alloc] init];
        params.arg1 = [NSNumber numberWithBool:mArg1];
        [cluster testSimpleOptionalArgumentRequestWithParams:params
                                           completionHandler:^(NSError * _Nullable error) {
                                               CHIP_ERROR err = CHIP_NO_ERROR;
                                               err = [CHIPError errorToCHIPErrorCode:error];

                                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                               SetCommandExitStatus(err);
                                           }];

        return CHIP_NO_ERROR;
    }

private:
    bool mArg1;
};

/*
 * Command TestSpecific
 */
class TestClusterTestSpecific : public ModelCommand {
public:
    TestClusterTestSpecific()
        : ModelCommand("test-specific")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster testSpecificWithCompletionHandler:^(
            CHIPTestClusterClusterTestSpecificResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestStructArgumentRequest
 */
class TestClusterTestStructArgumentRequest : public ModelCommand {
public:
    TestClusterTestStructArgumentRequest()
        : ModelCommand("test-struct-argument-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPTestClusterClusterTestStructArgumentRequestParams alloc] init];
        // arg1 Struct parsing is not supported yet
        [cluster testStructArgumentRequestWithParams:params
                                   completionHandler:^(
                                       CHIPTestClusterClusterBooleanResponseParams * _Nullable values, NSError * _Nullable error) {
                                       NSLog(@"Values: %@", values);
                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                       err = [CHIPError errorToCHIPErrorCode:error];

                                       ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                       SetCommandExitStatus(err);
                                   }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TestUnknownCommand
 */
class TestClusterTestUnknownCommand : public ModelCommand {
public:
    TestClusterTestUnknownCommand()
        : ModelCommand("test-unknown-command")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster testUnknownCommandWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command TimedInvokeRequest
 */
class TestClusterTimedInvokeRequest : public ModelCommand {
public:
    TestClusterTimedInvokeRequest()
        : ModelCommand("timed-invoke-request")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) command (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster timedInvokeRequestWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Event TestEvent
 */
class ReadTestClusterTestEvent : public ModelCommand {
public:
    ReadTestClusterTestEvent()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "test-event");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTestEvent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportTestClusterTestEvent : public ModelCommand {
public:
    ReportTestClusterTestEvent()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "test-event");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterTestEvent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event TestFabricScopedEvent
 */
class ReadTestClusterTestFabricScopedEvent : public ModelCommand {
public:
    ReadTestClusterTestFabricScopedEvent()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "test-fabric-scoped-event");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTestFabricScopedEvent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportTestClusterTestFabricScopedEvent : public ModelCommand {
public:
    ReportTestClusterTestFabricScopedEvent()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "test-fabric-scoped-event");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterTestFabricScopedEvent() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Boolean
 */
class ReadTestClusterBoolean : public ModelCommand {
public:
    ReadTestClusterBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Boolean response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Boolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterBoolean : public ModelCommand {
public:
    WriteTestClusterBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeBooleanWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "TestCluster Boolean Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportTestClusterBoolean : public ModelCommand {
public:
    ReportTestClusterBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap8
 */
class ReadTestClusterBitmap8 : public ModelCommand {
public:
    ReadTestClusterBitmap8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap8 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterBitmap8 : public ModelCommand {
public:
    WriteTestClusterBitmap8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeBitmap8WithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "TestCluster Bitmap8 Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterBitmap8 : public ModelCommand {
public:
    ReportTestClusterBitmap8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap16
 */
class ReadTestClusterBitmap16 : public ModelCommand {
public:
    ReadTestClusterBitmap16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap16 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterBitmap16 : public ModelCommand {
public:
    WriteTestClusterBitmap16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeBitmap16WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "TestCluster Bitmap16 Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterBitmap16 : public ModelCommand {
public:
    ReportTestClusterBitmap16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap32
 */
class ReadTestClusterBitmap32 : public ModelCommand {
public:
    ReadTestClusterBitmap32()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap32 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap32 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterBitmap32 : public ModelCommand {
public:
    WriteTestClusterBitmap32()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeBitmap32WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "TestCluster Bitmap32 Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterBitmap32 : public ModelCommand {
public:
    ReportTestClusterBitmap32()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bitmap64
 */
class ReadTestClusterBitmap64 : public ModelCommand {
public:
    ReadTestClusterBitmap64()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Bitmap64 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Bitmap64 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterBitmap64 : public ModelCommand {
public:
    WriteTestClusterBitmap64()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeBitmap64WithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "TestCluster Bitmap64 Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterBitmap64 : public ModelCommand {
public:
    ReportTestClusterBitmap64()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8u
 */
class ReadTestClusterInt8u : public ModelCommand {
public:
    ReadTestClusterInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int8u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt8u : public ModelCommand {
public:
    WriteTestClusterInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeInt8uWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogError(chipTool, "TestCluster Int8u Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterInt8u : public ModelCommand {
public:
    ReportTestClusterInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16u
 */
class ReadTestClusterInt16u : public ModelCommand {
public:
    ReadTestClusterInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int16u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt16u : public ModelCommand {
public:
    WriteTestClusterInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeInt16uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int16u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterInt16u : public ModelCommand {
public:
    ReportTestClusterInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24u
 */
class ReadTestClusterInt24u : public ModelCommand {
public:
    ReadTestClusterInt24u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt24uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int24u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int24u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt24u : public ModelCommand {
public:
    WriteTestClusterInt24u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeInt24uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int24u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterInt24u : public ModelCommand {
public:
    ReportTestClusterInt24u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32u
 */
class ReadTestClusterInt32u : public ModelCommand {
public:
    ReadTestClusterInt32u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int32u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int32u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt32u : public ModelCommand {
public:
    WriteTestClusterInt32u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeInt32uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int32u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterInt32u : public ModelCommand {
public:
    ReportTestClusterInt32u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40u
 */
class ReadTestClusterInt40u : public ModelCommand {
public:
    ReadTestClusterInt40u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt40uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int40u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int40u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt40u : public ModelCommand {
public:
    WriteTestClusterInt40u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeInt40uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int40u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt40u : public ModelCommand {
public:
    ReportTestClusterInt40u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48u
 */
class ReadTestClusterInt48u : public ModelCommand {
public:
    ReadTestClusterInt48u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt48uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int48u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int48u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt48u : public ModelCommand {
public:
    WriteTestClusterInt48u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeInt48uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int48u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt48u : public ModelCommand {
public:
    ReportTestClusterInt48u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56u
 */
class ReadTestClusterInt56u : public ModelCommand {
public:
    ReadTestClusterInt56u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt56uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int56u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int56u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt56u : public ModelCommand {
public:
    WriteTestClusterInt56u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeInt56uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int56u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt56u : public ModelCommand {
public:
    ReportTestClusterInt56u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64u
 */
class ReadTestClusterInt64u : public ModelCommand {
public:
    ReadTestClusterInt64u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int64u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int64u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt64u : public ModelCommand {
public:
    WriteTestClusterInt64u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeInt64uWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int64u Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterInt64u : public ModelCommand {
public:
    ReportTestClusterInt64u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int8s
 */
class ReadTestClusterInt8s : public ModelCommand {
public:
    ReadTestClusterInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int8s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt8s : public ModelCommand {
public:
    WriteTestClusterInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];
        [cluster writeAttributeInt8sWithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogError(chipTool, "TestCluster Int8s Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return CHIP_NO_ERROR;
    }

private:
    int8_t mValue;
};

class ReportTestClusterInt8s : public ModelCommand {
public:
    ReportTestClusterInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int16s
 */
class ReadTestClusterInt16s : public ModelCommand {
public:
    ReadTestClusterInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int16s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt16s : public ModelCommand {
public:
    WriteTestClusterInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster writeAttributeInt16sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int16s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportTestClusterInt16s : public ModelCommand {
public:
    ReportTestClusterInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int24s
 */
class ReadTestClusterInt24s : public ModelCommand {
public:
    ReadTestClusterInt24s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt24sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int24s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int24s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt24s : public ModelCommand {
public:
    WriteTestClusterInt24s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithInt:mValue];
        [cluster writeAttributeInt24sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int24s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int32_t mValue;
};

class ReportTestClusterInt24s : public ModelCommand {
public:
    ReportTestClusterInt24s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int32s
 */
class ReadTestClusterInt32s : public ModelCommand {
public:
    ReadTestClusterInt32s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int32s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int32s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt32s : public ModelCommand {
public:
    WriteTestClusterInt32s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithInt:mValue];
        [cluster writeAttributeInt32sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int32s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int32_t mValue;
};

class ReportTestClusterInt32s : public ModelCommand {
public:
    ReportTestClusterInt32s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int40s
 */
class ReadTestClusterInt40s : public ModelCommand {
public:
    ReadTestClusterInt40s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt40sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int40s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int40s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt40s : public ModelCommand {
public:
    WriteTestClusterInt40s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeInt40sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int40s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt40s : public ModelCommand {
public:
    ReportTestClusterInt40s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int48s
 */
class ReadTestClusterInt48s : public ModelCommand {
public:
    ReadTestClusterInt48s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt48sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int48s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int48s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt48s : public ModelCommand {
public:
    WriteTestClusterInt48s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeInt48sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int48s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt48s : public ModelCommand {
public:
    ReportTestClusterInt48s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int56s
 */
class ReadTestClusterInt56s : public ModelCommand {
public:
    ReadTestClusterInt56s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt56sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int56s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int56s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt56s : public ModelCommand {
public:
    WriteTestClusterInt56s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeInt56sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int56s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt56s : public ModelCommand {
public:
    ReportTestClusterInt56s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Int64s
 */
class ReadTestClusterInt64s : public ModelCommand {
public:
    ReadTestClusterInt64s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Int64s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Int64s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterInt64s : public ModelCommand {
public:
    WriteTestClusterInt64s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeInt64sWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Int64s Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterInt64s : public ModelCommand {
public:
    ReportTestClusterInt64s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum8
 */
class ReadTestClusterEnum8 : public ModelCommand {
public:
    ReadTestClusterEnum8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Enum8 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Enum8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterEnum8 : public ModelCommand {
public:
    WriteTestClusterEnum8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeEnum8WithValue:value
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogError(chipTool, "TestCluster Enum8 Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterEnum8 : public ModelCommand {
public:
    ReportTestClusterEnum8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Enum16
 */
class ReadTestClusterEnum16 : public ModelCommand {
public:
    ReadTestClusterEnum16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Enum16 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Enum16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterEnum16 : public ModelCommand {
public:
    WriteTestClusterEnum16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeEnum16WithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster Enum16 Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterEnum16 : public ModelCommand {
public:
    ReportTestClusterEnum16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatSingle
 */
class ReadTestClusterFloatSingle : public ModelCommand {
public:
    ReadTestClusterFloatSingle()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.FloatSingle response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster FloatSingle Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterFloatSingle : public ModelCommand {
public:
    WriteTestClusterFloatSingle()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithFloat:mValue];
        [cluster writeAttributeFloatSingleWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "TestCluster FloatSingle Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    float mValue;
};

class ReportTestClusterFloatSingle : public ModelCommand {
public:
    ReportTestClusterFloatSingle()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FloatDouble
 */
class ReadTestClusterFloatDouble : public ModelCommand {
public:
    ReadTestClusterFloatDouble()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.FloatDouble response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster FloatDouble Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterFloatDouble : public ModelCommand {
public:
    WriteTestClusterFloatDouble()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithDouble:mValue];
        [cluster writeAttributeFloatDoubleWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "TestCluster FloatDouble Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    double mValue;
};

class ReportTestClusterFloatDouble : public ModelCommand {
public:
    ReportTestClusterFloatDouble()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OctetString
 */
class ReadTestClusterOctetString : public ModelCommand {
public:
    ReadTestClusterOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.OctetString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster OctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterOctetString : public ModelCommand {
public:
    WriteTestClusterOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSData * _Nonnull value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];
        [cluster writeAttributeOctetStringWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "TestCluster OctetString Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterOctetString : public ModelCommand {
public:
    ReportTestClusterOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListInt8u
 */
class ReadTestClusterListInt8u : public ModelCommand {
public:
    ReadTestClusterListInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeListInt8uWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListInt8u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterListInt8u : public ModelCommand {
public:
    ReportTestClusterListInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListOctetString
 */
class ReadTestClusterListOctetString : public ModelCommand {
public:
    ReadTestClusterListOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeListOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListOctetString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterListOctetString : public ModelCommand {
public:
    ReportTestClusterListOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListStructOctetString
 */
class ReadTestClusterListStructOctetString : public ModelCommand {
public:
    ReadTestClusterListStructOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeListStructOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListStructOctetString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListStructOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterListStructOctetString : public ModelCommand {
public:
    ReportTestClusterListStructOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-struct-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListStructOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongOctetString
 */
class ReadTestClusterLongOctetString : public ModelCommand {
public:
    ReadTestClusterLongOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLongOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.LongOctetString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster LongOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterLongOctetString : public ModelCommand {
public:
    WriteTestClusterLongOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSData * _Nonnull value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];
        [cluster writeAttributeLongOctetStringWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "TestCluster LongOctetString Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterLongOctetString : public ModelCommand {
public:
    ReportTestClusterLongOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CharString
 */
class ReadTestClusterCharString : public ModelCommand {
public:
    ReadTestClusterCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.CharString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster CharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterCharString : public ModelCommand {
public:
    WriteTestClusterCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeCharStringWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogError(chipTool, "TestCluster CharString Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterCharString : public ModelCommand {
public:
    ReportTestClusterCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LongCharString
 */
class ReadTestClusterLongCharString : public ModelCommand {
public:
    ReadTestClusterLongCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "long-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLongCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.LongCharString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster LongCharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterLongCharString : public ModelCommand {
public:
    WriteTestClusterLongCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSString * _Nonnull value = [[NSString alloc] initWithBytes:mValue.data()
                                                             length:mValue.size()
                                                           encoding:NSUTF8StringEncoding];

        [cluster writeAttributeLongCharStringWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster LongCharString Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterLongCharString : public ModelCommand {
public:
    ReportTestClusterLongCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "long-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterLongCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochUs
 */
class ReadTestClusterEpochUs : public ModelCommand {
public:
    ReadTestClusterEpochUs()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-us");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEpochUsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EpochUs response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EpochUs Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterEpochUs : public ModelCommand {
public:
    WriteTestClusterEpochUs()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeEpochUsWithValue:value
                              completionHandler:^(NSError * _Nullable error) {
                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                  err = [CHIPError errorToCHIPErrorCode:error];

                                  ChipLogError(chipTool, "TestCluster EpochUs Error: %s", chip::ErrorStr(err));
                                  SetCommandExitStatus(err);
                              }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterEpochUs : public ModelCommand {
public:
    ReportTestClusterEpochUs()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "epoch-us");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEpochUs() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EpochS
 */
class ReadTestClusterEpochS : public ModelCommand {
public:
    ReadTestClusterEpochS()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "epoch-s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEpochSWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EpochS response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EpochS Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterEpochS : public ModelCommand {
public:
    WriteTestClusterEpochS()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeEpochSWithValue:value
                             completionHandler:^(NSError * _Nullable error) {
                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                 err = [CHIPError errorToCHIPErrorCode:error];

                                 ChipLogError(chipTool, "TestCluster EpochS Error: %s", chip::ErrorStr(err));
                                 SetCommandExitStatus(err);
                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterEpochS : public ModelCommand {
public:
    ReportTestClusterEpochS()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "epoch-s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEpochS() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute VendorId
 */
class ReadTestClusterVendorId : public ModelCommand {
public:
    ReadTestClusterVendorId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "vendor-id");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeVendorIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.VendorId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster VendorId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterVendorId : public ModelCommand {
public:
    WriteTestClusterVendorId()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeVendorIdWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "TestCluster VendorId Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    chip::VendorId mValue;
};

class ReportTestClusterVendorId : public ModelCommand {
public:
    ReportTestClusterVendorId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "vendor-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterVendorId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListNullablesAndOptionalsStruct
 */
class ReadTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    ReadTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeListNullablesAndOptionalsStructWithCompletionHandler:^(
            NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListNullablesAndOptionalsStruct response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListNullablesAndOptionalsStruct Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterListNullablesAndOptionalsStruct : public ModelCommand {
public:
    ReportTestClusterListNullablesAndOptionalsStruct()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-nullables-and-optionals-struct");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListNullablesAndOptionalsStruct() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EnumAttr
 */
class ReadTestClusterEnumAttr : public ModelCommand {
public:
    ReadTestClusterEnumAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.EnumAttr response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster EnumAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterEnumAttr : public ModelCommand {
public:
    WriteTestClusterEnumAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeEnumAttrWithValue:value
                               completionHandler:^(NSError * _Nullable error) {
                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                   err = [CHIPError errorToCHIPErrorCode:error];

                                   ChipLogError(chipTool, "TestCluster EnumAttr Error: %s", chip::ErrorStr(err));
                                   SetCommandExitStatus(err);
                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterEnumAttr : public ModelCommand {
public:
    ReportTestClusterEnumAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8u
 */
class ReadTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeRangeRestrictedInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt8u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster
            writeAttributeRangeRestrictedInt8uWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "TestCluster RangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterRangeRestrictedInt8u : public ModelCommand {
public:
    ReportTestClusterRangeRestrictedInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt8s
 */
class ReadTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeRangeRestrictedInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt8s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];
        [cluster
            writeAttributeRangeRestrictedInt8sWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "TestCluster RangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    int8_t mValue;
};

class ReportTestClusterRangeRestrictedInt8s : public ModelCommand {
public:
    ReportTestClusterRangeRestrictedInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16u
 */
class ReadTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeRangeRestrictedInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt16u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeRangeRestrictedInt16uWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                CHIP_ERROR err = CHIP_NO_ERROR;
                                                err = [CHIPError errorToCHIPErrorCode:error];

                                                ChipLogError(
                                                    chipTool, "TestCluster RangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
                                                SetCommandExitStatus(err);
                                            }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterRangeRestrictedInt16u : public ModelCommand {
public:
    ReportTestClusterRangeRestrictedInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RangeRestrictedInt16s
 */
class ReadTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    ReadTestClusterRangeRestrictedInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeRangeRestrictedInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.RangeRestrictedInt16s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster RangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    WriteTestClusterRangeRestrictedInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster writeAttributeRangeRestrictedInt16sWithValue:value
                                            completionHandler:^(NSError * _Nullable error) {
                                                CHIP_ERROR err = CHIP_NO_ERROR;
                                                err = [CHIPError errorToCHIPErrorCode:error];

                                                ChipLogError(
                                                    chipTool, "TestCluster RangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
                                                SetCommandExitStatus(err);
                                            }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportTestClusterRangeRestrictedInt16s : public ModelCommand {
public:
    ReportTestClusterRangeRestrictedInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ListLongOctetString
 */
class ReadTestClusterListLongOctetString : public ModelCommand {
public:
    ReadTestClusterListLongOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "list-long-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeListLongOctetStringWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ListLongOctetString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ListLongOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterListLongOctetString : public ModelCommand {
public:
    ReportTestClusterListLongOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "list-long-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterListLongOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TimedWriteBoolean
 */
class ReadTestClusterTimedWriteBoolean : public ModelCommand {
public:
    ReadTestClusterTimedWriteBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "timed-write-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeTimedWriteBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.TimedWriteBoolean response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster TimedWriteBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterTimedWriteBoolean : public ModelCommand {
public:
    WriteTestClusterTimedWriteBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeTimedWriteBooleanWithValue:value
                                        completionHandler:^(NSError * _Nullable error) {
                                            CHIP_ERROR err = CHIP_NO_ERROR;
                                            err = [CHIPError errorToCHIPErrorCode:error];

                                            ChipLogError(chipTool, "TestCluster TimedWriteBoolean Error: %s", chip::ErrorStr(err));
                                            SetCommandExitStatus(err);
                                        }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportTestClusterTimedWriteBoolean : public ModelCommand {
public:
    ReportTestClusterTimedWriteBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "timed-write-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterTimedWriteBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute GeneralErrorBoolean
 */
class ReadTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    ReadTestClusterGeneralErrorBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "general-error-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeGeneralErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.GeneralErrorBoolean response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster GeneralErrorBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    WriteTestClusterGeneralErrorBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "general-error-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster
            writeAttributeGeneralErrorBooleanWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster GeneralErrorBoolean Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportTestClusterGeneralErrorBoolean : public ModelCommand {
public:
    ReportTestClusterGeneralErrorBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "general-error-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterGeneralErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterErrorBoolean
 */
class ReadTestClusterClusterErrorBoolean : public ModelCommand {
public:
    ReadTestClusterClusterErrorBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterErrorBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ClusterErrorBoolean response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ClusterErrorBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterClusterErrorBoolean : public ModelCommand {
public:
    WriteTestClusterClusterErrorBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster
            writeAttributeClusterErrorBooleanWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster ClusterErrorBoolean Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportTestClusterClusterErrorBoolean : public ModelCommand {
public:
    ReportTestClusterClusterErrorBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-error-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterClusterErrorBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Unsupported
 */
class ReadTestClusterUnsupported : public ModelCommand {
public:
    ReadTestClusterUnsupported()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "unsupported");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x000000FF) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeUnsupportedWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.Unsupported response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster Unsupported Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterUnsupported : public ModelCommand {
public:
    WriteTestClusterUnsupported()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x000000FF) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeUnsupportedWithValue:value
                                  completionHandler:^(NSError * _Nullable error) {
                                      CHIP_ERROR err = CHIP_NO_ERROR;
                                      err = [CHIPError errorToCHIPErrorCode:error];

                                      ChipLogError(chipTool, "TestCluster Unsupported Error: %s", chip::ErrorStr(err));
                                      SetCommandExitStatus(err);
                                  }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportTestClusterUnsupported : public ModelCommand {
public:
    ReportTestClusterUnsupported()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "unsupported");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterUnsupported() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x000000FF) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBoolean
 */
class ReadTestClusterNullableBoolean : public ModelCommand {
public:
    ReadTestClusterNullableBoolean()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-boolean");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableBooleanWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBoolean response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBoolean Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableBoolean : public ModelCommand {
public:
    WriteTestClusterNullableBoolean()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("attr-value", 0, 1, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, 1, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithBool:mValue];
        [cluster writeAttributeNullableBooleanWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "TestCluster NullableBoolean Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    bool mValue;
};

class ReportTestClusterNullableBoolean : public ModelCommand {
public:
    ReportTestClusterNullableBoolean()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-boolean");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBoolean() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap8
 */
class ReadTestClusterNullableBitmap8 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableBitmap8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap8 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableBitmap8 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeNullableBitmap8WithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "TestCluster NullableBitmap8 Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterNullableBitmap8 : public ModelCommand {
public:
    ReportTestClusterNullableBitmap8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap16
 */
class ReadTestClusterNullableBitmap16 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableBitmap16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap16 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableBitmap16 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008002) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeNullableBitmap16WithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "TestCluster NullableBitmap16 Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterNullableBitmap16 : public ModelCommand {
public:
    ReportTestClusterNullableBitmap16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap32
 */
class ReadTestClusterNullableBitmap32 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap32()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableBitmap32WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap32 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap32 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableBitmap32 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap32()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008003) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeNullableBitmap32WithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "TestCluster NullableBitmap32 Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterNullableBitmap32 : public ModelCommand {
public:
    ReportTestClusterNullableBitmap32()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap32");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap32() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableBitmap64
 */
class ReadTestClusterNullableBitmap64 : public ModelCommand {
public:
    ReadTestClusterNullableBitmap64()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableBitmap64WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableBitmap64 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableBitmap64 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableBitmap64 : public ModelCommand {
public:
    WriteTestClusterNullableBitmap64()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008004) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeNullableBitmap64WithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "TestCluster NullableBitmap64 Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterNullableBitmap64 : public ModelCommand {
public:
    ReportTestClusterNullableBitmap64()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-bitmap64");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableBitmap64() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8u
 */
class ReadTestClusterNullableInt8u : public ModelCommand {
public:
    ReadTestClusterNullableInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt8uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt8u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt8u : public ModelCommand {
public:
    WriteTestClusterNullableInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008005) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeNullableInt8uWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(chipTool, "TestCluster NullableInt8u Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterNullableInt8u : public ModelCommand {
public:
    ReportTestClusterNullableInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16u
 */
class ReadTestClusterNullableInt16u : public ModelCommand {
public:
    ReadTestClusterNullableInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt16uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt16u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt16u : public ModelCommand {
public:
    WriteTestClusterNullableInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008006) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeNullableInt16uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt16u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterNullableInt16u : public ModelCommand {
public:
    ReportTestClusterNullableInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24u
 */
class ReadTestClusterNullableInt24u : public ModelCommand {
public:
    ReadTestClusterNullableInt24u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt24uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt24u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt24u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt24u : public ModelCommand {
public:
    WriteTestClusterNullableInt24u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008007) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeNullableInt24uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt24u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterNullableInt24u : public ModelCommand {
public:
    ReportTestClusterNullableInt24u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int24u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt24u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32u
 */
class ReadTestClusterNullableInt32u : public ModelCommand {
public:
    ReadTestClusterNullableInt32u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt32uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt32u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt32u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt32u : public ModelCommand {
public:
    WriteTestClusterNullableInt32u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("attr-value", 0, UINT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008008) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedInt:mValue];
        [cluster writeAttributeNullableInt32uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt32u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint32_t mValue;
};

class ReportTestClusterNullableInt32u : public ModelCommand {
public:
    ReportTestClusterNullableInt32u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int32u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt32u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40u
 */
class ReadTestClusterNullableInt40u : public ModelCommand {
public:
    ReadTestClusterNullableInt40u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt40uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt40u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt40u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt40u : public ModelCommand {
public:
    WriteTestClusterNullableInt40u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008009) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeNullableInt40uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt40u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterNullableInt40u : public ModelCommand {
public:
    ReportTestClusterNullableInt40u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int40u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt40u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48u
 */
class ReadTestClusterNullableInt48u : public ModelCommand {
public:
    ReadTestClusterNullableInt48u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt48uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt48u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt48u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt48u : public ModelCommand {
public:
    WriteTestClusterNullableInt48u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800A) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeNullableInt48uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt48u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterNullableInt48u : public ModelCommand {
public:
    ReportTestClusterNullableInt48u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int48u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt48u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56u
 */
class ReadTestClusterNullableInt56u : public ModelCommand {
public:
    ReadTestClusterNullableInt56u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt56uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt56u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt56u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt56u : public ModelCommand {
public:
    WriteTestClusterNullableInt56u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800B) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeNullableInt56uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt56u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterNullableInt56u : public ModelCommand {
public:
    ReportTestClusterNullableInt56u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int56u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt56u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64u
 */
class ReadTestClusterNullableInt64u : public ModelCommand {
public:
    ReadTestClusterNullableInt64u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt64uWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt64u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt64u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt64u : public ModelCommand {
public:
    WriteTestClusterNullableInt64u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("attr-value", 0, UINT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800C) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedLongLong:mValue];
        [cluster writeAttributeNullableInt64uWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt64u Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint64_t mValue;
};

class ReportTestClusterNullableInt64u : public ModelCommand {
public:
    ReportTestClusterNullableInt64u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int64u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt64u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt8s
 */
class ReadTestClusterNullableInt8s : public ModelCommand {
public:
    ReadTestClusterNullableInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt8sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt8s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt8s : public ModelCommand {
public:
    WriteTestClusterNullableInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800D) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithChar:mValue];
        [cluster writeAttributeNullableInt8sWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(chipTool, "TestCluster NullableInt8s Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    int8_t mValue;
};

class ReportTestClusterNullableInt8s : public ModelCommand {
public:
    ReportTestClusterNullableInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt16s
 */
class ReadTestClusterNullableInt16s : public ModelCommand {
public:
    ReadTestClusterNullableInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt16sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt16s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt16s : public ModelCommand {
public:
    WriteTestClusterNullableInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800E) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithShort:mValue];
        [cluster writeAttributeNullableInt16sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt16s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportTestClusterNullableInt16s : public ModelCommand {
public:
    ReportTestClusterNullableInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt24s
 */
class ReadTestClusterNullableInt24s : public ModelCommand {
public:
    ReadTestClusterNullableInt24s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int24s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000800F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt24sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt24s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt24s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt24s : public ModelCommand {
public:
    WriteTestClusterNullableInt24s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000800F) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithInt:mValue];
        [cluster writeAttributeNullableInt24sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt24s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int32_t mValue;
};

class ReportTestClusterNullableInt24s : public ModelCommand {
public:
    ReportTestClusterNullableInt24s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int24s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt24s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000800F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt32s
 */
class ReadTestClusterNullableInt32s : public ModelCommand {
public:
    ReadTestClusterNullableInt32s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int32s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt32sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt32s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt32s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt32s : public ModelCommand {
public:
    WriteTestClusterNullableInt32s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008010) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT32_MIN, INT32_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithInt:mValue];
        [cluster writeAttributeNullableInt32sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt32s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int32_t mValue;
};

class ReportTestClusterNullableInt32s : public ModelCommand {
public:
    ReportTestClusterNullableInt32s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int32s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt32s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt40s
 */
class ReadTestClusterNullableInt40s : public ModelCommand {
public:
    ReadTestClusterNullableInt40s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int40s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt40sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt40s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt40s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt40s : public ModelCommand {
public:
    WriteTestClusterNullableInt40s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008011) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeNullableInt40sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt40s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterNullableInt40s : public ModelCommand {
public:
    ReportTestClusterNullableInt40s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int40s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt40s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt48s
 */
class ReadTestClusterNullableInt48s : public ModelCommand {
public:
    ReadTestClusterNullableInt48s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int48s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt48sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt48s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt48s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt48s : public ModelCommand {
public:
    WriteTestClusterNullableInt48s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008012) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeNullableInt48sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt48s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterNullableInt48s : public ModelCommand {
public:
    ReportTestClusterNullableInt48s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int48s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt48s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt56s
 */
class ReadTestClusterNullableInt56s : public ModelCommand {
public:
    ReadTestClusterNullableInt56s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int56s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt56sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt56s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt56s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt56s : public ModelCommand {
public:
    WriteTestClusterNullableInt56s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008013) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeNullableInt56sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt56s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterNullableInt56s : public ModelCommand {
public:
    ReportTestClusterNullableInt56s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int56s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt56s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableInt64s
 */
class ReadTestClusterNullableInt64s : public ModelCommand {
public:
    ReadTestClusterNullableInt64s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-int64s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableInt64sWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableInt64s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableInt64s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableInt64s : public ModelCommand {
public:
    WriteTestClusterNullableInt64s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008014) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT64_MIN, INT64_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithLongLong:mValue];
        [cluster writeAttributeNullableInt64sWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableInt64s Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int64_t mValue;
};

class ReportTestClusterNullableInt64s : public ModelCommand {
public:
    ReportTestClusterNullableInt64s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-int64s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableInt64s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008014) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum8
 */
class ReadTestClusterNullableEnum8 : public ModelCommand {
public:
    ReadTestClusterNullableEnum8()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum8");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableEnum8WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnum8 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnum8 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableEnum8 : public ModelCommand {
public:
    WriteTestClusterNullableEnum8()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008015) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeNullableEnum8WithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(chipTool, "TestCluster NullableEnum8 Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterNullableEnum8 : public ModelCommand {
public:
    ReportTestClusterNullableEnum8()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum8");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnum8() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnum16
 */
class ReadTestClusterNullableEnum16 : public ModelCommand {
public:
    ReadTestClusterNullableEnum16()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum16");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableEnum16WithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnum16 response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnum16 Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableEnum16 : public ModelCommand {
public:
    WriteTestClusterNullableEnum16()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008016) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster writeAttributeNullableEnum16WithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableEnum16 Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterNullableEnum16 : public ModelCommand {
public:
    ReportTestClusterNullableEnum16()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum16");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnum16() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008016) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatSingle
 */
class ReadTestClusterNullableFloatSingle : public ModelCommand {
public:
    ReadTestClusterNullableFloatSingle()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-single");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableFloatSingleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableFloatSingle response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableFloatSingle Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableFloatSingle : public ModelCommand {
public:
    WriteTestClusterNullableFloatSingle()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008017) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", -std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithFloat:mValue];
        [cluster
            writeAttributeNullableFloatSingleWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableFloatSingle Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    float mValue;
};

class ReportTestClusterNullableFloatSingle : public ModelCommand {
public:
    ReportTestClusterNullableFloatSingle()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-float-single");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableFloatSingle() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableFloatDouble
 */
class ReadTestClusterNullableFloatDouble : public ModelCommand {
public:
    ReadTestClusterNullableFloatDouble()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-float-double");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableFloatDoubleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableFloatDouble response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableFloatDouble Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableFloatDouble : public ModelCommand {
public:
    WriteTestClusterNullableFloatDouble()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008018) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", -std::numeric_limits<double>::infinity(), std::numeric_limits<double>::infinity(), &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithDouble:mValue];
        [cluster
            writeAttributeNullableFloatDoubleWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableFloatDouble Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    double mValue;
};

class ReportTestClusterNullableFloatDouble : public ModelCommand {
public:
    ReportTestClusterNullableFloatDouble()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-float-double");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableFloatDouble() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008018) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableOctetString
 */
class ReadTestClusterNullableOctetString : public ModelCommand {
public:
    ReadTestClusterNullableOctetString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-octet-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableOctetStringWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableOctetString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableOctetString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableOctetString : public ModelCommand {
public:
    WriteTestClusterNullableOctetString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008019) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSData * _Nullable value = [[NSData alloc] initWithBytes:mValue.data() length:mValue.size()];
        [cluster
            writeAttributeNullableOctetStringWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "TestCluster NullableOctetString Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterNullableOctetString : public ModelCommand {
public:
    ReportTestClusterNullableOctetString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-octet-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableOctetString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008019) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableCharString
 */
class ReadTestClusterNullableCharString : public ModelCommand {
public:
    ReadTestClusterNullableCharString()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-char-string");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000801E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableCharStringWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableCharString response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableCharString Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableCharString : public ModelCommand {
public:
    WriteTestClusterNullableCharString()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("attr-value", &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x0000801E) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSString * _Nullable value = [[NSString alloc] initWithBytes:mValue.data()
                                                              length:mValue.size()
                                                            encoding:NSUTF8StringEncoding];

        [cluster
            writeAttributeNullableCharStringWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(chipTool, "TestCluster NullableCharString Error: %s", chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    chip::ByteSpan mValue;
};

class ReportTestClusterNullableCharString : public ModelCommand {
public:
    ReportTestClusterNullableCharString()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-char-string");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableCharString() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000801E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableEnumAttr
 */
class ReadTestClusterNullableEnumAttr : public ModelCommand {
public:
    ReadTestClusterNullableEnumAttr()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableEnumAttrWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableEnumAttr response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableEnumAttr Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableEnumAttr : public ModelCommand {
public:
    WriteTestClusterNullableEnumAttr()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008024) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeNullableEnumAttrWithValue:value
                                       completionHandler:^(NSError * _Nullable error) {
                                           CHIP_ERROR err = CHIP_NO_ERROR;
                                           err = [CHIPError errorToCHIPErrorCode:error];

                                           ChipLogError(chipTool, "TestCluster NullableEnumAttr Error: %s", chip::ErrorStr(err));
                                           SetCommandExitStatus(err);
                                       }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterNullableEnumAttr : public ModelCommand {
public:
    ReportTestClusterNullableEnumAttr()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-enum-attr");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableEnumAttr() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008024) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8u
 */
class ReadTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableRangeRestrictedInt8uWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt8u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008026) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeNullableRangeRestrictedInt8uWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                                       err = [CHIPError errorToCHIPErrorCode:error];

                                                       ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8u Error: %s",
                                                           chip::ErrorStr(err));
                                                       SetCommandExitStatus(err);
                                                   }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTestClusterNullableRangeRestrictedInt8u : public ModelCommand {
public:
    ReportTestClusterNullableRangeRestrictedInt8u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt8u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008026) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt8s
 */
class ReadTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008027) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableRangeRestrictedInt8sWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt8s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008027) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithChar:mValue];
        [cluster writeAttributeNullableRangeRestrictedInt8sWithValue:value
                                                   completionHandler:^(NSError * _Nullable error) {
                                                       CHIP_ERROR err = CHIP_NO_ERROR;
                                                       err = [CHIPError errorToCHIPErrorCode:error];

                                                       ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt8s Error: %s",
                                                           chip::ErrorStr(err));
                                                       SetCommandExitStatus(err);
                                                   }];
        return CHIP_NO_ERROR;
    }

private:
    int8_t mValue;
};

class ReportTestClusterNullableRangeRestrictedInt8s : public ModelCommand {
public:
    ReportTestClusterNullableRangeRestrictedInt8s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int8s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt8s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008027) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16u
 */
class ReadTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableRangeRestrictedInt16uWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt16u response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16u Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("attr-value", 0, UINT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008028) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithUnsignedShort:mValue];
        [cluster
            writeAttributeNullableRangeRestrictedInt16uWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                                   err = [CHIPError errorToCHIPErrorCode:error];

                                                   ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16u Error: %s",
                                                       chip::ErrorStr(err));
                                                   SetCommandExitStatus(err);
                                               }];
        return CHIP_NO_ERROR;
    }

private:
    uint16_t mValue;
};

class ReportTestClusterNullableRangeRestrictedInt16u : public ModelCommand {
public:
    ReportTestClusterNullableRangeRestrictedInt16u()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16u");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt16u() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008028) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NullableRangeRestrictedInt16s
 */
class ReadTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    ReadTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x00008029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeNullableRangeRestrictedInt16sWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.NullableRangeRestrictedInt16s response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16s Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    WriteTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) WriteAttribute (0x00008029) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nullable value = [NSNumber numberWithShort:mValue];
        [cluster
            writeAttributeNullableRangeRestrictedInt16sWithValue:value
                                               completionHandler:^(NSError * _Nullable error) {
                                                   CHIP_ERROR err = CHIP_NO_ERROR;
                                                   err = [CHIPError errorToCHIPErrorCode:error];

                                                   ChipLogError(chipTool, "TestCluster NullableRangeRestrictedInt16s Error: %s",
                                                       chip::ErrorStr(err));
                                                   SetCommandExitStatus(err);
                                               }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportTestClusterNullableRangeRestrictedInt16s : public ModelCommand {
public:
    ReportTestClusterNullableRangeRestrictedInt16s()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "nullable-range-restricted-int16s");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterNullableRangeRestrictedInt16s() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x00008029) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadTestClusterServerGeneratedCommandList : public ModelCommand {
public:
    ReadTestClusterServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TestCluster.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TestCluster ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterServerGeneratedCommandList : public ModelCommand {
public:
    ReportTestClusterServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadTestClusterClientGeneratedCommandList : public ModelCommand {
public:
    ReadTestClusterClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TestCluster.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TestCluster ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterClientGeneratedCommandList : public ModelCommand {
public:
    ReportTestClusterClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadTestClusterAttributeList : public ModelCommand {
public:
    ReadTestClusterAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterAttributeList : public ModelCommand {
public:
    ReportTestClusterAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTestClusterClusterRevision : public ModelCommand {
public:
    ReadTestClusterClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTestCluster * cluster = [[CHIPTestCluster alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TestCluster.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TestCluster ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTestClusterClusterRevision : public ModelCommand {
public:
    ReportTestClusterClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTestClusterClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000050F) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster Thermostat                                                  | 0x0201 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ClearWeeklySchedule                                               |   0x03 |
| * GetRelayStatusLog                                                 |   0x04 |
| * GetWeeklySchedule                                                 |   0x02 |
| * SetWeeklySchedule                                                 |   0x01 |
| * SetpointRaiseLower                                                |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LocalTemperature                                                  | 0x0000 |
| * AbsMinHeatSetpointLimit                                           | 0x0003 |
| * AbsMaxHeatSetpointLimit                                           | 0x0004 |
| * AbsMinCoolSetpointLimit                                           | 0x0005 |
| * AbsMaxCoolSetpointLimit                                           | 0x0006 |
| * OccupiedCoolingSetpoint                                           | 0x0011 |
| * OccupiedHeatingSetpoint                                           | 0x0012 |
| * MinHeatSetpointLimit                                              | 0x0015 |
| * MaxHeatSetpointLimit                                              | 0x0016 |
| * MinCoolSetpointLimit                                              | 0x0017 |
| * MaxCoolSetpointLimit                                              | 0x0018 |
| * MinSetpointDeadBand                                               | 0x0019 |
| * ControlSequenceOfOperation                                        | 0x001B |
| * SystemMode                                                        | 0x001C |
| * StartOfWeek                                                       | 0x0020 |
| * NumberOfWeeklyTransitions                                         | 0x0021 |
| * NumberOfDailyTransitions                                          | 0x0022 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command ClearWeeklySchedule
 */
class ThermostatClearWeeklySchedule : public ModelCommand {
public:
    ThermostatClearWeeklySchedule()
        : ModelCommand("clear-weekly-schedule")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster clearWeeklyScheduleWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command GetRelayStatusLog
 */
class ThermostatGetRelayStatusLog : public ModelCommand {
public:
    ThermostatGetRelayStatusLog()
        : ModelCommand("get-relay-status-log")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster getRelayStatusLogWithCompletionHandler:^(
            CHIPThermostatClusterGetRelayStatusLogResponseParams * _Nullable values, NSError * _Nullable error) {
            NSLog(@"Values: %@", values);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command GetWeeklySchedule
 */
class ThermostatGetWeeklySchedule : public ModelCommand {
public:
    ThermostatGetWeeklySchedule()
        : ModelCommand("get-weekly-schedule")
    {
        AddArgument("DaysToReturn", 0, UINT8_MAX, &mDaysToReturn);
        AddArgument("ModeToReturn", 0, UINT8_MAX, &mModeToReturn);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPThermostatClusterGetWeeklyScheduleParams alloc] init];
        params.daysToReturn = [NSNumber numberWithUnsignedChar:mDaysToReturn];
        params.modeToReturn = [NSNumber numberWithUnsignedChar:mModeToReturn];
        [cluster getWeeklyScheduleWithParams:params
                           completionHandler:^(
                               CHIPThermostatClusterGetWeeklyScheduleResponseParams * _Nullable values, NSError * _Nullable error) {
                               NSLog(@"Values: %@", values);
                               CHIP_ERROR err = CHIP_NO_ERROR;
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mDaysToReturn;
    uint8_t mModeToReturn;
};

/*
 * Command SetWeeklySchedule
 */
class ThermostatSetWeeklySchedule : public ModelCommand {
public:
    ThermostatSetWeeklySchedule()
        : ModelCommand("set-weekly-schedule")
    {
        AddArgument("NumberOfTransitionsForSequence", 0, UINT8_MAX, &mNumberOfTransitionsForSequence);
        AddArgument("DayOfWeekForSequence", 0, UINT8_MAX, &mDayOfWeekForSequence);
        AddArgument("ModeForSequence", 0, UINT8_MAX, &mModeForSequence);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPThermostatClusterSetWeeklyScheduleParams alloc] init];
        params.numberOfTransitionsForSequence = [NSNumber numberWithUnsignedChar:mNumberOfTransitionsForSequence];
        params.dayOfWeekForSequence = [NSNumber numberWithUnsignedChar:mDayOfWeekForSequence];
        params.modeForSequence = [NSNumber numberWithUnsignedChar:mModeForSequence];
        // payload Array parsing is not supported yet
        [cluster setWeeklyScheduleWithParams:params
                           completionHandler:^(NSError * _Nullable error) {
                               CHIP_ERROR err = CHIP_NO_ERROR;
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mNumberOfTransitionsForSequence;
    uint8_t mDayOfWeekForSequence;
    uint8_t mModeForSequence;
};

/*
 * Command SetpointRaiseLower
 */
class ThermostatSetpointRaiseLower : public ModelCommand {
public:
    ThermostatSetpointRaiseLower()
        : ModelCommand("setpoint-raise-lower")
    {
        AddArgument("Mode", 0, UINT8_MAX, &mMode);
        AddArgument("Amount", INT8_MIN, INT8_MAX, &mAmount);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPThermostatClusterSetpointRaiseLowerParams alloc] init];
        params.mode = [NSNumber numberWithUnsignedChar:mMode];
        params.amount = [NSNumber numberWithChar:mAmount];
        [cluster setpointRaiseLowerWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    uint8_t mMode;
    int8_t mAmount;
};

/*
 * Attribute LocalTemperature
 */
class ReadThermostatLocalTemperature : public ModelCommand {
public:
    ReadThermostatLocalTemperature()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "local-temperature");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLocalTemperatureWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.LocalTemperature response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat LocalTemperature Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatLocalTemperature : public ModelCommand {
public:
    ReportThermostatLocalTemperature()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "local-temperature");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatLocalTemperature() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinHeatSetpointLimit
 */
class ReadThermostatAbsMinHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMinHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeAbsMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMinHeatSetpointLimit response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatAbsMinHeatSetpointLimit : public ModelCommand {
public:
    ReportThermostatAbsMinHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxHeatSetpointLimit
 */
class ReadThermostatAbsMaxHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMaxHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeAbsMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMaxHeatSetpointLimit response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatAbsMaxHeatSetpointLimit : public ModelCommand {
public:
    ReportThermostatAbsMaxHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMinCoolSetpointLimit
 */
class ReadThermostatAbsMinCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMinCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeAbsMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMinCoolSetpointLimit response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatAbsMinCoolSetpointLimit : public ModelCommand {
public:
    ReportThermostatAbsMinCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AbsMaxCoolSetpointLimit
 */
class ReadThermostatAbsMaxCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatAbsMaxCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeAbsMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.AbsMaxCoolSetpointLimit response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat AbsMaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatAbsMaxCoolSetpointLimit : public ModelCommand {
public:
    ReportThermostatAbsMaxCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "abs-max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAbsMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedCoolingSetpoint
 */
class ReadThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    ReadThermostatOccupiedCoolingSetpoint()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeOccupiedCoolingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.OccupiedCoolingSetpoint response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat OccupiedCoolingSetpoint Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    WriteThermostatOccupiedCoolingSetpoint()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster writeAttributeOccupiedCoolingSetpointWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                                  err = [CHIPError errorToCHIPErrorCode:error];

                                                  ChipLogError(chipTool, "Thermostat OccupiedCoolingSetpoint Error: %s",
                                                      chip::ErrorStr(err));
                                                  SetCommandExitStatus(err);
                                              }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportThermostatOccupiedCoolingSetpoint : public ModelCommand {
public:
    ReportThermostatOccupiedCoolingSetpoint()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupied-cooling-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatOccupiedCoolingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OccupiedHeatingSetpoint
 */
class ReadThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    ReadThermostatOccupiedHeatingSetpoint()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeOccupiedHeatingSetpointWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.OccupiedHeatingSetpoint response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat OccupiedHeatingSetpoint Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    WriteThermostatOccupiedHeatingSetpoint()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster writeAttributeOccupiedHeatingSetpointWithValue:value
                                              completionHandler:^(NSError * _Nullable error) {
                                                  CHIP_ERROR err = CHIP_NO_ERROR;
                                                  err = [CHIPError errorToCHIPErrorCode:error];

                                                  ChipLogError(chipTool, "Thermostat OccupiedHeatingSetpoint Error: %s",
                                                      chip::ErrorStr(err));
                                                  SetCommandExitStatus(err);
                                              }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportThermostatOccupiedHeatingSetpoint : public ModelCommand {
public:
    ReportThermostatOccupiedHeatingSetpoint()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "occupied-heating-setpoint");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatOccupiedHeatingSetpoint() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinHeatSetpointLimit
 */
class ReadThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatMinHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinHeatSetpointLimit response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    WriteThermostatMinHeatSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster
            writeAttributeMinHeatSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "Thermostat MinHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportThermostatMinHeatSetpointLimit : public ModelCommand {
public:
    ReportThermostatMinHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxHeatSetpointLimit
 */
class ReadThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    ReadThermostatMaxHeatSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxHeatSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MaxHeatSetpointLimit response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    WriteThermostatMaxHeatSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster
            writeAttributeMaxHeatSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "Thermostat MaxHeatSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportThermostatMaxHeatSetpointLimit : public ModelCommand {
public:
    ReportThermostatMaxHeatSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-heat-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMaxHeatSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinCoolSetpointLimit
 */
class ReadThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatMinCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinCoolSetpointLimit response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    WriteThermostatMinCoolSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster
            writeAttributeMinCoolSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "Thermostat MinCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportThermostatMinCoolSetpointLimit : public ModelCommand {
public:
    ReportThermostatMinCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MaxCoolSetpointLimit
 */
class ReadThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    ReadThermostatMaxCoolSetpointLimit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMaxCoolSetpointLimitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MaxCoolSetpointLimit response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    WriteThermostatMaxCoolSetpointLimit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT16_MIN, INT16_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithShort:mValue];
        [cluster
            writeAttributeMaxCoolSetpointLimitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "Thermostat MaxCoolSetpointLimit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    int16_t mValue;
};

class ReportThermostatMaxCoolSetpointLimit : public ModelCommand {
public:
    ReportThermostatMaxCoolSetpointLimit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "max-cool-setpoint-limit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMaxCoolSetpointLimit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MinSetpointDeadBand
 */
class ReadThermostatMinSetpointDeadBand : public ModelCommand {
public:
    ReadThermostatMinSetpointDeadBand()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeMinSetpointDeadBandWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.MinSetpointDeadBand response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat MinSetpointDeadBand Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatMinSetpointDeadBand : public ModelCommand {
public:
    WriteThermostatMinSetpointDeadBand()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", INT8_MIN, INT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithChar:mValue];
        [cluster
            writeAttributeMinSetpointDeadBandWithValue:value
                                     completionHandler:^(NSError * _Nullable error) {
                                         CHIP_ERROR err = CHIP_NO_ERROR;
                                         err = [CHIPError errorToCHIPErrorCode:error];

                                         ChipLogError(chipTool, "Thermostat MinSetpointDeadBand Error: %s", chip::ErrorStr(err));
                                         SetCommandExitStatus(err);
                                     }];
        return CHIP_NO_ERROR;
    }

private:
    int8_t mValue;
};

class ReportThermostatMinSetpointDeadBand : public ModelCommand {
public:
    ReportThermostatMinSetpointDeadBand()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "min-setpoint-dead-band");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatMinSetpointDeadBand() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ControlSequenceOfOperation
 */
class ReadThermostatControlSequenceOfOperation : public ModelCommand {
public:
    ReadThermostatControlSequenceOfOperation()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeControlSequenceOfOperationWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.ControlSequenceOfOperation response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat ControlSequenceOfOperation Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatControlSequenceOfOperation : public ModelCommand {
public:
    WriteThermostatControlSequenceOfOperation()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeControlSequenceOfOperationWithValue:value
                                                 completionHandler:^(NSError * _Nullable error) {
                                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                                     err = [CHIPError errorToCHIPErrorCode:error];

                                                     ChipLogError(chipTool, "Thermostat ControlSequenceOfOperation Error: %s",
                                                         chip::ErrorStr(err));
                                                     SetCommandExitStatus(err);
                                                 }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportThermostatControlSequenceOfOperation : public ModelCommand {
public:
    ReportThermostatControlSequenceOfOperation()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "control-sequence-of-operation");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatControlSequenceOfOperation() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SystemMode
 */
class ReadThermostatSystemMode : public ModelCommand {
public:
    ReadThermostatSystemMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "system-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSystemModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.SystemMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat SystemMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatSystemMode : public ModelCommand {
public:
    WriteThermostatSystemMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) WriteAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeSystemModeWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogError(chipTool, "Thermostat SystemMode Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportThermostatSystemMode : public ModelCommand {
public:
    ReportThermostatSystemMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "system-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatSystemMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StartOfWeek
 */
class ReadThermostatStartOfWeek : public ModelCommand {
public:
    ReadThermostatStartOfWeek()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "start-of-week");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeStartOfWeekWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.StartOfWeek response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat StartOfWeek Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatStartOfWeek : public ModelCommand {
public:
    ReportThermostatStartOfWeek()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "start-of-week");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatStartOfWeek() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfWeeklyTransitions
 */
class ReadThermostatNumberOfWeeklyTransitions : public ModelCommand {
public:
    ReadThermostatNumberOfWeeklyTransitions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeNumberOfWeeklyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.NumberOfWeeklyTransitions response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat NumberOfWeeklyTransitions Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatNumberOfWeeklyTransitions : public ModelCommand {
public:
    ReportThermostatNumberOfWeeklyTransitions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-weekly-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatNumberOfWeeklyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NumberOfDailyTransitions
 */
class ReadThermostatNumberOfDailyTransitions : public ModelCommand {
public:
    ReadThermostatNumberOfDailyTransitions()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeNumberOfDailyTransitionsWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"Thermostat.NumberOfDailyTransitions response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "Thermostat NumberOfDailyTransitions Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatNumberOfDailyTransitions : public ModelCommand {
public:
    ReportThermostatNumberOfDailyTransitions()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "number-of-daily-transitions");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatNumberOfDailyTransitions() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatAttributeList : public ModelCommand {
public:
    ReadThermostatAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatAttributeList : public ModelCommand {
public:
    ReportThermostatAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThermostatFeatureMap : public ModelCommand {
public:
    ReadThermostatFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatFeatureMap : public ModelCommand {
public:
    ReportThermostatFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatClusterRevision : public ModelCommand {
public:
    ReadThermostatClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostat * cluster = [[CHIPThermostat alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"Thermostat.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "Thermostat ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatClusterRevision : public ModelCommand {
public:
    ReportThermostatClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000201) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThermostatUserInterfaceConfiguration                        | 0x0204 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureDisplayMode                                            | 0x0000 |
| * KeypadLockout                                                     | 0x0001 |
| * ScheduleProgrammingVisibility                                     | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureDisplayMode
 */
class ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-display-mode");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeTemperatureDisplayModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.TemperatureDisplayMode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration TemperatureDisplayMode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeTemperatureDisplayModeWithValue:value
                                             completionHandler:^(NSError * _Nullable error) {
                                                 CHIP_ERROR err = CHIP_NO_ERROR;
                                                 err = [CHIPError errorToCHIPErrorCode:error];

                                                 ChipLogError(chipTool,
                                                     "ThermostatUserInterfaceConfiguration TemperatureDisplayMode Error: %s",
                                                     chip::ErrorStr(err));
                                                 SetCommandExitStatus(err);
                                             }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "temperature-display-mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute KeypadLockout
 */
class ReadThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "keypad-lockout");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeKeypadLockoutWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.KeypadLockout response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration KeypadLockout Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeKeypadLockoutWithValue:value
                                    completionHandler:^(NSError * _Nullable error) {
                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                        err = [CHIPError errorToCHIPErrorCode:error];

                                        ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration KeypadLockout Error: %s",
                                            chip::ErrorStr(err));
                                        SetCommandExitStatus(err);
                                    }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationKeypadLockout : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationKeypadLockout()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "keypad-lockout");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationKeypadLockout() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ScheduleProgrammingVisibility
 */
class ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeScheduleProgrammingVisibilityWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.ScheduleProgrammingVisibility response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(
                chipTool, "ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) WriteAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeScheduleProgrammingVisibilityWithValue:value
                                                    completionHandler:^(NSError * _Nullable error) {
                                                        CHIP_ERROR err = CHIP_NO_ERROR;
                                                        err = [CHIPError errorToCHIPErrorCode:error];

                                                        ChipLogError(chipTool,
                                                            "ThermostatUserInterfaceConfiguration ScheduleProgrammingVisibility "
                                                            "Error: %s",
                                                            chip::ErrorStr(err));
                                                        SetCommandExitStatus(err);
                                                    }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "schedule-programming-visibility");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThermostatUserInterfaceConfiguration.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(
                    chipTool, "ThermostatUserInterfaceConfiguration ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatUserInterfaceConfigurationServerGeneratedCommandList : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThermostatUserInterfaceConfiguration.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(
                    chipTool, "ThermostatUserInterfaceConfiguration ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatUserInterfaceConfigurationClientGeneratedCommandList : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThermostatUserInterfaceConfigurationAttributeList : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatUserInterfaceConfigurationAttributeList : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand {
public:
    ReadThermostatUserInterfaceConfigurationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThermostatUserInterfaceConfiguration * cluster =
            [[CHIPThermostatUserInterfaceConfiguration alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThermostatUserInterfaceConfiguration.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThermostatUserInterfaceConfiguration ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThermostatUserInterfaceConfigurationClusterRevision : public ModelCommand {
public:
    ReportThermostatUserInterfaceConfigurationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThermostatUserInterfaceConfigurationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000204) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster ThreadNetworkDiagnostics                                    | 0x0035 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Channel                                                           | 0x0000 |
| * RoutingRole                                                       | 0x0001 |
| * NetworkName                                                       | 0x0002 |
| * PanId                                                             | 0x0003 |
| * ExtendedPanId                                                     | 0x0004 |
| * MeshLocalPrefix                                                   | 0x0005 |
| * OverrunCount                                                      | 0x0006 |
| * NeighborTableList                                                 | 0x0007 |
| * RouteTableList                                                    | 0x0008 |
| * PartitionId                                                       | 0x0009 |
| * Weighting                                                         | 0x000A |
| * DataVersion                                                       | 0x000B |
| * StableDataVersion                                                 | 0x000C |
| * LeaderRouterId                                                    | 0x000D |
| * DetachedRoleCount                                                 | 0x000E |
| * ChildRoleCount                                                    | 0x000F |
| * RouterRoleCount                                                   | 0x0010 |
| * LeaderRoleCount                                                   | 0x0011 |
| * AttachAttemptCount                                                | 0x0012 |
| * PartitionIdChangeCount                                            | 0x0013 |
| * BetterPartitionAttachAttemptCount                                 | 0x0014 |
| * ParentChangeCount                                                 | 0x0015 |
| * TxTotalCount                                                      | 0x0016 |
| * TxUnicastCount                                                    | 0x0017 |
| * TxBroadcastCount                                                  | 0x0018 |
| * TxAckRequestedCount                                               | 0x0019 |
| * TxAckedCount                                                      | 0x001A |
| * TxNoAckRequestedCount                                             | 0x001B |
| * TxDataCount                                                       | 0x001C |
| * TxDataPollCount                                                   | 0x001D |
| * TxBeaconCount                                                     | 0x001E |
| * TxBeaconRequestCount                                              | 0x001F |
| * TxOtherCount                                                      | 0x0020 |
| * TxRetryCount                                                      | 0x0021 |
| * TxDirectMaxRetryExpiryCount                                       | 0x0022 |
| * TxIndirectMaxRetryExpiryCount                                     | 0x0023 |
| * TxErrCcaCount                                                     | 0x0024 |
| * TxErrAbortCount                                                   | 0x0025 |
| * TxErrBusyChannelCount                                             | 0x0026 |
| * RxTotalCount                                                      | 0x0027 |
| * RxUnicastCount                                                    | 0x0028 |
| * RxBroadcastCount                                                  | 0x0029 |
| * RxDataCount                                                       | 0x002A |
| * RxDataPollCount                                                   | 0x002B |
| * RxBeaconCount                                                     | 0x002C |
| * RxBeaconRequestCount                                              | 0x002D |
| * RxOtherCount                                                      | 0x002E |
| * RxAddressFilteredCount                                            | 0x002F |
| * RxDestAddrFilteredCount                                           | 0x0030 |
| * RxDuplicatedCount                                                 | 0x0031 |
| * RxErrNoFrameCount                                                 | 0x0032 |
| * RxErrUnknownNeighborCount                                         | 0x0033 |
| * RxErrInvalidSrcAddrCount                                          | 0x0034 |
| * RxErrSecCount                                                     | 0x0035 |
| * RxErrFcsCount                                                     | 0x0036 |
| * RxErrOtherCount                                                   | 0x0037 |
| * ActiveTimestamp                                                   | 0x0038 |
| * PendingTimestamp                                                  | 0x0039 |
| * Delay                                                             | 0x003A |
| * SecurityPolicy                                                    | 0x003B |
| * ChannelMask                                                       | 0x003C |
| * OperationalDatasetComponents                                      | 0x003D |
| * ActiveNetworkFaultsList                                           | 0x003E |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * ConnectionStatus                                                  | 0x0000 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class ThreadNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    ThreadNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Event ConnectionStatus
 */
class ReadThreadNetworkDiagnosticsConnectionStatus : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsConnectionStatus()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "connection-status");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportThreadNetworkDiagnosticsConnectionStatus : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsConnectionStatus()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "connection-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Channel
 */
class ReadThreadNetworkDiagnosticsChannel : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChannel()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeChannelWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Channel response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Channel Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsChannel : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsChannel()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChannel() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RoutingRole
 */
class ReadThreadNetworkDiagnosticsRoutingRole : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRoutingRole()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "routing-role");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRoutingRoleWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RoutingRole response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RoutingRole Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRoutingRole : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRoutingRole()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "routing-role");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRoutingRole() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NetworkName
 */
class ReadThreadNetworkDiagnosticsNetworkName : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsNetworkName()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "network-name");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeNetworkNameWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.NetworkName response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics NetworkName Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsNetworkName : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsNetworkName()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "network-name");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsNetworkName() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PanId
 */
class ReadThreadNetworkDiagnosticsPanId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPanId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributePanIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PanId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PanId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsPanId : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsPanId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ExtendedPanId
 */
class ReadThreadNetworkDiagnosticsExtendedPanId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsExtendedPanId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "extended-pan-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeExtendedPanIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ExtendedPanId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ExtendedPanId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsExtendedPanId : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsExtendedPanId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "extended-pan-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsExtendedPanId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute MeshLocalPrefix
 */
class ReadThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsMeshLocalPrefix()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeMeshLocalPrefixWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.MeshLocalPrefix response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics MeshLocalPrefix Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsMeshLocalPrefix : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsMeshLocalPrefix()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "mesh-local-prefix");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsMeshLocalPrefix() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadThreadNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.OverrunCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute NeighborTableList
 */
class ReadThreadNetworkDiagnosticsNeighborTableList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsNeighborTableList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "neighbor-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeNeighborTableListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.NeighborTableList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics NeighborTableList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsNeighborTableList : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsNeighborTableList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "neighbor-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsNeighborTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouteTableList
 */
class ReadThreadNetworkDiagnosticsRouteTableList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRouteTableList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "route-table-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRouteTableListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RouteTableList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RouteTableList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRouteTableList : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRouteTableList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "route-table-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRouteTableList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionId
 */
class ReadThreadNetworkDiagnosticsPartitionId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPartitionId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributePartitionIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PartitionId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PartitionId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsPartitionId : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsPartitionId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "partition-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPartitionId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Weighting
 */
class ReadThreadNetworkDiagnosticsWeighting : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsWeighting()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "weighting");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeWeightingWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Weighting response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Weighting Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsWeighting : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsWeighting()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "weighting");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsWeighting() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DataVersion
 */
class ReadThreadNetworkDiagnosticsDataVersion : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDataVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeDataVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.DataVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics DataVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsDataVersion : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsDataVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute StableDataVersion
 */
class ReadThreadNetworkDiagnosticsStableDataVersion : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsStableDataVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "stable-data-version");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeStableDataVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.StableDataVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics StableDataVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsStableDataVersion : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsStableDataVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "stable-data-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsStableDataVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRouterId
 */
class ReadThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsLeaderRouterId()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-router-id");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeLeaderRouterIdWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.LeaderRouterId response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics LeaderRouterId Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsLeaderRouterId : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsLeaderRouterId()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "leader-router-id");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsLeaderRouterId() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute DetachedRoleCount
 */
class ReadThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDetachedRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "detached-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeDetachedRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.DetachedRoleCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics DetachedRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsDetachedRoleCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsDetachedRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "detached-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDetachedRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChildRoleCount
 */
class ReadThreadNetworkDiagnosticsChildRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChildRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "child-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeChildRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ChildRoleCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ChildRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsChildRoleCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsChildRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "child-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChildRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RouterRoleCount
 */
class ReadThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRouterRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "router-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRouterRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RouterRoleCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RouterRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRouterRoleCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRouterRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "router-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRouterRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute LeaderRoleCount
 */
class ReadThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsLeaderRoleCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "leader-role-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeLeaderRoleCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.LeaderRoleCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics LeaderRoleCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsLeaderRoleCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsLeaderRoleCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "leader-role-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsLeaderRoleCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAttachAttemptCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeAttachAttemptCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AttachAttemptCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AttachAttemptCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsAttachAttemptCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsAttachAttemptCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PartitionIdChangeCount
 */
class ReadThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPartitionIdChangeCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "partition-id-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributePartitionIdChangeCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PartitionIdChangeCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PartitionIdChangeCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsPartitionIdChangeCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsPartitionIdChangeCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "partition-id-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPartitionIdChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BetterPartitionAttachAttemptCount
 */
class ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeBetterPartitionAttachAttemptCountWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.BetterPartitionAttachAttemptCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics BetterPartitionAttachAttemptCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "better-partition-attach-attempt-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000014) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ParentChangeCount
 */
class ReadThreadNetworkDiagnosticsParentChangeCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsParentChangeCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "parent-change-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeParentChangeCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ParentChangeCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ParentChangeCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsParentChangeCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsParentChangeCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "parent-change-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsParentChangeCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000015) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxTotalCount
 */
class ReadThreadNetworkDiagnosticsTxTotalCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxTotalCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxTotalCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxTotalCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxTotalCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxTotalCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxTotalCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000016) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxUnicastCount
 */
class ReadThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxUnicastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxUnicastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxUnicastCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxUnicastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxUnicastCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxUnicastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBroadcastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxBroadcastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBroadcastCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBroadcastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxBroadcastCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxBroadcastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000018) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxAckRequestedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxAckRequestedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxAckRequestedCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxAckRequestedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxAckRequestedCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxAckRequestedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000019) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxAckedCount
 */
class ReadThreadNetworkDiagnosticsTxAckedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxAckedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-acked-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxAckedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxAckedCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxAckedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxAckedCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxAckedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-acked-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxAckedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxNoAckRequestedCount
 */
class ReadThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxNoAckRequestedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxNoAckRequestedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxNoAckRequestedCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxNoAckRequestedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxNoAckRequestedCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxNoAckRequestedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-no-ack-requested-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxNoAckRequestedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataCount
 */
class ReadThreadNetworkDiagnosticsTxDataCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDataCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxDataCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxDataCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDataCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxDataCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxDataCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDataPollCount
 */
class ReadThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDataPollCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxDataPollCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxDataPollCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDataPollCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxDataPollCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxDataPollCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBeaconCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxBeaconCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBeaconCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBeaconCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxBeaconCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxBeaconCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxBeaconRequestCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxBeaconRequestCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxBeaconRequestCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxBeaconRequestCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxBeaconRequestCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxBeaconRequestCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000001F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxOtherCount
 */
class ReadThreadNetworkDiagnosticsTxOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxOtherCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxOtherCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000020) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxRetryCount
 */
class ReadThreadNetworkDiagnosticsTxRetryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxRetryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-retry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxRetryCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxRetryCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxRetryCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxRetryCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxRetryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-retry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxRetryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000021) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxDirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeTxDirectMaxRetryExpiryCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.TxDirectMaxRetryExpiryCount response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics TxDirectMaxRetryExpiryCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-direct-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000022) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxIndirectMaxRetryExpiryCount
 */
class ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxIndirectMaxRetryExpiryCountWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxIndirectMaxRetryExpiryCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxIndirectMaxRetryExpiryCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-indirect-max-retry-expiry-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000023) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrCcaCount
 */
class ReadThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrCcaCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxErrCcaCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrCcaCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrCcaCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxErrCcaCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxErrCcaCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-cca-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrCcaCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000024) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrAbortCount
 */
class ReadThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrAbortCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxErrAbortCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrAbortCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrAbortCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxErrAbortCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxErrAbortCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-abort-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrAbortCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000025) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TxErrBusyChannelCount
 */
class ReadThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsTxErrBusyChannelCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeTxErrBusyChannelCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.TxErrBusyChannelCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics TxErrBusyChannelCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsTxErrBusyChannelCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsTxErrBusyChannelCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "tx-err-busy-channel-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsTxErrBusyChannelCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000026) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxTotalCount
 */
class ReadThreadNetworkDiagnosticsRxTotalCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxTotalCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-total-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxTotalCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxTotalCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxTotalCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxTotalCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxTotalCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-total-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxTotalCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000027) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxUnicastCount
 */
class ReadThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxUnicastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-unicast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxUnicastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxUnicastCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxUnicastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxUnicastCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxUnicastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-unicast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxUnicastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000028) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBroadcastCount
 */
class ReadThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBroadcastCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxBroadcastCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBroadcastCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBroadcastCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxBroadcastCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxBroadcastCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-broadcast-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBroadcastCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000029) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataCount
 */
class ReadThreadNetworkDiagnosticsRxDataCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDataCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxDataCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDataCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDataCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxDataCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxDataCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-data-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDataCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDataPollCount
 */
class ReadThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDataPollCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxDataPollCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDataPollCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDataPollCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxDataPollCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxDataPollCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-data-poll-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDataPollCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBeaconCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxBeaconCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBeaconCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBeaconCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxBeaconCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxBeaconCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-beacon-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBeaconCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxBeaconRequestCount
 */
class ReadThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxBeaconRequestCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxBeaconRequestCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxBeaconRequestCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxBeaconRequestCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxBeaconRequestCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxBeaconRequestCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-beacon-request-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxBeaconRequestCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxOtherCount
 */
class ReadThreadNetworkDiagnosticsRxOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxOtherCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxOtherCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxAddressFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxAddressFilteredCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000002F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxAddressFilteredCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxAddressFilteredCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxAddressFilteredCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxAddressFilteredCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxAddressFilteredCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-address-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxAddressFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000002F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDestAddrFilteredCount
 */
class ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeRxDestAddrFilteredCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxDestAddrFilteredCount response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDestAddrFilteredCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-dest-addr-filtered-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000030) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxDuplicatedCount
 */
class ReadThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxDuplicatedCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxDuplicatedCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxDuplicatedCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxDuplicatedCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxDuplicatedCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxDuplicatedCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-duplicated-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxDuplicatedCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000031) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrNoFrameCount
 */
class ReadThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrNoFrameCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxErrNoFrameCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrNoFrameCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrNoFrameCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxErrNoFrameCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxErrNoFrameCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-no-frame-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrNoFrameCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000032) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrUnknownNeighborCount
 */
class ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeRxErrUnknownNeighborCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxErrUnknownNeighborCount response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrUnknownNeighborCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-unknown-neighbor-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000033) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrInvalidSrcAddrCount
 */
class ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeRxErrInvalidSrcAddrCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.RxErrInvalidSrcAddrCount response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrInvalidSrcAddrCount Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-invalid-src-addr-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000034) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrSecCount
 */
class ReadThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrSecCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000035) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxErrSecCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrSecCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrSecCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxErrSecCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxErrSecCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-sec-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrSecCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000035) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrFcsCount
 */
class ReadThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrFcsCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxErrFcsCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrFcsCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrFcsCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxErrFcsCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxErrFcsCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-fcs-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrFcsCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000036) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute RxErrOtherCount
 */
class ReadThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsRxErrOtherCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rx-err-other-count");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeRxErrOtherCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.RxErrOtherCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics RxErrOtherCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsRxErrOtherCount : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsRxErrOtherCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rx-err-other-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsRxErrOtherCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000037) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveTimestamp
 */
class ReadThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsActiveTimestamp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeActiveTimestampWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ActiveTimestamp response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ActiveTimestamp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsActiveTimestamp : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsActiveTimestamp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsActiveTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000038) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PendingTimestamp
 */
class ReadThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsPendingTimestamp()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "pending-timestamp");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x00000039) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributePendingTimestampWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.PendingTimestamp response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics PendingTimestamp Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsPendingTimestamp : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsPendingTimestamp()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "pending-timestamp");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsPendingTimestamp() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x00000039) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Delay
 */
class ReadThreadNetworkDiagnosticsDelay : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsDelay()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "delay");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeDelayWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.Delay response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics Delay Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsDelay : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsDelay()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "delay");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsDelay() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityPolicy
 */
class ReadThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsSecurityPolicy()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "security-policy");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeSecurityPolicyWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.SecurityPolicy response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics SecurityPolicy Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsSecurityPolicy : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsSecurityPolicy()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "security-policy");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsSecurityPolicy() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelMask
 */
class ReadThreadNetworkDiagnosticsChannelMask : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsChannelMask()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-mask");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeChannelMaskWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ChannelMask response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ChannelMask Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsChannelMask : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsChannelMask()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-mask");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsChannelMask() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalDatasetComponents
 */
class ReadThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsOperationalDatasetComponents()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-dataset-components");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeOperationalDatasetComponentsWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.OperationalDatasetComponents response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics OperationalDatasetComponents Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsOperationalDatasetComponents : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsOperationalDatasetComponents()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operational-dataset-components");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsOperationalDatasetComponents() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveNetworkFaultsList
 */
class ReadThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsActiveNetworkFaultsList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-network-faults-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000003E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeActiveNetworkFaultsListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ActiveNetworkFaultsList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ActiveNetworkFaultsList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsActiveNetworkFaultsList : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsActiveNetworkFaultsList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-network-faults-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsActiveNetworkFaultsList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000003E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadThreadNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadThreadNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"ThreadNetworkDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "ThreadNetworkDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadThreadNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadThreadNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadThreadNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadThreadNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPThreadNetworkDiagnostics * cluster = [[CHIPThreadNetworkDiagnostics alloc] initWithDevice:device
                                                                                             endpoint:endpointId
                                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"ThreadNetworkDiagnostics.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "ThreadNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportThreadNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReportThreadNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportThreadNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000035) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster TimeFormatLocalization                                      | 0x002C |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * HourFormat                                                        | 0x0000 |
| * ActiveCalendarType                                                | 0x0001 |
| * SupportedCalendarTypes                                            | 0x0002 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute HourFormat
 */
class ReadTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    ReadTimeFormatLocalizationHourFormat()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "hour-format");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeHourFormatWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.HourFormat response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization HourFormat Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    WriteTimeFormatLocalizationHourFormat()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "hour-format");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeHourFormatWithValue:value
                                 completionHandler:^(NSError * _Nullable error) {
                                     CHIP_ERROR err = CHIP_NO_ERROR;
                                     err = [CHIPError errorToCHIPErrorCode:error];

                                     ChipLogError(chipTool, "TimeFormatLocalization HourFormat Error: %s", chip::ErrorStr(err));
                                     SetCommandExitStatus(err);
                                 }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTimeFormatLocalizationHourFormat : public ModelCommand {
public:
    ReportTimeFormatLocalizationHourFormat()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "hour-format");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTimeFormatLocalizationHourFormat() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ActiveCalendarType
 */
class ReadTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    ReadTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "active-calendar-type");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeActiveCalendarTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.ActiveCalendarType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization ActiveCalendarType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    WriteTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "active-calendar-type");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) WriteAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeActiveCalendarTypeWithValue:value
                                         completionHandler:^(NSError * _Nullable error) {
                                             CHIP_ERROR err = CHIP_NO_ERROR;
                                             err = [CHIPError errorToCHIPErrorCode:error];

                                             ChipLogError(chipTool, "TimeFormatLocalization ActiveCalendarType Error: %s",
                                                 chip::ErrorStr(err));
                                             SetCommandExitStatus(err);
                                         }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportTimeFormatLocalizationActiveCalendarType : public ModelCommand {
public:
    ReportTimeFormatLocalizationActiveCalendarType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "active-calendar-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTimeFormatLocalizationActiveCalendarType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SupportedCalendarTypes
 */
class ReadTimeFormatLocalizationSupportedCalendarTypes : public ModelCommand {
public:
    ReadTimeFormatLocalizationSupportedCalendarTypes()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "supported-calendar-types");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationSupportedCalendarTypes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeSupportedCalendarTypesWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.SupportedCalendarTypes response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization SupportedCalendarTypes Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTimeFormatLocalizationSupportedCalendarTypes : public ModelCommand {
public:
    ReportTimeFormatLocalizationSupportedCalendarTypes()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "supported-calendar-types");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTimeFormatLocalizationSupportedCalendarTypes() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadTimeFormatLocalizationServerGeneratedCommandList : public ModelCommand {
public:
    ReadTimeFormatLocalizationServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TimeFormatLocalization.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TimeFormatLocalization ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportTimeFormatLocalizationServerGeneratedCommandList : public ModelCommand {
public:
    ReportTimeFormatLocalizationServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTimeFormatLocalizationServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadTimeFormatLocalizationClientGeneratedCommandList : public ModelCommand {
public:
    ReadTimeFormatLocalizationClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"TimeFormatLocalization.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "TimeFormatLocalization ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportTimeFormatLocalizationClientGeneratedCommandList : public ModelCommand {
public:
    ReportTimeFormatLocalizationClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTimeFormatLocalizationClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadTimeFormatLocalizationClusterRevision : public ModelCommand {
public:
    ReadTimeFormatLocalizationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadTimeFormatLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPTimeFormatLocalization * cluster = [[CHIPTimeFormatLocalization alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"TimeFormatLocalization.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "TimeFormatLocalization ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportTimeFormatLocalizationClusterRevision : public ModelCommand {
public:
    ReportTimeFormatLocalizationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportTimeFormatLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002C) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UnitLocalization                                            | 0x002D |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * TemperatureUnit                                                   | 0x0000 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute TemperatureUnit
 */
class ReadUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    ReadUnitLocalizationTemperatureUnit()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "temperature-unit");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeTemperatureUnitWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.TemperatureUnit response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization TemperatureUnit Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    WriteUnitLocalizationTemperatureUnit()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "temperature-unit");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) WriteAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeTemperatureUnitWithValue:value
                                      completionHandler:^(NSError * _Nullable error) {
                                          CHIP_ERROR err = CHIP_NO_ERROR;
                                          err = [CHIPError errorToCHIPErrorCode:error];

                                          ChipLogError(chipTool, "UnitLocalization TemperatureUnit Error: %s", chip::ErrorStr(err));
                                          SetCommandExitStatus(err);
                                      }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportUnitLocalizationTemperatureUnit : public ModelCommand {
public:
    ReportUnitLocalizationTemperatureUnit()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "temperature-unit");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUnitLocalizationTemperatureUnit() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadUnitLocalizationAttributeList : public ModelCommand {
public:
    ReadUnitLocalizationAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportUnitLocalizationAttributeList : public ModelCommand {
public:
    ReportUnitLocalizationAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUnitLocalizationAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadUnitLocalizationFeatureMap : public ModelCommand {
public:
    ReadUnitLocalizationFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportUnitLocalizationFeatureMap : public ModelCommand {
public:
    ReportUnitLocalizationFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUnitLocalizationFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadUnitLocalizationClusterRevision : public ModelCommand {
public:
    ReadUnitLocalizationClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUnitLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUnitLocalization * cluster = [[CHIPUnitLocalization alloc] initWithDevice:device
                                                                             endpoint:endpointId
                                                                                queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UnitLocalization.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UnitLocalization ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportUnitLocalizationClusterRevision : public ModelCommand {
public:
    ReportUnitLocalizationClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUnitLocalizationClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x0000002D) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster UserLabel                                                   | 0x0041 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * LabelList                                                         | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute LabelList
 */
class ReadUserLabelLabelList : public ModelCommand {
public:
    ReadUserLabelLabelList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "label-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeLabelListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.LabelList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel LabelList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportUserLabelLabelList : public ModelCommand {
public:
    ReportUserLabelLabelList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "label-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUserLabelLabelList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadUserLabelServerGeneratedCommandList : public ModelCommand {
public:
    ReadUserLabelServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"UserLabel.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "UserLabel ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportUserLabelServerGeneratedCommandList : public ModelCommand {
public:
    ReportUserLabelServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUserLabelServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadUserLabelClientGeneratedCommandList : public ModelCommand {
public:
    ReadUserLabelClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"UserLabel.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "UserLabel ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportUserLabelClientGeneratedCommandList : public ModelCommand {
public:
    ReportUserLabelClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUserLabelClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadUserLabelClusterRevision : public ModelCommand {
public:
    ReadUserLabelClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPUserLabel * cluster = [[CHIPUserLabel alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"UserLabel.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "UserLabel ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportUserLabelClusterRevision : public ModelCommand {
public:
    ReportUserLabelClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportUserLabelClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000041) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WakeOnLan                                                   | 0x0503 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * WakeOnLanMacAddress                                               | 0x0000 |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Attribute WakeOnLanMacAddress
 */
class ReadWakeOnLanWakeOnLanMacAddress : public ModelCommand {
public:
    ReadWakeOnLanWakeOnLanMacAddress()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wake-on-lan-mac-address");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanWakeOnLanMacAddress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeWakeOnLanMacAddressWithCompletionHandler:^(NSString * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.WakeOnLanMacAddress response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan WakeOnLanMacAddress Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWakeOnLanWakeOnLanMacAddress : public ModelCommand {
public:
    ReportWakeOnLanWakeOnLanMacAddress()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wake-on-lan-mac-address");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanWakeOnLanMacAddress() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadWakeOnLanServerGeneratedCommandList : public ModelCommand {
public:
    ReadWakeOnLanServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WakeOnLan.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WakeOnLan ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWakeOnLanServerGeneratedCommandList : public ModelCommand {
public:
    ReportWakeOnLanServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadWakeOnLanClientGeneratedCommandList : public ModelCommand {
public:
    ReadWakeOnLanClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WakeOnLan.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WakeOnLan ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWakeOnLanClientGeneratedCommandList : public ModelCommand {
public:
    ReportWakeOnLanClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWakeOnLanAttributeList : public ModelCommand {
public:
    ReadWakeOnLanAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWakeOnLanAttributeList : public ModelCommand {
public:
    ReportWakeOnLanAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWakeOnLanClusterRevision : public ModelCommand {
public:
    ReadWakeOnLanClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWakeOnLan * cluster = [[CHIPWakeOnLan alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WakeOnLan.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WakeOnLan ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWakeOnLanClusterRevision : public ModelCommand {
public:
    ReportWakeOnLanClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWakeOnLanClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000503) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WiFiNetworkDiagnostics                                      | 0x0036 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * ResetCounts                                                       |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Bssid                                                             | 0x0000 |
| * SecurityType                                                      | 0x0001 |
| * WiFiVersion                                                       | 0x0002 |
| * ChannelNumber                                                     | 0x0003 |
| * Rssi                                                              | 0x0004 |
| * BeaconLostCount                                                   | 0x0005 |
| * BeaconRxCount                                                     | 0x0006 |
| * PacketMulticastRxCount                                            | 0x0007 |
| * PacketMulticastTxCount                                            | 0x0008 |
| * PacketUnicastRxCount                                              | 0x0009 |
| * PacketUnicastTxCount                                              | 0x000A |
| * CurrentMaxRate                                                    | 0x000B |
| * OverrunCount                                                      | 0x000C |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
| * Disconnection                                                     | 0x0000 |
| * AssociationFailure                                                | 0x0001 |
| * ConnectionStatus                                                  | 0x0002 |
\*----------------------------------------------------------------------------*/

/*
 * Command ResetCounts
 */
class WiFiNetworkDiagnosticsResetCounts : public ModelCommand {
public:
    WiFiNetworkDiagnosticsResetCounts()
        : ModelCommand("reset-counts")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster resetCountsWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Event Disconnection
 */
class ReadWiFiNetworkDiagnosticsDisconnection : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsDisconnection()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "disconnection");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsDisconnection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportWiFiNetworkDiagnosticsDisconnection : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsDisconnection()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "disconnection");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsDisconnection() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportEvent (0x00000000) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event AssociationFailure
 */
class ReadWiFiNetworkDiagnosticsAssociationFailure : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsAssociationFailure()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "association-failure");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAssociationFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportWiFiNetworkDiagnosticsAssociationFailure : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsAssociationFailure()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "association-failure");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsAssociationFailure() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportEvent (0x00000001) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};
/*
 * Event ConnectionStatus
 */
class ReadWiFiNetworkDiagnosticsConnectionStatus : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsConnectionStatus()
        : ModelCommand("read-event")
    {
        AddArgument("event-name", "connection-status");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }
};

class ReportWiFiNetworkDiagnosticsConnectionStatus : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsConnectionStatus()
        : ModelCommand("subscribe-event")
    {
        AddArgument("event-name", "connection-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsConnectionStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportEvent (0x00000002) on endpoint %" PRIu16, endpointId);
        SetCommandExitStatus(CHIP_ERROR_NOT_IMPLEMENTED);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Bssid
 */
class ReadWiFiNetworkDiagnosticsBssid : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBssid()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "bssid");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeBssidWithCompletionHandler:^(NSData * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.Bssid response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics Bssid Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsBssid : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsBssid()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "bssid");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBssid() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SecurityType
 */
class ReadWiFiNetworkDiagnosticsSecurityType : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsSecurityType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "security-type");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeSecurityTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.SecurityType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics SecurityType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsSecurityType : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsSecurityType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "security-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsSecurityType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000001) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute WiFiVersion
 */
class ReadWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsWiFiVersion()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "wi-fi-version");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeWiFiVersionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.WiFiVersion response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics WiFiVersion Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsWiFiVersion : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsWiFiVersion()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "wi-fi-version");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsWiFiVersion() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000002) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ChannelNumber
 */
class ReadWiFiNetworkDiagnosticsChannelNumber : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsChannelNumber()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "channel-number");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeChannelNumberWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.ChannelNumber response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics ChannelNumber Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsChannelNumber : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsChannelNumber()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "channel-number");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsChannelNumber() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Rssi
 */
class ReadWiFiNetworkDiagnosticsRssi : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsRssi()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "rssi");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeRssiWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.Rssi response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics Rssi Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsRssi : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsRssi()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "rssi");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsRssi() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconLostCount
 */
class ReadWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBeaconLostCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-lost-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeBeaconLostCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.BeaconLostCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics BeaconLostCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsBeaconLostCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsBeaconLostCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "beacon-lost-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBeaconLostCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000005) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute BeaconRxCount
 */
class ReadWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsBeaconRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "beacon-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeBeaconRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.BeaconRxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics BeaconRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsBeaconRxCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsBeaconRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "beacon-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsBeaconRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000006) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributePacketMulticastRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketMulticastRxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketMulticastRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsPacketMulticastRxCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsPacketMulticastRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-multicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketMulticastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketMulticastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketMulticastTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributePacketMulticastTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketMulticastTxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketMulticastTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsPacketMulticastTxCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsPacketMulticastTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-multicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketMulticastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastRxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastRxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributePacketUnicastRxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketUnicastRxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketUnicastRxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsPacketUnicastRxCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsPacketUnicastRxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-unicast-rx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketUnicastRxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute PacketUnicastTxCount
 */
class ReadWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsPacketUnicastTxCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributePacketUnicastTxCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.PacketUnicastTxCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics PacketUnicastTxCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsPacketUnicastTxCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsPacketUnicastTxCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "packet-unicast-tx-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsPacketUnicastTxCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentMaxRate
 */
class ReadWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsCurrentMaxRate()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-max-rate");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeCurrentMaxRateWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.CurrentMaxRate response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics CurrentMaxRate Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsCurrentMaxRate : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsCurrentMaxRate()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-max-rate");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsCurrentMaxRate() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OverrunCount
 */
class ReadWiFiNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsOverrunCount()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "overrun-count");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeOverrunCountWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.OverrunCount response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics OverrunCount Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsOverrunCount : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsOverrunCount()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "overrun-count");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsOverrunCount() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadWiFiNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WiFiNetworkDiagnostics.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WiFiNetworkDiagnostics ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsServerGeneratedCommandList : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadWiFiNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WiFiNetworkDiagnostics.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WiFiNetworkDiagnostics ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsClientGeneratedCommandList : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWiFiNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsAttributeList : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWiFiNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsFeatureMap : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWiFiNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReadWiFiNetworkDiagnosticsClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWiFiNetworkDiagnostics * cluster = [[CHIPWiFiNetworkDiagnostics alloc] initWithDevice:device
                                                                                         endpoint:endpointId
                                                                                            queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WiFiNetworkDiagnostics.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WiFiNetworkDiagnostics ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWiFiNetworkDiagnosticsClusterRevision : public ModelCommand {
public:
    ReportWiFiNetworkDiagnosticsClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWiFiNetworkDiagnosticsClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000036) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Cluster WindowCovering                                              | 0x0102 |
|------------------------------------------------------------------------------|
| Commands:                                                           |        |
| * DownOrClose                                                       |   0x01 |
| * GoToLiftPercentage                                                |   0x05 |
| * GoToLiftValue                                                     |   0x04 |
| * GoToTiltPercentage                                                |   0x08 |
| * GoToTiltValue                                                     |   0x07 |
| * StopMotion                                                        |   0x02 |
| * UpOrOpen                                                          |   0x00 |
|------------------------------------------------------------------------------|
| Attributes:                                                         |        |
| * Type                                                              | 0x0000 |
| * CurrentPositionLift                                               | 0x0003 |
| * CurrentPositionTilt                                               | 0x0004 |
| * ConfigStatus                                                      | 0x0007 |
| * CurrentPositionLiftPercentage                                     | 0x0008 |
| * CurrentPositionTiltPercentage                                     | 0x0009 |
| * OperationalStatus                                                 | 0x000A |
| * TargetPositionLiftPercent100ths                                   | 0x000B |
| * TargetPositionTiltPercent100ths                                   | 0x000C |
| * EndProductType                                                    | 0x000D |
| * CurrentPositionLiftPercent100ths                                  | 0x000E |
| * CurrentPositionTiltPercent100ths                                  | 0x000F |
| * InstalledOpenLimitLift                                            | 0x0010 |
| * InstalledClosedLimitLift                                          | 0x0011 |
| * InstalledOpenLimitTilt                                            | 0x0012 |
| * InstalledClosedLimitTilt                                          | 0x0013 |
| * Mode                                                              | 0x0017 |
| * SafetyStatus                                                      | 0x001A |
| * ServerGeneratedCommandList                                        | 0xFFF8 |
| * ClientGeneratedCommandList                                        | 0xFFF9 |
| * AttributeList                                                     | 0xFFFB |
| * FeatureMap                                                        | 0xFFFC |
| * ClusterRevision                                                   | 0xFFFD |
|------------------------------------------------------------------------------|
| Events:                                                             |        |
\*----------------------------------------------------------------------------*/

/*
 * Command DownOrClose
 */
class WindowCoveringDownOrClose : public ModelCommand {
public:
    WindowCoveringDownOrClose()
        : ModelCommand("down-or-close")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000001) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster downOrCloseWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command GoToLiftPercentage
 */
class WindowCoveringGoToLiftPercentage : public ModelCommand {
public:
    WindowCoveringGoToLiftPercentage()
        : ModelCommand("go-to-lift-percentage")
    {
        AddArgument("LiftPercentageValue", 0, UINT8_MAX, &mLiftPercentageValue);
        AddArgument("LiftPercent100thsValue", 0, UINT16_MAX, &mLiftPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000005) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftPercentageParams alloc] init];
        params.liftPercentageValue = [NSNumber numberWithUnsignedChar:mLiftPercentageValue];
        params.liftPercent100thsValue = [NSNumber numberWithUnsignedShort:mLiftPercent100thsValue];
        [cluster goToLiftPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    chip::Percent mLiftPercentageValue;
    chip::Percent100ths mLiftPercent100thsValue;
};

/*
 * Command GoToLiftValue
 */
class WindowCoveringGoToLiftValue : public ModelCommand {
public:
    WindowCoveringGoToLiftValue()
        : ModelCommand("go-to-lift-value")
    {
        AddArgument("LiftValue", 0, UINT16_MAX, &mLiftValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPWindowCoveringClusterGoToLiftValueParams alloc] init];
        params.liftValue = [NSNumber numberWithUnsignedShort:mLiftValue];
        [cluster goToLiftValueWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mLiftValue;
};

/*
 * Command GoToTiltPercentage
 */
class WindowCoveringGoToTiltPercentage : public ModelCommand {
public:
    WindowCoveringGoToTiltPercentage()
        : ModelCommand("go-to-tilt-percentage")
    {
        AddArgument("TiltPercentageValue", 0, UINT8_MAX, &mTiltPercentageValue);
        AddArgument("TiltPercent100thsValue", 0, UINT16_MAX, &mTiltPercent100thsValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltPercentageParams alloc] init];
        params.tiltPercentageValue = [NSNumber numberWithUnsignedChar:mTiltPercentageValue];
        params.tiltPercent100thsValue = [NSNumber numberWithUnsignedShort:mTiltPercent100thsValue];
        [cluster goToTiltPercentageWithParams:params
                            completionHandler:^(NSError * _Nullable error) {
                                CHIP_ERROR err = CHIP_NO_ERROR;
                                err = [CHIPError errorToCHIPErrorCode:error];

                                ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                                SetCommandExitStatus(err);
                            }];

        return CHIP_NO_ERROR;
    }

private:
    chip::Percent mTiltPercentageValue;
    chip::Percent100ths mTiltPercent100thsValue;
};

/*
 * Command GoToTiltValue
 */
class WindowCoveringGoToTiltValue : public ModelCommand {
public:
    WindowCoveringGoToTiltValue()
        : ModelCommand("go-to-tilt-value")
    {
        AddArgument("TiltValue", 0, UINT16_MAX, &mTiltValue);
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        __auto_type * params = [[CHIPWindowCoveringClusterGoToTiltValueParams alloc] init];
        params.tiltValue = [NSNumber numberWithUnsignedShort:mTiltValue];
        [cluster goToTiltValueWithParams:params
                       completionHandler:^(NSError * _Nullable error) {
                           CHIP_ERROR err = CHIP_NO_ERROR;
                           err = [CHIPError errorToCHIPErrorCode:error];

                           ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
                           SetCommandExitStatus(err);
                       }];

        return CHIP_NO_ERROR;
    }

private:
    uint16_t mTiltValue;
};

/*
 * Command StopMotion
 */
class WindowCoveringStopMotion : public ModelCommand {
public:
    WindowCoveringStopMotion()
        : ModelCommand("stop-motion")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000002) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster stopMotionWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Command UpOrOpen
 */
class WindowCoveringUpOrOpen : public ModelCommand {
public:
    WindowCoveringUpOrOpen()
        : ModelCommand("up-or-open")
    {
        ModelCommand::AddArguments();
    }

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) command (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster upOrOpenWithCompletionHandler:^(NSError * _Nullable error) {
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogProgress(chipTool, "Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];

        return CHIP_NO_ERROR;
    }

private:
};

/*
 * Attribute Type
 */
class ReadWindowCoveringType : public ModelCommand {
public:
    ReadWindowCoveringType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.Type response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering Type Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringType : public ModelCommand {
public:
    ReportWindowCoveringType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000000) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLift
 */
class ReadWindowCoveringCurrentPositionLift : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLift response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLift Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringCurrentPositionLift : public ModelCommand {
public:
    ReportWindowCoveringCurrentPositionLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000003) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTilt
 */
class ReadWindowCoveringCurrentPositionTilt : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTilt response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTilt Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringCurrentPositionTilt : public ModelCommand {
public:
    ReportWindowCoveringCurrentPositionTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000004) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ConfigStatus
 */
class ReadWindowCoveringConfigStatus : public ModelCommand {
public:
    ReadWindowCoveringConfigStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "config-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeConfigStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.ConfigStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering ConfigStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringConfigStatus : public ModelCommand {
public:
    ReportWindowCoveringConfigStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "config-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringConfigStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000007) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercentage
 */
class ReadWindowCoveringCurrentPositionLiftPercentage : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLiftPercentage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionLiftPercentageWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLiftPercentage response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLiftPercentage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringCurrentPositionLiftPercentage : public ModelCommand {
public:
    ReportWindowCoveringCurrentPositionLiftPercentage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLiftPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000008) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercentage
 */
class ReadWindowCoveringCurrentPositionTiltPercentage : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTiltPercentage()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionTiltPercentageWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTiltPercentage response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTiltPercentage Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringCurrentPositionTiltPercentage : public ModelCommand {
public:
    ReportWindowCoveringCurrentPositionTiltPercentage()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt-percentage");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTiltPercentage() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000009) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute OperationalStatus
 */
class ReadWindowCoveringOperationalStatus : public ModelCommand {
public:
    ReadWindowCoveringOperationalStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "operational-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeOperationalStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.OperationalStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering OperationalStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringOperationalStatus : public ModelCommand {
public:
    ReportWindowCoveringOperationalStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "operational-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringOperationalStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionLiftPercent100ths
 */
class ReadWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringTargetPositionLiftPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeTargetPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.TargetPositionLiftPercent100ths response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering TargetPositionLiftPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringTargetPositionLiftPercent100ths : public ModelCommand {
public:
    ReportWindowCoveringTargetPositionLiftPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringTargetPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000B) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute TargetPositionTiltPercent100ths
 */
class ReadWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringTargetPositionTiltPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeTargetPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.TargetPositionTiltPercent100ths response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering TargetPositionTiltPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringTargetPositionTiltPercent100ths : public ModelCommand {
public:
    ReportWindowCoveringTargetPositionTiltPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "target-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringTargetPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000C) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute EndProductType
 */
class ReadWindowCoveringEndProductType : public ModelCommand {
public:
    ReadWindowCoveringEndProductType()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "end-product-type");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeEndProductTypeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.EndProductType response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering EndProductType Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringEndProductType : public ModelCommand {
public:
    ReportWindowCoveringEndProductType()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "end-product-type");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringEndProductType() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000D) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionLiftPercent100ths
 */
class ReadWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionLiftPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionLiftPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionLiftPercent100ths response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionLiftPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringCurrentPositionLiftPercent100ths : public ModelCommand {
public:
    ReportWindowCoveringCurrentPositionLiftPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-lift-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionLiftPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000E) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute CurrentPositionTiltPercent100ths
 */
class ReadWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand {
public:
    ReadWindowCoveringCurrentPositionTiltPercent100ths()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeCurrentPositionTiltPercent100thsWithCompletionHandler:^(
            NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.CurrentPositionTiltPercent100ths response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering CurrentPositionTiltPercent100ths Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringCurrentPositionTiltPercent100ths : public ModelCommand {
public:
    ReportWindowCoveringCurrentPositionTiltPercent100ths()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "current-position-tilt-percent100ths");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringCurrentPositionTiltPercent100ths() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000000F) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitLift
 */
class ReadWindowCoveringInstalledOpenLimitLift : public ModelCommand {
public:
    ReadWindowCoveringInstalledOpenLimitLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInstalledOpenLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.InstalledOpenLimitLift response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering InstalledOpenLimitLift Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringInstalledOpenLimitLift : public ModelCommand {
public:
    ReportWindowCoveringInstalledOpenLimitLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-open-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledOpenLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000010) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitLift
 */
class ReadWindowCoveringInstalledClosedLimitLift : public ModelCommand {
public:
    ReadWindowCoveringInstalledClosedLimitLift()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeInstalledClosedLimitLiftWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.InstalledClosedLimitLift response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering InstalledClosedLimitLift Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringInstalledClosedLimitLift : public ModelCommand {
public:
    ReportWindowCoveringInstalledClosedLimitLift()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-closed-limit-lift");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledClosedLimitLift() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000011) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledOpenLimitTilt
 */
class ReadWindowCoveringInstalledOpenLimitTilt : public ModelCommand {
public:
    ReadWindowCoveringInstalledOpenLimitTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeInstalledOpenLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.InstalledOpenLimitTilt response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering InstalledOpenLimitTilt Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringInstalledOpenLimitTilt : public ModelCommand {
public:
    ReportWindowCoveringInstalledOpenLimitTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-open-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledOpenLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000012) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute InstalledClosedLimitTilt
 */
class ReadWindowCoveringInstalledClosedLimitTilt : public ModelCommand {
public:
    ReadWindowCoveringInstalledClosedLimitTilt()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeInstalledClosedLimitTiltWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.InstalledClosedLimitTilt response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering InstalledClosedLimitTilt Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringInstalledClosedLimitTilt : public ModelCommand {
public:
    ReportWindowCoveringInstalledClosedLimitTilt()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "installed-closed-limit-tilt");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringInstalledClosedLimitTilt() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000013) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute Mode
 */
class ReadWindowCoveringMode : public ModelCommand {
public:
    ReadWindowCoveringMode()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "mode");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeModeWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.Mode response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering Mode Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class WriteWindowCoveringMode : public ModelCommand {
public:
    WriteWindowCoveringMode()
        : ModelCommand("write")
    {
        AddArgument("attr-name", "mode");
        AddArgument("attr-value", 0, UINT8_MAX, &mValue);
        ModelCommand::AddArguments();
    }

    ~WriteWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) WriteAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        AddArgument("attr-value", 0, UINT8_MAX, &mValue);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        NSNumber * _Nonnull value = [NSNumber numberWithUnsignedChar:mValue];
        [cluster writeAttributeModeWithValue:value
                           completionHandler:^(NSError * _Nullable error) {
                               CHIP_ERROR err = CHIP_NO_ERROR;
                               err = [CHIPError errorToCHIPErrorCode:error];

                               ChipLogError(chipTool, "WindowCovering Mode Error: %s", chip::ErrorStr(err));
                               SetCommandExitStatus(err);
                           }];
        return CHIP_NO_ERROR;
    }

private:
    uint8_t mValue;
};

class ReportWindowCoveringMode : public ModelCommand {
public:
    ReportWindowCoveringMode()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "mode");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringMode() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x00000017) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute SafetyStatus
 */
class ReadWindowCoveringSafetyStatus : public ModelCommand {
public:
    ReadWindowCoveringSafetyStatus()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "safety-status");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeSafetyStatusWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.SafetyStatus response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering SafetyStatus Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringSafetyStatus : public ModelCommand {
public:
    ReportWindowCoveringSafetyStatus()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "safety-status");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringSafetyStatus() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000001A) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ServerGeneratedCommandList
 */
class ReadWindowCoveringServerGeneratedCommandList : public ModelCommand {
public:
    ReadWindowCoveringServerGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "server-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeServerGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.ServerGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering ServerGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringServerGeneratedCommandList : public ModelCommand {
public:
    ReportWindowCoveringServerGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "server-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringServerGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFF8) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClientGeneratedCommandList
 */
class ReadWindowCoveringClientGeneratedCommandList : public ModelCommand {
public:
    ReadWindowCoveringClientGeneratedCommandList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "client-generated-command-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster
            readAttributeClientGeneratedCommandListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
                NSLog(@"WindowCovering.ClientGeneratedCommandList response %@", [value description]);
                CHIP_ERROR err = CHIP_NO_ERROR;
                err = [CHIPError errorToCHIPErrorCode:error];

                ChipLogError(chipTool, "WindowCovering ClientGeneratedCommandList Error: %s", chip::ErrorStr(err));
                SetCommandExitStatus(err);
            }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringClientGeneratedCommandList : public ModelCommand {
public:
    ReportWindowCoveringClientGeneratedCommandList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "client-generated-command-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringClientGeneratedCommandList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFF9) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute AttributeList
 */
class ReadWindowCoveringAttributeList : public ModelCommand {
public:
    ReadWindowCoveringAttributeList()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "attribute-list");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeAttributeListWithCompletionHandler:^(NSArray * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.AttributeList response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering AttributeList Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringAttributeList : public ModelCommand {
public:
    ReportWindowCoveringAttributeList()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "attribute-list");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringAttributeList() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFB) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute FeatureMap
 */
class ReadWindowCoveringFeatureMap : public ModelCommand {
public:
    ReadWindowCoveringFeatureMap()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "feature-map");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeFeatureMapWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.FeatureMap response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering FeatureMap Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringFeatureMap : public ModelCommand {
public:
    ReportWindowCoveringFeatureMap()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "feature-map");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringFeatureMap() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFC) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*
 * Attribute ClusterRevision
 */
class ReadWindowCoveringClusterRevision : public ModelCommand {
public:
    ReadWindowCoveringClusterRevision()
        : ModelCommand("read")
    {
        AddArgument("attr-name", "cluster-revision");
        ModelCommand::AddArguments();
    }

    ~ReadWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReadAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        dispatch_queue_t callbackQueue = dispatch_queue_create("com.chip.command", DISPATCH_QUEUE_SERIAL);
        CHIPWindowCovering * cluster = [[CHIPWindowCovering alloc] initWithDevice:device endpoint:endpointId queue:callbackQueue];

        [cluster readAttributeClusterRevisionWithCompletionHandler:^(NSNumber * _Nullable value, NSError * _Nullable error) {
            NSLog(@"WindowCovering.ClusterRevision response %@", [value description]);
            CHIP_ERROR err = CHIP_NO_ERROR;
            err = [CHIPError errorToCHIPErrorCode:error];

            ChipLogError(chipTool, "WindowCovering ClusterRevision Error: %s", chip::ErrorStr(err));
            SetCommandExitStatus(err);
        }];
        return CHIP_NO_ERROR;
    }
};

class ReportWindowCoveringClusterRevision : public ModelCommand {
public:
    ReportWindowCoveringClusterRevision()
        : ModelCommand("subscribe")
    {
        AddArgument("attr-name", "cluster-revision");
        AddArgument("min-interval", 0, UINT16_MAX, &mMinInterval);
        AddArgument("max-interval", 0, UINT16_MAX, &mMaxInterval);
        AddArgument("wait", 0, 1, &mWait);
        ModelCommand::AddArguments();
    }

    ~ReportWindowCoveringClusterRevision() {}

    CHIP_ERROR SendCommand(CHIPDevice * device, chip::EndpointId endpointId) override
    {
        ChipLogProgress(chipTool, "Sending cluster (0x00000102) ReportAttribute (0x0000FFFD) on endpoint %" PRIu16, endpointId);

        return CHIP_ERROR_NOT_IMPLEMENTED;
    }

    chip::System::Clock::Timeout GetWaitDuration() const override
    {
        return chip::System::Clock::Seconds16(mWait ? UINT16_MAX : 10);
    }

private:
    uint16_t mMinInterval;
    uint16_t mMaxInterval;
    bool mWait;
};

/*----------------------------------------------------------------------------*\
| Register all Clusters commands                                               |
\*----------------------------------------------------------------------------*/
void registerClusterAccessControl(Commands & commands)
{
    const char * clusterName = "AccessControl";

    commands_list clusterCommands = {
        make_unique<ReadAccessControlAcl>(), //
        make_unique<ReportAccessControlAcl>(), //
        make_unique<ReadAccessControlExtension>(), //
        make_unique<ReportAccessControlExtension>(), //
        make_unique<ReadAccessControlServerGeneratedCommandList>(), //
        make_unique<ReportAccessControlServerGeneratedCommandList>(), //
        make_unique<ReadAccessControlClientGeneratedCommandList>(), //
        make_unique<ReportAccessControlClientGeneratedCommandList>(), //
        make_unique<ReadAccessControlAttributeList>(), //
        make_unique<ReportAccessControlAttributeList>(), //
        make_unique<ReadAccessControlClusterRevision>(), //
        make_unique<ReportAccessControlClusterRevision>(), //
        make_unique<ReadAccessControlAccessControlEntryChanged>(), //
        make_unique<ReportAccessControlAccessControlEntryChanged>(), //
        make_unique<ReadAccessControlAccessControlExtensionChanged>(), //
        make_unique<ReportAccessControlAccessControlExtensionChanged>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAccountLogin(Commands & commands)
{
    const char * clusterName = "AccountLogin";

    commands_list clusterCommands = {
        make_unique<AccountLoginGetSetupPINRequest>(), //
        make_unique<AccountLoginLoginRequest>(), //
        make_unique<AccountLoginLogoutRequest>(), //
        make_unique<ReadAccountLoginServerGeneratedCommandList>(), //
        make_unique<ReportAccountLoginServerGeneratedCommandList>(), //
        make_unique<ReadAccountLoginClientGeneratedCommandList>(), //
        make_unique<ReportAccountLoginClientGeneratedCommandList>(), //
        make_unique<ReadAccountLoginAttributeList>(), //
        make_unique<ReportAccountLoginAttributeList>(), //
        make_unique<ReadAccountLoginClusterRevision>(), //
        make_unique<ReportAccountLoginClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAdministratorCommissioning(Commands & commands)
{
    const char * clusterName = "AdministratorCommissioning";

    commands_list clusterCommands = {
        make_unique<AdministratorCommissioningOpenBasicCommissioningWindow>(), //
        make_unique<AdministratorCommissioningOpenCommissioningWindow>(), //
        make_unique<AdministratorCommissioningRevokeCommissioning>(), //
        make_unique<ReadAdministratorCommissioningWindowStatus>(), //
        make_unique<ReportAdministratorCommissioningWindowStatus>(), //
        make_unique<ReadAdministratorCommissioningAdminFabricIndex>(), //
        make_unique<ReportAdministratorCommissioningAdminFabricIndex>(), //
        make_unique<ReadAdministratorCommissioningAdminVendorId>(), //
        make_unique<ReportAdministratorCommissioningAdminVendorId>(), //
        make_unique<ReadAdministratorCommissioningServerGeneratedCommandList>(), //
        make_unique<ReportAdministratorCommissioningServerGeneratedCommandList>(), //
        make_unique<ReadAdministratorCommissioningClientGeneratedCommandList>(), //
        make_unique<ReportAdministratorCommissioningClientGeneratedCommandList>(), //
        make_unique<ReadAdministratorCommissioningAttributeList>(), //
        make_unique<ReportAdministratorCommissioningAttributeList>(), //
        make_unique<ReadAdministratorCommissioningClusterRevision>(), //
        make_unique<ReportAdministratorCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationBasic(Commands & commands)
{
    const char * clusterName = "ApplicationBasic";

    commands_list clusterCommands = {
        make_unique<ReadApplicationBasicVendorName>(), //
        make_unique<ReportApplicationBasicVendorName>(), //
        make_unique<ReadApplicationBasicVendorId>(), //
        make_unique<ReportApplicationBasicVendorId>(), //
        make_unique<ReadApplicationBasicApplicationName>(), //
        make_unique<ReportApplicationBasicApplicationName>(), //
        make_unique<ReadApplicationBasicProductId>(), //
        make_unique<ReportApplicationBasicProductId>(), //
        make_unique<ReadApplicationBasicApplicationStatus>(), //
        make_unique<ReportApplicationBasicApplicationStatus>(), //
        make_unique<ReadApplicationBasicApplicationVersion>(), //
        make_unique<ReportApplicationBasicApplicationVersion>(), //
        make_unique<ReadApplicationBasicAllowedVendorList>(), //
        make_unique<ReportApplicationBasicAllowedVendorList>(), //
        make_unique<ReadApplicationBasicServerGeneratedCommandList>(), //
        make_unique<ReportApplicationBasicServerGeneratedCommandList>(), //
        make_unique<ReadApplicationBasicClientGeneratedCommandList>(), //
        make_unique<ReportApplicationBasicClientGeneratedCommandList>(), //
        make_unique<ReadApplicationBasicAttributeList>(), //
        make_unique<ReportApplicationBasicAttributeList>(), //
        make_unique<ReadApplicationBasicClusterRevision>(), //
        make_unique<ReportApplicationBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterApplicationLauncher(Commands & commands)
{
    const char * clusterName = "ApplicationLauncher";

    commands_list clusterCommands = {
        make_unique<ApplicationLauncherHideAppRequest>(), //
        make_unique<ApplicationLauncherLaunchAppRequest>(), //
        make_unique<ApplicationLauncherStopAppRequest>(), //
        make_unique<ReadApplicationLauncherApplicationLauncherList>(), //
        make_unique<ReportApplicationLauncherApplicationLauncherList>(), //
        make_unique<ReadApplicationLauncherServerGeneratedCommandList>(), //
        make_unique<ReportApplicationLauncherServerGeneratedCommandList>(), //
        make_unique<ReadApplicationLauncherClientGeneratedCommandList>(), //
        make_unique<ReportApplicationLauncherClientGeneratedCommandList>(), //
        make_unique<ReadApplicationLauncherAttributeList>(), //
        make_unique<ReportApplicationLauncherAttributeList>(), //
        make_unique<ReadApplicationLauncherClusterRevision>(), //
        make_unique<ReportApplicationLauncherClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterAudioOutput(Commands & commands)
{
    const char * clusterName = "AudioOutput";

    commands_list clusterCommands = {
        make_unique<AudioOutputRenameOutputRequest>(), //
        make_unique<AudioOutputSelectOutputRequest>(), //
        make_unique<ReadAudioOutputAudioOutputList>(), //
        make_unique<ReportAudioOutputAudioOutputList>(), //
        make_unique<ReadAudioOutputCurrentAudioOutput>(), //
        make_unique<ReportAudioOutputCurrentAudioOutput>(), //
        make_unique<ReadAudioOutputServerGeneratedCommandList>(), //
        make_unique<ReportAudioOutputServerGeneratedCommandList>(), //
        make_unique<ReadAudioOutputClientGeneratedCommandList>(), //
        make_unique<ReportAudioOutputClientGeneratedCommandList>(), //
        make_unique<ReadAudioOutputAttributeList>(), //
        make_unique<ReportAudioOutputAttributeList>(), //
        make_unique<ReadAudioOutputClusterRevision>(), //
        make_unique<ReportAudioOutputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBarrierControl(Commands & commands)
{
    const char * clusterName = "BarrierControl";

    commands_list clusterCommands = {
        make_unique<BarrierControlBarrierControlGoToPercent>(), //
        make_unique<BarrierControlBarrierControlStop>(), //
        make_unique<ReadBarrierControlBarrierMovingState>(), //
        make_unique<ReportBarrierControlBarrierMovingState>(), //
        make_unique<ReadBarrierControlBarrierSafetyStatus>(), //
        make_unique<ReportBarrierControlBarrierSafetyStatus>(), //
        make_unique<ReadBarrierControlBarrierCapabilities>(), //
        make_unique<ReportBarrierControlBarrierCapabilities>(), //
        make_unique<ReadBarrierControlBarrierPosition>(), //
        make_unique<ReportBarrierControlBarrierPosition>(), //
        make_unique<ReadBarrierControlServerGeneratedCommandList>(), //
        make_unique<ReportBarrierControlServerGeneratedCommandList>(), //
        make_unique<ReadBarrierControlClientGeneratedCommandList>(), //
        make_unique<ReportBarrierControlClientGeneratedCommandList>(), //
        make_unique<ReadBarrierControlAttributeList>(), //
        make_unique<ReportBarrierControlAttributeList>(), //
        make_unique<ReadBarrierControlClusterRevision>(), //
        make_unique<ReportBarrierControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBasic(Commands & commands)
{
    const char * clusterName = "Basic";

    commands_list clusterCommands = {
        make_unique<ReadBasicDataModelRevision>(), //
        make_unique<ReportBasicDataModelRevision>(), //
        make_unique<ReadBasicVendorName>(), //
        make_unique<ReportBasicVendorName>(), //
        make_unique<ReadBasicVendorID>(), //
        make_unique<ReportBasicVendorID>(), //
        make_unique<ReadBasicProductName>(), //
        make_unique<ReportBasicProductName>(), //
        make_unique<ReadBasicProductID>(), //
        make_unique<ReportBasicProductID>(), //
        make_unique<ReadBasicNodeLabel>(), //
        make_unique<WriteBasicNodeLabel>(), //
        make_unique<ReportBasicNodeLabel>(), //
        make_unique<ReadBasicLocation>(), //
        make_unique<WriteBasicLocation>(), //
        make_unique<ReportBasicLocation>(), //
        make_unique<ReadBasicHardwareVersion>(), //
        make_unique<ReportBasicHardwareVersion>(), //
        make_unique<ReadBasicHardwareVersionString>(), //
        make_unique<ReportBasicHardwareVersionString>(), //
        make_unique<ReadBasicSoftwareVersion>(), //
        make_unique<ReportBasicSoftwareVersion>(), //
        make_unique<ReadBasicSoftwareVersionString>(), //
        make_unique<ReportBasicSoftwareVersionString>(), //
        make_unique<ReadBasicManufacturingDate>(), //
        make_unique<ReportBasicManufacturingDate>(), //
        make_unique<ReadBasicPartNumber>(), //
        make_unique<ReportBasicPartNumber>(), //
        make_unique<ReadBasicProductURL>(), //
        make_unique<ReportBasicProductURL>(), //
        make_unique<ReadBasicProductLabel>(), //
        make_unique<ReportBasicProductLabel>(), //
        make_unique<ReadBasicSerialNumber>(), //
        make_unique<ReportBasicSerialNumber>(), //
        make_unique<ReadBasicLocalConfigDisabled>(), //
        make_unique<WriteBasicLocalConfigDisabled>(), //
        make_unique<ReportBasicLocalConfigDisabled>(), //
        make_unique<ReadBasicReachable>(), //
        make_unique<ReportBasicReachable>(), //
        make_unique<ReadBasicUniqueID>(), //
        make_unique<ReportBasicUniqueID>(), //
        make_unique<ReadBasicServerGeneratedCommandList>(), //
        make_unique<ReportBasicServerGeneratedCommandList>(), //
        make_unique<ReadBasicClientGeneratedCommandList>(), //
        make_unique<ReportBasicClientGeneratedCommandList>(), //
        make_unique<ReadBasicAttributeList>(), //
        make_unique<ReportBasicAttributeList>(), //
        make_unique<ReadBasicClusterRevision>(), //
        make_unique<ReportBasicClusterRevision>(), //
        make_unique<ReadBasicStartUp>(), //
        make_unique<ReportBasicStartUp>(), //
        make_unique<ReadBasicShutDown>(), //
        make_unique<ReportBasicShutDown>(), //
        make_unique<ReadBasicLeave>(), //
        make_unique<ReportBasicLeave>(), //
        make_unique<ReadBasicReachableChanged>(), //
        make_unique<ReportBasicReachableChanged>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinaryInputBasic(Commands & commands)
{
    const char * clusterName = "BinaryInputBasic";

    commands_list clusterCommands = {
        make_unique<ReadBinaryInputBasicOutOfService>(), //
        make_unique<WriteBinaryInputBasicOutOfService>(), //
        make_unique<ReportBinaryInputBasicOutOfService>(), //
        make_unique<ReadBinaryInputBasicPresentValue>(), //
        make_unique<WriteBinaryInputBasicPresentValue>(), //
        make_unique<ReportBinaryInputBasicPresentValue>(), //
        make_unique<ReadBinaryInputBasicStatusFlags>(), //
        make_unique<ReportBinaryInputBasicStatusFlags>(), //
        make_unique<ReadBinaryInputBasicServerGeneratedCommandList>(), //
        make_unique<ReportBinaryInputBasicServerGeneratedCommandList>(), //
        make_unique<ReadBinaryInputBasicClientGeneratedCommandList>(), //
        make_unique<ReportBinaryInputBasicClientGeneratedCommandList>(), //
        make_unique<ReadBinaryInputBasicAttributeList>(), //
        make_unique<ReportBinaryInputBasicAttributeList>(), //
        make_unique<ReadBinaryInputBasicClusterRevision>(), //
        make_unique<ReportBinaryInputBasicClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBinding(Commands & commands)
{
    const char * clusterName = "Binding";

    commands_list clusterCommands = {
        make_unique<BindingBind>(), //
        make_unique<BindingUnbind>(), //
        make_unique<ReadBindingServerGeneratedCommandList>(), //
        make_unique<ReportBindingServerGeneratedCommandList>(), //
        make_unique<ReadBindingClientGeneratedCommandList>(), //
        make_unique<ReportBindingClientGeneratedCommandList>(), //
        make_unique<ReadBindingAttributeList>(), //
        make_unique<ReportBindingAttributeList>(), //
        make_unique<ReadBindingClusterRevision>(), //
        make_unique<ReportBindingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBooleanState(Commands & commands)
{
    const char * clusterName = "BooleanState";

    commands_list clusterCommands = {
        make_unique<ReadBooleanStateStateValue>(), //
        make_unique<ReportBooleanStateStateValue>(), //
        make_unique<ReadBooleanStateServerGeneratedCommandList>(), //
        make_unique<ReportBooleanStateServerGeneratedCommandList>(), //
        make_unique<ReadBooleanStateClientGeneratedCommandList>(), //
        make_unique<ReportBooleanStateClientGeneratedCommandList>(), //
        make_unique<ReadBooleanStateAttributeList>(), //
        make_unique<ReportBooleanStateAttributeList>(), //
        make_unique<ReadBooleanStateClusterRevision>(), //
        make_unique<ReportBooleanStateClusterRevision>(), //
        make_unique<ReadBooleanStateStateChange>(), //
        make_unique<ReportBooleanStateStateChange>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedActions(Commands & commands)
{
    const char * clusterName = "BridgedActions";

    commands_list clusterCommands = {
        make_unique<BridgedActionsDisableAction>(), //
        make_unique<BridgedActionsDisableActionWithDuration>(), //
        make_unique<BridgedActionsEnableAction>(), //
        make_unique<BridgedActionsEnableActionWithDuration>(), //
        make_unique<BridgedActionsInstantAction>(), //
        make_unique<BridgedActionsInstantActionWithTransition>(), //
        make_unique<BridgedActionsPauseAction>(), //
        make_unique<BridgedActionsPauseActionWithDuration>(), //
        make_unique<BridgedActionsResumeAction>(), //
        make_unique<BridgedActionsStartAction>(), //
        make_unique<BridgedActionsStartActionWithDuration>(), //
        make_unique<BridgedActionsStopAction>(), //
        make_unique<ReadBridgedActionsActionList>(), //
        make_unique<ReportBridgedActionsActionList>(), //
        make_unique<ReadBridgedActionsEndpointList>(), //
        make_unique<ReportBridgedActionsEndpointList>(), //
        make_unique<ReadBridgedActionsSetupUrl>(), //
        make_unique<ReportBridgedActionsSetupUrl>(), //
        make_unique<ReadBridgedActionsServerGeneratedCommandList>(), //
        make_unique<ReportBridgedActionsServerGeneratedCommandList>(), //
        make_unique<ReadBridgedActionsClientGeneratedCommandList>(), //
        make_unique<ReportBridgedActionsClientGeneratedCommandList>(), //
        make_unique<ReadBridgedActionsAttributeList>(), //
        make_unique<ReportBridgedActionsAttributeList>(), //
        make_unique<ReadBridgedActionsClusterRevision>(), //
        make_unique<ReportBridgedActionsClusterRevision>(), //
        make_unique<ReadBridgedActionsStateChanged>(), //
        make_unique<ReportBridgedActionsStateChanged>(), //
        make_unique<ReadBridgedActionsActionFailed>(), //
        make_unique<ReportBridgedActionsActionFailed>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterBridgedDeviceBasic(Commands & commands)
{
    const char * clusterName = "BridgedDeviceBasic";

    commands_list clusterCommands = {
        make_unique<ReadBridgedDeviceBasicVendorName>(), //
        make_unique<ReportBridgedDeviceBasicVendorName>(), //
        make_unique<ReadBridgedDeviceBasicVendorID>(), //
        make_unique<ReportBridgedDeviceBasicVendorID>(), //
        make_unique<ReadBridgedDeviceBasicProductName>(), //
        make_unique<ReportBridgedDeviceBasicProductName>(), //
        make_unique<ReadBridgedDeviceBasicNodeLabel>(), //
        make_unique<WriteBridgedDeviceBasicNodeLabel>(), //
        make_unique<ReportBridgedDeviceBasicNodeLabel>(), //
        make_unique<ReadBridgedDeviceBasicHardwareVersion>(), //
        make_unique<ReportBridgedDeviceBasicHardwareVersion>(), //
        make_unique<ReadBridgedDeviceBasicHardwareVersionString>(), //
        make_unique<ReportBridgedDeviceBasicHardwareVersionString>(), //
        make_unique<ReadBridgedDeviceBasicSoftwareVersion>(), //
        make_unique<ReportBridgedDeviceBasicSoftwareVersion>(), //
        make_unique<ReadBridgedDeviceBasicSoftwareVersionString>(), //
        make_unique<ReportBridgedDeviceBasicSoftwareVersionString>(), //
        make_unique<ReadBridgedDeviceBasicManufacturingDate>(), //
        make_unique<ReportBridgedDeviceBasicManufacturingDate>(), //
        make_unique<ReadBridgedDeviceBasicPartNumber>(), //
        make_unique<ReportBridgedDeviceBasicPartNumber>(), //
        make_unique<ReadBridgedDeviceBasicProductURL>(), //
        make_unique<ReportBridgedDeviceBasicProductURL>(), //
        make_unique<ReadBridgedDeviceBasicProductLabel>(), //
        make_unique<ReportBridgedDeviceBasicProductLabel>(), //
        make_unique<ReadBridgedDeviceBasicSerialNumber>(), //
        make_unique<ReportBridgedDeviceBasicSerialNumber>(), //
        make_unique<ReadBridgedDeviceBasicReachable>(), //
        make_unique<ReportBridgedDeviceBasicReachable>(), //
        make_unique<ReadBridgedDeviceBasicServerGeneratedCommandList>(), //
        make_unique<ReportBridgedDeviceBasicServerGeneratedCommandList>(), //
        make_unique<ReadBridgedDeviceBasicClientGeneratedCommandList>(), //
        make_unique<ReportBridgedDeviceBasicClientGeneratedCommandList>(), //
        make_unique<ReadBridgedDeviceBasicAttributeList>(), //
        make_unique<ReportBridgedDeviceBasicAttributeList>(), //
        make_unique<ReadBridgedDeviceBasicClusterRevision>(), //
        make_unique<ReportBridgedDeviceBasicClusterRevision>(), //
        make_unique<ReadBridgedDeviceBasicStartUp>(), //
        make_unique<ReportBridgedDeviceBasicStartUp>(), //
        make_unique<ReadBridgedDeviceBasicShutDown>(), //
        make_unique<ReportBridgedDeviceBasicShutDown>(), //
        make_unique<ReadBridgedDeviceBasicLeave>(), //
        make_unique<ReportBridgedDeviceBasicLeave>(), //
        make_unique<ReadBridgedDeviceBasicReachableChanged>(), //
        make_unique<ReportBridgedDeviceBasicReachableChanged>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterChannel(Commands & commands)
{
    const char * clusterName = "Channel";

    commands_list clusterCommands = {
        make_unique<ChannelChangeChannelByNumberRequest>(), //
        make_unique<ChannelChangeChannelRequest>(), //
        make_unique<ChannelSkipChannelRequest>(), //
        make_unique<ReadChannelChannelList>(), //
        make_unique<ReportChannelChannelList>(), //
        make_unique<ReadChannelServerGeneratedCommandList>(), //
        make_unique<ReportChannelServerGeneratedCommandList>(), //
        make_unique<ReadChannelClientGeneratedCommandList>(), //
        make_unique<ReportChannelClientGeneratedCommandList>(), //
        make_unique<ReadChannelAttributeList>(), //
        make_unique<ReportChannelAttributeList>(), //
        make_unique<ReadChannelClusterRevision>(), //
        make_unique<ReportChannelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterColorControl(Commands & commands)
{
    const char * clusterName = "ColorControl";

    commands_list clusterCommands = {
        make_unique<ColorControlColorLoopSet>(), //
        make_unique<ColorControlEnhancedMoveHue>(), //
        make_unique<ColorControlEnhancedMoveToHue>(), //
        make_unique<ColorControlEnhancedMoveToHueAndSaturation>(), //
        make_unique<ColorControlEnhancedStepHue>(), //
        make_unique<ColorControlMoveColor>(), //
        make_unique<ColorControlMoveColorTemperature>(), //
        make_unique<ColorControlMoveHue>(), //
        make_unique<ColorControlMoveSaturation>(), //
        make_unique<ColorControlMoveToColor>(), //
        make_unique<ColorControlMoveToColorTemperature>(), //
        make_unique<ColorControlMoveToHue>(), //
        make_unique<ColorControlMoveToHueAndSaturation>(), //
        make_unique<ColorControlMoveToSaturation>(), //
        make_unique<ColorControlStepColor>(), //
        make_unique<ColorControlStepColorTemperature>(), //
        make_unique<ColorControlStepHue>(), //
        make_unique<ColorControlStepSaturation>(), //
        make_unique<ColorControlStopMoveStep>(), //
        make_unique<ReadColorControlCurrentHue>(), //
        make_unique<ReportColorControlCurrentHue>(), //
        make_unique<ReadColorControlCurrentSaturation>(), //
        make_unique<ReportColorControlCurrentSaturation>(), //
        make_unique<ReadColorControlRemainingTime>(), //
        make_unique<ReportColorControlRemainingTime>(), //
        make_unique<ReadColorControlCurrentX>(), //
        make_unique<ReportColorControlCurrentX>(), //
        make_unique<ReadColorControlCurrentY>(), //
        make_unique<ReportColorControlCurrentY>(), //
        make_unique<ReadColorControlDriftCompensation>(), //
        make_unique<ReportColorControlDriftCompensation>(), //
        make_unique<ReadColorControlCompensationText>(), //
        make_unique<ReportColorControlCompensationText>(), //
        make_unique<ReadColorControlColorTemperature>(), //
        make_unique<ReportColorControlColorTemperature>(), //
        make_unique<ReadColorControlColorMode>(), //
        make_unique<ReportColorControlColorMode>(), //
        make_unique<ReadColorControlColorControlOptions>(), //
        make_unique<WriteColorControlColorControlOptions>(), //
        make_unique<ReportColorControlColorControlOptions>(), //
        make_unique<ReadColorControlNumberOfPrimaries>(), //
        make_unique<ReportColorControlNumberOfPrimaries>(), //
        make_unique<ReadColorControlPrimary1X>(), //
        make_unique<ReportColorControlPrimary1X>(), //
        make_unique<ReadColorControlPrimary1Y>(), //
        make_unique<ReportColorControlPrimary1Y>(), //
        make_unique<ReadColorControlPrimary1Intensity>(), //
        make_unique<ReportColorControlPrimary1Intensity>(), //
        make_unique<ReadColorControlPrimary2X>(), //
        make_unique<ReportColorControlPrimary2X>(), //
        make_unique<ReadColorControlPrimary2Y>(), //
        make_unique<ReportColorControlPrimary2Y>(), //
        make_unique<ReadColorControlPrimary2Intensity>(), //
        make_unique<ReportColorControlPrimary2Intensity>(), //
        make_unique<ReadColorControlPrimary3X>(), //
        make_unique<ReportColorControlPrimary3X>(), //
        make_unique<ReadColorControlPrimary3Y>(), //
        make_unique<ReportColorControlPrimary3Y>(), //
        make_unique<ReadColorControlPrimary3Intensity>(), //
        make_unique<ReportColorControlPrimary3Intensity>(), //
        make_unique<ReadColorControlPrimary4X>(), //
        make_unique<ReportColorControlPrimary4X>(), //
        make_unique<ReadColorControlPrimary4Y>(), //
        make_unique<ReportColorControlPrimary4Y>(), //
        make_unique<ReadColorControlPrimary4Intensity>(), //
        make_unique<ReportColorControlPrimary4Intensity>(), //
        make_unique<ReadColorControlPrimary5X>(), //
        make_unique<ReportColorControlPrimary5X>(), //
        make_unique<ReadColorControlPrimary5Y>(), //
        make_unique<ReportColorControlPrimary5Y>(), //
        make_unique<ReadColorControlPrimary5Intensity>(), //
        make_unique<ReportColorControlPrimary5Intensity>(), //
        make_unique<ReadColorControlPrimary6X>(), //
        make_unique<ReportColorControlPrimary6X>(), //
        make_unique<ReadColorControlPrimary6Y>(), //
        make_unique<ReportColorControlPrimary6Y>(), //
        make_unique<ReadColorControlPrimary6Intensity>(), //
        make_unique<ReportColorControlPrimary6Intensity>(), //
        make_unique<ReadColorControlWhitePointX>(), //
        make_unique<WriteColorControlWhitePointX>(), //
        make_unique<ReportColorControlWhitePointX>(), //
        make_unique<ReadColorControlWhitePointY>(), //
        make_unique<WriteColorControlWhitePointY>(), //
        make_unique<ReportColorControlWhitePointY>(), //
        make_unique<ReadColorControlColorPointRX>(), //
        make_unique<WriteColorControlColorPointRX>(), //
        make_unique<ReportColorControlColorPointRX>(), //
        make_unique<ReadColorControlColorPointRY>(), //
        make_unique<WriteColorControlColorPointRY>(), //
        make_unique<ReportColorControlColorPointRY>(), //
        make_unique<ReadColorControlColorPointRIntensity>(), //
        make_unique<WriteColorControlColorPointRIntensity>(), //
        make_unique<ReportColorControlColorPointRIntensity>(), //
        make_unique<ReadColorControlColorPointGX>(), //
        make_unique<WriteColorControlColorPointGX>(), //
        make_unique<ReportColorControlColorPointGX>(), //
        make_unique<ReadColorControlColorPointGY>(), //
        make_unique<WriteColorControlColorPointGY>(), //
        make_unique<ReportColorControlColorPointGY>(), //
        make_unique<ReadColorControlColorPointGIntensity>(), //
        make_unique<WriteColorControlColorPointGIntensity>(), //
        make_unique<ReportColorControlColorPointGIntensity>(), //
        make_unique<ReadColorControlColorPointBX>(), //
        make_unique<WriteColorControlColorPointBX>(), //
        make_unique<ReportColorControlColorPointBX>(), //
        make_unique<ReadColorControlColorPointBY>(), //
        make_unique<WriteColorControlColorPointBY>(), //
        make_unique<ReportColorControlColorPointBY>(), //
        make_unique<ReadColorControlColorPointBIntensity>(), //
        make_unique<WriteColorControlColorPointBIntensity>(), //
        make_unique<ReportColorControlColorPointBIntensity>(), //
        make_unique<ReadColorControlEnhancedCurrentHue>(), //
        make_unique<ReportColorControlEnhancedCurrentHue>(), //
        make_unique<ReadColorControlEnhancedColorMode>(), //
        make_unique<ReportColorControlEnhancedColorMode>(), //
        make_unique<ReadColorControlColorLoopActive>(), //
        make_unique<ReportColorControlColorLoopActive>(), //
        make_unique<ReadColorControlColorLoopDirection>(), //
        make_unique<ReportColorControlColorLoopDirection>(), //
        make_unique<ReadColorControlColorLoopTime>(), //
        make_unique<ReportColorControlColorLoopTime>(), //
        make_unique<ReadColorControlColorLoopStartEnhancedHue>(), //
        make_unique<ReportColorControlColorLoopStartEnhancedHue>(), //
        make_unique<ReadColorControlColorLoopStoredEnhancedHue>(), //
        make_unique<ReportColorControlColorLoopStoredEnhancedHue>(), //
        make_unique<ReadColorControlColorCapabilities>(), //
        make_unique<ReportColorControlColorCapabilities>(), //
        make_unique<ReadColorControlColorTempPhysicalMin>(), //
        make_unique<ReportColorControlColorTempPhysicalMin>(), //
        make_unique<ReadColorControlColorTempPhysicalMax>(), //
        make_unique<ReportColorControlColorTempPhysicalMax>(), //
        make_unique<ReadColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<ReportColorControlCoupleColorTempToLevelMinMireds>(), //
        make_unique<ReadColorControlStartUpColorTemperatureMireds>(), //
        make_unique<WriteColorControlStartUpColorTemperatureMireds>(), //
        make_unique<ReportColorControlStartUpColorTemperatureMireds>(), //
        make_unique<ReadColorControlServerGeneratedCommandList>(), //
        make_unique<ReportColorControlServerGeneratedCommandList>(), //
        make_unique<ReadColorControlClientGeneratedCommandList>(), //
        make_unique<ReportColorControlClientGeneratedCommandList>(), //
        make_unique<ReadColorControlAttributeList>(), //
        make_unique<ReportColorControlAttributeList>(), //
        make_unique<ReadColorControlClusterRevision>(), //
        make_unique<ReportColorControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterContentLauncher(Commands & commands)
{
    const char * clusterName = "ContentLauncher";

    commands_list clusterCommands = {
        make_unique<ContentLauncherLaunchContentRequest>(), //
        make_unique<ContentLauncherLaunchURLRequest>(), //
        make_unique<ReadContentLauncherAcceptHeaderList>(), //
        make_unique<ReportContentLauncherAcceptHeaderList>(), //
        make_unique<ReadContentLauncherSupportedStreamingProtocols>(), //
        make_unique<WriteContentLauncherSupportedStreamingProtocols>(), //
        make_unique<ReportContentLauncherSupportedStreamingProtocols>(), //
        make_unique<ReadContentLauncherServerGeneratedCommandList>(), //
        make_unique<ReportContentLauncherServerGeneratedCommandList>(), //
        make_unique<ReadContentLauncherClientGeneratedCommandList>(), //
        make_unique<ReportContentLauncherClientGeneratedCommandList>(), //
        make_unique<ReadContentLauncherAttributeList>(), //
        make_unique<ReportContentLauncherAttributeList>(), //
        make_unique<ReadContentLauncherClusterRevision>(), //
        make_unique<ReportContentLauncherClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDescriptor(Commands & commands)
{
    const char * clusterName = "Descriptor";

    commands_list clusterCommands = {
        make_unique<ReadDescriptorDeviceList>(), //
        make_unique<ReportDescriptorDeviceList>(), //
        make_unique<ReadDescriptorServerList>(), //
        make_unique<ReportDescriptorServerList>(), //
        make_unique<ReadDescriptorClientList>(), //
        make_unique<ReportDescriptorClientList>(), //
        make_unique<ReadDescriptorPartsList>(), //
        make_unique<ReportDescriptorPartsList>(), //
        make_unique<ReadDescriptorServerGeneratedCommandList>(), //
        make_unique<ReportDescriptorServerGeneratedCommandList>(), //
        make_unique<ReadDescriptorClientGeneratedCommandList>(), //
        make_unique<ReportDescriptorClientGeneratedCommandList>(), //
        make_unique<ReadDescriptorAttributeList>(), //
        make_unique<ReportDescriptorAttributeList>(), //
        make_unique<ReadDescriptorClusterRevision>(), //
        make_unique<ReportDescriptorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDiagnosticLogs(Commands & commands)
{
    const char * clusterName = "DiagnosticLogs";

    commands_list clusterCommands = {
        make_unique<DiagnosticLogsRetrieveLogsRequest>(), //
        make_unique<ReadDiagnosticLogsServerGeneratedCommandList>(), //
        make_unique<ReportDiagnosticLogsServerGeneratedCommandList>(), //
        make_unique<ReadDiagnosticLogsClientGeneratedCommandList>(), //
        make_unique<ReportDiagnosticLogsClientGeneratedCommandList>(), //
        make_unique<ReadDiagnosticLogsAttributeList>(), //
        make_unique<ReportDiagnosticLogsAttributeList>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterDoorLock(Commands & commands)
{
    const char * clusterName = "DoorLock";

    commands_list clusterCommands = {
        make_unique<DoorLockClearCredential>(), //
        make_unique<DoorLockClearUser>(), //
        make_unique<DoorLockClearWeekDaySchedule>(), //
        make_unique<DoorLockClearYearDaySchedule>(), //
        make_unique<DoorLockGetCredentialStatus>(), //
        make_unique<DoorLockGetUser>(), //
        make_unique<DoorLockGetWeekDaySchedule>(), //
        make_unique<DoorLockGetYearDaySchedule>(), //
        make_unique<DoorLockLockDoor>(), //
        make_unique<DoorLockSetCredential>(), //
        make_unique<DoorLockSetUser>(), //
        make_unique<DoorLockSetWeekDaySchedule>(), //
        make_unique<DoorLockSetYearDaySchedule>(), //
        make_unique<DoorLockUnlockDoor>(), //
        make_unique<DoorLockUnlockWithTimeout>(), //
        make_unique<ReadDoorLockLockState>(), //
        make_unique<ReportDoorLockLockState>(), //
        make_unique<ReadDoorLockLockType>(), //
        make_unique<ReportDoorLockLockType>(), //
        make_unique<ReadDoorLockActuatorEnabled>(), //
        make_unique<ReportDoorLockActuatorEnabled>(), //
        make_unique<ReadDoorLockDoorState>(), //
        make_unique<ReportDoorLockDoorState>(), //
        make_unique<ReadDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<ReportDoorLockNumberOfTotalUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfPINUsersSupported>(), //
        make_unique<ReportDoorLockNumberOfPINUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfRFIDUsersSupported>(), //
        make_unique<ReportDoorLockNumberOfRFIDUsersSupported>(), //
        make_unique<ReadDoorLockNumberOfWeekDaySchedulesSupportedPerUser>(), //
        make_unique<ReportDoorLockNumberOfWeekDaySchedulesSupportedPerUser>(), //
        make_unique<ReadDoorLockNumberOfYearDaySchedulesSupportedPerUser>(), //
        make_unique<ReportDoorLockNumberOfYearDaySchedulesSupportedPerUser>(), //
        make_unique<ReadDoorLockMaxPINCodeLength>(), //
        make_unique<ReportDoorLockMaxPINCodeLength>(), //
        make_unique<ReadDoorLockMinPINCodeLength>(), //
        make_unique<ReportDoorLockMinPINCodeLength>(), //
        make_unique<ReadDoorLockMaxRFIDCodeLength>(), //
        make_unique<ReportDoorLockMaxRFIDCodeLength>(), //
        make_unique<ReadDoorLockMinRFIDCodeLength>(), //
        make_unique<ReportDoorLockMinRFIDCodeLength>(), //
        make_unique<ReadDoorLockLanguage>(), //
        make_unique<WriteDoorLockLanguage>(), //
        make_unique<ReportDoorLockLanguage>(), //
        make_unique<ReadDoorLockAutoRelockTime>(), //
        make_unique<WriteDoorLockAutoRelockTime>(), //
        make_unique<ReportDoorLockAutoRelockTime>(), //
        make_unique<ReadDoorLockSoundVolume>(), //
        make_unique<WriteDoorLockSoundVolume>(), //
        make_unique<ReportDoorLockSoundVolume>(), //
        make_unique<ReadDoorLockOperatingMode>(), //
        make_unique<WriteDoorLockOperatingMode>(), //
        make_unique<ReportDoorLockOperatingMode>(), //
        make_unique<ReadDoorLockSupportedOperatingModes>(), //
        make_unique<ReportDoorLockSupportedOperatingModes>(), //
        make_unique<ReadDoorLockEnableOneTouchLocking>(), //
        make_unique<WriteDoorLockEnableOneTouchLocking>(), //
        make_unique<ReportDoorLockEnableOneTouchLocking>(), //
        make_unique<ReadDoorLockEnablePrivacyModeButton>(), //
        make_unique<WriteDoorLockEnablePrivacyModeButton>(), //
        make_unique<ReportDoorLockEnablePrivacyModeButton>(), //
        make_unique<ReadDoorLockWrongCodeEntryLimit>(), //
        make_unique<WriteDoorLockWrongCodeEntryLimit>(), //
        make_unique<ReportDoorLockWrongCodeEntryLimit>(), //
        make_unique<ReadDoorLockServerGeneratedCommandList>(), //
        make_unique<ReportDoorLockServerGeneratedCommandList>(), //
        make_unique<ReadDoorLockClientGeneratedCommandList>(), //
        make_unique<ReportDoorLockClientGeneratedCommandList>(), //
        make_unique<ReadDoorLockAttributeList>(), //
        make_unique<ReportDoorLockAttributeList>(), //
        make_unique<ReadDoorLockClusterRevision>(), //
        make_unique<ReportDoorLockClusterRevision>(), //
        make_unique<ReadDoorLockDoorLockAlarm>(), //
        make_unique<ReportDoorLockDoorLockAlarm>(), //
        make_unique<ReadDoorLockDoorStateChange>(), //
        make_unique<ReportDoorLockDoorStateChange>(), //
        make_unique<ReadDoorLockLockOperation>(), //
        make_unique<ReportDoorLockLockOperation>(), //
        make_unique<ReadDoorLockLockOperationError>(), //
        make_unique<ReportDoorLockLockOperationError>(), //
        make_unique<ReadDoorLockLockUserChange>(), //
        make_unique<ReportDoorLockLockUserChange>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterElectricalMeasurement(Commands & commands)
{
    const char * clusterName = "ElectricalMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadElectricalMeasurementMeasurementType>(), //
        make_unique<ReportElectricalMeasurementMeasurementType>(), //
        make_unique<ReadElectricalMeasurementTotalActivePower>(), //
        make_unique<ReportElectricalMeasurementTotalActivePower>(), //
        make_unique<ReadElectricalMeasurementRmsVoltage>(), //
        make_unique<ReportElectricalMeasurementRmsVoltage>(), //
        make_unique<ReadElectricalMeasurementRmsVoltageMin>(), //
        make_unique<ReportElectricalMeasurementRmsVoltageMin>(), //
        make_unique<ReadElectricalMeasurementRmsVoltageMax>(), //
        make_unique<ReportElectricalMeasurementRmsVoltageMax>(), //
        make_unique<ReadElectricalMeasurementRmsCurrent>(), //
        make_unique<ReportElectricalMeasurementRmsCurrent>(), //
        make_unique<ReadElectricalMeasurementRmsCurrentMin>(), //
        make_unique<ReportElectricalMeasurementRmsCurrentMin>(), //
        make_unique<ReadElectricalMeasurementRmsCurrentMax>(), //
        make_unique<ReportElectricalMeasurementRmsCurrentMax>(), //
        make_unique<ReadElectricalMeasurementActivePower>(), //
        make_unique<ReportElectricalMeasurementActivePower>(), //
        make_unique<ReadElectricalMeasurementActivePowerMin>(), //
        make_unique<ReportElectricalMeasurementActivePowerMin>(), //
        make_unique<ReadElectricalMeasurementActivePowerMax>(), //
        make_unique<ReportElectricalMeasurementActivePowerMax>(), //
        make_unique<ReadElectricalMeasurementServerGeneratedCommandList>(), //
        make_unique<ReportElectricalMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadElectricalMeasurementClientGeneratedCommandList>(), //
        make_unique<ReportElectricalMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadElectricalMeasurementAttributeList>(), //
        make_unique<ReportElectricalMeasurementAttributeList>(), //
        make_unique<ReadElectricalMeasurementClusterRevision>(), //
        make_unique<ReportElectricalMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterEthernetNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "EthernetNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<EthernetNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPHYRate>(), //
        make_unique<ReportEthernetNetworkDiagnosticsPHYRate>(), //
        make_unique<ReadEthernetNetworkDiagnosticsFullDuplex>(), //
        make_unique<ReportEthernetNetworkDiagnosticsFullDuplex>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPacketRxCount>(), //
        make_unique<ReportEthernetNetworkDiagnosticsPacketRxCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsPacketTxCount>(), //
        make_unique<ReportEthernetNetworkDiagnosticsPacketTxCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsTxErrCount>(), //
        make_unique<ReportEthernetNetworkDiagnosticsTxErrCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsCollisionCount>(), //
        make_unique<ReportEthernetNetworkDiagnosticsCollisionCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReportEthernetNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadEthernetNetworkDiagnosticsCarrierDetect>(), //
        make_unique<ReportEthernetNetworkDiagnosticsCarrierDetect>(), //
        make_unique<ReadEthernetNetworkDiagnosticsTimeSinceReset>(), //
        make_unique<ReportEthernetNetworkDiagnosticsTimeSinceReset>(), //
        make_unique<ReadEthernetNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReportEthernetNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReportEthernetNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsAttributeList>(), //
        make_unique<ReportEthernetNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadEthernetNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReportEthernetNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadEthernetNetworkDiagnosticsClusterRevision>(), //
        make_unique<ReportEthernetNetworkDiagnosticsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFixedLabel(Commands & commands)
{
    const char * clusterName = "FixedLabel";

    commands_list clusterCommands = {
        make_unique<ReadFixedLabelLabelList>(), //
        make_unique<ReportFixedLabelLabelList>(), //
        make_unique<ReadFixedLabelServerGeneratedCommandList>(), //
        make_unique<ReportFixedLabelServerGeneratedCommandList>(), //
        make_unique<ReadFixedLabelClientGeneratedCommandList>(), //
        make_unique<ReportFixedLabelClientGeneratedCommandList>(), //
        make_unique<ReadFixedLabelAttributeList>(), //
        make_unique<ReportFixedLabelAttributeList>(), //
        make_unique<ReadFixedLabelClusterRevision>(), //
        make_unique<ReportFixedLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterFlowMeasurement(Commands & commands)
{
    const char * clusterName = "FlowMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadFlowMeasurementMeasuredValue>(), //
        make_unique<ReportFlowMeasurementMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMinMeasuredValue>(), //
        make_unique<ReportFlowMeasurementMinMeasuredValue>(), //
        make_unique<ReadFlowMeasurementMaxMeasuredValue>(), //
        make_unique<ReportFlowMeasurementMaxMeasuredValue>(), //
        make_unique<ReadFlowMeasurementTolerance>(), //
        make_unique<ReportFlowMeasurementTolerance>(), //
        make_unique<ReadFlowMeasurementServerGeneratedCommandList>(), //
        make_unique<ReportFlowMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadFlowMeasurementClientGeneratedCommandList>(), //
        make_unique<ReportFlowMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadFlowMeasurementAttributeList>(), //
        make_unique<ReportFlowMeasurementAttributeList>(), //
        make_unique<ReadFlowMeasurementClusterRevision>(), //
        make_unique<ReportFlowMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralCommissioning(Commands & commands)
{
    const char * clusterName = "GeneralCommissioning";

    commands_list clusterCommands = {
        make_unique<GeneralCommissioningArmFailSafe>(), //
        make_unique<GeneralCommissioningCommissioningComplete>(), //
        make_unique<GeneralCommissioningSetRegulatoryConfig>(), //
        make_unique<ReadGeneralCommissioningBreadcrumb>(), //
        make_unique<WriteGeneralCommissioningBreadcrumb>(), //
        make_unique<ReportGeneralCommissioningBreadcrumb>(), //
        make_unique<ReadGeneralCommissioningRegulatoryConfig>(), //
        make_unique<ReportGeneralCommissioningRegulatoryConfig>(), //
        make_unique<ReadGeneralCommissioningLocationCapability>(), //
        make_unique<ReportGeneralCommissioningLocationCapability>(), //
        make_unique<ReadGeneralCommissioningServerGeneratedCommandList>(), //
        make_unique<ReportGeneralCommissioningServerGeneratedCommandList>(), //
        make_unique<ReadGeneralCommissioningClientGeneratedCommandList>(), //
        make_unique<ReportGeneralCommissioningClientGeneratedCommandList>(), //
        make_unique<ReadGeneralCommissioningAttributeList>(), //
        make_unique<ReportGeneralCommissioningAttributeList>(), //
        make_unique<ReadGeneralCommissioningClusterRevision>(), //
        make_unique<ReportGeneralCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGeneralDiagnostics(Commands & commands)
{
    const char * clusterName = "GeneralDiagnostics";

    commands_list clusterCommands = {
        make_unique<ReadGeneralDiagnosticsNetworkInterfaces>(), //
        make_unique<ReportGeneralDiagnosticsNetworkInterfaces>(), //
        make_unique<ReadGeneralDiagnosticsRebootCount>(), //
        make_unique<ReportGeneralDiagnosticsRebootCount>(), //
        make_unique<ReadGeneralDiagnosticsUpTime>(), //
        make_unique<ReportGeneralDiagnosticsUpTime>(), //
        make_unique<ReadGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<ReportGeneralDiagnosticsTotalOperationalHours>(), //
        make_unique<ReadGeneralDiagnosticsBootReasons>(), //
        make_unique<ReportGeneralDiagnosticsBootReasons>(), //
        make_unique<ReadGeneralDiagnosticsActiveHardwareFaults>(), //
        make_unique<ReportGeneralDiagnosticsActiveHardwareFaults>(), //
        make_unique<ReadGeneralDiagnosticsActiveRadioFaults>(), //
        make_unique<ReportGeneralDiagnosticsActiveRadioFaults>(), //
        make_unique<ReadGeneralDiagnosticsActiveNetworkFaults>(), //
        make_unique<ReportGeneralDiagnosticsActiveNetworkFaults>(), //
        make_unique<ReadGeneralDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReportGeneralDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadGeneralDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReportGeneralDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadGeneralDiagnosticsAttributeList>(), //
        make_unique<ReportGeneralDiagnosticsAttributeList>(), //
        make_unique<ReadGeneralDiagnosticsClusterRevision>(), //
        make_unique<ReportGeneralDiagnosticsClusterRevision>(), //
        make_unique<ReadGeneralDiagnosticsHardwareFaultChange>(), //
        make_unique<ReportGeneralDiagnosticsHardwareFaultChange>(), //
        make_unique<ReadGeneralDiagnosticsRadioFaultChange>(), //
        make_unique<ReportGeneralDiagnosticsRadioFaultChange>(), //
        make_unique<ReadGeneralDiagnosticsNetworkFaultChange>(), //
        make_unique<ReportGeneralDiagnosticsNetworkFaultChange>(), //
        make_unique<ReadGeneralDiagnosticsBootReason>(), //
        make_unique<ReportGeneralDiagnosticsBootReason>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroupKeyManagement(Commands & commands)
{
    const char * clusterName = "GroupKeyManagement";

    commands_list clusterCommands = {
        make_unique<GroupKeyManagementKeySetRead>(), //
        make_unique<GroupKeyManagementKeySetReadAllIndices>(), //
        make_unique<GroupKeyManagementKeySetRemove>(), //
        make_unique<GroupKeyManagementKeySetWrite>(), //
        make_unique<ReadGroupKeyManagementGroupKeyMap>(), //
        make_unique<ReportGroupKeyManagementGroupKeyMap>(), //
        make_unique<ReadGroupKeyManagementGroupTable>(), //
        make_unique<ReportGroupKeyManagementGroupTable>(), //
        make_unique<ReadGroupKeyManagementMaxGroupsPerFabric>(), //
        make_unique<ReportGroupKeyManagementMaxGroupsPerFabric>(), //
        make_unique<ReadGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<ReportGroupKeyManagementMaxGroupKeysPerFabric>(), //
        make_unique<ReadGroupKeyManagementServerGeneratedCommandList>(), //
        make_unique<ReportGroupKeyManagementServerGeneratedCommandList>(), //
        make_unique<ReadGroupKeyManagementClientGeneratedCommandList>(), //
        make_unique<ReportGroupKeyManagementClientGeneratedCommandList>(), //
        make_unique<ReadGroupKeyManagementAttributeList>(), //
        make_unique<ReportGroupKeyManagementAttributeList>(), //
        make_unique<ReadGroupKeyManagementClusterRevision>(), //
        make_unique<ReportGroupKeyManagementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterGroups(Commands & commands)
{
    const char * clusterName = "Groups";

    commands_list clusterCommands = {
        make_unique<GroupsAddGroup>(), //
        make_unique<GroupsAddGroupIfIdentifying>(), //
        make_unique<GroupsGetGroupMembership>(), //
        make_unique<GroupsRemoveAllGroups>(), //
        make_unique<GroupsRemoveGroup>(), //
        make_unique<GroupsViewGroup>(), //
        make_unique<ReadGroupsNameSupport>(), //
        make_unique<ReportGroupsNameSupport>(), //
        make_unique<ReadGroupsServerGeneratedCommandList>(), //
        make_unique<ReportGroupsServerGeneratedCommandList>(), //
        make_unique<ReadGroupsClientGeneratedCommandList>(), //
        make_unique<ReportGroupsClientGeneratedCommandList>(), //
        make_unique<ReadGroupsAttributeList>(), //
        make_unique<ReportGroupsAttributeList>(), //
        make_unique<ReadGroupsClusterRevision>(), //
        make_unique<ReportGroupsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIdentify(Commands & commands)
{
    const char * clusterName = "Identify";

    commands_list clusterCommands = {
        make_unique<IdentifyIdentify>(), //
        make_unique<IdentifyIdentifyQuery>(), //
        make_unique<IdentifyTriggerEffect>(), //
        make_unique<ReadIdentifyIdentifyTime>(), //
        make_unique<WriteIdentifyIdentifyTime>(), //
        make_unique<ReportIdentifyIdentifyTime>(), //
        make_unique<ReadIdentifyIdentifyType>(), //
        make_unique<ReportIdentifyIdentifyType>(), //
        make_unique<ReadIdentifyServerGeneratedCommandList>(), //
        make_unique<ReportIdentifyServerGeneratedCommandList>(), //
        make_unique<ReadIdentifyClientGeneratedCommandList>(), //
        make_unique<ReportIdentifyClientGeneratedCommandList>(), //
        make_unique<ReadIdentifyAttributeList>(), //
        make_unique<ReportIdentifyAttributeList>(), //
        make_unique<ReadIdentifyClusterRevision>(), //
        make_unique<ReportIdentifyClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterIlluminanceMeasurement(Commands & commands)
{
    const char * clusterName = "IlluminanceMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadIlluminanceMeasurementMeasuredValue>(), //
        make_unique<ReportIlluminanceMeasurementMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<ReportIlluminanceMeasurementMinMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<ReportIlluminanceMeasurementMaxMeasuredValue>(), //
        make_unique<ReadIlluminanceMeasurementTolerance>(), //
        make_unique<ReportIlluminanceMeasurementTolerance>(), //
        make_unique<ReadIlluminanceMeasurementLightSensorType>(), //
        make_unique<ReportIlluminanceMeasurementLightSensorType>(), //
        make_unique<ReadIlluminanceMeasurementServerGeneratedCommandList>(), //
        make_unique<ReportIlluminanceMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadIlluminanceMeasurementClientGeneratedCommandList>(), //
        make_unique<ReportIlluminanceMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadIlluminanceMeasurementAttributeList>(), //
        make_unique<ReportIlluminanceMeasurementAttributeList>(), //
        make_unique<ReadIlluminanceMeasurementClusterRevision>(), //
        make_unique<ReportIlluminanceMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterKeypadInput(Commands & commands)
{
    const char * clusterName = "KeypadInput";

    commands_list clusterCommands = {
        make_unique<KeypadInputSendKeyRequest>(), //
        make_unique<ReadKeypadInputServerGeneratedCommandList>(), //
        make_unique<ReportKeypadInputServerGeneratedCommandList>(), //
        make_unique<ReadKeypadInputClientGeneratedCommandList>(), //
        make_unique<ReportKeypadInputClientGeneratedCommandList>(), //
        make_unique<ReadKeypadInputAttributeList>(), //
        make_unique<ReportKeypadInputAttributeList>(), //
        make_unique<ReadKeypadInputClusterRevision>(), //
        make_unique<ReportKeypadInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLevelControl(Commands & commands)
{
    const char * clusterName = "LevelControl";

    commands_list clusterCommands = {
        make_unique<LevelControlMove>(), //
        make_unique<LevelControlMoveToLevel>(), //
        make_unique<LevelControlMoveToLevelWithOnOff>(), //
        make_unique<LevelControlMoveWithOnOff>(), //
        make_unique<LevelControlStep>(), //
        make_unique<LevelControlStepWithOnOff>(), //
        make_unique<LevelControlStop>(), //
        make_unique<LevelControlStopWithOnOff>(), //
        make_unique<ReadLevelControlCurrentLevel>(), //
        make_unique<ReportLevelControlCurrentLevel>(), //
        make_unique<ReadLevelControlRemainingTime>(), //
        make_unique<ReportLevelControlRemainingTime>(), //
        make_unique<ReadLevelControlMinLevel>(), //
        make_unique<ReportLevelControlMinLevel>(), //
        make_unique<ReadLevelControlMaxLevel>(), //
        make_unique<ReportLevelControlMaxLevel>(), //
        make_unique<ReadLevelControlCurrentFrequency>(), //
        make_unique<ReportLevelControlCurrentFrequency>(), //
        make_unique<ReadLevelControlMinFrequency>(), //
        make_unique<ReportLevelControlMinFrequency>(), //
        make_unique<ReadLevelControlMaxFrequency>(), //
        make_unique<ReportLevelControlMaxFrequency>(), //
        make_unique<ReadLevelControlOptions>(), //
        make_unique<WriteLevelControlOptions>(), //
        make_unique<ReportLevelControlOptions>(), //
        make_unique<ReadLevelControlOnOffTransitionTime>(), //
        make_unique<WriteLevelControlOnOffTransitionTime>(), //
        make_unique<ReportLevelControlOnOffTransitionTime>(), //
        make_unique<ReadLevelControlOnLevel>(), //
        make_unique<WriteLevelControlOnLevel>(), //
        make_unique<ReportLevelControlOnLevel>(), //
        make_unique<ReadLevelControlOnTransitionTime>(), //
        make_unique<WriteLevelControlOnTransitionTime>(), //
        make_unique<ReportLevelControlOnTransitionTime>(), //
        make_unique<ReadLevelControlOffTransitionTime>(), //
        make_unique<WriteLevelControlOffTransitionTime>(), //
        make_unique<ReportLevelControlOffTransitionTime>(), //
        make_unique<ReadLevelControlDefaultMoveRate>(), //
        make_unique<WriteLevelControlDefaultMoveRate>(), //
        make_unique<ReportLevelControlDefaultMoveRate>(), //
        make_unique<ReadLevelControlStartUpCurrentLevel>(), //
        make_unique<WriteLevelControlStartUpCurrentLevel>(), //
        make_unique<ReportLevelControlStartUpCurrentLevel>(), //
        make_unique<ReadLevelControlServerGeneratedCommandList>(), //
        make_unique<ReportLevelControlServerGeneratedCommandList>(), //
        make_unique<ReadLevelControlClientGeneratedCommandList>(), //
        make_unique<ReportLevelControlClientGeneratedCommandList>(), //
        make_unique<ReadLevelControlAttributeList>(), //
        make_unique<ReportLevelControlAttributeList>(), //
        make_unique<ReadLevelControlFeatureMap>(), //
        make_unique<ReportLevelControlFeatureMap>(), //
        make_unique<ReadLevelControlClusterRevision>(), //
        make_unique<ReportLevelControlClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLocalizationConfiguration(Commands & commands)
{
    const char * clusterName = "LocalizationConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadLocalizationConfigurationActiveLocale>(), //
        make_unique<WriteLocalizationConfigurationActiveLocale>(), //
        make_unique<ReportLocalizationConfigurationActiveLocale>(), //
        make_unique<ReadLocalizationConfigurationSupportedLocales>(), //
        make_unique<ReportLocalizationConfigurationSupportedLocales>(), //
        make_unique<ReadLocalizationConfigurationServerGeneratedCommandList>(), //
        make_unique<ReportLocalizationConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadLocalizationConfigurationClientGeneratedCommandList>(), //
        make_unique<ReportLocalizationConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadLocalizationConfigurationClusterRevision>(), //
        make_unique<ReportLocalizationConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterLowPower(Commands & commands)
{
    const char * clusterName = "LowPower";

    commands_list clusterCommands = {
        make_unique<LowPowerSleep>(), //
        make_unique<ReadLowPowerServerGeneratedCommandList>(), //
        make_unique<ReportLowPowerServerGeneratedCommandList>(), //
        make_unique<ReadLowPowerClientGeneratedCommandList>(), //
        make_unique<ReportLowPowerClientGeneratedCommandList>(), //
        make_unique<ReadLowPowerAttributeList>(), //
        make_unique<ReportLowPowerAttributeList>(), //
        make_unique<ReadLowPowerClusterRevision>(), //
        make_unique<ReportLowPowerClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaInput(Commands & commands)
{
    const char * clusterName = "MediaInput";

    commands_list clusterCommands = {
        make_unique<MediaInputHideInputStatusRequest>(), //
        make_unique<MediaInputRenameInputRequest>(), //
        make_unique<MediaInputSelectInputRequest>(), //
        make_unique<MediaInputShowInputStatusRequest>(), //
        make_unique<ReadMediaInputMediaInputList>(), //
        make_unique<ReportMediaInputMediaInputList>(), //
        make_unique<ReadMediaInputCurrentMediaInput>(), //
        make_unique<ReportMediaInputCurrentMediaInput>(), //
        make_unique<ReadMediaInputServerGeneratedCommandList>(), //
        make_unique<ReportMediaInputServerGeneratedCommandList>(), //
        make_unique<ReadMediaInputClientGeneratedCommandList>(), //
        make_unique<ReportMediaInputClientGeneratedCommandList>(), //
        make_unique<ReadMediaInputAttributeList>(), //
        make_unique<ReportMediaInputAttributeList>(), //
        make_unique<ReadMediaInputClusterRevision>(), //
        make_unique<ReportMediaInputClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterMediaPlayback(Commands & commands)
{
    const char * clusterName = "MediaPlayback";

    commands_list clusterCommands = {
        make_unique<MediaPlaybackFastForwardRequest>(), //
        make_unique<MediaPlaybackNextRequest>(), //
        make_unique<MediaPlaybackPauseRequest>(), //
        make_unique<MediaPlaybackPlayRequest>(), //
        make_unique<MediaPlaybackPreviousRequest>(), //
        make_unique<MediaPlaybackRewindRequest>(), //
        make_unique<MediaPlaybackSeekRequest>(), //
        make_unique<MediaPlaybackSkipBackwardRequest>(), //
        make_unique<MediaPlaybackSkipForwardRequest>(), //
        make_unique<MediaPlaybackStartOverRequest>(), //
        make_unique<MediaPlaybackStopRequest>(), //
        make_unique<ReadMediaPlaybackPlaybackState>(), //
        make_unique<ReportMediaPlaybackPlaybackState>(), //
        make_unique<ReadMediaPlaybackStartTime>(), //
        make_unique<ReportMediaPlaybackStartTime>(), //
        make_unique<ReadMediaPlaybackDuration>(), //
        make_unique<ReportMediaPlaybackDuration>(), //
        make_unique<ReadMediaPlaybackPlaybackSpeed>(), //
        make_unique<ReportMediaPlaybackPlaybackSpeed>(), //
        make_unique<ReadMediaPlaybackSeekRangeEnd>(), //
        make_unique<ReportMediaPlaybackSeekRangeEnd>(), //
        make_unique<ReadMediaPlaybackSeekRangeStart>(), //
        make_unique<ReportMediaPlaybackSeekRangeStart>(), //
        make_unique<ReadMediaPlaybackServerGeneratedCommandList>(), //
        make_unique<ReportMediaPlaybackServerGeneratedCommandList>(), //
        make_unique<ReadMediaPlaybackClientGeneratedCommandList>(), //
        make_unique<ReportMediaPlaybackClientGeneratedCommandList>(), //
        make_unique<ReadMediaPlaybackAttributeList>(), //
        make_unique<ReportMediaPlaybackAttributeList>(), //
        make_unique<ReadMediaPlaybackClusterRevision>(), //
        make_unique<ReportMediaPlaybackClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterModeSelect(Commands & commands)
{
    const char * clusterName = "ModeSelect";

    commands_list clusterCommands = {
        make_unique<ModeSelectChangeToMode>(), //
        make_unique<ReadModeSelectCurrentMode>(), //
        make_unique<ReportModeSelectCurrentMode>(), //
        make_unique<ReadModeSelectSupportedModes>(), //
        make_unique<ReportModeSelectSupportedModes>(), //
        make_unique<ReadModeSelectOnMode>(), //
        make_unique<WriteModeSelectOnMode>(), //
        make_unique<ReportModeSelectOnMode>(), //
        make_unique<ReadModeSelectStartUpMode>(), //
        make_unique<ReportModeSelectStartUpMode>(), //
        make_unique<ReadModeSelectDescription>(), //
        make_unique<ReportModeSelectDescription>(), //
        make_unique<ReadModeSelectServerGeneratedCommandList>(), //
        make_unique<ReportModeSelectServerGeneratedCommandList>(), //
        make_unique<ReadModeSelectClientGeneratedCommandList>(), //
        make_unique<ReportModeSelectClientGeneratedCommandList>(), //
        make_unique<ReadModeSelectAttributeList>(), //
        make_unique<ReportModeSelectAttributeList>(), //
        make_unique<ReadModeSelectClusterRevision>(), //
        make_unique<ReportModeSelectClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterNetworkCommissioning(Commands & commands)
{
    const char * clusterName = "NetworkCommissioning";

    commands_list clusterCommands = {
        make_unique<NetworkCommissioningAddOrUpdateThreadNetwork>(), //
        make_unique<NetworkCommissioningAddOrUpdateWiFiNetwork>(), //
        make_unique<NetworkCommissioningConnectNetwork>(), //
        make_unique<NetworkCommissioningRemoveNetwork>(), //
        make_unique<NetworkCommissioningReorderNetwork>(), //
        make_unique<NetworkCommissioningScanNetworks>(), //
        make_unique<ReadNetworkCommissioningMaxNetworks>(), //
        make_unique<ReportNetworkCommissioningMaxNetworks>(), //
        make_unique<ReadNetworkCommissioningNetworks>(), //
        make_unique<ReportNetworkCommissioningNetworks>(), //
        make_unique<ReadNetworkCommissioningScanMaxTimeSeconds>(), //
        make_unique<ReportNetworkCommissioningScanMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<ReportNetworkCommissioningConnectMaxTimeSeconds>(), //
        make_unique<ReadNetworkCommissioningInterfaceEnabled>(), //
        make_unique<WriteNetworkCommissioningInterfaceEnabled>(), //
        make_unique<ReportNetworkCommissioningInterfaceEnabled>(), //
        make_unique<ReadNetworkCommissioningLastNetworkingStatus>(), //
        make_unique<ReportNetworkCommissioningLastNetworkingStatus>(), //
        make_unique<ReadNetworkCommissioningLastNetworkID>(), //
        make_unique<ReportNetworkCommissioningLastNetworkID>(), //
        make_unique<ReadNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<ReportNetworkCommissioningLastConnectErrorValue>(), //
        make_unique<ReadNetworkCommissioningServerGeneratedCommandList>(), //
        make_unique<ReportNetworkCommissioningServerGeneratedCommandList>(), //
        make_unique<ReadNetworkCommissioningClientGeneratedCommandList>(), //
        make_unique<ReportNetworkCommissioningClientGeneratedCommandList>(), //
        make_unique<ReadNetworkCommissioningFeatureMap>(), //
        make_unique<ReportNetworkCommissioningFeatureMap>(), //
        make_unique<ReadNetworkCommissioningClusterRevision>(), //
        make_unique<ReportNetworkCommissioningClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateProvider(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateProvider";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateProviderApplyUpdateRequest>(), //
        make_unique<OtaSoftwareUpdateProviderNotifyUpdateApplied>(), //
        make_unique<OtaSoftwareUpdateProviderQueryImage>(), //
        make_unique<ReadOtaSoftwareUpdateProviderAttributeList>(), //
        make_unique<ReportOtaSoftwareUpdateProviderAttributeList>(), //
        make_unique<ReadOtaSoftwareUpdateProviderClusterRevision>(), //
        make_unique<ReportOtaSoftwareUpdateProviderClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOtaSoftwareUpdateRequestor(Commands & commands)
{
    const char * clusterName = "OtaSoftwareUpdateRequestor";

    commands_list clusterCommands = {
        make_unique<OtaSoftwareUpdateRequestorAnnounceOtaProvider>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorDefaultOtaProviders>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdatePossible>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdatePossible>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateState>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdateState>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorUpdateStateProgress>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorAttributeList>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorAttributeList>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorClusterRevision>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorClusterRevision>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorStateTransition>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorStateTransition>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorVersionApplied>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorVersionApplied>(), //
        make_unique<ReadOtaSoftwareUpdateRequestorDownloadError>(), //
        make_unique<ReportOtaSoftwareUpdateRequestorDownloadError>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOccupancySensing(Commands & commands)
{
    const char * clusterName = "OccupancySensing";

    commands_list clusterCommands = {
        make_unique<ReadOccupancySensingOccupancy>(), //
        make_unique<ReportOccupancySensingOccupancy>(), //
        make_unique<ReadOccupancySensingOccupancySensorType>(), //
        make_unique<ReportOccupancySensingOccupancySensorType>(), //
        make_unique<ReadOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<ReportOccupancySensingOccupancySensorTypeBitmap>(), //
        make_unique<ReadOccupancySensingServerGeneratedCommandList>(), //
        make_unique<ReportOccupancySensingServerGeneratedCommandList>(), //
        make_unique<ReadOccupancySensingClientGeneratedCommandList>(), //
        make_unique<ReportOccupancySensingClientGeneratedCommandList>(), //
        make_unique<ReadOccupancySensingAttributeList>(), //
        make_unique<ReportOccupancySensingAttributeList>(), //
        make_unique<ReadOccupancySensingClusterRevision>(), //
        make_unique<ReportOccupancySensingClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOff(Commands & commands)
{
    const char * clusterName = "OnOff";

    commands_list clusterCommands = {
        make_unique<OnOffOff>(), //
        make_unique<OnOffOffWithEffect>(), //
        make_unique<OnOffOn>(), //
        make_unique<OnOffOnWithRecallGlobalScene>(), //
        make_unique<OnOffOnWithTimedOff>(), //
        make_unique<OnOffToggle>(), //
        make_unique<ReadOnOffOnOff>(), //
        make_unique<ReportOnOffOnOff>(), //
        make_unique<ReadOnOffGlobalSceneControl>(), //
        make_unique<ReportOnOffGlobalSceneControl>(), //
        make_unique<ReadOnOffOnTime>(), //
        make_unique<WriteOnOffOnTime>(), //
        make_unique<ReportOnOffOnTime>(), //
        make_unique<ReadOnOffOffWaitTime>(), //
        make_unique<WriteOnOffOffWaitTime>(), //
        make_unique<ReportOnOffOffWaitTime>(), //
        make_unique<ReadOnOffStartUpOnOff>(), //
        make_unique<WriteOnOffStartUpOnOff>(), //
        make_unique<ReportOnOffStartUpOnOff>(), //
        make_unique<ReadOnOffServerGeneratedCommandList>(), //
        make_unique<ReportOnOffServerGeneratedCommandList>(), //
        make_unique<ReadOnOffClientGeneratedCommandList>(), //
        make_unique<ReportOnOffClientGeneratedCommandList>(), //
        make_unique<ReadOnOffAttributeList>(), //
        make_unique<ReportOnOffAttributeList>(), //
        make_unique<ReadOnOffFeatureMap>(), //
        make_unique<ReportOnOffFeatureMap>(), //
        make_unique<ReadOnOffClusterRevision>(), //
        make_unique<ReportOnOffClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOnOffSwitchConfiguration(Commands & commands)
{
    const char * clusterName = "OnOffSwitchConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadOnOffSwitchConfigurationSwitchType>(), //
        make_unique<ReportOnOffSwitchConfigurationSwitchType>(), //
        make_unique<ReadOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<WriteOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<ReportOnOffSwitchConfigurationSwitchActions>(), //
        make_unique<ReadOnOffSwitchConfigurationServerGeneratedCommandList>(), //
        make_unique<ReportOnOffSwitchConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadOnOffSwitchConfigurationClientGeneratedCommandList>(), //
        make_unique<ReportOnOffSwitchConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadOnOffSwitchConfigurationAttributeList>(), //
        make_unique<ReportOnOffSwitchConfigurationAttributeList>(), //
        make_unique<ReadOnOffSwitchConfigurationClusterRevision>(), //
        make_unique<ReportOnOffSwitchConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterOperationalCredentials(Commands & commands)
{
    const char * clusterName = "OperationalCredentials";

    commands_list clusterCommands = {
        make_unique<OperationalCredentialsAddNOC>(), //
        make_unique<OperationalCredentialsAddTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsAttestationRequest>(), //
        make_unique<OperationalCredentialsCSRRequest>(), //
        make_unique<OperationalCredentialsCertificateChainRequest>(), //
        make_unique<OperationalCredentialsRemoveFabric>(), //
        make_unique<OperationalCredentialsRemoveTrustedRootCertificate>(), //
        make_unique<OperationalCredentialsUpdateFabricLabel>(), //
        make_unique<OperationalCredentialsUpdateNOC>(), //
        make_unique<ReadOperationalCredentialsNOCs>(), //
        make_unique<ReportOperationalCredentialsNOCs>(), //
        make_unique<ReadOperationalCredentialsFabricsList>(), //
        make_unique<ReportOperationalCredentialsFabricsList>(), //
        make_unique<ReadOperationalCredentialsSupportedFabrics>(), //
        make_unique<ReportOperationalCredentialsSupportedFabrics>(), //
        make_unique<ReadOperationalCredentialsCommissionedFabrics>(), //
        make_unique<ReportOperationalCredentialsCommissionedFabrics>(), //
        make_unique<ReadOperationalCredentialsTrustedRootCertificates>(), //
        make_unique<ReportOperationalCredentialsTrustedRootCertificates>(), //
        make_unique<ReadOperationalCredentialsCurrentFabricIndex>(), //
        make_unique<ReportOperationalCredentialsCurrentFabricIndex>(), //
        make_unique<ReadOperationalCredentialsServerGeneratedCommandList>(), //
        make_unique<ReportOperationalCredentialsServerGeneratedCommandList>(), //
        make_unique<ReadOperationalCredentialsClientGeneratedCommandList>(), //
        make_unique<ReportOperationalCredentialsClientGeneratedCommandList>(), //
        make_unique<ReadOperationalCredentialsAttributeList>(), //
        make_unique<ReportOperationalCredentialsAttributeList>(), //
        make_unique<ReadOperationalCredentialsClusterRevision>(), //
        make_unique<ReportOperationalCredentialsClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSource(Commands & commands)
{
    const char * clusterName = "PowerSource";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceStatus>(), //
        make_unique<ReportPowerSourceStatus>(), //
        make_unique<ReadPowerSourceOrder>(), //
        make_unique<ReportPowerSourceOrder>(), //
        make_unique<ReadPowerSourceDescription>(), //
        make_unique<ReportPowerSourceDescription>(), //
        make_unique<ReadPowerSourceBatteryVoltage>(), //
        make_unique<ReportPowerSourceBatteryVoltage>(), //
        make_unique<ReadPowerSourceBatteryPercentRemaining>(), //
        make_unique<ReportPowerSourceBatteryPercentRemaining>(), //
        make_unique<ReadPowerSourceBatteryTimeRemaining>(), //
        make_unique<ReportPowerSourceBatteryTimeRemaining>(), //
        make_unique<ReadPowerSourceBatteryChargeLevel>(), //
        make_unique<ReportPowerSourceBatteryChargeLevel>(), //
        make_unique<ReadPowerSourceActiveBatteryFaults>(), //
        make_unique<ReportPowerSourceActiveBatteryFaults>(), //
        make_unique<ReadPowerSourceBatteryChargeState>(), //
        make_unique<ReportPowerSourceBatteryChargeState>(), //
        make_unique<ReadPowerSourceServerGeneratedCommandList>(), //
        make_unique<ReportPowerSourceServerGeneratedCommandList>(), //
        make_unique<ReadPowerSourceClientGeneratedCommandList>(), //
        make_unique<ReportPowerSourceClientGeneratedCommandList>(), //
        make_unique<ReadPowerSourceAttributeList>(), //
        make_unique<ReportPowerSourceAttributeList>(), //
        make_unique<ReadPowerSourceFeatureMap>(), //
        make_unique<ReportPowerSourceFeatureMap>(), //
        make_unique<ReadPowerSourceClusterRevision>(), //
        make_unique<ReportPowerSourceClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPowerSourceConfiguration(Commands & commands)
{
    const char * clusterName = "PowerSourceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadPowerSourceConfigurationSources>(), //
        make_unique<ReportPowerSourceConfigurationSources>(), //
        make_unique<ReadPowerSourceConfigurationServerGeneratedCommandList>(), //
        make_unique<ReportPowerSourceConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadPowerSourceConfigurationClientGeneratedCommandList>(), //
        make_unique<ReportPowerSourceConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadPowerSourceConfigurationAttributeList>(), //
        make_unique<ReportPowerSourceConfigurationAttributeList>(), //
        make_unique<ReadPowerSourceConfigurationClusterRevision>(), //
        make_unique<ReportPowerSourceConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPressureMeasurement(Commands & commands)
{
    const char * clusterName = "PressureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadPressureMeasurementMeasuredValue>(), //
        make_unique<ReportPressureMeasurementMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMinMeasuredValue>(), //
        make_unique<ReportPressureMeasurementMinMeasuredValue>(), //
        make_unique<ReadPressureMeasurementMaxMeasuredValue>(), //
        make_unique<ReportPressureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadPressureMeasurementAttributeList>(), //
        make_unique<ReportPressureMeasurementAttributeList>(), //
        make_unique<ReadPressureMeasurementClusterRevision>(), //
        make_unique<ReportPressureMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterPumpConfigurationAndControl(Commands & commands)
{
    const char * clusterName = "PumpConfigurationAndControl";

    commands_list clusterCommands = {
        make_unique<ReadPumpConfigurationAndControlMaxPressure>(), //
        make_unique<ReportPumpConfigurationAndControlMaxPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxSpeed>(), //
        make_unique<ReportPumpConfigurationAndControlMaxSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMaxFlow>(), //
        make_unique<ReportPumpConfigurationAndControlMaxFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstPressure>(), //
        make_unique<ReportPumpConfigurationAndControlMinConstPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstPressure>(), //
        make_unique<ReportPumpConfigurationAndControlMaxConstPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMinCompPressure>(), //
        make_unique<ReportPumpConfigurationAndControlMinCompPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMaxCompPressure>(), //
        make_unique<ReportPumpConfigurationAndControlMaxCompPressure>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstSpeed>(), //
        make_unique<ReportPumpConfigurationAndControlMinConstSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstSpeed>(), //
        make_unique<ReportPumpConfigurationAndControlMaxConstSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstFlow>(), //
        make_unique<ReportPumpConfigurationAndControlMinConstFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstFlow>(), //
        make_unique<ReportPumpConfigurationAndControlMaxConstFlow>(), //
        make_unique<ReadPumpConfigurationAndControlMinConstTemp>(), //
        make_unique<ReportPumpConfigurationAndControlMinConstTemp>(), //
        make_unique<ReadPumpConfigurationAndControlMaxConstTemp>(), //
        make_unique<ReportPumpConfigurationAndControlMaxConstTemp>(), //
        make_unique<ReadPumpConfigurationAndControlPumpStatus>(), //
        make_unique<ReportPumpConfigurationAndControlPumpStatus>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<ReportPumpConfigurationAndControlEffectiveOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlEffectiveControlMode>(), //
        make_unique<ReportPumpConfigurationAndControlEffectiveControlMode>(), //
        make_unique<ReadPumpConfigurationAndControlCapacity>(), //
        make_unique<ReportPumpConfigurationAndControlCapacity>(), //
        make_unique<ReadPumpConfigurationAndControlSpeed>(), //
        make_unique<ReportPumpConfigurationAndControlSpeed>(), //
        make_unique<ReadPumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<WritePumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<ReportPumpConfigurationAndControlLifetimeRunningHours>(), //
        make_unique<ReadPumpConfigurationAndControlPower>(), //
        make_unique<ReportPumpConfigurationAndControlPower>(), //
        make_unique<ReadPumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<WritePumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<ReportPumpConfigurationAndControlLifetimeEnergyConsumed>(), //
        make_unique<ReadPumpConfigurationAndControlOperationMode>(), //
        make_unique<WritePumpConfigurationAndControlOperationMode>(), //
        make_unique<ReportPumpConfigurationAndControlOperationMode>(), //
        make_unique<ReadPumpConfigurationAndControlControlMode>(), //
        make_unique<WritePumpConfigurationAndControlControlMode>(), //
        make_unique<ReportPumpConfigurationAndControlControlMode>(), //
        make_unique<ReadPumpConfigurationAndControlAlarmMask>(), //
        make_unique<ReportPumpConfigurationAndControlAlarmMask>(), //
        make_unique<ReadPumpConfigurationAndControlServerGeneratedCommandList>(), //
        make_unique<ReportPumpConfigurationAndControlServerGeneratedCommandList>(), //
        make_unique<ReadPumpConfigurationAndControlClientGeneratedCommandList>(), //
        make_unique<ReportPumpConfigurationAndControlClientGeneratedCommandList>(), //
        make_unique<ReadPumpConfigurationAndControlAttributeList>(), //
        make_unique<ReportPumpConfigurationAndControlAttributeList>(), //
        make_unique<ReadPumpConfigurationAndControlFeatureMap>(), //
        make_unique<ReportPumpConfigurationAndControlFeatureMap>(), //
        make_unique<ReadPumpConfigurationAndControlClusterRevision>(), //
        make_unique<ReportPumpConfigurationAndControlClusterRevision>(), //
        make_unique<ReadPumpConfigurationAndControlSupplyVoltageLow>(), //
        make_unique<ReportPumpConfigurationAndControlSupplyVoltageLow>(), //
        make_unique<ReadPumpConfigurationAndControlSupplyVoltageHigh>(), //
        make_unique<ReportPumpConfigurationAndControlSupplyVoltageHigh>(), //
        make_unique<ReadPumpConfigurationAndControlPowerMissingPhase>(), //
        make_unique<ReportPumpConfigurationAndControlPowerMissingPhase>(), //
        make_unique<ReadPumpConfigurationAndControlSystemPressureLow>(), //
        make_unique<ReportPumpConfigurationAndControlSystemPressureLow>(), //
        make_unique<ReadPumpConfigurationAndControlSystemPressureHigh>(), //
        make_unique<ReportPumpConfigurationAndControlSystemPressureHigh>(), //
        make_unique<ReadPumpConfigurationAndControlDryRunning>(), //
        make_unique<ReportPumpConfigurationAndControlDryRunning>(), //
        make_unique<ReadPumpConfigurationAndControlMotorTemperatureHigh>(), //
        make_unique<ReportPumpConfigurationAndControlMotorTemperatureHigh>(), //
        make_unique<ReadPumpConfigurationAndControlPumpMotorFatalFailure>(), //
        make_unique<ReportPumpConfigurationAndControlPumpMotorFatalFailure>(), //
        make_unique<ReadPumpConfigurationAndControlElectronicTemperatureHigh>(), //
        make_unique<ReportPumpConfigurationAndControlElectronicTemperatureHigh>(), //
        make_unique<ReadPumpConfigurationAndControlPumpBlocked>(), //
        make_unique<ReportPumpConfigurationAndControlPumpBlocked>(), //
        make_unique<ReadPumpConfigurationAndControlSensorFailure>(), //
        make_unique<ReportPumpConfigurationAndControlSensorFailure>(), //
        make_unique<ReadPumpConfigurationAndControlElectronicNonFatalFailure>(), //
        make_unique<ReportPumpConfigurationAndControlElectronicNonFatalFailure>(), //
        make_unique<ReadPumpConfigurationAndControlElectronicFatalFailure>(), //
        make_unique<ReportPumpConfigurationAndControlElectronicFatalFailure>(), //
        make_unique<ReadPumpConfigurationAndControlGeneralFault>(), //
        make_unique<ReportPumpConfigurationAndControlGeneralFault>(), //
        make_unique<ReadPumpConfigurationAndControlLeakage>(), //
        make_unique<ReportPumpConfigurationAndControlLeakage>(), //
        make_unique<ReadPumpConfigurationAndControlAirDetection>(), //
        make_unique<ReportPumpConfigurationAndControlAirDetection>(), //
        make_unique<ReadPumpConfigurationAndControlTurbineOperation>(), //
        make_unique<ReportPumpConfigurationAndControlTurbineOperation>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterRelativeHumidityMeasurement(Commands & commands)
{
    const char * clusterName = "RelativeHumidityMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadRelativeHumidityMeasurementMeasuredValue>(), //
        make_unique<ReportRelativeHumidityMeasurementMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<ReportRelativeHumidityMeasurementMinMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<ReportRelativeHumidityMeasurementMaxMeasuredValue>(), //
        make_unique<ReadRelativeHumidityMeasurementTolerance>(), //
        make_unique<ReportRelativeHumidityMeasurementTolerance>(), //
        make_unique<ReadRelativeHumidityMeasurementServerGeneratedCommandList>(), //
        make_unique<ReportRelativeHumidityMeasurementServerGeneratedCommandList>(), //
        make_unique<ReadRelativeHumidityMeasurementClientGeneratedCommandList>(), //
        make_unique<ReportRelativeHumidityMeasurementClientGeneratedCommandList>(), //
        make_unique<ReadRelativeHumidityMeasurementAttributeList>(), //
        make_unique<ReportRelativeHumidityMeasurementAttributeList>(), //
        make_unique<ReadRelativeHumidityMeasurementClusterRevision>(), //
        make_unique<ReportRelativeHumidityMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterScenes(Commands & commands)
{
    const char * clusterName = "Scenes";

    commands_list clusterCommands = {
        make_unique<ScenesAddScene>(), //
        make_unique<ScenesGetSceneMembership>(), //
        make_unique<ScenesRecallScene>(), //
        make_unique<ScenesRemoveAllScenes>(), //
        make_unique<ScenesRemoveScene>(), //
        make_unique<ScenesStoreScene>(), //
        make_unique<ScenesViewScene>(), //
        make_unique<ReadScenesSceneCount>(), //
        make_unique<ReportScenesSceneCount>(), //
        make_unique<ReadScenesCurrentScene>(), //
        make_unique<ReportScenesCurrentScene>(), //
        make_unique<ReadScenesCurrentGroup>(), //
        make_unique<ReportScenesCurrentGroup>(), //
        make_unique<ReadScenesSceneValid>(), //
        make_unique<ReportScenesSceneValid>(), //
        make_unique<ReadScenesNameSupport>(), //
        make_unique<ReportScenesNameSupport>(), //
        make_unique<ReadScenesServerGeneratedCommandList>(), //
        make_unique<ReportScenesServerGeneratedCommandList>(), //
        make_unique<ReadScenesClientGeneratedCommandList>(), //
        make_unique<ReportScenesClientGeneratedCommandList>(), //
        make_unique<ReadScenesAttributeList>(), //
        make_unique<ReportScenesAttributeList>(), //
        make_unique<ReadScenesClusterRevision>(), //
        make_unique<ReportScenesClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSoftwareDiagnostics(Commands & commands)
{
    const char * clusterName = "SoftwareDiagnostics";

    commands_list clusterCommands = {
        make_unique<SoftwareDiagnosticsResetWatermarks>(), //
        make_unique<ReadSoftwareDiagnosticsThreadMetrics>(), //
        make_unique<ReportSoftwareDiagnosticsThreadMetrics>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapFree>(), //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapFree>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapUsed>(), //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapUsed>(), //
        make_unique<ReadSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<ReportSoftwareDiagnosticsCurrentHeapHighWatermark>(), //
        make_unique<ReadSoftwareDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReportSoftwareDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadSoftwareDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReportSoftwareDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadSoftwareDiagnosticsAttributeList>(), //
        make_unique<ReportSoftwareDiagnosticsAttributeList>(), //
        make_unique<ReadSoftwareDiagnosticsFeatureMap>(), //
        make_unique<ReportSoftwareDiagnosticsFeatureMap>(), //
        make_unique<ReadSoftwareDiagnosticsClusterRevision>(), //
        make_unique<ReportSoftwareDiagnosticsClusterRevision>(), //
        make_unique<ReadSoftwareDiagnosticsSoftwareFault>(), //
        make_unique<ReportSoftwareDiagnosticsSoftwareFault>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterSwitch(Commands & commands)
{
    const char * clusterName = "Switch";

    commands_list clusterCommands = {
        make_unique<ReadSwitchNumberOfPositions>(), //
        make_unique<ReportSwitchNumberOfPositions>(), //
        make_unique<ReadSwitchCurrentPosition>(), //
        make_unique<ReportSwitchCurrentPosition>(), //
        make_unique<ReadSwitchMultiPressMax>(), //
        make_unique<ReportSwitchMultiPressMax>(), //
        make_unique<ReadSwitchServerGeneratedCommandList>(), //
        make_unique<ReportSwitchServerGeneratedCommandList>(), //
        make_unique<ReadSwitchClientGeneratedCommandList>(), //
        make_unique<ReportSwitchClientGeneratedCommandList>(), //
        make_unique<ReadSwitchAttributeList>(), //
        make_unique<ReportSwitchAttributeList>(), //
        make_unique<ReadSwitchFeatureMap>(), //
        make_unique<ReportSwitchFeatureMap>(), //
        make_unique<ReadSwitchClusterRevision>(), //
        make_unique<ReportSwitchClusterRevision>(), //
        make_unique<ReadSwitchSwitchLatched>(), //
        make_unique<ReportSwitchSwitchLatched>(), //
        make_unique<ReadSwitchInitialPress>(), //
        make_unique<ReportSwitchInitialPress>(), //
        make_unique<ReadSwitchLongPress>(), //
        make_unique<ReportSwitchLongPress>(), //
        make_unique<ReadSwitchShortRelease>(), //
        make_unique<ReportSwitchShortRelease>(), //
        make_unique<ReadSwitchLongRelease>(), //
        make_unique<ReportSwitchLongRelease>(), //
        make_unique<ReadSwitchMultiPressOngoing>(), //
        make_unique<ReportSwitchMultiPressOngoing>(), //
        make_unique<ReadSwitchMultiPressComplete>(), //
        make_unique<ReportSwitchMultiPressComplete>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTargetNavigator(Commands & commands)
{
    const char * clusterName = "TargetNavigator";

    commands_list clusterCommands = {
        make_unique<TargetNavigatorNavigateTargetRequest>(), //
        make_unique<ReadTargetNavigatorTargetNavigatorList>(), //
        make_unique<ReportTargetNavigatorTargetNavigatorList>(), //
        make_unique<ReadTargetNavigatorCurrentNavigatorTarget>(), //
        make_unique<ReportTargetNavigatorCurrentNavigatorTarget>(), //
        make_unique<ReadTargetNavigatorServerGeneratedCommandList>(), //
        make_unique<ReportTargetNavigatorServerGeneratedCommandList>(), //
        make_unique<ReadTargetNavigatorClientGeneratedCommandList>(), //
        make_unique<ReportTargetNavigatorClientGeneratedCommandList>(), //
        make_unique<ReadTargetNavigatorAttributeList>(), //
        make_unique<ReportTargetNavigatorAttributeList>(), //
        make_unique<ReadTargetNavigatorClusterRevision>(), //
        make_unique<ReportTargetNavigatorClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTemperatureMeasurement(Commands & commands)
{
    const char * clusterName = "TemperatureMeasurement";

    commands_list clusterCommands = {
        make_unique<ReadTemperatureMeasurementMeasuredValue>(), //
        make_unique<ReportTemperatureMeasurementMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<ReportTemperatureMeasurementMinMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<ReportTemperatureMeasurementMaxMeasuredValue>(), //
        make_unique<ReadTemperatureMeasurementTolerance>(), //
        make_unique<ReportTemperatureMeasurementTolerance>(), //
        make_unique<ReadTemperatureMeasurementAttributeList>(), //
        make_unique<ReportTemperatureMeasurementAttributeList>(), //
        make_unique<ReadTemperatureMeasurementClusterRevision>(), //
        make_unique<ReportTemperatureMeasurementClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTestCluster(Commands & commands)
{
    const char * clusterName = "TestCluster";

    commands_list clusterCommands = {
        make_unique<TestClusterSimpleStructEchoRequest>(), //
        make_unique<TestClusterTest>(), //
        make_unique<TestClusterTestAddArguments>(), //
        make_unique<TestClusterTestEmitTestEventRequest>(), //
        make_unique<TestClusterTestEnumsRequest>(), //
        make_unique<TestClusterTestListInt8UArgumentRequest>(), //
        make_unique<TestClusterTestListInt8UReverseRequest>(), //
        make_unique<TestClusterTestListNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestListStructArgumentRequest>(), //
        make_unique<TestClusterTestNestedStructArgumentRequest>(), //
        make_unique<TestClusterTestNestedStructListArgumentRequest>(), //
        make_unique<TestClusterTestNotHandled>(), //
        make_unique<TestClusterTestNullableOptionalRequest>(), //
        make_unique<TestClusterTestSimpleOptionalArgumentRequest>(), //
        make_unique<TestClusterTestSpecific>(), //
        make_unique<TestClusterTestStructArgumentRequest>(), //
        make_unique<TestClusterTestUnknownCommand>(), //
        make_unique<TestClusterTimedInvokeRequest>(), //
        make_unique<ReadTestClusterBoolean>(), //
        make_unique<WriteTestClusterBoolean>(), //
        make_unique<ReportTestClusterBoolean>(), //
        make_unique<ReadTestClusterBitmap8>(), //
        make_unique<WriteTestClusterBitmap8>(), //
        make_unique<ReportTestClusterBitmap8>(), //
        make_unique<ReadTestClusterBitmap16>(), //
        make_unique<WriteTestClusterBitmap16>(), //
        make_unique<ReportTestClusterBitmap16>(), //
        make_unique<ReadTestClusterBitmap32>(), //
        make_unique<WriteTestClusterBitmap32>(), //
        make_unique<ReportTestClusterBitmap32>(), //
        make_unique<ReadTestClusterBitmap64>(), //
        make_unique<WriteTestClusterBitmap64>(), //
        make_unique<ReportTestClusterBitmap64>(), //
        make_unique<ReadTestClusterInt8u>(), //
        make_unique<WriteTestClusterInt8u>(), //
        make_unique<ReportTestClusterInt8u>(), //
        make_unique<ReadTestClusterInt16u>(), //
        make_unique<WriteTestClusterInt16u>(), //
        make_unique<ReportTestClusterInt16u>(), //
        make_unique<ReadTestClusterInt24u>(), //
        make_unique<WriteTestClusterInt24u>(), //
        make_unique<ReportTestClusterInt24u>(), //
        make_unique<ReadTestClusterInt32u>(), //
        make_unique<WriteTestClusterInt32u>(), //
        make_unique<ReportTestClusterInt32u>(), //
        make_unique<ReadTestClusterInt40u>(), //
        make_unique<WriteTestClusterInt40u>(), //
        make_unique<ReportTestClusterInt40u>(), //
        make_unique<ReadTestClusterInt48u>(), //
        make_unique<WriteTestClusterInt48u>(), //
        make_unique<ReportTestClusterInt48u>(), //
        make_unique<ReadTestClusterInt56u>(), //
        make_unique<WriteTestClusterInt56u>(), //
        make_unique<ReportTestClusterInt56u>(), //
        make_unique<ReadTestClusterInt64u>(), //
        make_unique<WriteTestClusterInt64u>(), //
        make_unique<ReportTestClusterInt64u>(), //
        make_unique<ReadTestClusterInt8s>(), //
        make_unique<WriteTestClusterInt8s>(), //
        make_unique<ReportTestClusterInt8s>(), //
        make_unique<ReadTestClusterInt16s>(), //
        make_unique<WriteTestClusterInt16s>(), //
        make_unique<ReportTestClusterInt16s>(), //
        make_unique<ReadTestClusterInt24s>(), //
        make_unique<WriteTestClusterInt24s>(), //
        make_unique<ReportTestClusterInt24s>(), //
        make_unique<ReadTestClusterInt32s>(), //
        make_unique<WriteTestClusterInt32s>(), //
        make_unique<ReportTestClusterInt32s>(), //
        make_unique<ReadTestClusterInt40s>(), //
        make_unique<WriteTestClusterInt40s>(), //
        make_unique<ReportTestClusterInt40s>(), //
        make_unique<ReadTestClusterInt48s>(), //
        make_unique<WriteTestClusterInt48s>(), //
        make_unique<ReportTestClusterInt48s>(), //
        make_unique<ReadTestClusterInt56s>(), //
        make_unique<WriteTestClusterInt56s>(), //
        make_unique<ReportTestClusterInt56s>(), //
        make_unique<ReadTestClusterInt64s>(), //
        make_unique<WriteTestClusterInt64s>(), //
        make_unique<ReportTestClusterInt64s>(), //
        make_unique<ReadTestClusterEnum8>(), //
        make_unique<WriteTestClusterEnum8>(), //
        make_unique<ReportTestClusterEnum8>(), //
        make_unique<ReadTestClusterEnum16>(), //
        make_unique<WriteTestClusterEnum16>(), //
        make_unique<ReportTestClusterEnum16>(), //
        make_unique<ReadTestClusterFloatSingle>(), //
        make_unique<WriteTestClusterFloatSingle>(), //
        make_unique<ReportTestClusterFloatSingle>(), //
        make_unique<ReadTestClusterFloatDouble>(), //
        make_unique<WriteTestClusterFloatDouble>(), //
        make_unique<ReportTestClusterFloatDouble>(), //
        make_unique<ReadTestClusterOctetString>(), //
        make_unique<WriteTestClusterOctetString>(), //
        make_unique<ReportTestClusterOctetString>(), //
        make_unique<ReadTestClusterListInt8u>(), //
        make_unique<ReportTestClusterListInt8u>(), //
        make_unique<ReadTestClusterListOctetString>(), //
        make_unique<ReportTestClusterListOctetString>(), //
        make_unique<ReadTestClusterListStructOctetString>(), //
        make_unique<ReportTestClusterListStructOctetString>(), //
        make_unique<ReadTestClusterLongOctetString>(), //
        make_unique<WriteTestClusterLongOctetString>(), //
        make_unique<ReportTestClusterLongOctetString>(), //
        make_unique<ReadTestClusterCharString>(), //
        make_unique<WriteTestClusterCharString>(), //
        make_unique<ReportTestClusterCharString>(), //
        make_unique<ReadTestClusterLongCharString>(), //
        make_unique<WriteTestClusterLongCharString>(), //
        make_unique<ReportTestClusterLongCharString>(), //
        make_unique<ReadTestClusterEpochUs>(), //
        make_unique<WriteTestClusterEpochUs>(), //
        make_unique<ReportTestClusterEpochUs>(), //
        make_unique<ReadTestClusterEpochS>(), //
        make_unique<WriteTestClusterEpochS>(), //
        make_unique<ReportTestClusterEpochS>(), //
        make_unique<ReadTestClusterVendorId>(), //
        make_unique<WriteTestClusterVendorId>(), //
        make_unique<ReportTestClusterVendorId>(), //
        make_unique<ReadTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<ReportTestClusterListNullablesAndOptionalsStruct>(), //
        make_unique<ReadTestClusterEnumAttr>(), //
        make_unique<WriteTestClusterEnumAttr>(), //
        make_unique<ReportTestClusterEnumAttr>(), //
        make_unique<ReadTestClusterRangeRestrictedInt8u>(), //
        make_unique<WriteTestClusterRangeRestrictedInt8u>(), //
        make_unique<ReportTestClusterRangeRestrictedInt8u>(), //
        make_unique<ReadTestClusterRangeRestrictedInt8s>(), //
        make_unique<WriteTestClusterRangeRestrictedInt8s>(), //
        make_unique<ReportTestClusterRangeRestrictedInt8s>(), //
        make_unique<ReadTestClusterRangeRestrictedInt16u>(), //
        make_unique<WriteTestClusterRangeRestrictedInt16u>(), //
        make_unique<ReportTestClusterRangeRestrictedInt16u>(), //
        make_unique<ReadTestClusterRangeRestrictedInt16s>(), //
        make_unique<WriteTestClusterRangeRestrictedInt16s>(), //
        make_unique<ReportTestClusterRangeRestrictedInt16s>(), //
        make_unique<ReadTestClusterListLongOctetString>(), //
        make_unique<ReportTestClusterListLongOctetString>(), //
        make_unique<ReadTestClusterTimedWriteBoolean>(), //
        make_unique<WriteTestClusterTimedWriteBoolean>(), //
        make_unique<ReportTestClusterTimedWriteBoolean>(), //
        make_unique<ReadTestClusterGeneralErrorBoolean>(), //
        make_unique<WriteTestClusterGeneralErrorBoolean>(), //
        make_unique<ReportTestClusterGeneralErrorBoolean>(), //
        make_unique<ReadTestClusterClusterErrorBoolean>(), //
        make_unique<WriteTestClusterClusterErrorBoolean>(), //
        make_unique<ReportTestClusterClusterErrorBoolean>(), //
        make_unique<ReadTestClusterUnsupported>(), //
        make_unique<WriteTestClusterUnsupported>(), //
        make_unique<ReportTestClusterUnsupported>(), //
        make_unique<ReadTestClusterNullableBoolean>(), //
        make_unique<WriteTestClusterNullableBoolean>(), //
        make_unique<ReportTestClusterNullableBoolean>(), //
        make_unique<ReadTestClusterNullableBitmap8>(), //
        make_unique<WriteTestClusterNullableBitmap8>(), //
        make_unique<ReportTestClusterNullableBitmap8>(), //
        make_unique<ReadTestClusterNullableBitmap16>(), //
        make_unique<WriteTestClusterNullableBitmap16>(), //
        make_unique<ReportTestClusterNullableBitmap16>(), //
        make_unique<ReadTestClusterNullableBitmap32>(), //
        make_unique<WriteTestClusterNullableBitmap32>(), //
        make_unique<ReportTestClusterNullableBitmap32>(), //
        make_unique<ReadTestClusterNullableBitmap64>(), //
        make_unique<WriteTestClusterNullableBitmap64>(), //
        make_unique<ReportTestClusterNullableBitmap64>(), //
        make_unique<ReadTestClusterNullableInt8u>(), //
        make_unique<WriteTestClusterNullableInt8u>(), //
        make_unique<ReportTestClusterNullableInt8u>(), //
        make_unique<ReadTestClusterNullableInt16u>(), //
        make_unique<WriteTestClusterNullableInt16u>(), //
        make_unique<ReportTestClusterNullableInt16u>(), //
        make_unique<ReadTestClusterNullableInt24u>(), //
        make_unique<WriteTestClusterNullableInt24u>(), //
        make_unique<ReportTestClusterNullableInt24u>(), //
        make_unique<ReadTestClusterNullableInt32u>(), //
        make_unique<WriteTestClusterNullableInt32u>(), //
        make_unique<ReportTestClusterNullableInt32u>(), //
        make_unique<ReadTestClusterNullableInt40u>(), //
        make_unique<WriteTestClusterNullableInt40u>(), //
        make_unique<ReportTestClusterNullableInt40u>(), //
        make_unique<ReadTestClusterNullableInt48u>(), //
        make_unique<WriteTestClusterNullableInt48u>(), //
        make_unique<ReportTestClusterNullableInt48u>(), //
        make_unique<ReadTestClusterNullableInt56u>(), //
        make_unique<WriteTestClusterNullableInt56u>(), //
        make_unique<ReportTestClusterNullableInt56u>(), //
        make_unique<ReadTestClusterNullableInt64u>(), //
        make_unique<WriteTestClusterNullableInt64u>(), //
        make_unique<ReportTestClusterNullableInt64u>(), //
        make_unique<ReadTestClusterNullableInt8s>(), //
        make_unique<WriteTestClusterNullableInt8s>(), //
        make_unique<ReportTestClusterNullableInt8s>(), //
        make_unique<ReadTestClusterNullableInt16s>(), //
        make_unique<WriteTestClusterNullableInt16s>(), //
        make_unique<ReportTestClusterNullableInt16s>(), //
        make_unique<ReadTestClusterNullableInt24s>(), //
        make_unique<WriteTestClusterNullableInt24s>(), //
        make_unique<ReportTestClusterNullableInt24s>(), //
        make_unique<ReadTestClusterNullableInt32s>(), //
        make_unique<WriteTestClusterNullableInt32s>(), //
        make_unique<ReportTestClusterNullableInt32s>(), //
        make_unique<ReadTestClusterNullableInt40s>(), //
        make_unique<WriteTestClusterNullableInt40s>(), //
        make_unique<ReportTestClusterNullableInt40s>(), //
        make_unique<ReadTestClusterNullableInt48s>(), //
        make_unique<WriteTestClusterNullableInt48s>(), //
        make_unique<ReportTestClusterNullableInt48s>(), //
        make_unique<ReadTestClusterNullableInt56s>(), //
        make_unique<WriteTestClusterNullableInt56s>(), //
        make_unique<ReportTestClusterNullableInt56s>(), //
        make_unique<ReadTestClusterNullableInt64s>(), //
        make_unique<WriteTestClusterNullableInt64s>(), //
        make_unique<ReportTestClusterNullableInt64s>(), //
        make_unique<ReadTestClusterNullableEnum8>(), //
        make_unique<WriteTestClusterNullableEnum8>(), //
        make_unique<ReportTestClusterNullableEnum8>(), //
        make_unique<ReadTestClusterNullableEnum16>(), //
        make_unique<WriteTestClusterNullableEnum16>(), //
        make_unique<ReportTestClusterNullableEnum16>(), //
        make_unique<ReadTestClusterNullableFloatSingle>(), //
        make_unique<WriteTestClusterNullableFloatSingle>(), //
        make_unique<ReportTestClusterNullableFloatSingle>(), //
        make_unique<ReadTestClusterNullableFloatDouble>(), //
        make_unique<WriteTestClusterNullableFloatDouble>(), //
        make_unique<ReportTestClusterNullableFloatDouble>(), //
        make_unique<ReadTestClusterNullableOctetString>(), //
        make_unique<WriteTestClusterNullableOctetString>(), //
        make_unique<ReportTestClusterNullableOctetString>(), //
        make_unique<ReadTestClusterNullableCharString>(), //
        make_unique<WriteTestClusterNullableCharString>(), //
        make_unique<ReportTestClusterNullableCharString>(), //
        make_unique<ReadTestClusterNullableEnumAttr>(), //
        make_unique<WriteTestClusterNullableEnumAttr>(), //
        make_unique<ReportTestClusterNullableEnumAttr>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<ReportTestClusterNullableRangeRestrictedInt8u>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<ReportTestClusterNullableRangeRestrictedInt8s>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<ReportTestClusterNullableRangeRestrictedInt16u>(), //
        make_unique<ReadTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<WriteTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<ReportTestClusterNullableRangeRestrictedInt16s>(), //
        make_unique<ReadTestClusterServerGeneratedCommandList>(), //
        make_unique<ReportTestClusterServerGeneratedCommandList>(), //
        make_unique<ReadTestClusterClientGeneratedCommandList>(), //
        make_unique<ReportTestClusterClientGeneratedCommandList>(), //
        make_unique<ReadTestClusterAttributeList>(), //
        make_unique<ReportTestClusterAttributeList>(), //
        make_unique<ReadTestClusterClusterRevision>(), //
        make_unique<ReportTestClusterClusterRevision>(), //
        make_unique<ReadTestClusterTestEvent>(), //
        make_unique<ReportTestClusterTestEvent>(), //
        make_unique<ReadTestClusterTestFabricScopedEvent>(), //
        make_unique<ReportTestClusterTestFabricScopedEvent>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostat(Commands & commands)
{
    const char * clusterName = "Thermostat";

    commands_list clusterCommands = {
        make_unique<ThermostatClearWeeklySchedule>(), //
        make_unique<ThermostatGetRelayStatusLog>(), //
        make_unique<ThermostatGetWeeklySchedule>(), //
        make_unique<ThermostatSetWeeklySchedule>(), //
        make_unique<ThermostatSetpointRaiseLower>(), //
        make_unique<ReadThermostatLocalTemperature>(), //
        make_unique<ReportThermostatLocalTemperature>(), //
        make_unique<ReadThermostatAbsMinHeatSetpointLimit>(), //
        make_unique<ReportThermostatAbsMinHeatSetpointLimit>(), //
        make_unique<ReadThermostatAbsMaxHeatSetpointLimit>(), //
        make_unique<ReportThermostatAbsMaxHeatSetpointLimit>(), //
        make_unique<ReadThermostatAbsMinCoolSetpointLimit>(), //
        make_unique<ReportThermostatAbsMinCoolSetpointLimit>(), //
        make_unique<ReadThermostatAbsMaxCoolSetpointLimit>(), //
        make_unique<ReportThermostatAbsMaxCoolSetpointLimit>(), //
        make_unique<ReadThermostatOccupiedCoolingSetpoint>(), //
        make_unique<WriteThermostatOccupiedCoolingSetpoint>(), //
        make_unique<ReportThermostatOccupiedCoolingSetpoint>(), //
        make_unique<ReadThermostatOccupiedHeatingSetpoint>(), //
        make_unique<WriteThermostatOccupiedHeatingSetpoint>(), //
        make_unique<ReportThermostatOccupiedHeatingSetpoint>(), //
        make_unique<ReadThermostatMinHeatSetpointLimit>(), //
        make_unique<WriteThermostatMinHeatSetpointLimit>(), //
        make_unique<ReportThermostatMinHeatSetpointLimit>(), //
        make_unique<ReadThermostatMaxHeatSetpointLimit>(), //
        make_unique<WriteThermostatMaxHeatSetpointLimit>(), //
        make_unique<ReportThermostatMaxHeatSetpointLimit>(), //
        make_unique<ReadThermostatMinCoolSetpointLimit>(), //
        make_unique<WriteThermostatMinCoolSetpointLimit>(), //
        make_unique<ReportThermostatMinCoolSetpointLimit>(), //
        make_unique<ReadThermostatMaxCoolSetpointLimit>(), //
        make_unique<WriteThermostatMaxCoolSetpointLimit>(), //
        make_unique<ReportThermostatMaxCoolSetpointLimit>(), //
        make_unique<ReadThermostatMinSetpointDeadBand>(), //
        make_unique<WriteThermostatMinSetpointDeadBand>(), //
        make_unique<ReportThermostatMinSetpointDeadBand>(), //
        make_unique<ReadThermostatControlSequenceOfOperation>(), //
        make_unique<WriteThermostatControlSequenceOfOperation>(), //
        make_unique<ReportThermostatControlSequenceOfOperation>(), //
        make_unique<ReadThermostatSystemMode>(), //
        make_unique<WriteThermostatSystemMode>(), //
        make_unique<ReportThermostatSystemMode>(), //
        make_unique<ReadThermostatStartOfWeek>(), //
        make_unique<ReportThermostatStartOfWeek>(), //
        make_unique<ReadThermostatNumberOfWeeklyTransitions>(), //
        make_unique<ReportThermostatNumberOfWeeklyTransitions>(), //
        make_unique<ReadThermostatNumberOfDailyTransitions>(), //
        make_unique<ReportThermostatNumberOfDailyTransitions>(), //
        make_unique<ReadThermostatAttributeList>(), //
        make_unique<ReportThermostatAttributeList>(), //
        make_unique<ReadThermostatFeatureMap>(), //
        make_unique<ReportThermostatFeatureMap>(), //
        make_unique<ReadThermostatClusterRevision>(), //
        make_unique<ReportThermostatClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThermostatUserInterfaceConfiguration(Commands & commands)
{
    const char * clusterName = "ThermostatUserInterfaceConfiguration";

    commands_list clusterCommands = {
        make_unique<ReadThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationTemperatureDisplayMode>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationKeypadLockout>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<WriteThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationScheduleProgrammingVisibility>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationServerGeneratedCommandList>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationServerGeneratedCommandList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationClientGeneratedCommandList>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationClientGeneratedCommandList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationAttributeList>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationAttributeList>(), //
        make_unique<ReadThermostatUserInterfaceConfigurationClusterRevision>(), //
        make_unique<ReportThermostatUserInterfaceConfigurationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterThreadNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "ThreadNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<ThreadNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadThreadNetworkDiagnosticsChannel>(), //
        make_unique<ReportThreadNetworkDiagnosticsChannel>(), //
        make_unique<ReadThreadNetworkDiagnosticsRoutingRole>(), //
        make_unique<ReportThreadNetworkDiagnosticsRoutingRole>(), //
        make_unique<ReadThreadNetworkDiagnosticsNetworkName>(), //
        make_unique<ReportThreadNetworkDiagnosticsNetworkName>(), //
        make_unique<ReadThreadNetworkDiagnosticsPanId>(), //
        make_unique<ReportThreadNetworkDiagnosticsPanId>(), //
        make_unique<ReadThreadNetworkDiagnosticsExtendedPanId>(), //
        make_unique<ReportThreadNetworkDiagnosticsExtendedPanId>(), //
        make_unique<ReadThreadNetworkDiagnosticsMeshLocalPrefix>(), //
        make_unique<ReportThreadNetworkDiagnosticsMeshLocalPrefix>(), //
        make_unique<ReadThreadNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsNeighborTableList>(), //
        make_unique<ReportThreadNetworkDiagnosticsNeighborTableList>(), //
        make_unique<ReadThreadNetworkDiagnosticsRouteTableList>(), //
        make_unique<ReportThreadNetworkDiagnosticsRouteTableList>(), //
        make_unique<ReadThreadNetworkDiagnosticsPartitionId>(), //
        make_unique<ReportThreadNetworkDiagnosticsPartitionId>(), //
        make_unique<ReadThreadNetworkDiagnosticsWeighting>(), //
        make_unique<ReportThreadNetworkDiagnosticsWeighting>(), //
        make_unique<ReadThreadNetworkDiagnosticsDataVersion>(), //
        make_unique<ReportThreadNetworkDiagnosticsDataVersion>(), //
        make_unique<ReadThreadNetworkDiagnosticsStableDataVersion>(), //
        make_unique<ReportThreadNetworkDiagnosticsStableDataVersion>(), //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRouterId>(), //
        make_unique<ReportThreadNetworkDiagnosticsLeaderRouterId>(), //
        make_unique<ReadThreadNetworkDiagnosticsDetachedRoleCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsDetachedRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsChildRoleCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsChildRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRouterRoleCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRouterRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsLeaderRoleCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsLeaderRoleCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsAttachAttemptCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsPartitionIdChangeCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsPartitionIdChangeCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsBetterPartitionAttachAttemptCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsParentChangeCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsParentChangeCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxTotalCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxTotalCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxUnicastCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxUnicastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBroadcastCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxBroadcastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxAckRequestedCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxAckRequestedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxAckedCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxAckedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxNoAckRequestedCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxNoAckRequestedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDataCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxDataCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDataPollCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxDataPollCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxBeaconCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxBeaconRequestCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxBeaconRequestCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxOtherCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxRetryCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxRetryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxDirectMaxRetryExpiryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxIndirectMaxRetryExpiryCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrCcaCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxErrCcaCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrAbortCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxErrAbortCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsTxErrBusyChannelCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsTxErrBusyChannelCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxTotalCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxTotalCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxUnicastCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxUnicastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBroadcastCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxBroadcastCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDataCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxDataCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDataPollCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxDataPollCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxBeaconCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxBeaconRequestCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxBeaconRequestCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxOtherCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxAddressFilteredCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxAddressFilteredCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDestAddrFilteredCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxDestAddrFilteredCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxDuplicatedCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxDuplicatedCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrNoFrameCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxErrNoFrameCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxErrUnknownNeighborCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxErrInvalidSrcAddrCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrSecCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxErrSecCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrFcsCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxErrFcsCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsRxErrOtherCount>(), //
        make_unique<ReportThreadNetworkDiagnosticsRxErrOtherCount>(), //
        make_unique<ReadThreadNetworkDiagnosticsActiveTimestamp>(), //
        make_unique<ReportThreadNetworkDiagnosticsActiveTimestamp>(), //
        make_unique<ReadThreadNetworkDiagnosticsPendingTimestamp>(), //
        make_unique<ReportThreadNetworkDiagnosticsPendingTimestamp>(), //
        make_unique<ReadThreadNetworkDiagnosticsDelay>(), //
        make_unique<ReportThreadNetworkDiagnosticsDelay>(), //
        make_unique<ReadThreadNetworkDiagnosticsSecurityPolicy>(), //
        make_unique<ReportThreadNetworkDiagnosticsSecurityPolicy>(), //
        make_unique<ReadThreadNetworkDiagnosticsChannelMask>(), //
        make_unique<ReportThreadNetworkDiagnosticsChannelMask>(), //
        make_unique<ReadThreadNetworkDiagnosticsOperationalDatasetComponents>(), //
        make_unique<ReportThreadNetworkDiagnosticsOperationalDatasetComponents>(), //
        make_unique<ReadThreadNetworkDiagnosticsActiveNetworkFaultsList>(), //
        make_unique<ReportThreadNetworkDiagnosticsActiveNetworkFaultsList>(), //
        make_unique<ReadThreadNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReportThreadNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadThreadNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReportThreadNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadThreadNetworkDiagnosticsAttributeList>(), //
        make_unique<ReportThreadNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadThreadNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReportThreadNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadThreadNetworkDiagnosticsClusterRevision>(), //
        make_unique<ReportThreadNetworkDiagnosticsClusterRevision>(), //
        make_unique<ReadThreadNetworkDiagnosticsConnectionStatus>(), //
        make_unique<ReportThreadNetworkDiagnosticsConnectionStatus>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterTimeFormatLocalization(Commands & commands)
{
    const char * clusterName = "TimeFormatLocalization";

    commands_list clusterCommands = {
        make_unique<ReadTimeFormatLocalizationHourFormat>(), //
        make_unique<WriteTimeFormatLocalizationHourFormat>(), //
        make_unique<ReportTimeFormatLocalizationHourFormat>(), //
        make_unique<ReadTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<WriteTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<ReportTimeFormatLocalizationActiveCalendarType>(), //
        make_unique<ReadTimeFormatLocalizationSupportedCalendarTypes>(), //
        make_unique<ReportTimeFormatLocalizationSupportedCalendarTypes>(), //
        make_unique<ReadTimeFormatLocalizationServerGeneratedCommandList>(), //
        make_unique<ReportTimeFormatLocalizationServerGeneratedCommandList>(), //
        make_unique<ReadTimeFormatLocalizationClientGeneratedCommandList>(), //
        make_unique<ReportTimeFormatLocalizationClientGeneratedCommandList>(), //
        make_unique<ReadTimeFormatLocalizationClusterRevision>(), //
        make_unique<ReportTimeFormatLocalizationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUnitLocalization(Commands & commands)
{
    const char * clusterName = "UnitLocalization";

    commands_list clusterCommands = {
        make_unique<ReadUnitLocalizationTemperatureUnit>(), //
        make_unique<WriteUnitLocalizationTemperatureUnit>(), //
        make_unique<ReportUnitLocalizationTemperatureUnit>(), //
        make_unique<ReadUnitLocalizationAttributeList>(), //
        make_unique<ReportUnitLocalizationAttributeList>(), //
        make_unique<ReadUnitLocalizationFeatureMap>(), //
        make_unique<ReportUnitLocalizationFeatureMap>(), //
        make_unique<ReadUnitLocalizationClusterRevision>(), //
        make_unique<ReportUnitLocalizationClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterUserLabel(Commands & commands)
{
    const char * clusterName = "UserLabel";

    commands_list clusterCommands = {
        make_unique<ReadUserLabelLabelList>(), //
        make_unique<ReportUserLabelLabelList>(), //
        make_unique<ReadUserLabelServerGeneratedCommandList>(), //
        make_unique<ReportUserLabelServerGeneratedCommandList>(), //
        make_unique<ReadUserLabelClientGeneratedCommandList>(), //
        make_unique<ReportUserLabelClientGeneratedCommandList>(), //
        make_unique<ReadUserLabelClusterRevision>(), //
        make_unique<ReportUserLabelClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWakeOnLan(Commands & commands)
{
    const char * clusterName = "WakeOnLan";

    commands_list clusterCommands = {
        make_unique<ReadWakeOnLanWakeOnLanMacAddress>(), //
        make_unique<ReportWakeOnLanWakeOnLanMacAddress>(), //
        make_unique<ReadWakeOnLanServerGeneratedCommandList>(), //
        make_unique<ReportWakeOnLanServerGeneratedCommandList>(), //
        make_unique<ReadWakeOnLanClientGeneratedCommandList>(), //
        make_unique<ReportWakeOnLanClientGeneratedCommandList>(), //
        make_unique<ReadWakeOnLanAttributeList>(), //
        make_unique<ReportWakeOnLanAttributeList>(), //
        make_unique<ReadWakeOnLanClusterRevision>(), //
        make_unique<ReportWakeOnLanClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWiFiNetworkDiagnostics(Commands & commands)
{
    const char * clusterName = "WiFiNetworkDiagnostics";

    commands_list clusterCommands = {
        make_unique<WiFiNetworkDiagnosticsResetCounts>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBssid>(), //
        make_unique<ReportWiFiNetworkDiagnosticsBssid>(), //
        make_unique<ReadWiFiNetworkDiagnosticsSecurityType>(), //
        make_unique<ReportWiFiNetworkDiagnosticsSecurityType>(), //
        make_unique<ReadWiFiNetworkDiagnosticsWiFiVersion>(), //
        make_unique<ReportWiFiNetworkDiagnosticsWiFiVersion>(), //
        make_unique<ReadWiFiNetworkDiagnosticsChannelNumber>(), //
        make_unique<ReportWiFiNetworkDiagnosticsChannelNumber>(), //
        make_unique<ReadWiFiNetworkDiagnosticsRssi>(), //
        make_unique<ReportWiFiNetworkDiagnosticsRssi>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconLostCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsBeaconLostCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsBeaconRxCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsBeaconRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsPacketMulticastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsPacketMulticastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastRxCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsPacketUnicastRxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsPacketUnicastTxCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsPacketUnicastTxCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsCurrentMaxRate>(), //
        make_unique<ReportWiFiNetworkDiagnosticsCurrentMaxRate>(), //
        make_unique<ReadWiFiNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReportWiFiNetworkDiagnosticsOverrunCount>(), //
        make_unique<ReadWiFiNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReportWiFiNetworkDiagnosticsServerGeneratedCommandList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReportWiFiNetworkDiagnosticsClientGeneratedCommandList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsAttributeList>(), //
        make_unique<ReportWiFiNetworkDiagnosticsAttributeList>(), //
        make_unique<ReadWiFiNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReportWiFiNetworkDiagnosticsFeatureMap>(), //
        make_unique<ReadWiFiNetworkDiagnosticsClusterRevision>(), //
        make_unique<ReportWiFiNetworkDiagnosticsClusterRevision>(), //
        make_unique<ReadWiFiNetworkDiagnosticsDisconnection>(), //
        make_unique<ReportWiFiNetworkDiagnosticsDisconnection>(), //
        make_unique<ReadWiFiNetworkDiagnosticsAssociationFailure>(), //
        make_unique<ReportWiFiNetworkDiagnosticsAssociationFailure>(), //
        make_unique<ReadWiFiNetworkDiagnosticsConnectionStatus>(), //
        make_unique<ReportWiFiNetworkDiagnosticsConnectionStatus>(), //
    };

    commands.Register(clusterName, clusterCommands);
}
void registerClusterWindowCovering(Commands & commands)
{
    const char * clusterName = "WindowCovering";

    commands_list clusterCommands = {
        make_unique<WindowCoveringDownOrClose>(), //
        make_unique<WindowCoveringGoToLiftPercentage>(), //
        make_unique<WindowCoveringGoToLiftValue>(), //
        make_unique<WindowCoveringGoToTiltPercentage>(), //
        make_unique<WindowCoveringGoToTiltValue>(), //
        make_unique<WindowCoveringStopMotion>(), //
        make_unique<WindowCoveringUpOrOpen>(), //
        make_unique<ReadWindowCoveringType>(), //
        make_unique<ReportWindowCoveringType>(), //
        make_unique<ReadWindowCoveringCurrentPositionLift>(), //
        make_unique<ReportWindowCoveringCurrentPositionLift>(), //
        make_unique<ReadWindowCoveringCurrentPositionTilt>(), //
        make_unique<ReportWindowCoveringCurrentPositionTilt>(), //
        make_unique<ReadWindowCoveringConfigStatus>(), //
        make_unique<ReportWindowCoveringConfigStatus>(), //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercentage>(), //
        make_unique<ReportWindowCoveringCurrentPositionLiftPercentage>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercentage>(), //
        make_unique<ReportWindowCoveringCurrentPositionTiltPercentage>(), //
        make_unique<ReadWindowCoveringOperationalStatus>(), //
        make_unique<ReportWindowCoveringOperationalStatus>(), //
        make_unique<ReadWindowCoveringTargetPositionLiftPercent100ths>(), //
        make_unique<ReportWindowCoveringTargetPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringTargetPositionTiltPercent100ths>(), //
        make_unique<ReportWindowCoveringTargetPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringEndProductType>(), //
        make_unique<ReportWindowCoveringEndProductType>(), //
        make_unique<ReadWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<ReportWindowCoveringCurrentPositionLiftPercent100ths>(), //
        make_unique<ReadWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<ReportWindowCoveringCurrentPositionTiltPercent100ths>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitLift>(), //
        make_unique<ReportWindowCoveringInstalledOpenLimitLift>(), //
        make_unique<ReadWindowCoveringInstalledClosedLimitLift>(), //
        make_unique<ReportWindowCoveringInstalledClosedLimitLift>(), //
        make_unique<ReadWindowCoveringInstalledOpenLimitTilt>(), //
        make_unique<ReportWindowCoveringInstalledOpenLimitTilt>(), //
        make_unique<ReadWindowCoveringInstalledClosedLimitTilt>(), //
        make_unique<ReportWindowCoveringInstalledClosedLimitTilt>(), //
        make_unique<ReadWindowCoveringMode>(), //
        make_unique<WriteWindowCoveringMode>(), //
        make_unique<ReportWindowCoveringMode>(), //
        make_unique<ReadWindowCoveringSafetyStatus>(), //
        make_unique<ReportWindowCoveringSafetyStatus>(), //
        make_unique<ReadWindowCoveringServerGeneratedCommandList>(), //
        make_unique<ReportWindowCoveringServerGeneratedCommandList>(), //
        make_unique<ReadWindowCoveringClientGeneratedCommandList>(), //
        make_unique<ReportWindowCoveringClientGeneratedCommandList>(), //
        make_unique<ReadWindowCoveringAttributeList>(), //
        make_unique<ReportWindowCoveringAttributeList>(), //
        make_unique<ReadWindowCoveringFeatureMap>(), //
        make_unique<ReportWindowCoveringFeatureMap>(), //
        make_unique<ReadWindowCoveringClusterRevision>(), //
        make_unique<ReportWindowCoveringClusterRevision>(), //
    };

    commands.Register(clusterName, clusterCommands);
}

void registerClusters(Commands & commands)
{
    registerClusterAccessControl(commands);
    registerClusterAccountLogin(commands);
    registerClusterAdministratorCommissioning(commands);
    registerClusterApplicationBasic(commands);
    registerClusterApplicationLauncher(commands);
    registerClusterAudioOutput(commands);
    registerClusterBarrierControl(commands);
    registerClusterBasic(commands);
    registerClusterBinaryInputBasic(commands);
    registerClusterBinding(commands);
    registerClusterBooleanState(commands);
    registerClusterBridgedActions(commands);
    registerClusterBridgedDeviceBasic(commands);
    registerClusterChannel(commands);
    registerClusterColorControl(commands);
    registerClusterContentLauncher(commands);
    registerClusterDescriptor(commands);
    registerClusterDiagnosticLogs(commands);
    registerClusterDoorLock(commands);
    registerClusterElectricalMeasurement(commands);
    registerClusterEthernetNetworkDiagnostics(commands);
    registerClusterFixedLabel(commands);
    registerClusterFlowMeasurement(commands);
    registerClusterGeneralCommissioning(commands);
    registerClusterGeneralDiagnostics(commands);
    registerClusterGroupKeyManagement(commands);
    registerClusterGroups(commands);
    registerClusterIdentify(commands);
    registerClusterIlluminanceMeasurement(commands);
    registerClusterKeypadInput(commands);
    registerClusterLevelControl(commands);
    registerClusterLocalizationConfiguration(commands);
    registerClusterLowPower(commands);
    registerClusterMediaInput(commands);
    registerClusterMediaPlayback(commands);
    registerClusterModeSelect(commands);
    registerClusterNetworkCommissioning(commands);
    registerClusterOtaSoftwareUpdateProvider(commands);
    registerClusterOtaSoftwareUpdateRequestor(commands);
    registerClusterOccupancySensing(commands);
    registerClusterOnOff(commands);
    registerClusterOnOffSwitchConfiguration(commands);
    registerClusterOperationalCredentials(commands);
    registerClusterPowerSource(commands);
    registerClusterPowerSourceConfiguration(commands);
    registerClusterPressureMeasurement(commands);
    registerClusterPumpConfigurationAndControl(commands);
    registerClusterRelativeHumidityMeasurement(commands);
    registerClusterScenes(commands);
    registerClusterSoftwareDiagnostics(commands);
    registerClusterSwitch(commands);
    registerClusterTargetNavigator(commands);
    registerClusterTemperatureMeasurement(commands);
    registerClusterTestCluster(commands);
    registerClusterThermostat(commands);
    registerClusterThermostatUserInterfaceConfiguration(commands);
    registerClusterThreadNetworkDiagnostics(commands);
    registerClusterTimeFormatLocalization(commands);
    registerClusterUnitLocalization(commands);
    registerClusterUserLabel(commands);
    registerClusterWakeOnLan(commands);
    registerClusterWiFiNetworkDiagnostics(commands);
    registerClusterWindowCovering(commands);
}
