/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
// This file is generated from clusters-shared-Structs.ipp.zapt

#include <clusters/shared/Structs.h>

#include <app/data-model/Decode.h>
#include <app/data-model/StructDecodeIterator.h>
#include <app/data-model/WrappedStructEncoder.h>

namespace chip {
namespace app {
namespace Clusters {
// Structs shared across multiple clusters.
namespace detail {
namespace Structs {

namespace ModeTagStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMfgCode), mfgCode);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kMfgCode))
        {
            err = DataModel::Decode(reader, mfgCode);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ModeTagStruct

namespace ModeOptionStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLabel), label);
    encoder.Encode(to_underlying(Fields::kMode), mode);
    encoder.Encode(to_underlying(Fields::kModeTags), modeTags);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else if (__context_tag == to_underlying(Fields::kMode))
        {
            err = DataModel::Decode(reader, mode);
        }
        else if (__context_tag == to_underlying(Fields::kModeTags))
        {
            err = DataModel::Decode(reader, modeTags);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ModeOptionStruct

namespace MeasurementAccuracyRangeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRangeMin), rangeMin);
    encoder.Encode(to_underlying(Fields::kRangeMax), rangeMax);
    encoder.Encode(to_underlying(Fields::kPercentMax), percentMax);
    encoder.Encode(to_underlying(Fields::kPercentMin), percentMin);
    encoder.Encode(to_underlying(Fields::kPercentTypical), percentTypical);
    encoder.Encode(to_underlying(Fields::kFixedMax), fixedMax);
    encoder.Encode(to_underlying(Fields::kFixedMin), fixedMin);
    encoder.Encode(to_underlying(Fields::kFixedTypical), fixedTypical);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kRangeMin))
        {
            err = DataModel::Decode(reader, rangeMin);
        }
        else if (__context_tag == to_underlying(Fields::kRangeMax))
        {
            err = DataModel::Decode(reader, rangeMax);
        }
        else if (__context_tag == to_underlying(Fields::kPercentMax))
        {
            err = DataModel::Decode(reader, percentMax);
        }
        else if (__context_tag == to_underlying(Fields::kPercentMin))
        {
            err = DataModel::Decode(reader, percentMin);
        }
        else if (__context_tag == to_underlying(Fields::kPercentTypical))
        {
            err = DataModel::Decode(reader, percentTypical);
        }
        else if (__context_tag == to_underlying(Fields::kFixedMax))
        {
            err = DataModel::Decode(reader, fixedMax);
        }
        else if (__context_tag == to_underlying(Fields::kFixedMin))
        {
            err = DataModel::Decode(reader, fixedMin);
        }
        else if (__context_tag == to_underlying(Fields::kFixedTypical))
        {
            err = DataModel::Decode(reader, fixedTypical);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementAccuracyRangeStruct

namespace MeasurementAccuracyStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMeasurementType), measurementType);
    encoder.Encode(to_underlying(Fields::kMeasured), measured);
    encoder.Encode(to_underlying(Fields::kMinMeasuredValue), minMeasuredValue);
    encoder.Encode(to_underlying(Fields::kMaxMeasuredValue), maxMeasuredValue);
    encoder.Encode(to_underlying(Fields::kAccuracyRanges), accuracyRanges);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kMeasurementType))
        {
            err = DataModel::Decode(reader, measurementType);
        }
        else if (__context_tag == to_underlying(Fields::kMeasured))
        {
            err = DataModel::Decode(reader, measured);
        }
        else if (__context_tag == to_underlying(Fields::kMinMeasuredValue))
        {
            err = DataModel::Decode(reader, minMeasuredValue);
        }
        else if (__context_tag == to_underlying(Fields::kMaxMeasuredValue))
        {
            err = DataModel::Decode(reader, maxMeasuredValue);
        }
        else if (__context_tag == to_underlying(Fields::kAccuracyRanges))
        {
            err = DataModel::Decode(reader, accuracyRanges);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementAccuracyStruct

namespace ApplicationStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCatalogVendorID), catalogVendorID);
    encoder.Encode(to_underlying(Fields::kApplicationID), applicationID);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kCatalogVendorID))
        {
            err = DataModel::Decode(reader, catalogVendorID);
        }
        else if (__context_tag == to_underlying(Fields::kApplicationID))
        {
            err = DataModel::Decode(reader, applicationID);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ApplicationStruct

namespace ErrorStateStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kErrorStateID), errorStateID);
    encoder.Encode(to_underlying(Fields::kErrorStateLabel), errorStateLabel);
    encoder.Encode(to_underlying(Fields::kErrorStateDetails), errorStateDetails);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kErrorStateID))
        {
            err = DataModel::Decode(reader, errorStateID);
        }
        else if (__context_tag == to_underlying(Fields::kErrorStateLabel))
        {
            err = DataModel::Decode(reader, errorStateLabel);
        }
        else if (__context_tag == to_underlying(Fields::kErrorStateDetails))
        {
            err = DataModel::Decode(reader, errorStateDetails);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ErrorStateStruct

namespace LabelStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLabel), label);
    encoder.Encode(to_underlying(Fields::kValue), value);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kLabel))
        {
            err = DataModel::Decode(reader, label);
        }
        else if (__context_tag == to_underlying(Fields::kValue))
        {
            err = DataModel::Decode(reader, value);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LabelStruct

namespace OperationalStateStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationalStateID), operationalStateID);
    encoder.Encode(to_underlying(Fields::kOperationalStateLabel), operationalStateLabel);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kOperationalStateID))
        {
            err = DataModel::Decode(reader, operationalStateID);
        }
        else if (__context_tag == to_underlying(Fields::kOperationalStateLabel))
        {
            err = DataModel::Decode(reader, operationalStateLabel);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace OperationalStateStruct
} // namespace Structs
} // namespace detail

namespace Globals {
// Global structs
namespace Structs {

namespace CurrencyStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCurrency), currency);
    encoder.Encode(to_underlying(Fields::kDecimalPoints), decimalPoints);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kCurrency))
        {
            err = DataModel::Decode(reader, currency);
        }
        else if (__context_tag == to_underlying(Fields::kDecimalPoints))
        {
            err = DataModel::Decode(reader, decimalPoints);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace CurrencyStruct

namespace PriceStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAmount), amount);
    encoder.Encode(to_underlying(Fields::kCurrency), currency);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kAmount))
        {
            err = DataModel::Decode(reader, amount);
        }
        else if (__context_tag == to_underlying(Fields::kCurrency))
        {
            err = DataModel::Decode(reader, currency);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PriceStruct

namespace MeasurementAccuracyRangeStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kRangeMin), rangeMin);
    encoder.Encode(to_underlying(Fields::kRangeMax), rangeMax);
    encoder.Encode(to_underlying(Fields::kPercentMax), percentMax);
    encoder.Encode(to_underlying(Fields::kPercentMin), percentMin);
    encoder.Encode(to_underlying(Fields::kPercentTypical), percentTypical);
    encoder.Encode(to_underlying(Fields::kFixedMax), fixedMax);
    encoder.Encode(to_underlying(Fields::kFixedMin), fixedMin);
    encoder.Encode(to_underlying(Fields::kFixedTypical), fixedTypical);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kRangeMin))
        {
            err = DataModel::Decode(reader, rangeMin);
        }
        else if (__context_tag == to_underlying(Fields::kRangeMax))
        {
            err = DataModel::Decode(reader, rangeMax);
        }
        else if (__context_tag == to_underlying(Fields::kPercentMax))
        {
            err = DataModel::Decode(reader, percentMax);
        }
        else if (__context_tag == to_underlying(Fields::kPercentMin))
        {
            err = DataModel::Decode(reader, percentMin);
        }
        else if (__context_tag == to_underlying(Fields::kPercentTypical))
        {
            err = DataModel::Decode(reader, percentTypical);
        }
        else if (__context_tag == to_underlying(Fields::kFixedMax))
        {
            err = DataModel::Decode(reader, fixedMax);
        }
        else if (__context_tag == to_underlying(Fields::kFixedMin))
        {
            err = DataModel::Decode(reader, fixedMin);
        }
        else if (__context_tag == to_underlying(Fields::kFixedTypical))
        {
            err = DataModel::Decode(reader, fixedTypical);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementAccuracyRangeStruct

namespace MeasurementAccuracyStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kMeasurementType), measurementType);
    encoder.Encode(to_underlying(Fields::kMeasured), measured);
    encoder.Encode(to_underlying(Fields::kMinMeasuredValue), minMeasuredValue);
    encoder.Encode(to_underlying(Fields::kMaxMeasuredValue), maxMeasuredValue);
    encoder.Encode(to_underlying(Fields::kAccuracyRanges), accuracyRanges);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kMeasurementType))
        {
            err = DataModel::Decode(reader, measurementType);
        }
        else if (__context_tag == to_underlying(Fields::kMeasured))
        {
            err = DataModel::Decode(reader, measured);
        }
        else if (__context_tag == to_underlying(Fields::kMinMeasuredValue))
        {
            err = DataModel::Decode(reader, minMeasuredValue);
        }
        else if (__context_tag == to_underlying(Fields::kMaxMeasuredValue))
        {
            err = DataModel::Decode(reader, maxMeasuredValue);
        }
        else if (__context_tag == to_underlying(Fields::kAccuracyRanges))
        {
            err = DataModel::Decode(reader, accuracyRanges);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace MeasurementAccuracyStruct

namespace AtomicAttributeStatusStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kAttributeID), attributeID);
    encoder.Encode(to_underlying(Fields::kStatusCode), statusCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kAttributeID))
        {
            err = DataModel::Decode(reader, attributeID);
        }
        else if (__context_tag == to_underlying(Fields::kStatusCode))
        {
            err = DataModel::Decode(reader, statusCode);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace AtomicAttributeStatusStruct

namespace ICECandidateStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCandidate), candidate);
    encoder.Encode(to_underlying(Fields::kSDPMid), SDPMid);
    encoder.Encode(to_underlying(Fields::kSDPMLineIndex), SDPMLineIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kCandidate))
        {
            err = DataModel::Decode(reader, candidate);
        }
        else if (__context_tag == to_underlying(Fields::kSDPMid))
        {
            err = DataModel::Decode(reader, SDPMid);
        }
        else if (__context_tag == to_underlying(Fields::kSDPMLineIndex))
        {
            err = DataModel::Decode(reader, SDPMLineIndex);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ICECandidateStruct

namespace ICEServerStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kURLs), URLs);
    encoder.Encode(to_underlying(Fields::kUsername), username);
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    encoder.Encode(to_underlying(Fields::kCaid), caid);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kURLs))
        {
            err = DataModel::Decode(reader, URLs);
        }
        else if (__context_tag == to_underlying(Fields::kUsername))
        {
            err = DataModel::Decode(reader, username);
        }
        else if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }
        else if (__context_tag == to_underlying(Fields::kCaid))
        {
            err = DataModel::Decode(reader, caid);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ICEServerStruct

namespace LocationDescriptorStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kLocationName), locationName);
    encoder.Encode(to_underlying(Fields::kFloorNumber), floorNumber);
    encoder.Encode(to_underlying(Fields::kAreaType), areaType);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kLocationName))
        {
            err = DataModel::Decode(reader, locationName);
        }
        else if (__context_tag == to_underlying(Fields::kFloorNumber))
        {
            err = DataModel::Decode(reader, floorNumber);
        }
        else if (__context_tag == to_underlying(Fields::kAreaType))
        {
            err = DataModel::Decode(reader, areaType);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace LocationDescriptorStruct

namespace PowerThresholdStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPowerThreshold), powerThreshold);
    encoder.Encode(to_underlying(Fields::kApparentPowerThreshold), apparentPowerThreshold);
    encoder.Encode(to_underlying(Fields::kPowerThresholdSource), powerThresholdSource);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kPowerThreshold))
        {
            err = DataModel::Decode(reader, powerThreshold);
        }
        else if (__context_tag == to_underlying(Fields::kApparentPowerThreshold))
        {
            err = DataModel::Decode(reader, apparentPowerThreshold);
        }
        else if (__context_tag == to_underlying(Fields::kPowerThresholdSource))
        {
            err = DataModel::Decode(reader, powerThresholdSource);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace PowerThresholdStruct

namespace TestGlobalStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kName), name);
    encoder.Encode(to_underlying(Fields::kMyBitmap), myBitmap);
    encoder.Encode(to_underlying(Fields::kMyEnum), myEnum);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kName))
        {
            err = DataModel::Decode(reader, name);
        }
        else if (__context_tag == to_underlying(Fields::kMyBitmap))
        {
            err = DataModel::Decode(reader, myBitmap);
        }
        else if (__context_tag == to_underlying(Fields::kMyEnum))
        {
            err = DataModel::Decode(reader, myEnum);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace TestGlobalStruct

namespace ViewportStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kX1), x1);
    encoder.Encode(to_underlying(Fields::kY1), y1);
    encoder.Encode(to_underlying(Fields::kX2), x2);
    encoder.Encode(to_underlying(Fields::kY2), y2);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kX1))
        {
            err = DataModel::Decode(reader, x1);
        }
        else if (__context_tag == to_underlying(Fields::kY1))
        {
            err = DataModel::Decode(reader, y1);
        }
        else if (__context_tag == to_underlying(Fields::kX2))
        {
            err = DataModel::Decode(reader, x2);
        }
        else if (__context_tag == to_underlying(Fields::kY2))
        {
            err = DataModel::Decode(reader, y2);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace ViewportStruct

namespace WebRTCSessionStruct {
CHIP_ERROR Type::EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    return DoEncode(aWriter, aTag, NullOptional);
}

CHIP_ERROR Type::EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const
{
    return DoEncode(aWriter, aTag, MakeOptional(aAccessingFabricIndex));
}

CHIP_ERROR Type::DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const
{

    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };

    encoder.Encode(to_underlying(Fields::kId), id);
    encoder.Encode(to_underlying(Fields::kPeerNodeID), peerNodeID);
    encoder.Encode(to_underlying(Fields::kPeerEndpointID), peerEndpointID);
    encoder.Encode(to_underlying(Fields::kStreamUsage), streamUsage);
    encoder.Encode(to_underlying(Fields::kVideoStreamID), videoStreamID);
    encoder.Encode(to_underlying(Fields::kAudioStreamID), audioStreamID);
    encoder.Encode(to_underlying(Fields::kMetadataEnabled), metadataEnabled);
    if (aAccessingFabricIndex.HasValue())
    {
        encoder.Encode(to_underlying(Fields::kFabricIndex), fabricIndex);
    }

    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kId))
        {
            err = DataModel::Decode(reader, id);
        }
        else if (__context_tag == to_underlying(Fields::kPeerNodeID))
        {
            err = DataModel::Decode(reader, peerNodeID);
        }
        else if (__context_tag == to_underlying(Fields::kPeerEndpointID))
        {
            err = DataModel::Decode(reader, peerEndpointID);
        }
        else if (__context_tag == to_underlying(Fields::kStreamUsage))
        {
            err = DataModel::Decode(reader, streamUsage);
        }
        else if (__context_tag == to_underlying(Fields::kVideoStreamID))
        {
            err = DataModel::Decode(reader, videoStreamID);
        }
        else if (__context_tag == to_underlying(Fields::kAudioStreamID))
        {
            err = DataModel::Decode(reader, audioStreamID);
        }
        else if (__context_tag == to_underlying(Fields::kMetadataEnabled))
        {
            err = DataModel::Decode(reader, metadataEnabled);
        }
        else if (__context_tag == to_underlying(Fields::kFabricIndex))
        {
            err = DataModel::Decode(reader, fabricIndex);
        }

        ReturnErrorOnFailure(err);
    }
}

} // namespace WebRTCSessionStruct

} // namespace Structs
} // namespace Globals
} // namespace Clusters
} // namespace app
} // namespace chip
