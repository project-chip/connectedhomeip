/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/List.h>
#include <app/data-model/Nullable.h>
#include <app/util/basic-types.h>
#include <lib/core/Optional.h>
#include <lib/core/TLV.h>
#include <lib/support/BitMask.h>

#include <clusters/shared/Structs.h>

#include <cstdint>

namespace chip {
namespace app {
namespace Clusters {
namespace DeviceEnergyManagement {
namespace Structs {
namespace CostStruct {
enum class Fields : uint8_t
{
    kCostType      = 0,
    kValue         = 1,
    kDecimalPoints = 2,
    kCurrency      = 3,
};

struct Type
{
public:
    CostTypeEnum costType = static_cast<CostTypeEnum>(0);
    int32_t value         = static_cast<int32_t>(0);
    uint8_t decimalPoints = static_cast<uint8_t>(0);
    Optional<uint16_t> currency;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CostStruct
namespace PowerAdjustStruct {
enum class Fields : uint8_t
{
    kMinPower    = 0,
    kMaxPower    = 1,
    kMinDuration = 2,
    kMaxDuration = 3,
};

struct Type
{
public:
    int64_t minPower     = static_cast<int64_t>(0);
    int64_t maxPower     = static_cast<int64_t>(0);
    uint32_t minDuration = static_cast<uint32_t>(0);
    uint32_t maxDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PowerAdjustStruct
namespace PowerAdjustCapabilityStruct {
enum class Fields : uint8_t
{
    kPowerAdjustCapability = 0,
    kCause                 = 1,
};

struct Type
{
public:
    DataModel::Nullable<DataModel::List<const Structs::PowerAdjustStruct::Type>> powerAdjustCapability;
    PowerAdjustReasonEnum cause = static_cast<PowerAdjustReasonEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<DataModel::DecodableList<Structs::PowerAdjustStruct::DecodableType>> powerAdjustCapability;
    PowerAdjustReasonEnum cause = static_cast<PowerAdjustReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace PowerAdjustCapabilityStruct
namespace SlotStruct {
enum class Fields : uint8_t
{
    kMinDuration           = 0,
    kMaxDuration           = 1,
    kDefaultDuration       = 2,
    kElapsedSlotTime       = 3,
    kRemainingSlotTime     = 4,
    kSlotIsPausable        = 5,
    kMinPauseDuration      = 6,
    kMaxPauseDuration      = 7,
    kManufacturerESAState  = 8,
    kNominalPower          = 9,
    kMinPower              = 10,
    kMaxPower              = 11,
    kNominalEnergy         = 12,
    kCosts                 = 13,
    kMinPowerAdjustment    = 14,
    kMaxPowerAdjustment    = 15,
    kMinDurationAdjustment = 16,
    kMaxDurationAdjustment = 17,
};

struct Type
{
public:
    uint32_t minDuration       = static_cast<uint32_t>(0);
    uint32_t maxDuration       = static_cast<uint32_t>(0);
    uint32_t defaultDuration   = static_cast<uint32_t>(0);
    uint32_t elapsedSlotTime   = static_cast<uint32_t>(0);
    uint32_t remainingSlotTime = static_cast<uint32_t>(0);
    Optional<bool> slotIsPausable;
    Optional<uint32_t> minPauseDuration;
    Optional<uint32_t> maxPauseDuration;
    Optional<uint16_t> manufacturerESAState;
    Optional<int64_t> nominalPower;
    Optional<int64_t> minPower;
    Optional<int64_t> maxPower;
    Optional<int64_t> nominalEnergy;
    Optional<DataModel::List<const Structs::CostStruct::Type>> costs;
    Optional<int64_t> minPowerAdjustment;
    Optional<int64_t> maxPowerAdjustment;
    Optional<uint32_t> minDurationAdjustment;
    Optional<uint32_t> maxDurationAdjustment;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint32_t minDuration       = static_cast<uint32_t>(0);
    uint32_t maxDuration       = static_cast<uint32_t>(0);
    uint32_t defaultDuration   = static_cast<uint32_t>(0);
    uint32_t elapsedSlotTime   = static_cast<uint32_t>(0);
    uint32_t remainingSlotTime = static_cast<uint32_t>(0);
    Optional<bool> slotIsPausable;
    Optional<uint32_t> minPauseDuration;
    Optional<uint32_t> maxPauseDuration;
    Optional<uint16_t> manufacturerESAState;
    Optional<int64_t> nominalPower;
    Optional<int64_t> minPower;
    Optional<int64_t> maxPower;
    Optional<int64_t> nominalEnergy;
    Optional<DataModel::DecodableList<Structs::CostStruct::DecodableType>> costs;
    Optional<int64_t> minPowerAdjustment;
    Optional<int64_t> maxPowerAdjustment;
    Optional<uint32_t> minDurationAdjustment;
    Optional<uint32_t> maxDurationAdjustment;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace SlotStruct
namespace ForecastStruct {
enum class Fields : uint8_t
{
    kForecastID           = 0,
    kActiveSlotNumber     = 1,
    kStartTime            = 2,
    kEndTime              = 3,
    kEarliestStartTime    = 4,
    kLatestEndTime        = 5,
    kIsPausable           = 6,
    kSlots                = 7,
    kForecastUpdateReason = 8,
};

struct Type
{
public:
    uint32_t forecastID = static_cast<uint32_t>(0);
    DataModel::Nullable<uint16_t> activeSlotNumber;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    Optional<DataModel::Nullable<uint32_t>> earliestStartTime;
    Optional<uint32_t> latestEndTime;
    bool isPausable = static_cast<bool>(0);
    DataModel::List<const Structs::SlotStruct::Type> slots;
    ForecastUpdateReasonEnum forecastUpdateReason = static_cast<ForecastUpdateReasonEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint32_t forecastID = static_cast<uint32_t>(0);
    DataModel::Nullable<uint16_t> activeSlotNumber;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    Optional<DataModel::Nullable<uint32_t>> earliestStartTime;
    Optional<uint32_t> latestEndTime;
    bool isPausable = static_cast<bool>(0);
    DataModel::DecodableList<Structs::SlotStruct::DecodableType> slots;
    ForecastUpdateReasonEnum forecastUpdateReason = static_cast<ForecastUpdateReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ForecastStruct
namespace ConstraintsStruct {
enum class Fields : uint8_t
{
    kStartTime     = 0,
    kDuration      = 1,
    kNominalPower  = 2,
    kMaximumEnergy = 3,
    kLoadControl   = 4,
};

struct Type
{
public:
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t duration  = static_cast<uint32_t>(0);
    Optional<int64_t> nominalPower;
    Optional<int64_t> maximumEnergy;
    Optional<int8_t> loadControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ConstraintsStruct
namespace SlotAdjustmentStruct {
enum class Fields : uint8_t
{
    kSlotIndex    = 0,
    kNominalPower = 1,
    kDuration     = 2,
};

struct Type
{
public:
    uint8_t slotIndex = static_cast<uint8_t>(0);
    Optional<int64_t> nominalPower;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SlotAdjustmentStruct
} // namespace Structs
} // namespace DeviceEnergyManagement
} // namespace Clusters
} // namespace app
} // namespace chip
