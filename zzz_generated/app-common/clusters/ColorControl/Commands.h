/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/data-model/Nullable.h>
#include <lib/core/DataModelTypes.h>
#include <lib/core/Optional.h>
#include <lib/core/TLV.h>
#include <lib/support/BitMask.h>

#include <clusters/shared/Enums.h>
#include <clusters/shared/Structs.h>

#include <clusters/ColorControl/ClusterId.h>
#include <clusters/ColorControl/CommandIds.h>
#include <clusters/ColorControl/Enums.h>
#include <clusters/ColorControl/Structs.h>

#include <cstdint>

namespace chip {
namespace app {
namespace Clusters {
namespace ColorControl {
namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToHue {
struct Type;
struct DecodableType;
} // namespace MoveToHue

namespace MoveHue {
struct Type;
struct DecodableType;
} // namespace MoveHue

namespace StepHue {
struct Type;
struct DecodableType;
} // namespace StepHue

namespace MoveToSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToSaturation

namespace MoveSaturation {
struct Type;
struct DecodableType;
} // namespace MoveSaturation

namespace StepSaturation {
struct Type;
struct DecodableType;
} // namespace StepSaturation

namespace MoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToHueAndSaturation

namespace MoveToColor {
struct Type;
struct DecodableType;
} // namespace MoveToColor

namespace MoveColor {
struct Type;
struct DecodableType;
} // namespace MoveColor

namespace StepColor {
struct Type;
struct DecodableType;
} // namespace StepColor

namespace MoveToColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveToColorTemperature

namespace EnhancedMoveToHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHue

namespace EnhancedMoveHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveHue

namespace EnhancedStepHue {
struct Type;
struct DecodableType;
} // namespace EnhancedStepHue

namespace EnhancedMoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHueAndSaturation

namespace ColorLoopSet {
struct Type;
struct DecodableType;
} // namespace ColorLoopSet

namespace StopMoveStep {
struct Type;
struct DecodableType;
} // namespace StopMoveStep

namespace MoveColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveColorTemperature

namespace StepColorTemperature {
struct Type;
struct DecodableType;
} // namespace StepColorTemperature

} // namespace Commands

namespace Commands {
namespace MoveToHue {
enum class Fields : uint8_t
{
    kHue             = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHue
namespace MoveHue {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveHue
namespace StepHue {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepHue
namespace MoveToSaturation {
enum class Fields : uint8_t
{
    kSaturation      = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToSaturation
namespace MoveSaturation {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveSaturation
namespace StepSaturation {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepSaturation
namespace MoveToHueAndSaturation {
enum class Fields : uint8_t
{
    kHue             = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHueAndSaturation
namespace MoveToColor {
enum class Fields : uint8_t
{
    kColorX          = 0,
    kColorY          = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX                              = static_cast<uint16_t>(0);
    uint16_t colorY                              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX                              = static_cast<uint16_t>(0);
    uint16_t colorY                              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColor
namespace MoveColor {
enum class Fields : uint8_t
{
    kRateX           = 0,
    kRateY           = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX                                = static_cast<int16_t>(0);
    int16_t rateY                                = static_cast<int16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX                                = static_cast<int16_t>(0);
    int16_t rateY                                = static_cast<int16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColor
namespace StepColor {
enum class Fields : uint8_t
{
    kStepX           = 0,
    kStepY           = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX                                = static_cast<int16_t>(0);
    int16_t stepY                                = static_cast<int16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX                                = static_cast<int16_t>(0);
    int16_t stepY                                = static_cast<int16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColor
namespace MoveToColorTemperature {
enum class Fields : uint8_t
{
    kColorTemperatureMireds = 0,
    kTransitionTime         = 1,
    kOptionsMask            = 2,
    kOptionsOverride        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperatureMireds              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperatureMireds              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColorTemperature
namespace EnhancedMoveToHue {
enum class Fields : uint8_t
{
    kEnhancedHue     = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHue
namespace EnhancedMoveHue {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveHue
namespace EnhancedStepHue {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedStepHue
namespace EnhancedMoveToHueAndSaturation {
enum class Fields : uint8_t
{
    kEnhancedHue     = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHueAndSaturation
namespace ColorLoopSet {
enum class Fields : uint8_t
{
    kUpdateFlags     = 0,
    kAction          = 1,
    kDirection       = 2,
    kTime            = 3,
    kStartHue        = 4,
    kOptionsMask     = 5,
    kOptionsOverride = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<UpdateFlagsBitmap> updateFlags = static_cast<chip::BitMask<UpdateFlagsBitmap>>(0);
    ColorLoopActionEnum action                   = static_cast<ColorLoopActionEnum>(0);
    ColorLoopDirectionEnum direction             = static_cast<ColorLoopDirectionEnum>(0);
    uint16_t time                                = static_cast<uint16_t>(0);
    uint16_t startHue                            = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<UpdateFlagsBitmap> updateFlags = static_cast<chip::BitMask<UpdateFlagsBitmap>>(0);
    ColorLoopActionEnum action                   = static_cast<ColorLoopActionEnum>(0);
    ColorLoopDirectionEnum direction             = static_cast<ColorLoopDirectionEnum>(0);
    uint16_t time                                = static_cast<uint16_t>(0);
    uint16_t startHue                            = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ColorLoopSet
namespace StopMoveStep {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMoveStep
namespace MoveColorTemperature {
enum class Fields : uint8_t
{
    kMoveMode                      = 0,
    kRate                          = 1,
    kColorTemperatureMinimumMireds = 2,
    kColorTemperatureMaximumMireds = 3,
    kOptionsMask                   = 4,
    kOptionsOverride               = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColorTemperature
namespace StepColorTemperature {
enum class Fields : uint8_t
{
    kStepMode                      = 0,
    kStepSize                      = 1,
    kTransitionTime                = 2,
    kColorTemperatureMinimumMireds = 3,
    kColorTemperatureMaximumMireds = 4,
    kOptionsMask                   = 5,
    kOptionsOverride               = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColorTemperature
} // namespace Commands
} // namespace ColorControl
} // namespace Clusters
} // namespace app
} // namespace chip
