/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
// This file is generated from clusters-Commands.h.zapt

#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/data-model/Nullable.h>
#include <lib/core/DataModelTypes.h>
#include <lib/core/Optional.h>
#include <lib/core/TLV.h>
#include <lib/support/BitMask.h>

#include <clusters/shared/Enums.h>
#include <clusters/shared/Structs.h>

#include <clusters/UnitTesting/ClusterId.h>
#include <clusters/UnitTesting/CommandIds.h>
#include <clusters/UnitTesting/Enums.h>
#include <clusters/UnitTesting/Structs.h>

#include <cstdint>

namespace chip {
namespace app {
namespace Clusters {
namespace UnitTesting {
namespace Commands {
// Forward-declarations so we can reference these later.

namespace Test {
struct Type;
struct DecodableType;
} // namespace Test

namespace TestSpecificResponse {
struct Type;
struct DecodableType;
} // namespace TestSpecificResponse

namespace TestNotHandled {
struct Type;
struct DecodableType;
} // namespace TestNotHandled

namespace TestAddArgumentsResponse {
struct Type;
struct DecodableType;
} // namespace TestAddArgumentsResponse

namespace TestSpecific {
struct Type;
struct DecodableType;
} // namespace TestSpecific

namespace TestSimpleArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentResponse

namespace TestUnknownCommand {
struct Type;
struct DecodableType;
} // namespace TestUnknownCommand

namespace TestStructArrayArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentResponse

namespace TestAddArguments {
struct Type;
struct DecodableType;
} // namespace TestAddArguments

namespace TestListInt8UReverseResponse {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseResponse

namespace TestSimpleArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentRequest

namespace TestEnumsResponse {
struct Type;
struct DecodableType;
} // namespace TestEnumsResponse

namespace TestStructArrayArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentRequest

namespace TestNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalResponse

namespace TestStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArgumentRequest

namespace TestComplexNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalResponse

namespace TestNestedStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructArgumentRequest

namespace BooleanResponse {
struct Type;
struct DecodableType;
} // namespace BooleanResponse

namespace TestListStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListStructArgumentRequest

namespace SimpleStructResponse {
struct Type;
struct DecodableType;
} // namespace SimpleStructResponse

namespace TestListInt8UArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UArgumentRequest

namespace TestEmitTestEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventResponse

namespace TestNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructListArgumentRequest

namespace TestEmitTestFabricScopedEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestFabricScopedEventResponse

namespace TestListNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListNestedStructListArgumentRequest

namespace TestBatchHelperResponse {
struct Type;
struct DecodableType;
} // namespace TestBatchHelperResponse

namespace TestListInt8UReverseRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseRequest

namespace StringEchoResponse {
struct Type;
struct DecodableType;
} // namespace StringEchoResponse

namespace TestEnumsRequest {
struct Type;
struct DecodableType;
} // namespace TestEnumsRequest

namespace GlobalEchoResponse {
struct Type;
struct DecodableType;
} // namespace GlobalEchoResponse

namespace TestNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalRequest

namespace TestComplexNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalRequest

namespace SimpleStructEchoRequest {
struct Type;
struct DecodableType;
} // namespace SimpleStructEchoRequest

namespace TimedInvokeRequest {
struct Type;
struct DecodableType;
} // namespace TimedInvokeRequest

namespace TestSimpleOptionalArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleOptionalArgumentRequest

namespace TestEmitTestEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventRequest

namespace TestEmitTestFabricScopedEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestFabricScopedEventRequest

namespace TestBatchHelperRequest {
struct Type;
struct DecodableType;
} // namespace TestBatchHelperRequest

namespace TestSecondBatchHelperRequest {
struct Type;
struct DecodableType;
} // namespace TestSecondBatchHelperRequest

namespace StringEchoRequest {
struct Type;
struct DecodableType;
} // namespace StringEchoRequest

namespace GlobalEchoRequest {
struct Type;
struct DecodableType;
} // namespace GlobalEchoRequest

namespace TestCheckCommandFlags {
struct Type;
struct DecodableType;
} // namespace TestCheckCommandFlags

namespace TestDifferentVendorMeiRequest {
struct Type;
struct DecodableType;
} // namespace TestDifferentVendorMeiRequest

namespace TestDifferentVendorMeiResponse {
struct Type;
struct DecodableType;
} // namespace TestDifferentVendorMeiResponse

} // namespace Commands

namespace Commands {
namespace Test {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Test
namespace TestSpecificResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecificResponse
namespace TestNotHandled {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNotHandled
namespace TestAddArgumentsResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArgumentsResponse
namespace TestSpecific {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestSpecificResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecific
namespace TestSimpleArgumentResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool returnValue = static_cast<bool>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool returnValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentResponse
namespace TestUnknownCommand {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestUnknownCommand
namespace TestStructArrayArgumentResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentResponse
namespace TestAddArguments {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestAddArgumentsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArguments
namespace TestListInt8UReverseResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseResponse
namespace TestSimpleArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool arg1 = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestSimpleArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool arg1 = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentRequest
namespace TestEnumsResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsResponse
namespace TestStructArrayArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestStructArrayArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentRequest
namespace TestNullableOptionalResponse {
enum class Fields : uint8_t
{
    kWasPresent    = 0,
    kWasNull       = 1,
    kValue         = 2,
    kOriginalValue = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool wasPresent = static_cast<bool>(0);
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool wasPresent = static_cast<bool>(0);
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalResponse
namespace TestStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::SimpleStruct::DecodableType arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArgumentRequest
namespace TestComplexNullableOptionalResponse {
enum class Fields : uint8_t
{
    kNullableIntWasNull               = 0,
    kNullableIntValue                 = 1,
    kOptionalIntWasPresent            = 2,
    kOptionalIntValue                 = 3,
    kNullableOptionalIntWasPresent    = 4,
    kNullableOptionalIntWasNull       = 5,
    kNullableOptionalIntValue         = 6,
    kNullableStringWasNull            = 7,
    kNullableStringValue              = 8,
    kOptionalStringWasPresent         = 9,
    kOptionalStringValue              = 10,
    kNullableOptionalStringWasPresent = 11,
    kNullableOptionalStringWasNull    = 12,
    kNullableOptionalStringValue      = 13,
    kNullableStructWasNull            = 14,
    kNullableStructValue              = 15,
    kOptionalStructWasPresent         = 16,
    kOptionalStructValue              = 17,
    kNullableOptionalStructWasPresent = 18,
    kNullableOptionalStructWasNull    = 19,
    kNullableOptionalStructValue      = 20,
    kNullableListWasNull              = 21,
    kNullableListValue                = 22,
    kOptionalListWasPresent           = 23,
    kOptionalListValue                = 24,
    kNullableOptionalListWasPresent   = 25,
    kNullableOptionalListWasNull      = 26,
    kNullableOptionalListValue        = 27,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool nullableIntWasNull = static_cast<bool>(0);
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent = static_cast<bool>(0);
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull = static_cast<bool>(0);
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent = static_cast<bool>(0);
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::Type> nullableStructValue;
    bool optionalStructWasPresent = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::Type> optionalStructValue;
    bool nullableOptionalStructWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::Type> nullableOptionalStructValue;
    bool nullableListWasNull = static_cast<bool>(0);
    Optional<DataModel::List<const SimpleEnum>> nullableListValue;
    bool optionalListWasPresent = static_cast<bool>(0);
    Optional<DataModel::List<const SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::List<const SimpleEnum>> nullableOptionalListValue;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool nullableIntWasNull = static_cast<bool>(0);
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent = static_cast<bool>(0);
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull = static_cast<bool>(0);
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent = static_cast<bool>(0);
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::DecodableType> nullableStructValue;
    bool optionalStructWasPresent = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::DecodableType> optionalStructValue;
    bool nullableOptionalStructWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::DecodableType> nullableOptionalStructValue;
    bool nullableListWasNull = static_cast<bool>(0);
    Optional<DataModel::DecodableList<SimpleEnum>> nullableListValue;
    bool optionalListWasPresent = static_cast<bool>(0);
    Optional<DataModel::DecodableList<SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::DecodableList<SimpleEnum>> nullableOptionalListValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalResponse
namespace TestNestedStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::NestedStruct::DecodableType arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructArgumentRequest
namespace BooleanResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool value = static_cast<bool>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool value = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BooleanResponse
namespace TestListStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::SimpleStruct::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListStructArgumentRequest
namespace SimpleStructResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructResponse
namespace TestListInt8UArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::DecodableList<uint8_t> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UArgumentRequest
namespace TestEmitTestEventResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventResponse
namespace TestNestedStructListArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStructList::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::NestedStructList::DecodableType arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructListArgumentRequest
namespace TestEmitTestFabricScopedEventResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestFabricScopedEventResponse
namespace TestListNestedStructListArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListNestedStructListArgumentRequest
namespace TestBatchHelperResponse {
enum class Fields : uint8_t
{
    kBuffer = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan buffer;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan buffer;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestBatchHelperResponse
namespace TestListInt8UReverseRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestListInt8UReverseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::DecodableList<uint8_t> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseRequest
namespace StringEchoResponse {
enum class Fields : uint8_t
{
    kPayload = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StringEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StringEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StringEchoResponse
namespace TestEnumsRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEnumsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsRequest
namespace GlobalEchoResponse {
enum class Fields : uint8_t
{
    kField1 = 0,
    kField2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::Type field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::DecodableType field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GlobalEchoResponse
namespace TestNullableOptionalRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<DataModel::Nullable<uint8_t>> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalRequest
namespace TestComplexNullableOptionalRequest {
enum class Fields : uint8_t
{
    kNullableInt            = 0,
    kOptionalInt            = 1,
    kNullableOptionalInt    = 2,
    kNullableString         = 3,
    kOptionalString         = 4,
    kNullableOptionalString = 5,
    kNullableStruct         = 6,
    kOptionalStruct         = 7,
    kNullableOptionalStruct = 8,
    kNullableList           = 9,
    kOptionalList           = 10,
    kNullableOptionalList   = 11,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestComplexNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalRequest
namespace SimpleStructEchoRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::SimpleStructResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::SimpleStruct::DecodableType arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructEchoRequest
namespace TimedInvokeRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimedInvokeRequest
namespace TestSimpleOptionalArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<bool> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<bool> arg1;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleOptionalArgumentRequest
namespace TestEmitTestEventRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEmitTestEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventRequest
namespace TestEmitTestFabricScopedEventRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEmitTestFabricScopedEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestFabricScopedEventRequest
namespace TestBatchHelperRequest {
enum class Fields : uint8_t
{
    kSleepBeforeResponseTimeMs = 0,
    kSizeOfResponseBuffer      = 1,
    kFillCharacter             = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestBatchHelperResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestBatchHelperRequest
namespace TestSecondBatchHelperRequest {
enum class Fields : uint8_t
{
    kSleepBeforeResponseTimeMs = 0,
    kSizeOfResponseBuffer      = 1,
    kFillCharacter             = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSecondBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestBatchHelperResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSecondBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSecondBatchHelperRequest
namespace StringEchoRequest {
enum class Fields : uint8_t
{
    kPayload = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StringEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::StringEchoResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StringEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan payload;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StringEchoRequest
namespace GlobalEchoRequest {
enum class Fields : uint8_t
{
    kField1 = 0,
    kField2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::Type field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::GlobalEchoResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    Globals::Structs::TestGlobalStruct::DecodableType field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GlobalEchoRequest
namespace TestCheckCommandFlags {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestCheckCommandFlags::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestCheckCommandFlags::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = true;

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace TestCheckCommandFlags
namespace TestDifferentVendorMeiRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestDifferentVendorMeiResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestDifferentVendorMeiRequest
namespace TestDifferentVendorMeiResponse {
enum class Fields : uint8_t
{
    kArg1        = 0,
    kEventNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1         = static_cast<uint8_t>(0);
    uint64_t eventNumber = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1         = static_cast<uint8_t>(0);
    uint64_t eventNumber = static_cast<uint64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestDifferentVendorMeiResponse
} // namespace Commands
} // namespace UnitTesting
} // namespace Clusters
} // namespace app
} // namespace chip
