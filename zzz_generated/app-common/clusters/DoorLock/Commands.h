/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
// This file is generated from clusters-Commands.h.zapt

#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/data-model/Nullable.h>
#include <lib/core/DataModelTypes.h>
#include <lib/core/Optional.h>
#include <lib/core/TLV.h>
#include <lib/support/BitMask.h>

#include <clusters/shared/Enums.h>
#include <clusters/shared/Structs.h>

#include <clusters/DoorLock/ClusterId.h>
#include <clusters/DoorLock/CommandIds.h>
#include <clusters/DoorLock/Enums.h>
#include <clusters/DoorLock/Structs.h>

#include <cstdint>

namespace chip {
namespace app {
namespace Clusters {
namespace DoorLock {
namespace Commands {
// Forward-declarations so we can reference these later.

namespace LockDoor {
struct Type;
struct DecodableType;
} // namespace LockDoor

namespace UnlockDoor {
struct Type;
struct DecodableType;
} // namespace UnlockDoor

namespace UnlockWithTimeout {
struct Type;
struct DecodableType;
} // namespace UnlockWithTimeout

namespace SetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeekDaySchedule

namespace GetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeekDaySchedule

namespace GetWeekDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeekDayScheduleResponse

namespace ClearWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeekDaySchedule

namespace SetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetYearDaySchedule

namespace GetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetYearDaySchedule

namespace GetYearDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetYearDayScheduleResponse

namespace ClearYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearYearDaySchedule

namespace SetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace SetHolidaySchedule

namespace GetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace GetHolidaySchedule

namespace GetHolidayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetHolidayScheduleResponse

namespace ClearHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearHolidaySchedule

namespace SetUser {
struct Type;
struct DecodableType;
} // namespace SetUser

namespace GetUser {
struct Type;
struct DecodableType;
} // namespace GetUser

namespace GetUserResponse {
struct Type;
struct DecodableType;
} // namespace GetUserResponse

namespace ClearUser {
struct Type;
struct DecodableType;
} // namespace ClearUser

namespace SetCredential {
struct Type;
struct DecodableType;
} // namespace SetCredential

namespace SetCredentialResponse {
struct Type;
struct DecodableType;
} // namespace SetCredentialResponse

namespace GetCredentialStatus {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatus

namespace GetCredentialStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatusResponse

namespace ClearCredential {
struct Type;
struct DecodableType;
} // namespace ClearCredential

namespace UnboltDoor {
struct Type;
struct DecodableType;
} // namespace UnboltDoor

namespace SetAliroReaderConfig {
struct Type;
struct DecodableType;
} // namespace SetAliroReaderConfig

namespace ClearAliroReaderConfig {
struct Type;
struct DecodableType;
} // namespace ClearAliroReaderConfig

} // namespace Commands

namespace Commands {
namespace LockDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LockDoor
namespace UnlockDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockDoor
namespace UnlockWithTimeout {
enum class Fields : uint8_t
{
    kTimeout = 0,
    kPINCode = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t timeout = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockWithTimeout
namespace SetWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kDaysMask     = 2,
    kStartHour    = 3,
    kStartMinute  = 4,
    kEndHour      = 5,
    kEndMinute    = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex                = static_cast<uint8_t>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    chip::BitMask<DaysMaskMap> daysMask = static_cast<chip::BitMask<DaysMaskMap>>(0);
    uint8_t startHour                   = static_cast<uint8_t>(0);
    uint8_t startMinute                 = static_cast<uint8_t>(0);
    uint8_t endHour                     = static_cast<uint8_t>(0);
    uint8_t endMinute                   = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t weekDayIndex                = static_cast<uint8_t>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    chip::BitMask<DaysMaskMap> daysMask = static_cast<chip::BitMask<DaysMaskMap>>(0);
    uint8_t startHour                   = static_cast<uint8_t>(0);
    uint8_t startMinute                 = static_cast<uint8_t>(0);
    uint8_t endHour                     = static_cast<uint8_t>(0);
    uint8_t endMinute                   = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeekDaySchedule
namespace GetWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDaySchedule
namespace GetWeekDayScheduleResponse {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kStatus       = 2,
    kDaysMask     = 3,
    kStartHour    = 4,
    kStartMinute  = 5,
    kEndHour      = 6,
    kEndMinute    = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<chip::BitMask<DaysMaskMap>> daysMask;
    Optional<uint8_t> startHour;
    Optional<uint8_t> startMinute;
    Optional<uint8_t> endHour;
    Optional<uint8_t> endMinute;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<chip::BitMask<DaysMaskMap>> daysMask;
    Optional<uint8_t> startHour;
    Optional<uint8_t> startMinute;
    Optional<uint8_t> endHour;
    Optional<uint8_t> endMinute;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDayScheduleResponse
namespace ClearWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeekDaySchedule
namespace SetYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex    = static_cast<uint8_t>(0);
    uint16_t userIndex      = static_cast<uint16_t>(0);
    uint32_t localStartTime = static_cast<uint32_t>(0);
    uint32_t localEndTime   = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t yearDayIndex    = static_cast<uint8_t>(0);
    uint16_t userIndex      = static_cast<uint16_t>(0);
    uint32_t localStartTime = static_cast<uint32_t>(0);
    uint32_t localEndTime   = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetYearDaySchedule
namespace GetYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDaySchedule
namespace GetYearDayScheduleResponse {
enum class Fields : uint8_t
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kStatus         = 2,
    kLocalStartTime = 3,
    kLocalEndTime   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDayScheduleResponse
namespace ClearYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearYearDaySchedule
namespace SetHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex   = 0,
    kLocalStartTime = 1,
    kLocalEndTime   = 2,
    kOperatingMode  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex            = static_cast<uint8_t>(0);
    uint32_t localStartTime         = static_cast<uint32_t>(0);
    uint32_t localEndTime           = static_cast<uint32_t>(0);
    OperatingModeEnum operatingMode = static_cast<OperatingModeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t holidayIndex            = static_cast<uint8_t>(0);
    uint32_t localStartTime         = static_cast<uint32_t>(0);
    uint32_t localEndTime           = static_cast<uint32_t>(0);
    OperatingModeEnum operatingMode = static_cast<OperatingModeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetHolidaySchedule
namespace GetHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetHolidayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidaySchedule
namespace GetHolidayScheduleResponse {
enum class Fields : uint8_t
{
    kHolidayIndex   = 0,
    kStatus         = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
    kOperatingMode  = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    Optional<OperatingModeEnum> operatingMode;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    Optional<OperatingModeEnum> operatingMode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidayScheduleResponse
namespace ClearHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearHolidaySchedule
namespace SetUser {
enum class Fields : uint8_t
{
    kOperationType  = 0,
    kUserIndex      = 1,
    kUserName       = 2,
    kUserUniqueID   = 3,
    kUserStatus     = 4,
    kUserType       = 5,
    kCredentialRule = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUser
namespace GetUser {
enum class Fields : uint8_t
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetUserResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUser
namespace GetUserResponse {
enum class Fields : uint8_t
{
    kUserIndex               = 0,
    kUserName                = 1,
    kUserUniqueID            = 2,
    kUserStatus              = 3,
    kUserType                = 4,
    kCredentialRule          = 5,
    kCredentials             = 6,
    kCreatorFabricIndex      = 7,
    kLastModifiedFabricIndex = 8,
    kNextUserIndex           = 9,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextUserIndex;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextUserIndex;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserResponse
namespace ClearUser {
enum class Fields : uint8_t
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearUser
namespace SetCredential {
enum class Fields : uint8_t
{
    kOperationType  = 0,
    kCredential     = 1,
    kCredentialData = 2,
    kUserIndex      = 3,
    kUserStatus     = 4,
    kUserType       = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    Structs::CredentialStruct::Type credential;
    chip::ByteSpan credentialData;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    Structs::CredentialStruct::DecodableType credential;
    chip::ByteSpan credentialData;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredential
namespace SetCredentialResponse {
enum class Fields : uint8_t
{
    kStatus              = 0,
    kUserIndex           = 1,
    kNextCredentialIndex = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status = static_cast<DlStatus>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status = static_cast<DlStatus>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredentialResponse
namespace GetCredentialStatus {
enum class Fields : uint8_t
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::CredentialStruct::Type credential;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::CredentialStruct::DecodableType credential;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatus
namespace GetCredentialStatusResponse {
enum class Fields : uint8_t
{
    kCredentialExists        = 0,
    kUserIndex               = 1,
    kCreatorFabricIndex      = 2,
    kLastModifiedFabricIndex = 3,
    kNextCredentialIndex     = 4,
    kCredentialData          = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists = static_cast<bool>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    Optional<DataModel::Nullable<chip::ByteSpan>> credentialData;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists = static_cast<bool>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    Optional<DataModel::Nullable<chip::ByteSpan>> credentialData;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatusResponse
namespace ClearCredential {
enum class Fields : uint8_t
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataModel::Nullable<Structs::CredentialStruct::Type> credential;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::Nullable<Structs::CredentialStruct::DecodableType> credential;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearCredential
namespace UnboltDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnboltDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnboltDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnboltDoor
namespace SetAliroReaderConfig {
enum class Fields : uint8_t
{
    kSigningKey        = 0,
    kVerificationKey   = 1,
    kGroupIdentifier   = 2,
    kGroupResolvingKey = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    chip::ByteSpan signingKey;
    chip::ByteSpan verificationKey;
    chip::ByteSpan groupIdentifier;
    Optional<chip::ByteSpan> groupResolvingKey;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan signingKey;
    chip::ByteSpan verificationKey;
    chip::ByteSpan groupIdentifier;
    Optional<chip::ByteSpan> groupResolvingKey;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetAliroReaderConfig
namespace ClearAliroReaderConfig {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAliroReaderConfig
} // namespace Commands
} // namespace DoorLock
} // namespace Clusters
} // namespace app
} // namespace chip
