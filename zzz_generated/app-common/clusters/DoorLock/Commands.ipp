/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include <clusters/DoorLock/Commands.h>

#include <app/data-model/Decode.h>
#include <app/data-model/StructDecodeIterator.h>
#include <app/data-model/WrappedStructEncoder.h>

namespace chip {
namespace app {
namespace Clusters {
namespace DoorLock {
namespace Commands {
namespace LockDoor {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace LockDoor.
namespace UnlockDoor {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnlockDoor.
namespace UnlockWithTimeout {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kTimeout), timeout);
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kTimeout))
        {
            err = DataModel::Decode(reader, timeout);
        }
        else if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnlockWithTimeout.
namespace SetWeekDaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kDaysMask), daysMask);
    encoder.Encode(to_underlying(Fields::kStartHour), startHour);
    encoder.Encode(to_underlying(Fields::kStartMinute), startMinute);
    encoder.Encode(to_underlying(Fields::kEndHour), endHour);
    encoder.Encode(to_underlying(Fields::kEndMinute), endMinute);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kDaysMask))
        {
            err = DataModel::Decode(reader, daysMask);
        }
        else if (__context_tag == to_underlying(Fields::kStartHour))
        {
            err = DataModel::Decode(reader, startHour);
        }
        else if (__context_tag == to_underlying(Fields::kStartMinute))
        {
            err = DataModel::Decode(reader, startMinute);
        }
        else if (__context_tag == to_underlying(Fields::kEndHour))
        {
            err = DataModel::Decode(reader, endHour);
        }
        else if (__context_tag == to_underlying(Fields::kEndMinute))
        {
            err = DataModel::Decode(reader, endMinute);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetWeekDaySchedule.
namespace GetWeekDaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetWeekDaySchedule.
namespace GetWeekDayScheduleResponse {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kDaysMask), daysMask);
    encoder.Encode(to_underlying(Fields::kStartHour), startHour);
    encoder.Encode(to_underlying(Fields::kStartMinute), startMinute);
    encoder.Encode(to_underlying(Fields::kEndHour), endHour);
    encoder.Encode(to_underlying(Fields::kEndMinute), endMinute);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kDaysMask))
        {
            err = DataModel::Decode(reader, daysMask);
        }
        else if (__context_tag == to_underlying(Fields::kStartHour))
        {
            err = DataModel::Decode(reader, startHour);
        }
        else if (__context_tag == to_underlying(Fields::kStartMinute))
        {
            err = DataModel::Decode(reader, startMinute);
        }
        else if (__context_tag == to_underlying(Fields::kEndHour))
        {
            err = DataModel::Decode(reader, endHour);
        }
        else if (__context_tag == to_underlying(Fields::kEndMinute))
        {
            err = DataModel::Decode(reader, endMinute);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetWeekDayScheduleResponse.
namespace ClearWeekDaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kWeekDayIndex), weekDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kWeekDayIndex))
        {
            err = DataModel::Decode(reader, weekDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearWeekDaySchedule.
namespace SetYearDaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetYearDaySchedule.
namespace GetYearDaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetYearDaySchedule.
namespace GetYearDayScheduleResponse {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetYearDayScheduleResponse.
namespace ClearYearDaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kYearDayIndex), yearDayIndex);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kYearDayIndex))
        {
            err = DataModel::Decode(reader, yearDayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearYearDaySchedule.
namespace SetHolidaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    encoder.Encode(to_underlying(Fields::kOperatingMode), operatingMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }
        else if (__context_tag == to_underlying(Fields::kOperatingMode))
        {
            err = DataModel::Decode(reader, operatingMode);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetHolidaySchedule.
namespace GetHolidaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetHolidaySchedule.
namespace GetHolidayScheduleResponse {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kLocalStartTime), localStartTime);
    encoder.Encode(to_underlying(Fields::kLocalEndTime), localEndTime);
    encoder.Encode(to_underlying(Fields::kOperatingMode), operatingMode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }
        else if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kLocalStartTime))
        {
            err = DataModel::Decode(reader, localStartTime);
        }
        else if (__context_tag == to_underlying(Fields::kLocalEndTime))
        {
            err = DataModel::Decode(reader, localEndTime);
        }
        else if (__context_tag == to_underlying(Fields::kOperatingMode))
        {
            err = DataModel::Decode(reader, operatingMode);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetHolidayScheduleResponse.
namespace ClearHolidaySchedule {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kHolidayIndex), holidayIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kHolidayIndex))
        {
            err = DataModel::Decode(reader, holidayIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearHolidaySchedule.
namespace SetUser {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationType), operationType);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kUserName), userName);
    encoder.Encode(to_underlying(Fields::kUserUniqueID), userUniqueID);
    encoder.Encode(to_underlying(Fields::kUserStatus), userStatus);
    encoder.Encode(to_underlying(Fields::kUserType), userType);
    encoder.Encode(to_underlying(Fields::kCredentialRule), credentialRule);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kOperationType))
        {
            err = DataModel::Decode(reader, operationType);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserName))
        {
            err = DataModel::Decode(reader, userName);
        }
        else if (__context_tag == to_underlying(Fields::kUserUniqueID))
        {
            err = DataModel::Decode(reader, userUniqueID);
        }
        else if (__context_tag == to_underlying(Fields::kUserStatus))
        {
            err = DataModel::Decode(reader, userStatus);
        }
        else if (__context_tag == to_underlying(Fields::kUserType))
        {
            err = DataModel::Decode(reader, userType);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialRule))
        {
            err = DataModel::Decode(reader, credentialRule);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetUser.
namespace GetUser {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetUser.
namespace GetUserResponse {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kUserName), userName);
    encoder.Encode(to_underlying(Fields::kUserUniqueID), userUniqueID);
    encoder.Encode(to_underlying(Fields::kUserStatus), userStatus);
    encoder.Encode(to_underlying(Fields::kUserType), userType);
    encoder.Encode(to_underlying(Fields::kCredentialRule), credentialRule);
    encoder.Encode(to_underlying(Fields::kCredentials), credentials);
    encoder.Encode(to_underlying(Fields::kCreatorFabricIndex), creatorFabricIndex);
    encoder.Encode(to_underlying(Fields::kLastModifiedFabricIndex), lastModifiedFabricIndex);
    encoder.Encode(to_underlying(Fields::kNextUserIndex), nextUserIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserName))
        {
            err = DataModel::Decode(reader, userName);
        }
        else if (__context_tag == to_underlying(Fields::kUserUniqueID))
        {
            err = DataModel::Decode(reader, userUniqueID);
        }
        else if (__context_tag == to_underlying(Fields::kUserStatus))
        {
            err = DataModel::Decode(reader, userStatus);
        }
        else if (__context_tag == to_underlying(Fields::kUserType))
        {
            err = DataModel::Decode(reader, userType);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialRule))
        {
            err = DataModel::Decode(reader, credentialRule);
        }
        else if (__context_tag == to_underlying(Fields::kCredentials))
        {
            err = DataModel::Decode(reader, credentials);
        }
        else if (__context_tag == to_underlying(Fields::kCreatorFabricIndex))
        {
            err = DataModel::Decode(reader, creatorFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLastModifiedFabricIndex))
        {
            err = DataModel::Decode(reader, lastModifiedFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNextUserIndex))
        {
            err = DataModel::Decode(reader, nextUserIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetUserResponse.
namespace ClearUser {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearUser.
namespace SetCredential {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kOperationType), operationType);
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    encoder.Encode(to_underlying(Fields::kCredentialData), credentialData);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kUserStatus), userStatus);
    encoder.Encode(to_underlying(Fields::kUserType), userType);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kOperationType))
        {
            err = DataModel::Decode(reader, operationType);
        }
        else if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialData))
        {
            err = DataModel::Decode(reader, credentialData);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kUserStatus))
        {
            err = DataModel::Decode(reader, userStatus);
        }
        else if (__context_tag == to_underlying(Fields::kUserType))
        {
            err = DataModel::Decode(reader, userType);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetCredential.
namespace SetCredentialResponse {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kStatus), status);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kNextCredentialIndex), nextCredentialIndex);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kStatus))
        {
            err = DataModel::Decode(reader, status);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNextCredentialIndex))
        {
            err = DataModel::Decode(reader, nextCredentialIndex);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetCredentialResponse.
namespace GetCredentialStatus {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetCredentialStatus.
namespace GetCredentialStatusResponse {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredentialExists), credentialExists);
    encoder.Encode(to_underlying(Fields::kUserIndex), userIndex);
    encoder.Encode(to_underlying(Fields::kCreatorFabricIndex), creatorFabricIndex);
    encoder.Encode(to_underlying(Fields::kLastModifiedFabricIndex), lastModifiedFabricIndex);
    encoder.Encode(to_underlying(Fields::kNextCredentialIndex), nextCredentialIndex);
    encoder.Encode(to_underlying(Fields::kCredentialData), credentialData);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kCredentialExists))
        {
            err = DataModel::Decode(reader, credentialExists);
        }
        else if (__context_tag == to_underlying(Fields::kUserIndex))
        {
            err = DataModel::Decode(reader, userIndex);
        }
        else if (__context_tag == to_underlying(Fields::kCreatorFabricIndex))
        {
            err = DataModel::Decode(reader, creatorFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kLastModifiedFabricIndex))
        {
            err = DataModel::Decode(reader, lastModifiedFabricIndex);
        }
        else if (__context_tag == to_underlying(Fields::kNextCredentialIndex))
        {
            err = DataModel::Decode(reader, nextCredentialIndex);
        }
        else if (__context_tag == to_underlying(Fields::kCredentialData))
        {
            err = DataModel::Decode(reader, credentialData);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace GetCredentialStatusResponse.
namespace ClearCredential {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kCredential), credential);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kCredential))
        {
            err = DataModel::Decode(reader, credential);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearCredential.
namespace UnboltDoor {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kPINCode), PINCode);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kPINCode))
        {
            err = DataModel::Decode(reader, PINCode);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace UnboltDoor.
namespace SetAliroReaderConfig {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    encoder.Encode(to_underlying(Fields::kSigningKey), signingKey);
    encoder.Encode(to_underlying(Fields::kVerificationKey), verificationKey);
    encoder.Encode(to_underlying(Fields::kGroupIdentifier), groupIdentifier);
    encoder.Encode(to_underlying(Fields::kGroupResolvingKey), groupResolvingKey);
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        if (__context_tag == to_underlying(Fields::kSigningKey))
        {
            err = DataModel::Decode(reader, signingKey);
        }
        else if (__context_tag == to_underlying(Fields::kVerificationKey))
        {
            err = DataModel::Decode(reader, verificationKey);
        }
        else if (__context_tag == to_underlying(Fields::kGroupIdentifier))
        {
            err = DataModel::Decode(reader, groupIdentifier);
        }
        else if (__context_tag == to_underlying(Fields::kGroupResolvingKey))
        {
            err = DataModel::Decode(reader, groupResolvingKey);
        }

        ReturnErrorOnFailure(err);
    }
}
} // namespace SetAliroReaderConfig.
namespace ClearAliroReaderConfig {

CHIP_ERROR Type::Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const
{
    DataModel::WrappedStructEncoder encoder{ aWriter, aTag };
    return encoder.Finalize();
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    detail::StructDecodeIterator __iterator(reader);
    while (true)
    {
        uint8_t __context_tag = 0;
        CHIP_ERROR err        = __iterator.Next(__context_tag);
        VerifyOrReturnError(err != CHIP_ERROR_END_OF_TLV, CHIP_NO_ERROR);
        ReturnErrorOnFailure(err);

        ReturnErrorOnFailure(err);
    }
}
} // namespace ClearAliroReaderConfig.
} // namespace Commands
} // namespace DoorLock
} // namespace Clusters
} // namespace app
} // namespace chip
