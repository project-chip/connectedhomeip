/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/List.h>
#include <app/data-model/Nullable.h>
#include <app/util/basic-types.h>
#include <lib/core/Optional.h>
#include <lib/core/TLV.h>
#include <lib/support/BitMask.h>

#include <clusters/shared/Structs.h>

#include <cstdint>

namespace chip {
namespace app {
namespace Clusters {
namespace JointFabricDatastore {
namespace Structs {
namespace DatastoreStatusEntryStruct {
enum class Fields : uint8_t
{
    kState           = 0,
    kUpdateTimestamp = 1,
    kFailureCode     = 2,
};

struct Type
{
public:
    DatastoreStateEnum state = static_cast<DatastoreStateEnum>(0);
    uint32_t updateTimestamp = static_cast<uint32_t>(0);
    uint8_t failureCode      = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreStatusEntryStruct
namespace DatastoreNodeKeySetEntryStruct {
enum class Fields : uint8_t
{
    kNodeID        = 0,
    kGroupKeySetID = 1,
    kStatusEntry   = 2,
};

struct Type
{
public:
    chip::NodeId nodeID    = static_cast<chip::NodeId>(0);
    uint16_t groupKeySetID = static_cast<uint16_t>(0);
    Structs::DatastoreStatusEntryStruct::Type statusEntry;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreNodeKeySetEntryStruct
namespace DatastoreNodeInformationEntryStruct {
enum class Fields : uint8_t
{
    kNodeID                   = 1,
    kFriendlyName             = 2,
    kCommissioningStatusEntry = 3,
};

struct Type
{
public:
    chip::NodeId nodeID = static_cast<chip::NodeId>(0);
    chip::CharSpan friendlyName;
    Structs::DatastoreStatusEntryStruct::Type commissioningStatusEntry;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreNodeInformationEntryStruct
namespace DatastoreEndpointGroupIDEntryStruct {
enum class Fields : uint8_t
{
    kNodeID      = 0,
    kEndpointID  = 1,
    kGroupID     = 2,
    kStatusEntry = 3,
};

struct Type
{
public:
    chip::NodeId nodeID         = static_cast<chip::NodeId>(0);
    chip::EndpointId endpointID = static_cast<chip::EndpointId>(0);
    chip::GroupId groupID       = static_cast<chip::GroupId>(0);
    Structs::DatastoreStatusEntryStruct::Type statusEntry;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreEndpointGroupIDEntryStruct
namespace DatastoreEndpointEntryStruct {
enum class Fields : uint8_t
{
    kEndpointID   = 0,
    kNodeID       = 1,
    kFriendlyName = 2,
    kStatusEntry  = 3,
};

struct Type
{
public:
    chip::EndpointId endpointID = static_cast<chip::EndpointId>(0);
    chip::NodeId nodeID         = static_cast<chip::NodeId>(0);
    chip::CharSpan friendlyName;
    Structs::DatastoreStatusEntryStruct::Type statusEntry;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreEndpointEntryStruct
namespace DatastoreBindingTargetStruct {
enum class Fields : uint8_t
{
    kNode     = 1,
    kGroup    = 2,
    kEndpoint = 3,
    kCluster  = 4,
};

struct Type
{
public:
    Optional<chip::NodeId> node;
    Optional<chip::GroupId> group;
    Optional<chip::EndpointId> endpoint;
    Optional<chip::ClusterId> cluster;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreBindingTargetStruct
namespace DatastoreEndpointBindingEntryStruct {
enum class Fields : uint8_t
{
    kNodeID      = 0,
    kEndpointID  = 1,
    kListID      = 2,
    kBinding     = 3,
    kStatusEntry = 4,
};

struct Type
{
public:
    chip::NodeId nodeID         = static_cast<chip::NodeId>(0);
    chip::EndpointId endpointID = static_cast<chip::EndpointId>(0);
    uint16_t listID             = static_cast<uint16_t>(0);
    Structs::DatastoreBindingTargetStruct::Type binding;
    Structs::DatastoreStatusEntryStruct::Type statusEntry;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreEndpointBindingEntryStruct
namespace DatastoreAccessControlTargetStruct {
enum class Fields : uint8_t
{
    kCluster    = 0,
    kEndpoint   = 1,
    kDeviceType = 2,
};

struct Type
{
public:
    DataModel::Nullable<chip::ClusterId> cluster;
    DataModel::Nullable<chip::EndpointId> endpoint;
    DataModel::Nullable<chip::DeviceTypeId> deviceType;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreAccessControlTargetStruct
namespace DatastoreAccessControlEntryStruct {
enum class Fields : uint8_t
{
    kPrivilege = 1,
    kAuthMode  = 2,
    kSubjects  = 3,
    kTargets   = 4,
};

struct Type
{
public:
    DatastoreAccessControlEntryPrivilegeEnum privilege = static_cast<DatastoreAccessControlEntryPrivilegeEnum>(0);
    DatastoreAccessControlEntryAuthModeEnum authMode   = static_cast<DatastoreAccessControlEntryAuthModeEnum>(0);
    DataModel::Nullable<DataModel::List<const uint64_t>> subjects;
    DataModel::Nullable<DataModel::List<const Structs::DatastoreAccessControlTargetStruct::Type>> targets;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DatastoreAccessControlEntryPrivilegeEnum privilege = static_cast<DatastoreAccessControlEntryPrivilegeEnum>(0);
    DatastoreAccessControlEntryAuthModeEnum authMode   = static_cast<DatastoreAccessControlEntryAuthModeEnum>(0);
    DataModel::Nullable<DataModel::DecodableList<uint64_t>> subjects;
    DataModel::Nullable<DataModel::DecodableList<Structs::DatastoreAccessControlTargetStruct::DecodableType>> targets;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace DatastoreAccessControlEntryStruct
namespace DatastoreACLEntryStruct {
enum class Fields : uint8_t
{
    kNodeID      = 0,
    kListID      = 1,
    kACLEntry    = 2,
    kStatusEntry = 3,
};

struct Type
{
public:
    chip::NodeId nodeID = static_cast<chip::NodeId>(0);
    uint16_t listID     = static_cast<uint16_t>(0);
    Structs::DatastoreAccessControlEntryStruct::Type ACLEntry;
    Structs::DatastoreStatusEntryStruct::Type statusEntry;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::NodeId nodeID = static_cast<chip::NodeId>(0);
    uint16_t listID     = static_cast<uint16_t>(0);
    Structs::DatastoreAccessControlEntryStruct::DecodableType ACLEntry;
    Structs::DatastoreStatusEntryStruct::DecodableType statusEntry;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace DatastoreACLEntryStruct
namespace DatastoreAdministratorInformationEntryStruct {
enum class Fields : uint8_t
{
    kNodeID       = 1,
    kFriendlyName = 2,
    kVendorID     = 3,
    kIcac         = 4,
};

struct Type
{
public:
    chip::NodeId nodeID = static_cast<chip::NodeId>(0);
    chip::CharSpan friendlyName;
    chip::VendorId vendorID = static_cast<chip::VendorId>(0);
    chip::ByteSpan icac;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreAdministratorInformationEntryStruct
namespace DatastoreGroupInformationEntryStruct {
enum class Fields : uint8_t
{
    kGroupID         = 0,
    kFriendlyName    = 1,
    kGroupKeySetID   = 2,
    kGroupCAT        = 3,
    kGroupCATVersion = 4,
    kGroupPermission = 5,
};

struct Type
{
public:
    uint64_t groupID = static_cast<uint64_t>(0);
    chip::CharSpan friendlyName;
    DataModel::Nullable<uint16_t> groupKeySetID;
    DataModel::Nullable<uint16_t> groupCAT;
    DataModel::Nullable<uint16_t> groupCATVersion;
    DatastoreAccessControlEntryPrivilegeEnum groupPermission = static_cast<DatastoreAccessControlEntryPrivilegeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreGroupInformationEntryStruct
namespace DatastoreGroupKeySetStruct {
enum class Fields : uint8_t
{
    kGroupKeySetID           = 0,
    kGroupKeySecurityPolicy  = 1,
    kEpochKey0               = 2,
    kEpochStartTime0         = 3,
    kEpochKey1               = 4,
    kEpochStartTime1         = 5,
    kEpochKey2               = 6,
    kEpochStartTime2         = 7,
    kGroupKeyMulticastPolicy = 8,
};

struct Type
{
public:
    uint16_t groupKeySetID                                     = static_cast<uint16_t>(0);
    DatastoreGroupKeySecurityPolicyEnum groupKeySecurityPolicy = static_cast<DatastoreGroupKeySecurityPolicyEnum>(0);
    DataModel::Nullable<chip::ByteSpan> epochKey0;
    DataModel::Nullable<uint64_t> epochStartTime0;
    DataModel::Nullable<chip::ByteSpan> epochKey1;
    DataModel::Nullable<uint64_t> epochStartTime1;
    DataModel::Nullable<chip::ByteSpan> epochKey2;
    DataModel::Nullable<uint64_t> epochStartTime2;
    DatastoreGroupKeyMulticastPolicyEnum groupKeyMulticastPolicy = static_cast<DatastoreGroupKeyMulticastPolicyEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DatastoreGroupKeySetStruct
} // namespace Structs
} // namespace JointFabricDatastore
} // namespace Clusters
} // namespace app
} // namespace chip
