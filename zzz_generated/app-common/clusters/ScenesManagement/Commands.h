/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
// This file is generated from clusters-Commands.h.zapt

#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/data-model/Nullable.h>
#include <lib/core/DataModelTypes.h>
#include <lib/core/Optional.h>
#include <lib/core/TLV.h>
#include <lib/support/BitMask.h>

#include <clusters/shared/Enums.h>
#include <clusters/shared/Structs.h>

#include <clusters/ScenesManagement/ClusterId.h>
#include <clusters/ScenesManagement/CommandIds.h>
#include <clusters/ScenesManagement/Enums.h>
#include <clusters/ScenesManagement/Structs.h>

#include <cstdint>

namespace chip {
namespace app {
namespace Clusters {
namespace ScenesManagement {
namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddScene {
struct Type;
struct DecodableType;
} // namespace AddScene

namespace AddSceneResponse {
struct Type;
struct DecodableType;
} // namespace AddSceneResponse

namespace ViewScene {
struct Type;
struct DecodableType;
} // namespace ViewScene

namespace ViewSceneResponse {
struct Type;
struct DecodableType;
} // namespace ViewSceneResponse

namespace RemoveScene {
struct Type;
struct DecodableType;
} // namespace RemoveScene

namespace RemoveSceneResponse {
struct Type;
struct DecodableType;
} // namespace RemoveSceneResponse

namespace RemoveAllScenes {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenes

namespace RemoveAllScenesResponse {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenesResponse

namespace StoreScene {
struct Type;
struct DecodableType;
} // namespace StoreScene

namespace StoreSceneResponse {
struct Type;
struct DecodableType;
} // namespace StoreSceneResponse

namespace RecallScene {
struct Type;
struct DecodableType;
} // namespace RecallScene

namespace GetSceneMembership {
struct Type;
struct DecodableType;
} // namespace GetSceneMembership

namespace GetSceneMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetSceneMembershipResponse

namespace CopyScene {
struct Type;
struct DecodableType;
} // namespace CopyScene

namespace CopySceneResponse {
struct Type;
struct DecodableType;
} // namespace CopySceneResponse

} // namespace Commands

namespace Commands {
namespace AddScene {
enum class Fields : uint8_t
{
    kGroupID                  = 0,
    kSceneID                  = 1,
    kTransitionTime           = 2,
    kSceneName                = 3,
    kExtensionFieldSetStructs = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID   = static_cast<chip::GroupId>(0);
    uint8_t sceneID         = static_cast<uint8_t>(0);
    uint32_t transitionTime = static_cast<uint32_t>(0);
    chip::CharSpan sceneName;
    DataModel::List<const Structs::ExtensionFieldSetStruct::Type> extensionFieldSetStructs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::AddSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID   = static_cast<chip::GroupId>(0);
    uint8_t sceneID         = static_cast<uint8_t>(0);
    uint32_t transitionTime = static_cast<uint32_t>(0);
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::ExtensionFieldSetStruct::DecodableType> extensionFieldSetStructs;

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace AddScene
namespace AddSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddSceneResponse
namespace ViewScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::ViewSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace ViewScene
namespace ViewSceneResponse {
enum class Fields : uint8_t
{
    kStatus                   = 0,
    kGroupID                  = 1,
    kSceneID                  = 2,
    kTransitionTime           = 3,
    kSceneName                = 4,
    kExtensionFieldSetStructs = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<uint32_t> transitionTime;
    Optional<chip::CharSpan> sceneName;
    Optional<DataModel::List<const Structs::ExtensionFieldSetStruct::Type>> extensionFieldSetStructs;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<uint32_t> transitionTime;
    Optional<chip::CharSpan> sceneName;
    Optional<DataModel::DecodableList<Structs::ExtensionFieldSetStruct::DecodableType>> extensionFieldSetStructs;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewSceneResponse
namespace RemoveScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::RemoveSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace RemoveScene
namespace RemoveSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveSceneResponse
namespace RemoveAllScenes {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::RemoveAllScenesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace RemoveAllScenes
namespace RemoveAllScenesResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenesResponse
namespace StoreScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::StoreSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace StoreScene
namespace StoreSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreSceneResponse
namespace RecallScene {
enum class Fields : uint8_t
{
    kGroupID        = 0,
    kSceneID        = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> transitionTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace RecallScene
namespace GetSceneMembership {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::GetSceneMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace GetSceneMembership
namespace GetSceneMembershipResponse {
enum class Fields : uint8_t
{
    kStatus    = 0,
    kCapacity  = 1,
    kGroupID   = 2,
    kSceneList = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    DataModel::Nullable<uint8_t> capacity;
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    Optional<DataModel::List<const uint8_t>> sceneList;

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    DataModel::Nullable<uint8_t> capacity;
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    Optional<DataModel::DecodableList<uint8_t>> sceneList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembershipResponse
namespace CopyScene {
enum class Fields : uint8_t
{
    kMode                = 0,
    kGroupIdentifierFrom = 1,
    kSceneIdentifierFrom = 2,
    kGroupIdentifierTo   = 3,
    kSceneIdentifierTo   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::BitMask<CopyModeBitmap> mode = static_cast<chip::BitMask<CopyModeBitmap>>(0);
    chip::GroupId groupIdentifierFrom  = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom        = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierTo    = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierTo          = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::CopySceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::BitMask<CopyModeBitmap> mode = static_cast<chip::BitMask<CopyModeBitmap>>(0);
    chip::GroupId groupIdentifierFrom  = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom        = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierTo    = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierTo          = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader, FabricIndex aAccessingFabricIndex);
};
}; // namespace CopyScene
namespace CopySceneResponse {
enum class Fields : uint8_t
{
    kStatus              = 0,
    kGroupIdentifierFrom = 1,
    kSceneIdentifierFrom = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status                    = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierFrom = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(DataModel::FabricAwareTLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status                    = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierFrom = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom       = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopySceneResponse
} // namespace Commands
} // namespace ScenesManagement
} // namespace Clusters
} // namespace app
} // namespace chip
