/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include "af-structs.h"
#include "enums.h"
#include <app/util/af.h>
#include <app/util/attribute-list-byte-span.h>
#include <app/util/basic-types.h>
#include <lib/core/CHIPSafeCasts.h>
#include <lib/core/CHIPTLV.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/Span.h>
#include <lib/support/logging/CHIPLogging.h>
#include <stdint.h>

// TODO: This still not resolves issue for lists inside struct, however, it resolves lists of structs.

using namespace chip;
using namespace chip::app;
using namespace chip::app::List;

// Struct for ApplicationLauncherApp
CHIP_ERROR _ApplicationLauncherApp::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ApplicationLauncherApp & val = *reinterpret_cast<const _ApplicationLauncherApp *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.catalogVendorId));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.applicationId)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ApplicationLauncherApp::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ApplicationLauncherApp & val = *reinterpret_cast<_ApplicationLauncherApp *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.catalogVendorId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.applicationId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ApplicationLauncherApp::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    _ApplicationLauncherApp & val = *reinterpret_cast<_ApplicationLauncherApp *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.catalogVendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.catalogVendorId), buf + offset, sizeof(val.catalogVendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.catalogVendorId));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.applicationId = buf + offset;
        offset            = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ApplicationLauncherApp::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    const _ApplicationLauncherApp & val = *reinterpret_cast<const _ApplicationLauncherApp *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.catalogVendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.catalogVendorId), sizeof(val.catalogVendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.catalogVendorId));
    }
    {
        uint8_t stringLen = emberAfStringLength(val.applicationId);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.applicationId, bufLength - offset);
    }
    return CHIP_NO_ERROR;
}

// Struct for AudioOutputInfo
CHIP_ERROR _AudioOutputInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _AudioOutputInfo & val = *reinterpret_cast<const _AudioOutputInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.index));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.outputType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _AudioOutputInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _AudioOutputInfo & val = *reinterpret_cast<_AudioOutputInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.index));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.outputType));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _AudioOutputInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset        = 0;
    _AudioOutputInfo & val = *reinterpret_cast<_AudioOutputInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.index) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.index), buf + offset, sizeof(val.index)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.index));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.outputType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.outputType), buf + offset, sizeof(val.outputType)); // AudioOutputType
        offset = static_cast<uint16_t>(offset + sizeof(val.outputType));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & nameSpan      = val.name; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _AudioOutputInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset              = 0;
    const _AudioOutputInfo & val = *reinterpret_cast<const _AudioOutputInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.index) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.index), sizeof(val.index)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.index));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.outputType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.outputType), sizeof(val.outputType)); // AudioOutputType
        offset = static_cast<uint16_t>(offset + sizeof(val.outputType));
    }
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & nameSpan = val.name; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for BasicCommissioningInfoType
CHIP_ERROR _BasicCommissioningInfoType::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _BasicCommissioningInfoType & val = *reinterpret_cast<const _BasicCommissioningInfoType *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FailSafeExpiryLengthMs));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _BasicCommissioningInfoType::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _BasicCommissioningInfoType & val = *reinterpret_cast<_BasicCommissioningInfoType *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.FailSafeExpiryLengthMs));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _BasicCommissioningInfoType::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                   = 0;
    _BasicCommissioningInfoType & val = *reinterpret_cast<_BasicCommissioningInfoType *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.FailSafeExpiryLengthMs) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FailSafeExpiryLengthMs), buf + offset, sizeof(val.FailSafeExpiryLengthMs)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.FailSafeExpiryLengthMs));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _BasicCommissioningInfoType::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                         = 0;
    const _BasicCommissioningInfoType & val = *reinterpret_cast<const _BasicCommissioningInfoType *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.FailSafeExpiryLengthMs) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FailSafeExpiryLengthMs), sizeof(val.FailSafeExpiryLengthMs)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.FailSafeExpiryLengthMs));
    }
    return CHIP_NO_ERROR;
}

// Struct for ConfigureReportingRecord
CHIP_ERROR _ConfigureReportingRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ConfigureReportingRecord & val = *reinterpret_cast<const _ConfigureReportingRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.minimumReportingInterval));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.maximumReportingInterval));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.timeoutPeriod));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ConfigureReportingRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ConfigureReportingRecord & val = *reinterpret_cast<_ConfigureReportingRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.direction));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.minimumReportingInterval));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.maximumReportingInterval));
            break;
        }
        case 5: {
            // Nothing;
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(val.timeoutPeriod));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ConfigureReportingRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                 = 0;
    _ConfigureReportingRecord & val = *reinterpret_cast<_ConfigureReportingRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.direction), buf + offset, sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.minimumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.minimumReportingInterval), buf + offset, sizeof(val.minimumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.minimumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.maximumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.maximumReportingInterval), buf + offset, sizeof(val.maximumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.maximumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.reportableChangeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.reportableChangeLocation), buf + offset, sizeof(val.reportableChangeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.reportableChangeLocation));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.timeoutPeriod) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.timeoutPeriod), buf + offset, sizeof(val.timeoutPeriod)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.timeoutPeriod));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ConfigureReportingRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                       = 0;
    const _ConfigureReportingRecord & val = *reinterpret_cast<const _ConfigureReportingRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.direction), sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.minimumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.minimumReportingInterval), sizeof(val.minimumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.minimumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.maximumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.maximumReportingInterval), sizeof(val.maximumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.maximumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.reportableChangeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.reportableChangeLocation), sizeof(val.reportableChangeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.reportableChangeLocation));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.timeoutPeriod) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.timeoutPeriod), sizeof(val.timeoutPeriod)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.timeoutPeriod));
    }
    return CHIP_NO_ERROR;
}

// Struct for ConfigureReportingStatusRecord
CHIP_ERROR _ConfigureReportingStatusRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ConfigureReportingStatusRecord & val = *reinterpret_cast<const _ConfigureReportingStatusRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ConfigureReportingStatusRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ConfigureReportingStatusRecord & val = *reinterpret_cast<_ConfigureReportingStatusRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.direction));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ConfigureReportingStatusRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                       = 0;
    _ConfigureReportingStatusRecord & val = *reinterpret_cast<_ConfigureReportingStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.status), buf + offset, sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.direction), buf + offset, sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ConfigureReportingStatusRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                             = 0;
    const _ConfigureReportingStatusRecord & val = *reinterpret_cast<const _ConfigureReportingStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.status), sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.direction), sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    return CHIP_NO_ERROR;
}

// Struct for ContentLaunchAdditionalInfo
CHIP_ERROR _ContentLaunchAdditionalInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ContentLaunchAdditionalInfo & val = *reinterpret_cast<const _ContentLaunchAdditionalInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.name)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.value)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ContentLaunchAdditionalInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ContentLaunchAdditionalInfo & val = *reinterpret_cast<_ContentLaunchAdditionalInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.name));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.value));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ContentLaunchAdditionalInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                    = 0;
    _ContentLaunchAdditionalInfo & val = *reinterpret_cast<_ContentLaunchAdditionalInfo *>(valPtr);
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.name = buf + offset;
        offset   = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.value = buf + offset;
        offset    = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ContentLaunchAdditionalInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                          = 0;
    const _ContentLaunchAdditionalInfo & val = *reinterpret_cast<const _ContentLaunchAdditionalInfo *>(valPtr);
    {
        uint8_t stringLen = emberAfStringLength(val.name);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.name, bufLength - offset);
    }
    {
        uint8_t stringLen = emberAfStringLength(val.value);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.value, bufLength - offset);
    }
    return CHIP_NO_ERROR;
}

// Struct for ContentLaunchBrandingInformation
CHIP_ERROR _ContentLaunchBrandingInformation::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ContentLaunchBrandingInformation & val = *reinterpret_cast<const _ContentLaunchBrandingInformation *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.providerName)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.background));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.logo));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.progressBar));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.splash));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.waterMark));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ContentLaunchBrandingInformation::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ContentLaunchBrandingInformation & val = *reinterpret_cast<_ContentLaunchBrandingInformation *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.providerName));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.background));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.logo));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.progressBar));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.splash));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.waterMark));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ContentLaunchBrandingInformation::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                         = 0;
    _ContentLaunchBrandingInformation & val = *reinterpret_cast<_ContentLaunchBrandingInformation *>(valPtr);
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.providerName = buf + offset;
        offset           = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.background) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.background), buf + offset, sizeof(val.background)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.background));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.logo) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.logo), buf + offset, sizeof(val.logo)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.logo));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.progressBar) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.progressBar), buf + offset, sizeof(val.progressBar)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.progressBar));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.splash) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.splash), buf + offset, sizeof(val.splash)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.splash));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.waterMark) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.waterMark), buf + offset, sizeof(val.waterMark)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.waterMark));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ContentLaunchBrandingInformation::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                               = 0;
    const _ContentLaunchBrandingInformation & val = *reinterpret_cast<const _ContentLaunchBrandingInformation *>(valPtr);
    {
        uint8_t stringLen = emberAfStringLength(val.providerName);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.providerName, bufLength - offset);
    }
    {
        VerifyOrReturnError(offset + sizeof(val.background) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.background), sizeof(val.background)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.background));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.logo) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.logo), sizeof(val.logo)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.logo));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.progressBar) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.progressBar), sizeof(val.progressBar)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.progressBar));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.splash) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.splash), sizeof(val.splash)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.splash));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.waterMark) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.waterMark), sizeof(val.waterMark)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.waterMark));
    }
    return CHIP_NO_ERROR;
}

// Struct for ContentLaunchDimension
CHIP_ERROR _ContentLaunchDimension::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ContentLaunchDimension & val = *reinterpret_cast<const _ContentLaunchDimension *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.width)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.height)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.metric));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ContentLaunchDimension::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ContentLaunchDimension & val = *reinterpret_cast<_ContentLaunchDimension *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.width));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.height));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.metric));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ContentLaunchDimension::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    _ContentLaunchDimension & val = *reinterpret_cast<_ContentLaunchDimension *>(valPtr);
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.width = buf + offset;
        offset    = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.height = buf + offset;
        offset     = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.metric) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.metric), buf + offset, sizeof(val.metric)); // ContentLaunchMetricType
        offset = static_cast<uint16_t>(offset + sizeof(val.metric));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ContentLaunchDimension::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    const _ContentLaunchDimension & val = *reinterpret_cast<const _ContentLaunchDimension *>(valPtr);
    {
        uint8_t stringLen = emberAfStringLength(val.width);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.width, bufLength - offset);
    }
    {
        uint8_t stringLen = emberAfStringLength(val.height);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.height, bufLength - offset);
    }
    {
        VerifyOrReturnError(offset + sizeof(val.metric) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.metric), sizeof(val.metric)); // ContentLaunchMetricType
        offset = static_cast<uint16_t>(offset + sizeof(val.metric));
    }
    return CHIP_NO_ERROR;
}

// Struct for ContentLaunchParamater
CHIP_ERROR _ContentLaunchParamater::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ContentLaunchParamater & val = *reinterpret_cast<const _ContentLaunchParamater *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Type));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.Value)));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)) /* TODO: List inside struct is not implemented. */
    );
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ContentLaunchParamater::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ContentLaunchParamater & val = *reinterpret_cast<_ContentLaunchParamater *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.Type));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.Value));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.ExternalIDList));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ContentLaunchParamater::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    _ContentLaunchParamater & val = *reinterpret_cast<_ContentLaunchParamater *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.Type) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Type), buf + offset, sizeof(val.Type)); // ContentLaunchParameterEnum
        offset = static_cast<uint16_t>(offset + sizeof(val.Type));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.Value = buf + offset;
        offset    = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ExternalIDList) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ExternalIDList), buf + offset, sizeof(val.ExternalIDList)); // ARRAY
        offset = static_cast<uint16_t>(offset + sizeof(val.ExternalIDList));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ContentLaunchParamater::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    const _ContentLaunchParamater & val = *reinterpret_cast<const _ContentLaunchParamater *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.Type) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Type), sizeof(val.Type)); // ContentLaunchParameterEnum
        offset = static_cast<uint16_t>(offset + sizeof(val.Type));
    }
    {
        uint8_t stringLen = emberAfStringLength(val.Value);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.Value, bufLength - offset);
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ExternalIDList) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ExternalIDList), sizeof(val.ExternalIDList)); // ARRAY
        offset = static_cast<uint16_t>(offset + sizeof(val.ExternalIDList));
    }
    return CHIP_NO_ERROR;
}

// Struct for ContentLaunchStyleInformation
CHIP_ERROR _ContentLaunchStyleInformation::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ContentLaunchStyleInformation & val = *reinterpret_cast<const _ContentLaunchStyleInformation *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.imageUrl)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.color)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.size));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ContentLaunchStyleInformation::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ContentLaunchStyleInformation & val = *reinterpret_cast<_ContentLaunchStyleInformation *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.imageUrl));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.color));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.size));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ContentLaunchStyleInformation::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                      = 0;
    _ContentLaunchStyleInformation & val = *reinterpret_cast<_ContentLaunchStyleInformation *>(valPtr);
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.imageUrl = buf + offset;
        offset       = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.color = buf + offset;
        offset    = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.size) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.size), buf + offset, sizeof(val.size)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.size));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ContentLaunchStyleInformation::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                            = 0;
    const _ContentLaunchStyleInformation & val = *reinterpret_cast<const _ContentLaunchStyleInformation *>(valPtr);
    {
        uint8_t stringLen = emberAfStringLength(val.imageUrl);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.imageUrl, bufLength - offset);
    }
    {
        uint8_t stringLen = emberAfStringLength(val.color);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.color, bufLength - offset);
    }
    {
        VerifyOrReturnError(offset + sizeof(val.size) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.size), sizeof(val.size)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.size));
    }
    return CHIP_NO_ERROR;
}

// Struct for DeviceType
CHIP_ERROR _DeviceType::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _DeviceType & val = *reinterpret_cast<const _DeviceType *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.type));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.revision));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _DeviceType::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _DeviceType & val = *reinterpret_cast<_DeviceType *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.type));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.revision));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _DeviceType::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset   = 0;
    _DeviceType & val = *reinterpret_cast<_DeviceType *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.type) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.type), buf + offset, sizeof(val.type)); // DEVTYPE_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.type));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.revision) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.revision), buf + offset, sizeof(val.revision)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.revision));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _DeviceType::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset         = 0;
    const _DeviceType & val = *reinterpret_cast<const _DeviceType *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.type) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.type), sizeof(val.type)); // DEVTYPE_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.type));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.revision) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.revision), sizeof(val.revision)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.revision));
    }
    return CHIP_NO_ERROR;
}

// Struct for DiscoverAttributesInfoRecord
CHIP_ERROR _DiscoverAttributesInfoRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _DiscoverAttributesInfoRecord & val = *reinterpret_cast<const _DiscoverAttributesInfoRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _DiscoverAttributesInfoRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _DiscoverAttributesInfoRecord & val = *reinterpret_cast<_DiscoverAttributesInfoRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _DiscoverAttributesInfoRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    _DiscoverAttributesInfoRecord & val = *reinterpret_cast<_DiscoverAttributesInfoRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _DiscoverAttributesInfoRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                           = 0;
    const _DiscoverAttributesInfoRecord & val = *reinterpret_cast<const _DiscoverAttributesInfoRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    return CHIP_NO_ERROR;
}

// Struct for ExtendedDiscoverAttributesInfoRecord
CHIP_ERROR _ExtendedDiscoverAttributesInfoRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ExtendedDiscoverAttributesInfoRecord & val = *reinterpret_cast<const _ExtendedDiscoverAttributesInfoRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeAccessControl));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ExtendedDiscoverAttributesInfoRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ExtendedDiscoverAttributesInfoRecord & val = *reinterpret_cast<_ExtendedDiscoverAttributesInfoRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.attributeAccessControl));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ExtendedDiscoverAttributesInfoRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                             = 0;
    _ExtendedDiscoverAttributesInfoRecord & val = *reinterpret_cast<_ExtendedDiscoverAttributesInfoRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeAccessControl) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeAccessControl), buf + offset, sizeof(val.attributeAccessControl)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeAccessControl));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ExtendedDiscoverAttributesInfoRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                                   = 0;
    const _ExtendedDiscoverAttributesInfoRecord & val = *reinterpret_cast<const _ExtendedDiscoverAttributesInfoRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeAccessControl) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeAccessControl), sizeof(val.attributeAccessControl)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeAccessControl));
    }
    return CHIP_NO_ERROR;
}

// Struct for FabricDescriptor
CHIP_ERROR _FabricDescriptor::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _FabricDescriptor & val = *reinterpret_cast<const _FabricDescriptor *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FabricIndex));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RootPublicKey));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FabricId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NodeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Label));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _FabricDescriptor::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _FabricDescriptor & val = *reinterpret_cast<_FabricDescriptor *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.FabricIndex));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.RootPublicKey = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.VendorId));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.FabricId));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.NodeId));
            break;
        }
        case 5: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.Label = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _FabricDescriptor::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset         = 0;
    _FabricDescriptor & val = *reinterpret_cast<_FabricDescriptor *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.FabricIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FabricIndex), buf + offset, sizeof(val.FabricIndex)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricIndex));
    }
    {
        constexpr uint16_t kLengthSize     = 2;
        chip::ByteSpan & RootPublicKeySpan = val.RootPublicKey; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &RootPublicKeySpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + RootPublicKeySpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.VendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.VendorId), buf + offset, sizeof(val.VendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FabricId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FabricId), buf + offset, sizeof(val.FabricId)); // FABRIC_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.NodeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.NodeId), buf + offset, sizeof(val.NodeId)); // NODE_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.NodeId));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & LabelSpan     = val.Label; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &LabelSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + LabelSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _FabricDescriptor::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    const _FabricDescriptor & val = *reinterpret_cast<const _FabricDescriptor *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.FabricIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FabricIndex), sizeof(val.FabricIndex)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricIndex));
    }
    {
        constexpr uint16_t kLengthSize           = 2;
        const chip::ByteSpan & RootPublicKeySpan = val.RootPublicKey; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &RootPublicKeySpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + RootPublicKeySpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.VendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.VendorId), sizeof(val.VendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FabricId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FabricId), sizeof(val.FabricId)); // FABRIC_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.NodeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.NodeId), sizeof(val.NodeId)); // NODE_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.NodeId));
    }
    {
        constexpr uint16_t kLengthSize   = 2;
        const chip::ByteSpan & LabelSpan = val.Label; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &LabelSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + LabelSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for GroupKey
CHIP_ERROR _GroupKey::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _GroupKey & val = *reinterpret_cast<const _GroupKey *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeyIndex));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeyRoot));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeyEpochStartTime));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeySecurityPolicy));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _GroupKey::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _GroupKey & val = *reinterpret_cast<_GroupKey *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.VendorId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.GroupKeyIndex));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.GroupKeyRoot = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.GroupKeyEpochStartTime));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.GroupKeySecurityPolicy));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _GroupKey::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset = 0;
    _GroupKey & val = *reinterpret_cast<_GroupKey *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.VendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.VendorId), buf + offset, sizeof(val.VendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeyIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.GroupKeyIndex), buf + offset, sizeof(val.GroupKeyIndex)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeyIndex));
    }
    {
        constexpr uint16_t kLengthSize    = 2;
        chip::ByteSpan & GroupKeyRootSpan = val.GroupKeyRoot; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &GroupKeyRootSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + GroupKeyRootSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeyEpochStartTime) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.GroupKeyEpochStartTime), buf + offset, sizeof(val.GroupKeyEpochStartTime)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeyEpochStartTime));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeySecurityPolicy) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.GroupKeySecurityPolicy), buf + offset,
                sizeof(val.GroupKeySecurityPolicy)); // GroupKeySecurityPolicy
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeySecurityPolicy));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _GroupKey::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset       = 0;
    const _GroupKey & val = *reinterpret_cast<const _GroupKey *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.VendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.VendorId), sizeof(val.VendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeyIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.GroupKeyIndex), sizeof(val.GroupKeyIndex)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeyIndex));
    }
    {
        constexpr uint16_t kLengthSize          = 2;
        const chip::ByteSpan & GroupKeyRootSpan = val.GroupKeyRoot; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &GroupKeyRootSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + GroupKeyRootSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeyEpochStartTime) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.GroupKeyEpochStartTime), sizeof(val.GroupKeyEpochStartTime)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeyEpochStartTime));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeySecurityPolicy) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.GroupKeySecurityPolicy),
                sizeof(val.GroupKeySecurityPolicy)); // GroupKeySecurityPolicy
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeySecurityPolicy));
    }
    return CHIP_NO_ERROR;
}

// Struct for GroupState
CHIP_ERROR _GroupState::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _GroupState & val = *reinterpret_cast<const _GroupState *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.VendorGroupId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.GroupKeySetIndex));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _GroupState::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _GroupState & val = *reinterpret_cast<_GroupState *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.VendorId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.VendorGroupId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.GroupKeySetIndex));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _GroupState::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset   = 0;
    _GroupState & val = *reinterpret_cast<_GroupState *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.VendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.VendorId), buf + offset, sizeof(val.VendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.VendorGroupId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.VendorGroupId), buf + offset, sizeof(val.VendorGroupId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorGroupId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeySetIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.GroupKeySetIndex), buf + offset, sizeof(val.GroupKeySetIndex)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeySetIndex));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _GroupState::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset         = 0;
    const _GroupState & val = *reinterpret_cast<const _GroupState *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.VendorId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.VendorId), sizeof(val.VendorId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.VendorGroupId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.VendorGroupId), sizeof(val.VendorGroupId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.VendorGroupId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.GroupKeySetIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.GroupKeySetIndex), sizeof(val.GroupKeySetIndex)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.GroupKeySetIndex));
    }
    return CHIP_NO_ERROR;
}

// Struct for IasAceZoneStatusResult
CHIP_ERROR _IasAceZoneStatusResult::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _IasAceZoneStatusResult & val = *reinterpret_cast<const _IasAceZoneStatusResult *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.zoneId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.zoneStatus));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _IasAceZoneStatusResult::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _IasAceZoneStatusResult & val = *reinterpret_cast<_IasAceZoneStatusResult *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.zoneId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.zoneStatus));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _IasAceZoneStatusResult::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    _IasAceZoneStatusResult & val = *reinterpret_cast<_IasAceZoneStatusResult *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.zoneId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.zoneId), buf + offset, sizeof(val.zoneId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.zoneId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.zoneStatus) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.zoneStatus), buf + offset, sizeof(val.zoneStatus)); // IasZoneStatus
        offset = static_cast<uint16_t>(offset + sizeof(val.zoneStatus));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _IasAceZoneStatusResult::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    const _IasAceZoneStatusResult & val = *reinterpret_cast<const _IasAceZoneStatusResult *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.zoneId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.zoneId), sizeof(val.zoneId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.zoneId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.zoneStatus) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.zoneStatus), sizeof(val.zoneStatus)); // IasZoneStatus
        offset = static_cast<uint16_t>(offset + sizeof(val.zoneStatus));
    }
    return CHIP_NO_ERROR;
}

// Struct for LabelStruct
CHIP_ERROR _LabelStruct::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _LabelStruct & val = *reinterpret_cast<const _LabelStruct *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.label));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.value));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _LabelStruct::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _LabelStruct & val = *reinterpret_cast<_LabelStruct *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.label = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.value = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _LabelStruct::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset    = 0;
    _LabelStruct & val = *reinterpret_cast<_LabelStruct *>(valPtr);
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & labelSpan     = val.label; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &labelSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + labelSpan.size());
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & valueSpan     = val.value; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &valueSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + valueSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _LabelStruct::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset          = 0;
    const _LabelStruct & val = *reinterpret_cast<const _LabelStruct *>(valPtr);
    {
        constexpr uint16_t kLengthSize   = 2;
        const chip::ByteSpan & labelSpan = val.label; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &labelSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + labelSpan.size());
    }
    {
        constexpr uint16_t kLengthSize   = 2;
        const chip::ByteSpan & valueSpan = val.value; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &valueSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + valueSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for MediaInputInfo
CHIP_ERROR _MediaInputInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _MediaInputInfo & val = *reinterpret_cast<const _MediaInputInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.index));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.inputType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.description));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _MediaInputInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _MediaInputInfo & val = *reinterpret_cast<_MediaInputInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.index));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.inputType));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.description = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _MediaInputInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset       = 0;
    _MediaInputInfo & val = *reinterpret_cast<_MediaInputInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.index) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.index), buf + offset, sizeof(val.index)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.index));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.inputType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.inputType), buf + offset, sizeof(val.inputType)); // MediaInputType
        offset = static_cast<uint16_t>(offset + sizeof(val.inputType));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & nameSpan      = val.name; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    {
        constexpr uint16_t kLengthSize   = 2;
        chip::ByteSpan & descriptionSpan = val.description; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &descriptionSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + descriptionSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _MediaInputInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset             = 0;
    const _MediaInputInfo & val = *reinterpret_cast<const _MediaInputInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.index) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.index), sizeof(val.index)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.index));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.inputType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.inputType), sizeof(val.inputType)); // MediaInputType
        offset = static_cast<uint16_t>(offset + sizeof(val.inputType));
    }
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & nameSpan = val.name; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    {
        constexpr uint16_t kLengthSize         = 2;
        const chip::ByteSpan & descriptionSpan = val.description; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &descriptionSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + descriptionSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for MediaPlaybackPosition
CHIP_ERROR _MediaPlaybackPosition::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _MediaPlaybackPosition & val = *reinterpret_cast<const _MediaPlaybackPosition *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.updatedAt));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.position));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _MediaPlaybackPosition::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _MediaPlaybackPosition & val = *reinterpret_cast<_MediaPlaybackPosition *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.updatedAt));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.position));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _MediaPlaybackPosition::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset              = 0;
    _MediaPlaybackPosition & val = *reinterpret_cast<_MediaPlaybackPosition *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.updatedAt) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.updatedAt), buf + offset, sizeof(val.updatedAt)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.updatedAt));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.position) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.position), buf + offset, sizeof(val.position)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.position));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _MediaPlaybackPosition::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                    = 0;
    const _MediaPlaybackPosition & val = *reinterpret_cast<const _MediaPlaybackPosition *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.updatedAt) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.updatedAt), sizeof(val.updatedAt)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.updatedAt));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.position) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.position), sizeof(val.position)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.position));
    }
    return CHIP_NO_ERROR;
}

// Struct for NOCStruct
CHIP_ERROR _NOCStruct::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _NOCStruct & val = *reinterpret_cast<const _NOCStruct *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FabricIndex));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NOC));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _NOCStruct::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _NOCStruct & val = *reinterpret_cast<_NOCStruct *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.FabricIndex));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.NOC = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _NOCStruct::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset  = 0;
    _NOCStruct & val = *reinterpret_cast<_NOCStruct *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.FabricIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FabricIndex), buf + offset, sizeof(val.FabricIndex)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricIndex));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & NOCSpan       = val.NOC; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &NOCSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + NOCSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _NOCStruct::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset        = 0;
    const _NOCStruct & val = *reinterpret_cast<const _NOCStruct *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.FabricIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FabricIndex), sizeof(val.FabricIndex)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricIndex));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        const chip::ByteSpan & NOCSpan = val.NOC; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &NOCSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + NOCSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for NavigateTargetTargetInfo
CHIP_ERROR _NavigateTargetTargetInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _NavigateTargetTargetInfo & val = *reinterpret_cast<const _NavigateTargetTargetInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.identifier));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _NavigateTargetTargetInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _NavigateTargetTargetInfo & val = *reinterpret_cast<_NavigateTargetTargetInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.identifier));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _NavigateTargetTargetInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                 = 0;
    _NavigateTargetTargetInfo & val = *reinterpret_cast<_NavigateTargetTargetInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.identifier) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.identifier), buf + offset, sizeof(val.identifier)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.identifier));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & nameSpan      = val.name; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _NavigateTargetTargetInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                       = 0;
    const _NavigateTargetTargetInfo & val = *reinterpret_cast<const _NavigateTargetTargetInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.identifier) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.identifier), sizeof(val.identifier)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.identifier));
    }
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & nameSpan = val.name; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for NeighborTable
CHIP_ERROR _NeighborTable::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _NeighborTable & val = *reinterpret_cast<const _NeighborTable *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ExtAddress));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Age));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Rloc16));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LinkFrameCounter));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MleFrameCounter));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LQI));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.AverageRssi));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LastRssi));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FrameErrorRate));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MessageErrorRate));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RxOnWhenIdle));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FullThreadDevice));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FullNetworkData));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.IsChild));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _NeighborTable::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _NeighborTable & val = *reinterpret_cast<_NeighborTable *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.ExtAddress));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.Age));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.Rloc16));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.LinkFrameCounter));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.MleFrameCounter));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.LQI));
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(val.AverageRssi));
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(val.LastRssi));
            break;
        }
        case 8: {
            ReturnErrorOnFailure(reader.Get(val.FrameErrorRate));
            break;
        }
        case 9: {
            ReturnErrorOnFailure(reader.Get(val.MessageErrorRate));
            break;
        }
        case 10: {
            ReturnErrorOnFailure(reader.Get(val.RxOnWhenIdle));
            break;
        }
        case 11: {
            ReturnErrorOnFailure(reader.Get(val.FullThreadDevice));
            break;
        }
        case 12: {
            ReturnErrorOnFailure(reader.Get(val.FullNetworkData));
            break;
        }
        case 13: {
            ReturnErrorOnFailure(reader.Get(val.IsChild));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _NeighborTable::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset      = 0;
    _NeighborTable & val = *reinterpret_cast<_NeighborTable *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.ExtAddress) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ExtAddress), buf + offset, sizeof(val.ExtAddress)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.ExtAddress));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Age) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Age), buf + offset, sizeof(val.Age)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.Age));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Rloc16) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Rloc16), buf + offset, sizeof(val.Rloc16)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.Rloc16));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LinkFrameCounter) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.LinkFrameCounter), buf + offset, sizeof(val.LinkFrameCounter)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.LinkFrameCounter));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MleFrameCounter) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.MleFrameCounter), buf + offset, sizeof(val.MleFrameCounter)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.MleFrameCounter));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LQI) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.LQI), buf + offset, sizeof(val.LQI)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.LQI));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.AverageRssi) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.AverageRssi), buf + offset, sizeof(val.AverageRssi)); // INT8S
        offset = static_cast<uint16_t>(offset + sizeof(val.AverageRssi));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LastRssi) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.LastRssi), buf + offset, sizeof(val.LastRssi)); // INT8S
        offset = static_cast<uint16_t>(offset + sizeof(val.LastRssi));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FrameErrorRate) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FrameErrorRate), buf + offset, sizeof(val.FrameErrorRate)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.FrameErrorRate));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MessageErrorRate) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.MessageErrorRate), buf + offset, sizeof(val.MessageErrorRate)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.MessageErrorRate));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.RxOnWhenIdle) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.RxOnWhenIdle), buf + offset, sizeof(val.RxOnWhenIdle)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.RxOnWhenIdle));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FullThreadDevice) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FullThreadDevice), buf + offset, sizeof(val.FullThreadDevice)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.FullThreadDevice));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FullNetworkData) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FullNetworkData), buf + offset, sizeof(val.FullNetworkData)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.FullNetworkData));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.IsChild) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.IsChild), buf + offset, sizeof(val.IsChild)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.IsChild));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _NeighborTable::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset            = 0;
    const _NeighborTable & val = *reinterpret_cast<const _NeighborTable *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.ExtAddress) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ExtAddress), sizeof(val.ExtAddress)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.ExtAddress));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Age) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Age), sizeof(val.Age)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.Age));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Rloc16) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Rloc16), sizeof(val.Rloc16)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.Rloc16));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LinkFrameCounter) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.LinkFrameCounter), sizeof(val.LinkFrameCounter)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.LinkFrameCounter));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MleFrameCounter) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.MleFrameCounter), sizeof(val.MleFrameCounter)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.MleFrameCounter));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LQI) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.LQI), sizeof(val.LQI)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.LQI));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.AverageRssi) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.AverageRssi), sizeof(val.AverageRssi)); // INT8S
        offset = static_cast<uint16_t>(offset + sizeof(val.AverageRssi));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LastRssi) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.LastRssi), sizeof(val.LastRssi)); // INT8S
        offset = static_cast<uint16_t>(offset + sizeof(val.LastRssi));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FrameErrorRate) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FrameErrorRate), sizeof(val.FrameErrorRate)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.FrameErrorRate));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MessageErrorRate) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.MessageErrorRate), sizeof(val.MessageErrorRate)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.MessageErrorRate));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.RxOnWhenIdle) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.RxOnWhenIdle), sizeof(val.RxOnWhenIdle)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.RxOnWhenIdle));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FullThreadDevice) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FullThreadDevice), sizeof(val.FullThreadDevice)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.FullThreadDevice));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FullNetworkData) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FullNetworkData), sizeof(val.FullNetworkData)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.FullNetworkData));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.IsChild) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.IsChild), sizeof(val.IsChild)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.IsChild));
    }
    return CHIP_NO_ERROR;
}

// Struct for NetworkInterfaceType
CHIP_ERROR _NetworkInterfaceType::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _NetworkInterfaceType & val = *reinterpret_cast<const _NetworkInterfaceType *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FabricConnected));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.OffPremiseServicesReachableIPv4));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.OffPremiseServicesReachableIPv6));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.HardwareAddress));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Type));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _NetworkInterfaceType::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _NetworkInterfaceType & val = *reinterpret_cast<_NetworkInterfaceType *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.Name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.FabricConnected));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.OffPremiseServicesReachableIPv4));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.OffPremiseServicesReachableIPv6));
            break;
        }
        case 4: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.HardwareAddress = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.Type));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _NetworkInterfaceType::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset             = 0;
    _NetworkInterfaceType & val = *reinterpret_cast<_NetworkInterfaceType *>(valPtr);
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & NameSpan      = val.Name; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &NameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + NameSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FabricConnected) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FabricConnected), buf + offset, sizeof(val.FabricConnected)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricConnected));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.OffPremiseServicesReachableIPv4) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.OffPremiseServicesReachableIPv4), buf + offset,
                sizeof(val.OffPremiseServicesReachableIPv4)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.OffPremiseServicesReachableIPv4));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.OffPremiseServicesReachableIPv6) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.OffPremiseServicesReachableIPv6), buf + offset,
                sizeof(val.OffPremiseServicesReachableIPv6)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.OffPremiseServicesReachableIPv6));
    }
    {
        constexpr uint16_t kLengthSize       = 2;
        chip::ByteSpan & HardwareAddressSpan = val.HardwareAddress; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &HardwareAddressSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + HardwareAddressSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Type) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Type), buf + offset, sizeof(val.Type)); // ENUM8
        offset = static_cast<uint16_t>(offset + sizeof(val.Type));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _NetworkInterfaceType::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                   = 0;
    const _NetworkInterfaceType & val = *reinterpret_cast<const _NetworkInterfaceType *>(valPtr);
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & NameSpan = val.Name; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &NameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + NameSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FabricConnected) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FabricConnected), sizeof(val.FabricConnected)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.FabricConnected));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.OffPremiseServicesReachableIPv4) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.OffPremiseServicesReachableIPv4),
                sizeof(val.OffPremiseServicesReachableIPv4)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.OffPremiseServicesReachableIPv4));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.OffPremiseServicesReachableIPv6) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.OffPremiseServicesReachableIPv6),
                sizeof(val.OffPremiseServicesReachableIPv6)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.OffPremiseServicesReachableIPv6));
    }
    {
        constexpr uint16_t kLengthSize             = 2;
        const chip::ByteSpan & HardwareAddressSpan = val.HardwareAddress; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &HardwareAddressSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + HardwareAddressSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Type) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Type), sizeof(val.Type)); // ENUM8
        offset = static_cast<uint16_t>(offset + sizeof(val.Type));
    }
    return CHIP_NO_ERROR;
}

// Struct for Notification
CHIP_ERROR _Notification::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _Notification & val = *reinterpret_cast<const _Notification *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.contentId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.statusFeedback));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _Notification::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _Notification & val = *reinterpret_cast<_Notification *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.contentId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.statusFeedback));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _Notification::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset     = 0;
    _Notification & val = *reinterpret_cast<_Notification *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.contentId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.contentId), buf + offset, sizeof(val.contentId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.contentId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.statusFeedback) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.statusFeedback), buf + offset, sizeof(val.statusFeedback)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.statusFeedback));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _Notification::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset           = 0;
    const _Notification & val = *reinterpret_cast<const _Notification *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.contentId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.contentId), sizeof(val.contentId)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.contentId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.statusFeedback) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.statusFeedback), sizeof(val.statusFeedback)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.statusFeedback));
    }
    return CHIP_NO_ERROR;
}

// Struct for OperationalDatasetComponents
CHIP_ERROR _OperationalDatasetComponents::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _OperationalDatasetComponents & val = *reinterpret_cast<const _OperationalDatasetComponents *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ActiveTimestampPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PendingTimestampPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MasterKeyPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NetworkNamePresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ExtendedPanIdPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.MeshLocalPrefixPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.DelayPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PanIdPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ChannelPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PskcPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.SecurityPolicyPresent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ChannelMaskPresent));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _OperationalDatasetComponents::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _OperationalDatasetComponents & val = *reinterpret_cast<_OperationalDatasetComponents *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.ActiveTimestampPresent));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.PendingTimestampPresent));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.MasterKeyPresent));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.NetworkNamePresent));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.ExtendedPanIdPresent));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.MeshLocalPrefixPresent));
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(val.DelayPresent));
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(val.PanIdPresent));
            break;
        }
        case 8: {
            ReturnErrorOnFailure(reader.Get(val.ChannelPresent));
            break;
        }
        case 9: {
            ReturnErrorOnFailure(reader.Get(val.PskcPresent));
            break;
        }
        case 10: {
            ReturnErrorOnFailure(reader.Get(val.SecurityPolicyPresent));
            break;
        }
        case 11: {
            ReturnErrorOnFailure(reader.Get(val.ChannelMaskPresent));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _OperationalDatasetComponents::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    _OperationalDatasetComponents & val = *reinterpret_cast<_OperationalDatasetComponents *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.ActiveTimestampPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ActiveTimestampPresent), buf + offset, sizeof(val.ActiveTimestampPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ActiveTimestampPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PendingTimestampPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.PendingTimestampPresent), buf + offset, sizeof(val.PendingTimestampPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.PendingTimestampPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MasterKeyPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.MasterKeyPresent), buf + offset, sizeof(val.MasterKeyPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.MasterKeyPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.NetworkNamePresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.NetworkNamePresent), buf + offset, sizeof(val.NetworkNamePresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.NetworkNamePresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ExtendedPanIdPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ExtendedPanIdPresent), buf + offset, sizeof(val.ExtendedPanIdPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ExtendedPanIdPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MeshLocalPrefixPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.MeshLocalPrefixPresent), buf + offset, sizeof(val.MeshLocalPrefixPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.MeshLocalPrefixPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.DelayPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.DelayPresent), buf + offset, sizeof(val.DelayPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.DelayPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PanIdPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.PanIdPresent), buf + offset, sizeof(val.PanIdPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.PanIdPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ChannelPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ChannelPresent), buf + offset, sizeof(val.ChannelPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ChannelPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PskcPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.PskcPresent), buf + offset, sizeof(val.PskcPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.PskcPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.SecurityPolicyPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.SecurityPolicyPresent), buf + offset, sizeof(val.SecurityPolicyPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.SecurityPolicyPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ChannelMaskPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ChannelMaskPresent), buf + offset, sizeof(val.ChannelMaskPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ChannelMaskPresent));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _OperationalDatasetComponents::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                           = 0;
    const _OperationalDatasetComponents & val = *reinterpret_cast<const _OperationalDatasetComponents *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.ActiveTimestampPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ActiveTimestampPresent), sizeof(val.ActiveTimestampPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ActiveTimestampPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PendingTimestampPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.PendingTimestampPresent), sizeof(val.PendingTimestampPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.PendingTimestampPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MasterKeyPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.MasterKeyPresent), sizeof(val.MasterKeyPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.MasterKeyPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.NetworkNamePresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.NetworkNamePresent), sizeof(val.NetworkNamePresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.NetworkNamePresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ExtendedPanIdPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ExtendedPanIdPresent), sizeof(val.ExtendedPanIdPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ExtendedPanIdPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.MeshLocalPrefixPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.MeshLocalPrefixPresent), sizeof(val.MeshLocalPrefixPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.MeshLocalPrefixPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.DelayPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.DelayPresent), sizeof(val.DelayPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.DelayPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PanIdPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.PanIdPresent), sizeof(val.PanIdPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.PanIdPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ChannelPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ChannelPresent), sizeof(val.ChannelPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ChannelPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PskcPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.PskcPresent), sizeof(val.PskcPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.PskcPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.SecurityPolicyPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.SecurityPolicyPresent), sizeof(val.SecurityPolicyPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.SecurityPolicyPresent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.ChannelMaskPresent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ChannelMaskPresent), sizeof(val.ChannelMaskPresent)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.ChannelMaskPresent));
    }
    return CHIP_NO_ERROR;
}

// Struct for PowerProfileRecord
CHIP_ERROR _PowerProfileRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _PowerProfileRecord & val = *reinterpret_cast<const _PowerProfileRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.powerProfileId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energyPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.powerProfileRemoteControl));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.powerProfileState));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _PowerProfileRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _PowerProfileRecord & val = *reinterpret_cast<_PowerProfileRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.powerProfileId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.energyPhaseId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.powerProfileRemoteControl));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.powerProfileState));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _PowerProfileRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset           = 0;
    _PowerProfileRecord & val = *reinterpret_cast<_PowerProfileRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.powerProfileId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.powerProfileId), buf + offset, sizeof(val.powerProfileId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.powerProfileId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.energyPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.energyPhaseId), buf + offset, sizeof(val.energyPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.energyPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.powerProfileRemoteControl) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.powerProfileRemoteControl), buf + offset, sizeof(val.powerProfileRemoteControl)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.powerProfileRemoteControl));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.powerProfileState) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.powerProfileState), buf + offset, sizeof(val.powerProfileState)); // ENUM8
        offset = static_cast<uint16_t>(offset + sizeof(val.powerProfileState));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _PowerProfileRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                 = 0;
    const _PowerProfileRecord & val = *reinterpret_cast<const _PowerProfileRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.powerProfileId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.powerProfileId), sizeof(val.powerProfileId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.powerProfileId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.energyPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.energyPhaseId), sizeof(val.energyPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.energyPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.powerProfileRemoteControl) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.powerProfileRemoteControl), sizeof(val.powerProfileRemoteControl)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.powerProfileRemoteControl));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.powerProfileState) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.powerProfileState), sizeof(val.powerProfileState)); // ENUM8
        offset = static_cast<uint16_t>(offset + sizeof(val.powerProfileState));
    }
    return CHIP_NO_ERROR;
}

// Struct for ReadAttributeStatusRecord
CHIP_ERROR _ReadAttributeStatusRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ReadAttributeStatusRecord & val = *reinterpret_cast<const _ReadAttributeStatusRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ReadAttributeStatusRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ReadAttributeStatusRecord & val = *reinterpret_cast<_ReadAttributeStatusRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.status));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 3: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ReadAttributeStatusRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                  = 0;
    _ReadAttributeStatusRecord & val = *reinterpret_cast<_ReadAttributeStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.status), buf + offset, sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeLocation), buf + offset, sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ReadAttributeStatusRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                        = 0;
    const _ReadAttributeStatusRecord & val = *reinterpret_cast<const _ReadAttributeStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.status), sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeLocation), sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

// Struct for ReadReportingConfigurationAttributeRecord
CHIP_ERROR _ReadReportingConfigurationAttributeRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ReadReportingConfigurationAttributeRecord & val =
        *reinterpret_cast<const _ReadReportingConfigurationAttributeRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ReadReportingConfigurationAttributeRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ReadReportingConfigurationAttributeRecord & val = *reinterpret_cast<_ReadReportingConfigurationAttributeRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.direction));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ReadReportingConfigurationAttributeRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                                  = 0;
    _ReadReportingConfigurationAttributeRecord & val = *reinterpret_cast<_ReadReportingConfigurationAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.direction), buf + offset, sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ReadReportingConfigurationAttributeRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength,
                                                                     size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset = 0;
    const _ReadReportingConfigurationAttributeRecord & val =
        *reinterpret_cast<const _ReadReportingConfigurationAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.direction), sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    return CHIP_NO_ERROR;
}

// Struct for ReadReportingConfigurationRecord
CHIP_ERROR _ReadReportingConfigurationRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ReadReportingConfigurationRecord & val = *reinterpret_cast<const _ReadReportingConfigurationRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.direction));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.minimumReportingInterval));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.maximumReportingInterval));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.timeoutPeriod));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ReadReportingConfigurationRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ReadReportingConfigurationRecord & val = *reinterpret_cast<_ReadReportingConfigurationRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.direction));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.minimumReportingInterval));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.maximumReportingInterval));
            break;
        }
        case 6: {
            // Nothing;
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(val.timeoutPeriod));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ReadReportingConfigurationRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                         = 0;
    _ReadReportingConfigurationRecord & val = *reinterpret_cast<_ReadReportingConfigurationRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.status), buf + offset, sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.direction), buf + offset, sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.minimumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.minimumReportingInterval), buf + offset, sizeof(val.minimumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.minimumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.maximumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.maximumReportingInterval), buf + offset, sizeof(val.maximumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.maximumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.reportableChangeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.reportableChangeLocation), buf + offset, sizeof(val.reportableChangeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.reportableChangeLocation));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.timeoutPeriod) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.timeoutPeriod), buf + offset, sizeof(val.timeoutPeriod)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.timeoutPeriod));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ReadReportingConfigurationRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                               = 0;
    const _ReadReportingConfigurationRecord & val = *reinterpret_cast<const _ReadReportingConfigurationRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.status), sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.direction) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.direction), sizeof(val.direction)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.direction));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.minimumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.minimumReportingInterval), sizeof(val.minimumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.minimumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.maximumReportingInterval) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.maximumReportingInterval), sizeof(val.maximumReportingInterval)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.maximumReportingInterval));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.reportableChangeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.reportableChangeLocation), sizeof(val.reportableChangeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.reportableChangeLocation));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.timeoutPeriod) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.timeoutPeriod), sizeof(val.timeoutPeriod)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.timeoutPeriod));
    }
    return CHIP_NO_ERROR;
}

// Struct for ReadStructuredAttributeRecord
CHIP_ERROR _ReadStructuredAttributeRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ReadStructuredAttributeRecord & val = *reinterpret_cast<const _ReadStructuredAttributeRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicator));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicies));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ReadStructuredAttributeRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ReadStructuredAttributeRecord & val = *reinterpret_cast<_ReadStructuredAttributeRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.indicator));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.indicies));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ReadStructuredAttributeRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                      = 0;
    _ReadStructuredAttributeRecord & val = *reinterpret_cast<_ReadStructuredAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicator) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.indicator), buf + offset, sizeof(val.indicator)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicator));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicies) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.indicies), buf + offset, sizeof(val.indicies)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicies));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ReadStructuredAttributeRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                            = 0;
    const _ReadStructuredAttributeRecord & val = *reinterpret_cast<const _ReadStructuredAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicator) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.indicator), sizeof(val.indicator)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicator));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicies) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.indicies), sizeof(val.indicies)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicies));
    }
    return CHIP_NO_ERROR;
}

// Struct for ReportAttributeRecord
CHIP_ERROR _ReportAttributeRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ReportAttributeRecord & val = *reinterpret_cast<const _ReportAttributeRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ReportAttributeRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ReportAttributeRecord & val = *reinterpret_cast<_ReportAttributeRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 2: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ReportAttributeRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset              = 0;
    _ReportAttributeRecord & val = *reinterpret_cast<_ReportAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeLocation), buf + offset, sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ReportAttributeRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                    = 0;
    const _ReportAttributeRecord & val = *reinterpret_cast<const _ReportAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeLocation), sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

// Struct for RouteTable
CHIP_ERROR _RouteTable::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _RouteTable & val = *reinterpret_cast<const _RouteTable *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.ExtAddress));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Rloc16));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RouterId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.NextHop));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.PathCost));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LQIIn));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LQIOut));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Age));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Allocated));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.LinkEstablished));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _RouteTable::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _RouteTable & val = *reinterpret_cast<_RouteTable *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.ExtAddress));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.Rloc16));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.RouterId));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.NextHop));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.PathCost));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.LQIIn));
            break;
        }
        case 6: {
            ReturnErrorOnFailure(reader.Get(val.LQIOut));
            break;
        }
        case 7: {
            ReturnErrorOnFailure(reader.Get(val.Age));
            break;
        }
        case 8: {
            ReturnErrorOnFailure(reader.Get(val.Allocated));
            break;
        }
        case 9: {
            ReturnErrorOnFailure(reader.Get(val.LinkEstablished));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _RouteTable::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset   = 0;
    _RouteTable & val = *reinterpret_cast<_RouteTable *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.ExtAddress) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.ExtAddress), buf + offset, sizeof(val.ExtAddress)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.ExtAddress));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Rloc16) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Rloc16), buf + offset, sizeof(val.Rloc16)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.Rloc16));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.RouterId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.RouterId), buf + offset, sizeof(val.RouterId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.RouterId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.NextHop) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.NextHop), buf + offset, sizeof(val.NextHop)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.NextHop));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PathCost) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.PathCost), buf + offset, sizeof(val.PathCost)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.PathCost));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LQIIn) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.LQIIn), buf + offset, sizeof(val.LQIIn)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.LQIIn));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LQIOut) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.LQIOut), buf + offset, sizeof(val.LQIOut)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.LQIOut));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Age) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Age), buf + offset, sizeof(val.Age)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.Age));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Allocated) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Allocated), buf + offset, sizeof(val.Allocated)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.Allocated));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LinkEstablished) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.LinkEstablished), buf + offset, sizeof(val.LinkEstablished)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.LinkEstablished));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _RouteTable::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset         = 0;
    const _RouteTable & val = *reinterpret_cast<const _RouteTable *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.ExtAddress) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.ExtAddress), sizeof(val.ExtAddress)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.ExtAddress));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Rloc16) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Rloc16), sizeof(val.Rloc16)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.Rloc16));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.RouterId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.RouterId), sizeof(val.RouterId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.RouterId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.NextHop) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.NextHop), sizeof(val.NextHop)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.NextHop));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.PathCost) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.PathCost), sizeof(val.PathCost)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.PathCost));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LQIIn) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.LQIIn), sizeof(val.LQIIn)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.LQIIn));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LQIOut) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.LQIOut), sizeof(val.LQIOut)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.LQIOut));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Age) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Age), sizeof(val.Age)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.Age));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Allocated) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Allocated), sizeof(val.Allocated)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.Allocated));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.LinkEstablished) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.LinkEstablished), sizeof(val.LinkEstablished)); // BOOLEAN
        offset = static_cast<uint16_t>(offset + sizeof(val.LinkEstablished));
    }
    return CHIP_NO_ERROR;
}

// Struct for SceneExtensionAttributeInfo
CHIP_ERROR _SceneExtensionAttributeInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _SceneExtensionAttributeInfo & val = *reinterpret_cast<const _SceneExtensionAttributeInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _SceneExtensionAttributeInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _SceneExtensionAttributeInfo & val = *reinterpret_cast<_SceneExtensionAttributeInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 1: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _SceneExtensionAttributeInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                    = 0;
    _SceneExtensionAttributeInfo & val = *reinterpret_cast<_SceneExtensionAttributeInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeLocation), buf + offset, sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _SceneExtensionAttributeInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                          = 0;
    const _SceneExtensionAttributeInfo & val = *reinterpret_cast<const _SceneExtensionAttributeInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeLocation), sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

// Struct for SceneExtensionFieldSet
CHIP_ERROR _SceneExtensionFieldSet::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _SceneExtensionFieldSet & val = *reinterpret_cast<const _SceneExtensionFieldSet *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.clusterId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.length));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.value));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _SceneExtensionFieldSet::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _SceneExtensionFieldSet & val = *reinterpret_cast<_SceneExtensionFieldSet *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.clusterId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.length));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.value));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _SceneExtensionFieldSet::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    _SceneExtensionFieldSet & val = *reinterpret_cast<_SceneExtensionFieldSet *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.clusterId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.clusterId), buf + offset, sizeof(val.clusterId)); // CLUSTER_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.clusterId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.length) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.length), buf + offset, sizeof(val.length)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.length));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.value) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.value), buf + offset, sizeof(val.value)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.value));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _SceneExtensionFieldSet::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                     = 0;
    const _SceneExtensionFieldSet & val = *reinterpret_cast<const _SceneExtensionFieldSet *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.clusterId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.clusterId), sizeof(val.clusterId)); // CLUSTER_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.clusterId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.length) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.length), sizeof(val.length)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.length));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.value) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.value), sizeof(val.value)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.value));
    }
    return CHIP_NO_ERROR;
}

// Struct for ScheduledPhase
CHIP_ERROR _ScheduledPhase::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ScheduledPhase & val = *reinterpret_cast<const _ScheduledPhase *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energyPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.scheduledTime));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ScheduledPhase::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ScheduledPhase & val = *reinterpret_cast<_ScheduledPhase *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.energyPhaseId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.scheduledTime));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ScheduledPhase::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset       = 0;
    _ScheduledPhase & val = *reinterpret_cast<_ScheduledPhase *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.energyPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.energyPhaseId), buf + offset, sizeof(val.energyPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.energyPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.scheduledTime) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.scheduledTime), buf + offset, sizeof(val.scheduledTime)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.scheduledTime));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ScheduledPhase::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset             = 0;
    const _ScheduledPhase & val = *reinterpret_cast<const _ScheduledPhase *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.energyPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.energyPhaseId), sizeof(val.energyPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.energyPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.scheduledTime) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.scheduledTime), sizeof(val.scheduledTime)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.scheduledTime));
    }
    return CHIP_NO_ERROR;
}

// Struct for SecurityPolicy
CHIP_ERROR _SecurityPolicy::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _SecurityPolicy & val = *reinterpret_cast<const _SecurityPolicy *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.RotationTime));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Flags));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _SecurityPolicy::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _SecurityPolicy & val = *reinterpret_cast<_SecurityPolicy *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.RotationTime));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.Flags));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _SecurityPolicy::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset       = 0;
    _SecurityPolicy & val = *reinterpret_cast<_SecurityPolicy *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.RotationTime) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.RotationTime), buf + offset, sizeof(val.RotationTime)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.RotationTime));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Flags) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Flags), buf + offset, sizeof(val.Flags)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.Flags));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _SecurityPolicy::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset             = 0;
    const _SecurityPolicy & val = *reinterpret_cast<const _SecurityPolicy *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.RotationTime) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.RotationTime), sizeof(val.RotationTime)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.RotationTime));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Flags) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Flags), sizeof(val.Flags)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.Flags));
    }
    return CHIP_NO_ERROR;
}

// Struct for SimpleStruct
CHIP_ERROR _SimpleStruct::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _SimpleStruct & val = *reinterpret_cast<const _SimpleStruct *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.fieldA));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.fieldB));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _SimpleStruct::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _SimpleStruct & val = *reinterpret_cast<_SimpleStruct *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.fieldA));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.fieldB));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _SimpleStruct::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset     = 0;
    _SimpleStruct & val = *reinterpret_cast<_SimpleStruct *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.fieldA) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.fieldA), buf + offset, sizeof(val.fieldA)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.fieldA));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.fieldB) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.fieldB), buf + offset, sizeof(val.fieldB)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.fieldB));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _SimpleStruct::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset           = 0;
    const _SimpleStruct & val = *reinterpret_cast<const _SimpleStruct *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.fieldA) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.fieldA), sizeof(val.fieldA)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.fieldA));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.fieldB) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.fieldB), sizeof(val.fieldB)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.fieldB));
    }
    return CHIP_NO_ERROR;
}

// Struct for TestListStructOctet
CHIP_ERROR _TestListStructOctet::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _TestListStructOctet & val = *reinterpret_cast<const _TestListStructOctet *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.fabricIndex));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.operationalCert));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _TestListStructOctet::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _TestListStructOctet & val = *reinterpret_cast<_TestListStructOctet *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.fabricIndex));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.operationalCert = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _TestListStructOctet::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset            = 0;
    _TestListStructOctet & val = *reinterpret_cast<_TestListStructOctet *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.fabricIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.fabricIndex), buf + offset, sizeof(val.fabricIndex)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.fabricIndex));
    }
    {
        constexpr uint16_t kLengthSize       = 2;
        chip::ByteSpan & operationalCertSpan = val.operationalCert; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &operationalCertSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + operationalCertSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _TestListStructOctet::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                  = 0;
    const _TestListStructOctet & val = *reinterpret_cast<const _TestListStructOctet *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.fabricIndex) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.fabricIndex), sizeof(val.fabricIndex)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.fabricIndex));
    }
    {
        constexpr uint16_t kLengthSize             = 2;
        const chip::ByteSpan & operationalCertSpan = val.operationalCert; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &operationalCertSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + operationalCertSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for ThreadInterfaceScanResult
CHIP_ERROR _ThreadInterfaceScanResult::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ThreadInterfaceScanResult & val = *reinterpret_cast<const _ThreadInterfaceScanResult *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.DiscoveryResponse));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ThreadInterfaceScanResult::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ThreadInterfaceScanResult & val = *reinterpret_cast<_ThreadInterfaceScanResult *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.DiscoveryResponse = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ThreadInterfaceScanResult::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                  = 0;
    _ThreadInterfaceScanResult & val = *reinterpret_cast<_ThreadInterfaceScanResult *>(valPtr);
    {
        constexpr uint16_t kLengthSize         = 2;
        chip::ByteSpan & DiscoveryResponseSpan = val.DiscoveryResponse; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &DiscoveryResponseSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + DiscoveryResponseSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ThreadInterfaceScanResult::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                        = 0;
    const _ThreadInterfaceScanResult & val = *reinterpret_cast<const _ThreadInterfaceScanResult *>(valPtr);
    {
        constexpr uint16_t kLengthSize               = 2;
        const chip::ByteSpan & DiscoveryResponseSpan = val.DiscoveryResponse; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &DiscoveryResponseSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + DiscoveryResponseSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for ThreadMetrics
CHIP_ERROR _ThreadMetrics::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _ThreadMetrics & val = *reinterpret_cast<const _ThreadMetrics *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Id));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.StackFreeCurrent));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.StackFreeMinimum));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.StackSize));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _ThreadMetrics::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _ThreadMetrics & val = *reinterpret_cast<_ThreadMetrics *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.Id));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.Name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.StackFreeCurrent));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.StackFreeMinimum));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.StackSize));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _ThreadMetrics::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset      = 0;
    _ThreadMetrics & val = *reinterpret_cast<_ThreadMetrics *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.Id) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Id), buf + offset, sizeof(val.Id)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.Id));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & NameSpan      = val.Name; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &NameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + NameSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.StackFreeCurrent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.StackFreeCurrent), buf + offset, sizeof(val.StackFreeCurrent)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.StackFreeCurrent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.StackFreeMinimum) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.StackFreeMinimum), buf + offset, sizeof(val.StackFreeMinimum)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.StackFreeMinimum));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.StackSize) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.StackSize), buf + offset, sizeof(val.StackSize)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.StackSize));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _ThreadMetrics::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset            = 0;
    const _ThreadMetrics & val = *reinterpret_cast<const _ThreadMetrics *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.Id) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Id), sizeof(val.Id)); // INT64U
        offset = static_cast<uint16_t>(offset + sizeof(val.Id));
    }
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & NameSpan = val.Name; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &NameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + NameSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.StackFreeCurrent) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.StackFreeCurrent), sizeof(val.StackFreeCurrent)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.StackFreeCurrent));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.StackFreeMinimum) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.StackFreeMinimum), sizeof(val.StackFreeMinimum)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.StackFreeMinimum));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.StackSize) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.StackSize), sizeof(val.StackSize)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.StackSize));
    }
    return CHIP_NO_ERROR;
}

// Struct for TransferredPhase
CHIP_ERROR _TransferredPhase::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _TransferredPhase & val = *reinterpret_cast<const _TransferredPhase *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energyPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.macroPhaseId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.expectedDuration));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.peakPower));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.energy));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.maxActivationDelay));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _TransferredPhase::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _TransferredPhase & val = *reinterpret_cast<_TransferredPhase *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.energyPhaseId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.macroPhaseId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.expectedDuration));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.peakPower));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.energy));
            break;
        }
        case 5: {
            ReturnErrorOnFailure(reader.Get(val.maxActivationDelay));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _TransferredPhase::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset         = 0;
    _TransferredPhase & val = *reinterpret_cast<_TransferredPhase *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.energyPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.energyPhaseId), buf + offset, sizeof(val.energyPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.energyPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.macroPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.macroPhaseId), buf + offset, sizeof(val.macroPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.macroPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.expectedDuration) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.expectedDuration), buf + offset, sizeof(val.expectedDuration)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.expectedDuration));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.peakPower) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.peakPower), buf + offset, sizeof(val.peakPower)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.peakPower));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.energy) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.energy), buf + offset, sizeof(val.energy)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.energy));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.maxActivationDelay) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.maxActivationDelay), buf + offset, sizeof(val.maxActivationDelay)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.maxActivationDelay));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _TransferredPhase::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset               = 0;
    const _TransferredPhase & val = *reinterpret_cast<const _TransferredPhase *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.energyPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.energyPhaseId), sizeof(val.energyPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.energyPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.macroPhaseId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.macroPhaseId), sizeof(val.macroPhaseId)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.macroPhaseId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.expectedDuration) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.expectedDuration), sizeof(val.expectedDuration)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.expectedDuration));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.peakPower) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.peakPower), sizeof(val.peakPower)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.peakPower));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.energy) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.energy), sizeof(val.energy)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.energy));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.maxActivationDelay) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.maxActivationDelay), sizeof(val.maxActivationDelay)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.maxActivationDelay));
    }
    return CHIP_NO_ERROR;
}

// Struct for TvChannelInfo
CHIP_ERROR _TvChannelInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _TvChannelInfo & val = *reinterpret_cast<const _TvChannelInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.majorNumber));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.minorNumber));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.name));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.callSign));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.affiliateCallSign));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _TvChannelInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _TvChannelInfo & val = *reinterpret_cast<_TvChannelInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.majorNumber));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.minorNumber));
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.name = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.callSign = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 4: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.affiliateCallSign = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _TvChannelInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset      = 0;
    _TvChannelInfo & val = *reinterpret_cast<_TvChannelInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.majorNumber) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.majorNumber), buf + offset, sizeof(val.majorNumber)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.majorNumber));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.minorNumber) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.minorNumber), buf + offset, sizeof(val.minorNumber)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.minorNumber));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & nameSpan      = val.name; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & callSignSpan  = val.callSign; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &callSignSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + callSignSpan.size());
    }
    {
        constexpr uint16_t kLengthSize         = 2;
        chip::ByteSpan & affiliateCallSignSpan = val.affiliateCallSign; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &affiliateCallSignSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + affiliateCallSignSpan.size());
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _TvChannelInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset            = 0;
    const _TvChannelInfo & val = *reinterpret_cast<const _TvChannelInfo *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.majorNumber) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.majorNumber), sizeof(val.majorNumber)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.majorNumber));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.minorNumber) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.minorNumber), sizeof(val.minorNumber)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.minorNumber));
    }
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & nameSpan = val.name; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &nameSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + nameSpan.size());
    }
    {
        constexpr uint16_t kLengthSize      = 2;
        const chip::ByteSpan & callSignSpan = val.callSign; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &callSignSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + callSignSpan.size());
    }
    {
        constexpr uint16_t kLengthSize               = 2;
        const chip::ByteSpan & affiliateCallSignSpan = val.affiliateCallSign; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &affiliateCallSignSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + affiliateCallSignSpan.size());
    }
    return CHIP_NO_ERROR;
}

// Struct for TvChannelLineupInfo
CHIP_ERROR _TvChannelLineupInfo::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _TvChannelLineupInfo & val = *reinterpret_cast<const _TvChannelLineupInfo *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.operatorName)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.lineupName)));
    SuccessOrExit(err = writer.PutString(TLV::ContextTag(seq++), chip::Uint8::to_const_char(val.postalCode)));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.lineupInfoType));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _TvChannelLineupInfo::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _TvChannelLineupInfo & val = *reinterpret_cast<_TvChannelLineupInfo *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.operatorName));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.lineupName));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.GetDataPtr(val.postalCode));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.lineupInfoType));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _TvChannelLineupInfo::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset            = 0;
    _TvChannelLineupInfo & val = *reinterpret_cast<_TvChannelLineupInfo *>(valPtr);
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.operatorName = buf + offset;
        offset           = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.lineupName = buf + offset;
        offset         = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        uint8_t len;
        memcpy(&len, buf + offset, sizeof(len));
        val.postalCode = buf + offset;
        offset         = static_cast<uint16_t>(offset + len + sizeof(len));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.lineupInfoType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.lineupInfoType), buf + offset, sizeof(val.lineupInfoType)); // TvChannelLineupInfoType
        offset = static_cast<uint16_t>(offset + sizeof(val.lineupInfoType));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _TvChannelLineupInfo::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                  = 0;
    const _TvChannelLineupInfo & val = *reinterpret_cast<const _TvChannelLineupInfo *>(valPtr);
    {
        uint8_t stringLen = emberAfStringLength(val.operatorName);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.operatorName, bufLength - offset);
    }
    {
        uint8_t stringLen = emberAfStringLength(val.lineupName);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.lineupName, bufLength - offset);
    }
    {
        uint8_t stringLen = emberAfStringLength(val.postalCode);
        VerifyOrReturnError(offset + stringLen + sizeof(stringLen) <= bufLength, CHIP_ERROR_NO_MEMORY);
        emberAfCopyString(buf + offset, val.postalCode, bufLength - offset);
    }
    {
        VerifyOrReturnError(offset + sizeof(val.lineupInfoType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.lineupInfoType), sizeof(val.lineupInfoType)); // TvChannelLineupInfoType
        offset = static_cast<uint16_t>(offset + sizeof(val.lineupInfoType));
    }
    return CHIP_NO_ERROR;
}

// Struct for WiFiInterfaceScanResult
CHIP_ERROR _WiFiInterfaceScanResult::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _WiFiInterfaceScanResult & val = *reinterpret_cast<const _WiFiInterfaceScanResult *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Security));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.SSID));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.BSSID));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.Channel));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.FrequencyBand));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _WiFiInterfaceScanResult::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _WiFiInterfaceScanResult & val = *reinterpret_cast<_WiFiInterfaceScanResult *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.Security));
            break;
        }
        case 1: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.SSID = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 2: {
            {
                const uint8_t * data = nullptr;
                ReturnErrorOnFailure(reader.GetDataPtr(data));
                val.BSSID = chip::ByteSpan(data, reader.GetLength());
            }
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.Channel));
            break;
        }
        case 4: {
            ReturnErrorOnFailure(reader.Get(val.FrequencyBand));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _WiFiInterfaceScanResult::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                = 0;
    _WiFiInterfaceScanResult & val = *reinterpret_cast<_WiFiInterfaceScanResult *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.Security) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Security), buf + offset, sizeof(val.Security)); // BITMAP8
        offset = static_cast<uint16_t>(offset + sizeof(val.Security));
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & SSIDSpan      = val.SSID; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &SSIDSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + SSIDSpan.size());
    }
    {
        constexpr uint16_t kLengthSize = 2;
        chip::ByteSpan & BSSIDSpan     = val.BSSID; // OCTET_STRING
        ReturnErrorOnFailure(ReadByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &BSSIDSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + BSSIDSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Channel) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.Channel), buf + offset, sizeof(val.Channel)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.Channel));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FrequencyBand) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.FrequencyBand), buf + offset, sizeof(val.FrequencyBand)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.FrequencyBand));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _WiFiInterfaceScanResult::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                      = 0;
    const _WiFiInterfaceScanResult & val = *reinterpret_cast<const _WiFiInterfaceScanResult *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.Security) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Security), sizeof(val.Security)); // BITMAP8
        offset = static_cast<uint16_t>(offset + sizeof(val.Security));
    }
    {
        constexpr uint16_t kLengthSize  = 2;
        const chip::ByteSpan & SSIDSpan = val.SSID; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &SSIDSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + SSIDSpan.size());
    }
    {
        constexpr uint16_t kLengthSize   = 2;
        const chip::ByteSpan & BSSIDSpan = val.BSSID; // OCTET_STRING
        ReturnErrorOnFailure(WriteByteSpan(buf + offset, static_cast<uint16_t>(bufLength - offset), &BSSIDSpan));
        offset = static_cast<uint16_t>(offset + kLengthSize + BSSIDSpan.size());
    }
    {
        VerifyOrReturnError(offset + sizeof(val.Channel) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.Channel), sizeof(val.Channel)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.Channel));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.FrequencyBand) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.FrequencyBand), sizeof(val.FrequencyBand)); // INT32U
        offset = static_cast<uint16_t>(offset + sizeof(val.FrequencyBand));
    }
    return CHIP_NO_ERROR;
}

// Struct for WriteAttributeRecord
CHIP_ERROR _WriteAttributeRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _WriteAttributeRecord & val = *reinterpret_cast<const _WriteAttributeRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _WriteAttributeRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _WriteAttributeRecord & val = *reinterpret_cast<_WriteAttributeRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 2: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _WriteAttributeRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset             = 0;
    _WriteAttributeRecord & val = *reinterpret_cast<_WriteAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeLocation), buf + offset, sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _WriteAttributeRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                   = 0;
    const _WriteAttributeRecord & val = *reinterpret_cast<const _WriteAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeLocation), sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

// Struct for WriteAttributeStatusRecord
CHIP_ERROR _WriteAttributeStatusRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _WriteAttributeStatusRecord & val = *reinterpret_cast<const _WriteAttributeStatusRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _WriteAttributeStatusRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _WriteAttributeStatusRecord & val = *reinterpret_cast<_WriteAttributeStatusRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _WriteAttributeStatusRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                   = 0;
    _WriteAttributeStatusRecord & val = *reinterpret_cast<_WriteAttributeStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.status), buf + offset, sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _WriteAttributeStatusRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                         = 0;
    const _WriteAttributeStatusRecord & val = *reinterpret_cast<const _WriteAttributeStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.status), sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    return CHIP_NO_ERROR;
}

// Struct for WriteStructuredAttributeRecord
CHIP_ERROR _WriteStructuredAttributeRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _WriteStructuredAttributeRecord & val = *reinterpret_cast<const _WriteStructuredAttributeRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicator));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicies));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeType));
    SuccessOrExit(err = writer.PutNull(TLV::ContextTag(seq++)));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _WriteStructuredAttributeRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _WriteStructuredAttributeRecord & val = *reinterpret_cast<_WriteStructuredAttributeRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.indicator));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.indicies));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.attributeType));
            break;
        }
        case 4: {
            // Nothing;
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _WriteStructuredAttributeRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                       = 0;
    _WriteStructuredAttributeRecord & val = *reinterpret_cast<_WriteStructuredAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicator) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.indicator), buf + offset, sizeof(val.indicator)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicator));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicies) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.indicies), buf + offset, sizeof(val.indicies)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicies));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeType), buf + offset, sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeLocation), buf + offset, sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _WriteStructuredAttributeRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                             = 0;
    const _WriteStructuredAttributeRecord & val = *reinterpret_cast<const _WriteStructuredAttributeRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicator) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.indicator), sizeof(val.indicator)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicator));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicies) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.indicies), sizeof(val.indicies)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicies));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeType) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeType), sizeof(val.attributeType)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeType));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeLocation) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeLocation), sizeof(val.attributeLocation)); // NO_DATA
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeLocation));
    }
    return CHIP_NO_ERROR;
}

// Struct for WriteStructuredAttributeStatusRecord
CHIP_ERROR _WriteStructuredAttributeStatusRecord::Encode(const void * valPtr, TLV::TLVWriter & writer, uint64_t tag)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVType tmpType;
    uint8_t seq = 0;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    const _WriteStructuredAttributeStatusRecord & val = *reinterpret_cast<const _WriteStructuredAttributeStatusRecord *>(valPtr);
    SuccessOrExit(err = writer.StartContainer(tag, TLV::TLVType::kTLVType_Structure, tmpType));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.status));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.attributeId));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicator));
    SuccessOrExit(err = writer.Put(TLV::ContextTag(seq++), val.indicies));
exit:
    err = writer.EndContainer(tmpType);
    return err;
}

CHIP_ERROR _WriteStructuredAttributeStatusRecord::Decode(void * valPtr, const TLV::TLVReader & aReader)
{
    CHIP_ERROR err = CHIP_NO_ERROR;
    chip::TLV::TLVReader reader;
    chip::TLV::TLVType tmpType;
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    _WriteStructuredAttributeStatusRecord & val = *reinterpret_cast<_WriteStructuredAttributeStatusRecord *>(valPtr);
    reader.Init(aReader);
    VerifyOrReturnError(reader.GetType() == TLV::TLVType::kTLVType_Structure, CHIP_ERROR_INVALID_ARGUMENT);
    ReturnErrorOnFailure(reader.EnterContainer(tmpType));
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        if (!TLV::IsContextTag(reader.GetTag()))
        {
            continue;
        }
        uint32_t currentDecodeTagId = TLV::TagNumFromTag(reader.GetTag());
        switch (currentDecodeTagId)
        {
        case 0: {
            ReturnErrorOnFailure(reader.Get(val.status));
            break;
        }
        case 1: {
            ReturnErrorOnFailure(reader.Get(val.attributeId));
            break;
        }
        case 2: {
            ReturnErrorOnFailure(reader.Get(val.indicator));
            break;
        }
        case 3: {
            ReturnErrorOnFailure(reader.Get(val.indicies));
            break;
        }
        default:
            // Unsupported tag, ignore it.
            ChipLogProgress(Zcl, "Unknown TLV tag during processing.");
        }
    }
    if (err == CHIP_END_OF_TLV)
    {
        err = CHIP_NO_ERROR;
    }
    return err;
}

CHIP_ERROR _WriteStructuredAttributeStatusRecord::FromEmberBuffer(void * valPtr, const uint8_t * buf, size_t bufLength)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                             = 0;
    _WriteStructuredAttributeStatusRecord & val = *reinterpret_cast<_WriteStructuredAttributeStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.status), buf + offset, sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.attributeId), buf + offset, sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicator) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.indicator), buf + offset, sizeof(val.indicator)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicator));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicies) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove((uint8_t *) &(val.indicies), buf + offset, sizeof(val.indicies)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicies));
    }
    return CHIP_NO_ERROR;
}

CHIP_ERROR _WriteStructuredAttributeStatusRecord::ToEmberBuffer(const void * valPtr, uint8_t * buf, size_t bufLength, size_t & len)
{
    VerifyOrReturnError(valPtr != nullptr, CHIP_ERROR_INVALID_ARGUMENT);
    uint16_t offset                                   = 0;
    const _WriteStructuredAttributeStatusRecord & val = *reinterpret_cast<const _WriteStructuredAttributeStatusRecord *>(valPtr);
    {
        VerifyOrReturnError(offset + sizeof(val.status) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.status), sizeof(val.status)); // Status
        offset = static_cast<uint16_t>(offset + sizeof(val.status));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.attributeId) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.attributeId), sizeof(val.attributeId)); // ATTRIB_ID
        offset = static_cast<uint16_t>(offset + sizeof(val.attributeId));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicator) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.indicator), sizeof(val.indicator)); // INT8U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicator));
    }
    {
        VerifyOrReturnError(offset + sizeof(val.indicies) <= bufLength, CHIP_ERROR_INVALID_ARGUMENT);
        memmove(buf + offset, (uint8_t *) &(val.indicies), sizeof(val.indicies)); // INT16U
        offset = static_cast<uint16_t>(offset + sizeof(val.indicies));
    }
    return CHIP_NO_ERROR;
}
