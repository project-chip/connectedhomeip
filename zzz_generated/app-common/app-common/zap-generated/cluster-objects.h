/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/util/basic-types.h>

namespace chip {
namespace app {
namespace Clusters {

namespace PowerConfiguration {

} // namespace PowerConfiguration
namespace DeviceTemperatureConfiguration {

} // namespace DeviceTemperatureConfiguration
namespace Identify {
// Enum for IdentifyEffectIdentifier
enum class IdentifyEffectIdentifier : uint8_t
{
    IDENTIFY_EFFECT_IDENTIFIER_BLINK          = 0x00,
    IDENTIFY_EFFECT_IDENTIFIER_BREATHE        = 0x01,
    IDENTIFY_EFFECT_IDENTIFIER_OKAY           = 0x02,
    IDENTIFY_EFFECT_IDENTIFIER_CHANNEL_CHANGE = 0x0B,
    IDENTIFY_EFFECT_IDENTIFIER_FINISH_EFFECT  = 0xFE,
    IDENTIFY_EFFECT_IDENTIFIER_STOP_EFFECT    = 0xFF,
};
// Enum for IdentifyEffectVariant
enum class IdentifyEffectVariant : uint8_t
{
    IDENTIFY_EFFECT_VARIANT_DEFAULT = 0x00,
};
// Enum for IdentifyIdentifyType
enum class IdentifyIdentifyType : uint8_t
{
    IDENTIFY_IDENTIFY_TYPE_NONE          = 0x00,
    IDENTIFY_IDENTIFY_TYPE_VISIBLE_LIGHT = 0x01,
    IDENTIFY_IDENTIFY_TYPE_VISIBLE_LED   = 0x02,
    IDENTIFY_IDENTIFY_TYPE_AUDIBLE_BEEP  = 0x03,
    IDENTIFY_IDENTIFY_TYPE_DISPLAY       = 0x04,
    IDENTIFY_IDENTIFY_TYPE_ACTUATOR      = 0x05,
};

namespace Commands {
namespace Identify {
struct Type
{
};

struct DecodableType
{
};
} // namespace Identify

namespace IdentifyQueryResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace IdentifyQueryResponse

namespace IdentifyQuery {
struct Type
{
};

struct DecodableType
{
};
} // namespace IdentifyQuery

namespace TriggerEffect {
struct Type
{
};

struct DecodableType
{
};
} // namespace TriggerEffect

} // namespace Commands
} // namespace Identify
namespace Groups {

namespace Commands {
namespace AddGroup {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddGroup

namespace AddGroupResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddGroupResponse

namespace ViewGroup {
struct Type
{
};

struct DecodableType
{
};
} // namespace ViewGroup

namespace ViewGroupResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ViewGroupResponse

namespace GetGroupMembership {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetGroupMembership

namespace GetGroupMembershipResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetGroupMembershipResponse

namespace RemoveGroup {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveGroup

namespace RemoveGroupResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveGroupResponse

namespace RemoveAllGroups {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveAllGroups

namespace AddGroupIfIdentifying {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddGroupIfIdentifying

} // namespace Commands
} // namespace Groups
namespace Scenes {

namespace SceneExtensionFieldSet {
enum FieldId
{
    kClusterIdFieldId = 0,
    kLengthFieldId    = 1,
    kValueFieldId     = 2,
};

struct Type
{
public:
    uint32_t clusterId;
    uint8_t length;
    uint8_t value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SceneExtensionFieldSet

namespace Commands {
namespace AddScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddScene

namespace AddSceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddSceneResponse

namespace ViewScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace ViewScene

namespace ViewSceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ViewSceneResponse

namespace RemoveScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveScene

namespace RemoveSceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveSceneResponse

namespace RemoveAllScenes {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveAllScenes

namespace RemoveAllScenesResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveAllScenesResponse

namespace StoreScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace StoreScene

namespace StoreSceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace StoreSceneResponse

namespace RecallScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace RecallScene

namespace GetSceneMembership {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetSceneMembership

namespace GetSceneMembershipResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetSceneMembershipResponse

namespace EnhancedAddScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedAddScene

namespace EnhancedAddSceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedAddSceneResponse

namespace EnhancedViewScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedViewScene

namespace EnhancedViewSceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedViewSceneResponse

namespace CopyScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace CopyScene

namespace CopySceneResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace CopySceneResponse

} // namespace Commands
} // namespace Scenes
namespace OnOff {
// Enum for OnOffDelayedAllOffEffectVariant
enum class OnOffDelayedAllOffEffectVariant : uint8_t
{
    ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_FADE_TO_OFF_IN_0P8_SECONDS                                        = 0x00,
    ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_NO_FADE                                                           = 0x01,
    ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_50_PERCENT_DIM_DOWN_IN_0P8_SECONDS_THEN_FADE_TO_OFF_IN_12_SECONDS = 0x02,
};
// Enum for OnOffDyingLightEffectVariant
enum class OnOffDyingLightEffectVariant : uint8_t
{
    ON_OFF_DYING_LIGHT_EFFECT_VARIANT_20_PERCENTER_DIM_UP_IN_0P5_SECONDS_THEN_FADE_TO_OFF_IN_1_SECOND = 0x00,
};
// Enum for OnOffEffectIdentifier
enum class OnOffEffectIdentifier : uint8_t
{
    ON_OFF_EFFECT_IDENTIFIER_DELAYED_ALL_OFF = 0x00,
    ON_OFF_EFFECT_IDENTIFIER_DYING_LIGHT     = 0x01,
};

namespace Commands {
namespace Off {
struct Type
{
};

struct DecodableType
{
};
} // namespace Off

namespace SampleMfgSpecificOffWithTransition {
struct Type
{
};

struct DecodableType
{
};
} // namespace SampleMfgSpecificOffWithTransition

namespace On {
struct Type
{
};

struct DecodableType
{
};
} // namespace On

namespace SampleMfgSpecificOnWithTransition {
struct Type
{
};

struct DecodableType
{
};
} // namespace SampleMfgSpecificOnWithTransition

namespace SampleMfgSpecificOnWithTransition2 {
struct Type
{
};

struct DecodableType
{
};
} // namespace SampleMfgSpecificOnWithTransition2

namespace Toggle {
struct Type
{
};

struct DecodableType
{
};
} // namespace Toggle

namespace SampleMfgSpecificToggleWithTransition {
struct Type
{
};

struct DecodableType
{
};
} // namespace SampleMfgSpecificToggleWithTransition

namespace SampleMfgSpecificToggleWithTransition2 {
struct Type
{
};

struct DecodableType
{
};
} // namespace SampleMfgSpecificToggleWithTransition2

namespace OffWithEffect {
struct Type
{
};

struct DecodableType
{
};
} // namespace OffWithEffect

namespace OnWithRecallGlobalScene {
struct Type
{
};

struct DecodableType
{
};
} // namespace OnWithRecallGlobalScene

namespace OnWithTimedOff {
struct Type
{
};

struct DecodableType
{
};
} // namespace OnWithTimedOff

} // namespace Commands
} // namespace OnOff
namespace OnOffSwitchConfiguration {

} // namespace OnOffSwitchConfiguration
namespace LevelControl {
// Enum for MoveMode
enum class MoveMode : uint8_t
{
    MOVE_MODE_UP   = 0x00,
    MOVE_MODE_DOWN = 0x01,
};
// Enum for StepMode
enum class StepMode : uint8_t
{
    STEP_MODE_UP   = 0x00,
    STEP_MODE_DOWN = 0x01,
};

namespace Commands {
namespace MoveToLevel {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToLevel

namespace Move {
struct Type
{
};

struct DecodableType
{
};
} // namespace Move

namespace Step {
struct Type
{
};

struct DecodableType
{
};
} // namespace Step

namespace Stop {
struct Type
{
};

struct DecodableType
{
};
} // namespace Stop

namespace MoveToLevelWithOnOff {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToLevelWithOnOff

namespace MoveWithOnOff {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveWithOnOff

namespace StepWithOnOff {
struct Type
{
};

struct DecodableType
{
};
} // namespace StepWithOnOff

namespace StopWithOnOff {
struct Type
{
};

struct DecodableType
{
};
} // namespace StopWithOnOff

} // namespace Commands
} // namespace LevelControl
namespace Alarms {

namespace Commands {
namespace ResetAlarm {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetAlarm

namespace Alarm {
struct Type
{
};

struct DecodableType
{
};
} // namespace Alarm

namespace ResetAllAlarms {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetAllAlarms

namespace GetAlarmResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetAlarmResponse

namespace GetAlarm {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetAlarm

namespace ResetAlarmLog {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetAlarmLog

} // namespace Commands
} // namespace Alarms
namespace Time {

} // namespace Time
namespace BinaryInputBasic {

} // namespace BinaryInputBasic
namespace PowerProfile {

namespace PowerProfileRecord {
enum FieldId
{
    kPowerProfileIdFieldId            = 0,
    kEnergyPhaseIdFieldId             = 1,
    kPowerProfileRemoteControlFieldId = 2,
    kPowerProfileStateFieldId         = 3,
};

struct Type
{
public:
    uint8_t powerProfileId;
    uint8_t energyPhaseId;
    bool powerProfileRemoteControl;
    uint8_t powerProfileState;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace PowerProfileRecord
namespace ScheduledPhase {
enum FieldId
{
    kEnergyPhaseIdFieldId = 0,
    kScheduledTimeFieldId = 1,
};

struct Type
{
public:
    uint8_t energyPhaseId;
    uint16_t scheduledTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ScheduledPhase
namespace TransferredPhase {
enum FieldId
{
    kEnergyPhaseIdFieldId      = 0,
    kMacroPhaseIdFieldId       = 1,
    kExpectedDurationFieldId   = 2,
    kPeakPowerFieldId          = 3,
    kEnergyFieldId             = 4,
    kMaxActivationDelayFieldId = 5,
};

struct Type
{
public:
    uint8_t energyPhaseId;
    uint8_t macroPhaseId;
    uint16_t expectedDuration;
    uint16_t peakPower;
    uint16_t energy;
    uint16_t maxActivationDelay;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TransferredPhase

namespace Commands {
namespace PowerProfileRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileRequest

namespace PowerProfileNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileNotification

namespace PowerProfileStateRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileStateRequest

namespace PowerProfileResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileResponse

namespace GetPowerProfilePriceResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPowerProfilePriceResponse

namespace PowerProfileStateResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileStateResponse

namespace GetOverallSchedulePriceResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetOverallSchedulePriceResponse

namespace GetPowerProfilePrice {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPowerProfilePrice

namespace EnergyPhasesScheduleNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnergyPhasesScheduleNotification

namespace PowerProfilesStateNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfilesStateNotification

namespace EnergyPhasesScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnergyPhasesScheduleResponse

namespace GetOverallSchedulePrice {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetOverallSchedulePrice

namespace PowerProfileScheduleConstraintsRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileScheduleConstraintsRequest

namespace EnergyPhasesScheduleRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnergyPhasesScheduleRequest

namespace EnergyPhasesScheduleStateRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnergyPhasesScheduleStateRequest

namespace EnergyPhasesScheduleStateResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnergyPhasesScheduleStateResponse

namespace GetPowerProfilePriceExtendedResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPowerProfilePriceExtendedResponse

namespace EnergyPhasesScheduleStateNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnergyPhasesScheduleStateNotification

namespace PowerProfileScheduleConstraintsNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileScheduleConstraintsNotification

namespace PowerProfileScheduleConstraintsResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace PowerProfileScheduleConstraintsResponse

namespace GetPowerProfilePriceExtended {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPowerProfilePriceExtended

} // namespace Commands
} // namespace PowerProfile
namespace ApplianceControl {
// Enum for ApplianceStatus
enum class ApplianceStatus : uint8_t
{
    APPLIANCE_STATUS_OFF                         = 0x01,
    APPLIANCE_STATUS_STAND_BY                    = 0x02,
    APPLIANCE_STATUS_PROGRAMMED                  = 0x03,
    APPLIANCE_STATUS_PROGRAMMED_WAITING_TO_START = 0x04,
    APPLIANCE_STATUS_RUNNING                     = 0x05,
    APPLIANCE_STATUS_PAUSE                       = 0x06,
    APPLIANCE_STATUS_END_PROGRAMMED              = 0x07,
    APPLIANCE_STATUS_FAILURE                     = 0x08,
    APPLIANCE_STATUS_PROGRAMME_INTERRUPTED       = 0x09,
    APPLIANCE_STATUS_IDLE                        = 0x0A,
    APPLIANCE_STATUS_RINSE_HOLD                  = 0x0B,
    APPLIANCE_STATUS_SERVICE                     = 0x0C,
    APPLIANCE_STATUS_SUPERFREEZING               = 0x0D,
    APPLIANCE_STATUS_SUPERCOOLING                = 0x0E,
    APPLIANCE_STATUS_SUPERHEATING                = 0x0F,
};
// Enum for CommandIdentification
enum class CommandIdentification : uint8_t
{
    COMMAND_IDENTIFICATION_START                  = 0x01,
    COMMAND_IDENTIFICATION_STOP                   = 0x02,
    COMMAND_IDENTIFICATION_PAUSE                  = 0x03,
    COMMAND_IDENTIFICATION_START_SUPERFREEZING    = 0x04,
    COMMAND_IDENTIFICATION_STOP_SUPERFREEZING     = 0x05,
    COMMAND_IDENTIFICATION_START_SUPERCOOLING     = 0x06,
    COMMAND_IDENTIFICATION_STOP_SUPERCOOLING      = 0x07,
    COMMAND_IDENTIFICATION_DISABLE_GAS            = 0x08,
    COMMAND_IDENTIFICATION_ENABLE_GAS             = 0x09,
    COMMAND_IDENTIFICATION_ENABLE_ENERGY_CONTROL  = 0x0A,
    COMMAND_IDENTIFICATION_DISABLE_ENERGY_CONTROL = 0x0B,
};
// Enum for WarningEvent
enum class WarningEvent : uint8_t
{
    WARNING_EVENT_WARNING1_OVERALL_POWER_ABOVE_AVAILABLE_POWER_LEVEL                                             = 0x00,
    WARNING_EVENT_WARNING2_OVERALL_POWER_ABOVE_POWER_THRESHOLD_LEVEL                                             = 0x01,
    WARNING_EVENT_WARNING3_OVERALL_POWER_BACK_BELOW_THE_AVAILABLE_POWER_LEVEL                                    = 0x02,
    WARNING_EVENT_WARNING4_OVERALL_POWER_BACK_BELOW_THE_POWER_THRESHOLD_LEVEL                                    = 0x03,
    WARNING_EVENT_WARNING5_OVERALL_POWER_WILL_BE_POTENTIALLY_ABOVE_AVAILABLE_POWER_LEVEL_IF_THE_APPLIANCE_STARTS = 0x04,
};

namespace Commands {
namespace ExecutionOfACommand {
struct Type
{
};

struct DecodableType
{
};
} // namespace ExecutionOfACommand

namespace SignalStateResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SignalStateResponse

namespace SignalState {
struct Type
{
};

struct DecodableType
{
};
} // namespace SignalState

namespace SignalStateNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace SignalStateNotification

namespace WriteFunctions {
struct Type
{
};

struct DecodableType
{
};
} // namespace WriteFunctions

namespace OverloadPauseResume {
struct Type
{
};

struct DecodableType
{
};
} // namespace OverloadPauseResume

namespace OverloadPause {
struct Type
{
};

struct DecodableType
{
};
} // namespace OverloadPause

namespace OverloadWarning {
struct Type
{
};

struct DecodableType
{
};
} // namespace OverloadWarning

} // namespace Commands
} // namespace ApplianceControl
namespace Descriptor {

namespace DeviceType {
enum FieldId
{
    kTypeFieldId     = 0,
    kRevisionFieldId = 1,
};

struct Type
{
public:
    uint32_t type;
    uint16_t revision;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace DeviceType

} // namespace Descriptor
namespace PollControl {

namespace Commands {
namespace CheckIn {
struct Type
{
};

struct DecodableType
{
};
} // namespace CheckIn

namespace CheckInResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace CheckInResponse

namespace FastPollStop {
struct Type
{
};

struct DecodableType
{
};
} // namespace FastPollStop

namespace SetLongPollInterval {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetLongPollInterval

namespace SetShortPollInterval {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetShortPollInterval

} // namespace Commands
} // namespace PollControl
namespace Basic {

namespace Commands {
namespace StartUp {
struct Type
{
};

struct DecodableType
{
};
} // namespace StartUp

namespace MfgSpecificPing {
struct Type
{
};

struct DecodableType
{
};
} // namespace MfgSpecificPing

namespace ShutDown {
struct Type
{
};

struct DecodableType
{
};
} // namespace ShutDown

namespace Leave {
struct Type
{
};

struct DecodableType
{
};
} // namespace Leave

} // namespace Commands
} // namespace Basic
namespace OtaSoftwareUpdateProvider {
// Enum for OTAApplyUpdateAction
enum class OTAApplyUpdateAction : uint8_t
{
    OTA_APPLY_UPDATE_ACTION_PROCEED           = 0x00,
    OTA_APPLY_UPDATE_ACTION_AWAIT_NEXT_ACTION = 0x01,
    OTA_APPLY_UPDATE_ACTION_DISCONTINUE       = 0x02,
};
// Enum for OTADownloadProtocol
enum class OTADownloadProtocol : uint8_t
{
    OTA_DOWNLOAD_PROTOCOL_BDX_SYNCHRONOUS  = 0x00,
    OTA_DOWNLOAD_PROTOCOL_BDX_ASYNCHRONOUS = 0x01,
    OTA_DOWNLOAD_PROTOCOL_HTTPS            = 0x02,
    OTA_DOWNLOAD_PROTOCOL_VENDOR_SPECIFIC  = 0x03,
};
// Enum for OTAQueryStatus
enum class OTAQueryStatus : uint8_t
{
    OTA_QUERY_STATUS_UPDATE_AVAILABLE = 0x00,
    OTA_QUERY_STATUS_BUSY             = 0x01,
    OTA_QUERY_STATUS_NOT_AVAILABLE    = 0x02,
};

namespace Commands {
namespace QueryImage {
struct Type
{
};

struct DecodableType
{
};
} // namespace QueryImage

namespace ApplyUpdateRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace ApplyUpdateRequest

namespace NotifyUpdateApplied {
struct Type
{
};

struct DecodableType
{
};
} // namespace NotifyUpdateApplied

namespace QueryImageResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace QueryImageResponse

namespace ApplyUpdateRequestResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ApplyUpdateRequestResponse

} // namespace Commands
} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
// Enum for OTAAnnouncementReason
enum class OTAAnnouncementReason : uint8_t
{
    OTA_ANNOUNCEMENT_REASON_SIMPLE_ANNOUNCEMENT     = 0x00,
    OTA_ANNOUNCEMENT_REASON_UPDATE_AVAILABLE        = 0x01,
    OTA_ANNOUNCEMENT_REASON_URGENT_UPDATE_AVAILABLE = 0x02,
};

namespace Commands {
namespace AnnounceOtaProvider {
struct Type
{
};

struct DecodableType
{
};
} // namespace AnnounceOtaProvider

} // namespace Commands
} // namespace OtaSoftwareUpdateRequestor
namespace PowerSource {

} // namespace PowerSource
namespace GeneralCommissioning {
// Enum for GeneralCommissioningError
enum class GeneralCommissioningError : uint8_t
{
    GENERAL_COMMISSIONING_ERROR_OK                     = 0x00,
    GENERAL_COMMISSIONING_ERROR_VALUE_OUTSIDE_RANGE    = 0x01,
    GENERAL_COMMISSIONING_ERROR_INVALID_AUTHENTICATION = 0x02,
};
// Enum for RegulatoryLocationType
enum class RegulatoryLocationType : uint8_t
{
    REGULATORY_LOCATION_TYPE_INDOOR         = 0x00,
    REGULATORY_LOCATION_TYPE_OUTDOOR        = 0x01,
    REGULATORY_LOCATION_TYPE_INDOOR_OUTDOOR = 0x02,
};

namespace BasicCommissioningInfoType {
enum FieldId
{
    kFailSafeExpiryLengthMsFieldId = 0,
};

struct Type
{
public:
    uint32_t failSafeExpiryLengthMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace BasicCommissioningInfoType

namespace Commands {
namespace ArmFailSafe {
struct Type
{
};

struct DecodableType
{
};
} // namespace ArmFailSafe

namespace ArmFailSafeResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ArmFailSafeResponse

namespace SetRegulatoryConfig {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetRegulatoryConfig

namespace SetRegulatoryConfigResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetRegulatoryConfigResponse

namespace CommissioningComplete {
struct Type
{
};

struct DecodableType
{
};
} // namespace CommissioningComplete

namespace CommissioningCompleteResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace CommissioningCompleteResponse

} // namespace Commands
} // namespace GeneralCommissioning
namespace NetworkCommissioning {
// Enum for NetworkCommissioningError
enum class NetworkCommissioningError : uint8_t
{
    NETWORK_COMMISSIONING_ERROR_SUCCESS                  = 0x00,
    NETWORK_COMMISSIONING_ERROR_OUT_OF_RANGE             = 0x01,
    NETWORK_COMMISSIONING_ERROR_BOUNDS_EXCEEDED          = 0x02,
    NETWORK_COMMISSIONING_ERROR_NETWORK_ID_NOT_FOUND     = 0x03,
    NETWORK_COMMISSIONING_ERROR_DUPLICATE_NETWORK_ID     = 0x04,
    NETWORK_COMMISSIONING_ERROR_NETWORK_NOT_FOUND        = 0x05,
    NETWORK_COMMISSIONING_ERROR_REGULATORY_ERROR         = 0x06,
    NETWORK_COMMISSIONING_ERROR_AUTH_FAILURE             = 0x07,
    NETWORK_COMMISSIONING_ERROR_UNSUPPORTED_SECURITY     = 0x08,
    NETWORK_COMMISSIONING_ERROR_OTHER_CONNECTION_FAILURE = 0x09,
    NETWORK_COMMISSIONING_ERROR_IPV6_FAILED              = 0x0A,
    NETWORK_COMMISSIONING_ERROR_IP_BIND_FAILED           = 0x0B,
    NETWORK_COMMISSIONING_ERROR_LABEL9                   = 0x0C,
    NETWORK_COMMISSIONING_ERROR_LABEL10                  = 0x0D,
    NETWORK_COMMISSIONING_ERROR_LABEL11                  = 0x0E,
    NETWORK_COMMISSIONING_ERROR_LABEL12                  = 0x0F,
    NETWORK_COMMISSIONING_ERROR_LABEL13                  = 0x10,
    NETWORK_COMMISSIONING_ERROR_LABEL14                  = 0x11,
    NETWORK_COMMISSIONING_ERROR_LABEL15                  = 0x12,
    NETWORK_COMMISSIONING_ERROR_UNKNOWN_ERROR            = 0x13,
};

namespace ThreadInterfaceScanResult {
enum FieldId
{
    kDiscoveryResponseFieldId = 0,
};

struct Type
{
public:
    chip::ByteSpan discoveryResponse;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ThreadInterfaceScanResult
namespace WiFiInterfaceScanResult {
enum FieldId
{
    kSecurityFieldId      = 0,
    kSsidFieldId          = 1,
    kBssidFieldId         = 2,
    kChannelFieldId       = 3,
    kFrequencyBandFieldId = 4,
};

struct Type
{
public:
    uint8_t security;
    chip::ByteSpan ssid;
    chip::ByteSpan bssid;
    uint8_t channel;
    uint32_t frequencyBand;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace WiFiInterfaceScanResult

namespace Commands {
namespace ScanNetworks {
struct Type
{
};

struct DecodableType
{
};
} // namespace ScanNetworks

namespace ScanNetworksResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ScanNetworksResponse

namespace AddWiFiNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddWiFiNetwork

namespace AddWiFiNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddWiFiNetworkResponse

namespace UpdateWiFiNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpdateWiFiNetwork

namespace UpdateWiFiNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpdateWiFiNetworkResponse

namespace AddThreadNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddThreadNetwork

namespace AddThreadNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddThreadNetworkResponse

namespace UpdateThreadNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpdateThreadNetwork

namespace UpdateThreadNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpdateThreadNetworkResponse

namespace RemoveNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveNetwork

namespace RemoveNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveNetworkResponse

namespace EnableNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnableNetwork

namespace EnableNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnableNetworkResponse

namespace DisableNetwork {
struct Type
{
};

struct DecodableType
{
};
} // namespace DisableNetwork

namespace DisableNetworkResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace DisableNetworkResponse

namespace GetLastNetworkCommissioningResult {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetLastNetworkCommissioningResult

} // namespace Commands
} // namespace NetworkCommissioning
namespace DiagnosticLogs {
// Enum for LogsIntent
enum class LogsIntent : uint8_t
{
    LOGS_INTENT_END_USER_SUPPORT = 0x00,
    LOGS_INTENT_NETWORK_DIAG     = 0x01,
    LOGS_INTENT_CRASH_LOGS       = 0x02,
};
// Enum for LogsStatus
enum class LogsStatus : uint8_t
{
    LOGS_STATUS_SUCCESS   = 0x00,
    LOGS_STATUS_EXHAUSTED = 0x01,
    LOGS_STATUS_NO_LOGS   = 0x02,
    LOGS_STATUS_BUSY      = 0x03,
    LOGS_STATUS_DENIED    = 0x04,
};
// Enum for LogsTransferProtocol
enum class LogsTransferProtocol : uint8_t
{
    LOGS_TRANSFER_PROTOCOL_RESPONSE_PAYLOAD = 0x00,
    LOGS_TRANSFER_PROTOCOL_BDX              = 0x01,
};

namespace Commands {
namespace RetrieveLogsRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace RetrieveLogsRequest

namespace RetrieveLogsResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace RetrieveLogsResponse

} // namespace Commands
} // namespace DiagnosticLogs
namespace GeneralDiagnostics {
// Enum for BootReasonType
enum class BootReasonType : uint8_t
{
    BOOT_REASON_TYPE_UNSPECIFIED               = 0x00,
    BOOT_REASON_TYPE_POWER_ON_REBOOT           = 0x01,
    BOOT_REASON_TYPE_BROWN_OUT_RESET           = 0x02,
    BOOT_REASON_TYPE_SOFTWARE_WATCHDOG_RESET   = 0x03,
    BOOT_REASON_TYPE_HARDWARE_WATCHDOG_RESET   = 0x04,
    BOOT_REASON_TYPE_SOFTWARE_UPDATE_COMPLETED = 0x05,
    BOOT_REASON_TYPE_SOFTWARE_RESET            = 0x06,
};
// Enum for HardwareFaultType
enum class HardwareFaultType : uint8_t
{
    HARDWARE_FAULT_TYPE_UNSPECIFIED               = 0x00,
    HARDWARE_FAULT_TYPE_RADIO                     = 0x01,
    HARDWARE_FAULT_TYPE_SENSOR                    = 0x02,
    HARDWARE_FAULT_TYPE_RESETTABLE_OVER_TEMP      = 0x03,
    HARDWARE_FAULT_TYPE_NON_RESETTABLE_OVER_TEMP  = 0x04,
    HARDWARE_FAULT_TYPE_POWER_SOURCE              = 0x05,
    HARDWARE_FAULT_TYPE_VISUAL_DISPLAY_FAULT      = 0x06,
    HARDWARE_FAULT_TYPE_AUDIO_OUTPUT_FAULT        = 0x07,
    HARDWARE_FAULT_TYPE_USER_INTERFACE_FAULT      = 0x08,
    HARDWARE_FAULT_TYPE_NON_VOLATILE_MEMORY_ERROR = 0x09,
    HARDWARE_FAULT_TYPE_TAMPER_DETECTED           = 0x0A,
};
// Enum for InterfaceType
enum class InterfaceType : uint8_t
{
    INTERFACE_TYPE_UNSPECIFIED = 0x00,
    INTERFACE_TYPE_WI_FI       = 0x01,
    INTERFACE_TYPE_ETHERNET    = 0x02,
    INTERFACE_TYPE_CELLULAR    = 0x03,
    INTERFACE_TYPE_THREAD      = 0x04,
};
// Enum for NetworkFaultType
enum class NetworkFaultType : uint8_t
{
    NETWORK_FAULT_TYPE_UNSPECIFIED       = 0x00,
    NETWORK_FAULT_TYPE_HARDWARE_FAILURE  = 0x01,
    NETWORK_FAULT_TYPE_NETWORK_JAMMED    = 0x02,
    NETWORK_FAULT_TYPE_CONNECTION_FAILED = 0x03,
};
// Enum for RadioFaultType
enum class RadioFaultType : uint8_t
{
    RADIO_FAULT_TYPE_UNSPECIFIED    = 0x00,
    RADIO_FAULT_TYPE_WI_FI_FAULT    = 0x01,
    RADIO_FAULT_TYPE_CELLULAR_FAULT = 0x02,
    RADIO_FAULT_TYPE_THREAD_FAULT   = 0x03,
    RADIO_FAULT_TYPE_NFC_FAULT      = 0x04,
    RADIO_FAULT_TYPE_BLE_FAULT      = 0x05,
    RADIO_FAULT_TYPE_ETHERNET_FAULT = 0x06,
};

namespace NetworkInterfaceType {
enum FieldId
{
    kNameFieldId                            = 0,
    kFabricConnectedFieldId                 = 1,
    kOffPremiseServicesReachableIPv4FieldId = 2,
    kOffPremiseServicesReachableIPv6FieldId = 3,
    kHardwareAddressFieldId                 = 4,
    kTypeFieldId                            = 5,
};

struct Type
{
public:
    chip::ByteSpan name;
    bool fabricConnected;
    bool offPremiseServicesReachableIPv4;
    bool offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    InterfaceType type;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NetworkInterfaceType

} // namespace GeneralDiagnostics
namespace SoftwareDiagnostics {

namespace ThreadMetrics {
enum FieldId
{
    kIdFieldId               = 0,
    kNameFieldId             = 1,
    kStackFreeCurrentFieldId = 2,
    kStackFreeMinimumFieldId = 3,
    kStackSizeFieldId        = 4,
};

struct Type
{
public:
    uint64_t id;
    chip::ByteSpan name;
    uint32_t stackFreeCurrent;
    uint32_t stackFreeMinimum;
    uint32_t stackSize;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ThreadMetrics

namespace Commands {
namespace ResetWatermarks {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetWatermarks

} // namespace Commands
} // namespace SoftwareDiagnostics
namespace ThreadNetworkDiagnostics {
// Enum for NetworkFault
enum class NetworkFault : uint8_t
{
    NETWORK_FAULT_UNSPECIFIED      = 0x00,
    NETWORK_FAULT_LINK_DOWN        = 0x01,
    NETWORK_FAULT_HARDWARE_FAILURE = 0x02,
    NETWORK_FAULT_NETWORK_JAMMED   = 0x03,
};
// Enum for RoutingRole
enum class RoutingRole : uint8_t
{
    ROUTING_ROLE_UNSPECIFIED       = 0x00,
    ROUTING_ROLE_UNASSIGNED        = 0x01,
    ROUTING_ROLE_SLEEPY_END_DEVICE = 0x02,
    ROUTING_ROLE_END_DEVICE        = 0x03,
    ROUTING_ROLE_REED              = 0x04,
    ROUTING_ROLE_ROUTER            = 0x05,
    ROUTING_ROLE_LEADER            = 0x06,
};

namespace NeighborTable {
enum FieldId
{
    kExtAddressFieldId       = 0,
    kAgeFieldId              = 1,
    kRloc16FieldId           = 2,
    kLinkFrameCounterFieldId = 3,
    kMleFrameCounterFieldId  = 4,
    kLqiFieldId              = 5,
    kAverageRssiFieldId      = 6,
    kLastRssiFieldId         = 7,
    kFrameErrorRateFieldId   = 8,
    kMessageErrorRateFieldId = 9,
    kRxOnWhenIdleFieldId     = 10,
    kFullThreadDeviceFieldId = 11,
    kFullNetworkDataFieldId  = 12,
    kIsChildFieldId          = 13,
};

struct Type
{
public:
    uint64_t extAddress;
    uint32_t age;
    uint16_t rloc16;
    uint32_t linkFrameCounter;
    uint32_t mleFrameCounter;
    uint8_t lqi;
    int8_t averageRssi;
    int8_t lastRssi;
    uint8_t frameErrorRate;
    uint8_t messageErrorRate;
    bool rxOnWhenIdle;
    bool fullThreadDevice;
    bool fullNetworkData;
    bool isChild;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NeighborTable
namespace OperationalDatasetComponents {
enum FieldId
{
    kActiveTimestampPresentFieldId  = 0,
    kPendingTimestampPresentFieldId = 1,
    kMasterKeyPresentFieldId        = 2,
    kNetworkNamePresentFieldId      = 3,
    kExtendedPanIdPresentFieldId    = 4,
    kMeshLocalPrefixPresentFieldId  = 5,
    kDelayPresentFieldId            = 6,
    kPanIdPresentFieldId            = 7,
    kChannelPresentFieldId          = 8,
    kPskcPresentFieldId             = 9,
    kSecurityPolicyPresentFieldId   = 10,
    kChannelMaskPresentFieldId      = 11,
};

struct Type
{
public:
    bool activeTimestampPresent;
    bool pendingTimestampPresent;
    bool masterKeyPresent;
    bool networkNamePresent;
    bool extendedPanIdPresent;
    bool meshLocalPrefixPresent;
    bool delayPresent;
    bool panIdPresent;
    bool channelPresent;
    bool pskcPresent;
    bool securityPolicyPresent;
    bool channelMaskPresent;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace OperationalDatasetComponents
namespace RouteTable {
enum FieldId
{
    kExtAddressFieldId      = 0,
    kRloc16FieldId          = 1,
    kRouterIdFieldId        = 2,
    kNextHopFieldId         = 3,
    kPathCostFieldId        = 4,
    kLQIInFieldId           = 5,
    kLQIOutFieldId          = 6,
    kAgeFieldId             = 7,
    kAllocatedFieldId       = 8,
    kLinkEstablishedFieldId = 9,
};

struct Type
{
public:
    uint64_t extAddress;
    uint16_t rloc16;
    uint8_t routerId;
    uint8_t nextHop;
    uint8_t pathCost;
    uint8_t lQIIn;
    uint8_t lQIOut;
    uint8_t age;
    bool allocated;
    bool linkEstablished;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace RouteTable
namespace SecurityPolicy {
enum FieldId
{
    kRotationTimeFieldId = 0,
    kFlagsFieldId        = 1,
};

struct Type
{
public:
    uint16_t rotationTime;
    uint16_t flags;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SecurityPolicy

namespace Commands {
namespace ResetCounts {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetCounts

} // namespace Commands
} // namespace ThreadNetworkDiagnostics
namespace WiFiNetworkDiagnostics {
// Enum for SecurityType
enum class SecurityType : uint8_t
{
    SECURITY_TYPE_UNSPECIFIED = 0x00,
    SECURITY_TYPE_NONE        = 0x01,
    SECURITY_TYPE_WEP         = 0x02,
    SECURITY_TYPE_WPA         = 0x03,
    SECURITY_TYPE_WPA2        = 0x04,
    SECURITY_TYPE_WPA3        = 0x05,
};
// Enum for WiFiVersionType
enum class WiFiVersionType : uint8_t
{
    WI_FI_VERSION_TYPE_802__11A  = 0x00,
    WI_FI_VERSION_TYPE_802__11B  = 0x01,
    WI_FI_VERSION_TYPE_802__11G  = 0x02,
    WI_FI_VERSION_TYPE_802__11N  = 0x03,
    WI_FI_VERSION_TYPE_802__11AC = 0x04,
    WI_FI_VERSION_TYPE_802__11AX = 0x05,
};

namespace Commands {
namespace ResetCounts {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetCounts

} // namespace Commands
} // namespace WiFiNetworkDiagnostics
namespace EthernetNetworkDiagnostics {
// Enum for PHYRateType
enum class PHYRateType : uint8_t
{
    PHY_RATE_TYPE_10_M   = 0x00,
    PHY_RATE_TYPE_100_M  = 0x01,
    PHY_RATE_TYPE_1000_M = 0x02,
    PHY_RATE_TYPE_2__5_G = 0x03,
    PHY_RATE_TYPE_5_G    = 0x04,
    PHY_RATE_TYPE_10_G   = 0x05,
    PHY_RATE_TYPE_40_G   = 0x06,
    PHY_RATE_TYPE_100_G  = 0x07,
    PHY_RATE_TYPE_200_G  = 0x08,
    PHY_RATE_TYPE_400_G  = 0x09,
};

namespace Commands {
namespace ResetCounts {
struct Type
{
};

struct DecodableType
{
};
} // namespace ResetCounts

} // namespace Commands
} // namespace EthernetNetworkDiagnostics
namespace BridgedDeviceBasic {

namespace Commands {
namespace StartUp {
struct Type
{
};

struct DecodableType
{
};
} // namespace StartUp

namespace ShutDown {
struct Type
{
};

struct DecodableType
{
};
} // namespace ShutDown

namespace Leave {
struct Type
{
};

struct DecodableType
{
};
} // namespace Leave

namespace ReachableChanged {
struct Type
{
};

struct DecodableType
{
};
} // namespace ReachableChanged

} // namespace Commands
} // namespace BridgedDeviceBasic
namespace Switch {

} // namespace Switch
namespace AdministratorCommissioning {
// Enum for StatusCode
enum class StatusCode : uint8_t
{
    STATUS_CODE_SUCCESS       = 0x00,
    STATUS_CODE_BUSY          = 0x01,
    STATUS_CODE_GENERAL_ERROR = 0x02,
};

namespace Commands {
namespace OpenCommissioningWindow {
struct Type
{
};

struct DecodableType
{
};
} // namespace OpenCommissioningWindow

namespace OpenBasicCommissioningWindow {
struct Type
{
};

struct DecodableType
{
};
} // namespace OpenBasicCommissioningWindow

namespace RevokeCommissioning {
struct Type
{
};

struct DecodableType
{
};
} // namespace RevokeCommissioning

} // namespace Commands
} // namespace AdministratorCommissioning
namespace OperationalCredentials {
// Enum for NodeOperationalCertStatus
enum class NodeOperationalCertStatus : uint8_t
{
    NODE_OPERATIONAL_CERT_STATUS_SUCCESS                = 0x00,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_PUBLIC_KEY     = 0x01,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_NODE_OP_ID     = 0x02,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_NOC            = 0x03,
    NODE_OPERATIONAL_CERT_STATUS_MISSING_CSR            = 0x04,
    NODE_OPERATIONAL_CERT_STATUS_TABLE_FULL             = 0x05,
    NODE_OPERATIONAL_CERT_STATUS_INSUFFICIENT_PRIVILEGE = 0x08,
    NODE_OPERATIONAL_CERT_STATUS_FABRIC_CONFLICT        = 0x09,
    NODE_OPERATIONAL_CERT_STATUS_LABEL_CONFLICT         = 0x0A,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_FABRIC_INDEX   = 0x0B,
};

namespace FabricDescriptor {
enum FieldId
{
    kFabricIndexFieldId   = 0,
    kRootPublicKeyFieldId = 1,
    kVendorIdFieldId      = 2,
    kFabricIdFieldId      = 3,
    kNodeIdFieldId        = 4,
    kLabelFieldId         = 5,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan rootPublicKey;
    uint16_t vendorId;
    uint64_t fabricId;
    uint64_t nodeId;
    chip::ByteSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace FabricDescriptor
namespace NOCStruct {
enum FieldId
{
    kFabricIndexFieldId = 0,
    kNocFieldId         = 1,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan noc;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NOCStruct

namespace Commands {
namespace AttestationRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace AttestationRequest

namespace AttestationResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace AttestationResponse

namespace CertificateChainRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace CertificateChainRequest

namespace CertificateChainResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace CertificateChainResponse

namespace OpCSRRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace OpCSRRequest

namespace OpCSRResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace OpCSRResponse

namespace AddNOC {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddNOC

namespace UpdateNOC {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpdateNOC

namespace NOCResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace NOCResponse

namespace UpdateFabricLabel {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpdateFabricLabel

namespace RemoveFabric {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveFabric

namespace AddTrustedRootCertificate {
struct Type
{
};

struct DecodableType
{
};
} // namespace AddTrustedRootCertificate

namespace RemoveTrustedRootCertificate {
struct Type
{
};

struct DecodableType
{
};
} // namespace RemoveTrustedRootCertificate

} // namespace Commands
} // namespace OperationalCredentials
namespace FixedLabel {

namespace LabelStruct {
enum FieldId
{
    kLabelFieldId = 0,
    kValueFieldId = 1,
};

struct Type
{
public:
    chip::ByteSpan label;
    chip::ByteSpan value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace LabelStruct

} // namespace FixedLabel
namespace ShadeConfiguration {

} // namespace ShadeConfiguration
namespace DoorLock {
// Enum for DoorLockOperationEventCode
enum class DoorLockOperationEventCode : uint8_t
{
    DOOR_LOCK_OPERATION_EVENT_CODE_UNKNOWN_OR_MFG_SPECIFIC  = 0x00,
    DOOR_LOCK_OPERATION_EVENT_CODE_LOCK                     = 0x01,
    DOOR_LOCK_OPERATION_EVENT_CODE_UNLOCK                   = 0x02,
    DOOR_LOCK_OPERATION_EVENT_CODE_LOCK_INVALID_PIN_OR_ID   = 0x03,
    DOOR_LOCK_OPERATION_EVENT_CODE_LOCK_INVALID_SCHEDULE    = 0x04,
    DOOR_LOCK_OPERATION_EVENT_CODE_UNLOCK_INVALID_PIN_OR_ID = 0x05,
    DOOR_LOCK_OPERATION_EVENT_CODE_UNLOCK_INVALID_SCHEDULE  = 0x06,
    DOOR_LOCK_OPERATION_EVENT_CODE_ONE_TOUCH_LOCK           = 0x07,
    DOOR_LOCK_OPERATION_EVENT_CODE_KEY_LOCK                 = 0x08,
    DOOR_LOCK_OPERATION_EVENT_CODE_KEY_UNLOCK               = 0x09,
    DOOR_LOCK_OPERATION_EVENT_CODE_AUTO_LOCK                = 0x0A,
    DOOR_LOCK_OPERATION_EVENT_CODE_SCHEDULE_LOCK            = 0x0B,
    DOOR_LOCK_OPERATION_EVENT_CODE_SCHEDULE_UNLOCK          = 0x0C,
    DOOR_LOCK_OPERATION_EVENT_CODE_MANUAL_LOCK              = 0x0D,
    DOOR_LOCK_OPERATION_EVENT_CODE_MANUAL_UNLOCK            = 0x0E,
};
// Enum for DoorLockProgrammingEventCode
enum class DoorLockProgrammingEventCode : uint8_t
{
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_UNKNOWN_OR_MFG_SPECIFIC = 0x00,
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_MASTER_CODE_CHANGED     = 0x01,
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_PIN_ADDED               = 0x02,
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_PIN_DELETED             = 0x03,
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_PIN_CHANGED             = 0x04,
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_ID_ADDED                = 0x05,
    DOOR_LOCK_PROGRAMMING_EVENT_CODE_ID_DELETED              = 0x06,
};
// Enum for DoorLockSetPinOrIdStatus
enum class DoorLockSetPinOrIdStatus : uint8_t
{
    DOOR_LOCK_SET_PIN_OR_ID_STATUS_SUCCESS              = 0x00,
    DOOR_LOCK_SET_PIN_OR_ID_STATUS_GENERAL_FAILURE      = 0x01,
    DOOR_LOCK_SET_PIN_OR_ID_STATUS_MEMORY_FULL          = 0x02,
    DOOR_LOCK_SET_PIN_OR_ID_STATUS_DUPLICATE_CODE_ERROR = 0x03,
};
// Enum for DoorLockUserStatus
enum class DoorLockUserStatus : uint8_t
{
    DOOR_LOCK_USER_STATUS_AVAILABLE         = 0x00,
    DOOR_LOCK_USER_STATUS_OCCUPIED_ENABLED  = 0x01,
    DOOR_LOCK_USER_STATUS_OCCUPIED_DISABLED = 0x03,
    DOOR_LOCK_USER_STATUS_NOT_SUPPORTED     = 0xFF,
};
// Enum for DoorLockUserType
enum class DoorLockUserType : uint8_t
{
    DOOR_LOCK_USER_TYPE_UNRESTRICTED           = 0x00,
    DOOR_LOCK_USER_TYPE_YEAR_DAY_SCHEDULE_USER = 0x01,
    DOOR_LOCK_USER_TYPE_WEEK_DAY_SCHEDULE_USER = 0x02,
    DOOR_LOCK_USER_TYPE_MASTER_USER            = 0x03,
    DOOR_LOCK_USER_TYPE_NON_ACCESS_USER        = 0x04,
    DOOR_LOCK_USER_TYPE_NOT_SUPPORTED          = 0xFF,
};

namespace Commands {
namespace LockDoor {
struct Type
{
};

struct DecodableType
{
};
} // namespace LockDoor

namespace LockDoorResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace LockDoorResponse

namespace UnlockDoor {
struct Type
{
};

struct DecodableType
{
};
} // namespace UnlockDoor

namespace UnlockDoorResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace UnlockDoorResponse

namespace Toggle {
struct Type
{
};

struct DecodableType
{
};
} // namespace Toggle

namespace ToggleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ToggleResponse

namespace UnlockWithTimeout {
struct Type
{
};

struct DecodableType
{
};
} // namespace UnlockWithTimeout

namespace UnlockWithTimeoutResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace UnlockWithTimeoutResponse

namespace GetLogRecord {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetLogRecord

namespace GetLogRecordResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetLogRecordResponse

namespace SetPin {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetPin

namespace SetPinResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetPinResponse

namespace GetPin {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPin

namespace GetPinResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPinResponse

namespace ClearPin {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearPin

namespace ClearPinResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearPinResponse

namespace ClearAllPins {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearAllPins

namespace ClearAllPinsResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearAllPinsResponse

namespace SetUserStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetUserStatus

namespace SetUserStatusResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetUserStatusResponse

namespace GetUserStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetUserStatus

namespace GetUserStatusResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetUserStatusResponse

namespace SetWeekdaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetWeekdaySchedule

namespace SetWeekdayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetWeekdayScheduleResponse

namespace GetWeekdaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetWeekdaySchedule

namespace GetWeekdayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetWeekdayScheduleResponse

namespace ClearWeekdaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearWeekdaySchedule

namespace ClearWeekdayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearWeekdayScheduleResponse

namespace SetYeardaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetYeardaySchedule

namespace SetYeardayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetYeardayScheduleResponse

namespace GetYeardaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetYeardaySchedule

namespace GetYeardayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetYeardayScheduleResponse

namespace ClearYeardaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearYeardaySchedule

namespace ClearYeardayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearYeardayScheduleResponse

namespace SetHolidaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetHolidaySchedule

namespace SetHolidayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetHolidayScheduleResponse

namespace GetHolidaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetHolidaySchedule

namespace GetHolidayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetHolidayScheduleResponse

namespace ClearHolidaySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearHolidaySchedule

namespace ClearHolidayScheduleResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearHolidayScheduleResponse

namespace SetUserType {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetUserType

namespace SetUserTypeResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetUserTypeResponse

namespace GetUserType {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetUserType

namespace GetUserTypeResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetUserTypeResponse

namespace SetRfid {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetRfid

namespace SetRfidResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetRfidResponse

namespace GetRfid {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetRfid

namespace GetRfidResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetRfidResponse

namespace ClearRfid {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearRfid

namespace ClearRfidResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearRfidResponse

namespace ClearAllRfids {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearAllRfids

namespace ClearAllRfidsResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearAllRfidsResponse

namespace OperationEventNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace OperationEventNotification

namespace ProgrammingEventNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace ProgrammingEventNotification

} // namespace Commands
} // namespace DoorLock
namespace WindowCovering {
// Enum for WcEndProductType
enum class WcEndProductType : uint8_t
{
    WC_END_PRODUCT_TYPE_ROLLER_SHADE                 = 0x00,
    WC_END_PRODUCT_TYPE_ROMAN_SHADE                  = 0x01,
    WC_END_PRODUCT_TYPE_BALLOON_SHADE                = 0x02,
    WC_END_PRODUCT_TYPE_WOVEN_WOOD                   = 0x03,
    WC_END_PRODUCT_TYPE_PLEATED_SHADE                = 0x04,
    WC_END_PRODUCT_TYPE_CELLULAR_SHADE               = 0x05,
    WC_END_PRODUCT_TYPE_LAYERED_SHADE                = 0x06,
    WC_END_PRODUCT_TYPE_LAYERED_SHADE2_D             = 0x07,
    WC_END_PRODUCT_TYPE_SHEER_SHADE                  = 0x08,
    WC_END_PRODUCT_TYPE_TILT_ONLY_INTERIOR_BLIND     = 0x09,
    WC_END_PRODUCT_TYPE_INTERIOR_BLIND               = 0x0A,
    WC_END_PRODUCT_TYPE_VERTICAL_BLIND_STRIP_CURTAIN = 0x0B,
    WC_END_PRODUCT_TYPE_INTERIOR_VENETIAN_BLIND      = 0x0C,
    WC_END_PRODUCT_TYPE_EXTERIOR_VENETIAN_BLIND      = 0x0D,
    WC_END_PRODUCT_TYPE_LATERAL_LEFT_CURTAIN         = 0x0E,
    WC_END_PRODUCT_TYPE_LATERAL_RIGHT_CURTAIN        = 0x0F,
    WC_END_PRODUCT_TYPE_CENTRAL_CURTAIN              = 0x10,
    WC_END_PRODUCT_TYPE_ROLLER_SHUTTER               = 0x11,
    WC_END_PRODUCT_TYPE_EXTERIOR_VERTICAL_SCREEN     = 0x12,
    WC_END_PRODUCT_TYPE_AWNING_TERRACE_PATIO         = 0x13,
    WC_END_PRODUCT_TYPE_AWNING_VERTICAL_SCREEN       = 0x14,
    WC_END_PRODUCT_TYPE_TILT_ONLY_PERGOLA            = 0x15,
    WC_END_PRODUCT_TYPE_SWINGING_SHUTTER             = 0x16,
    WC_END_PRODUCT_TYPE_SLIDING_SHUTTER              = 0x17,
    WC_END_PRODUCT_TYPE_UNKNOWN                      = 0xFF,
};
// Enum for WcType
enum class WcType : uint8_t
{
    WC_TYPE_ROLLERSHADE                 = 0x00,
    WC_TYPE_ROLLERSHADE2_MOTOR          = 0x01,
    WC_TYPE_ROLLERSHADE_EXTERIOR        = 0x02,
    WC_TYPE_ROLLERSHADE_EXTERIOR2_MOTOR = 0x03,
    WC_TYPE_DRAPERY                     = 0x04,
    WC_TYPE_AWNING                      = 0x05,
    WC_TYPE_SHUTTER                     = 0x06,
    WC_TYPE_TILT_BLIND_TILT_ONLY        = 0x07,
    WC_TYPE_TILT_BLIND_LIFT_AND_TILT    = 0x08,
    WC_TYPE_PROJECTOR_SCREEN            = 0x09,
    WC_TYPE_UNKNOWN                     = 0xFF,
};

namespace Commands {
namespace UpOrOpen {
struct Type
{
};

struct DecodableType
{
};
} // namespace UpOrOpen

namespace DownOrClose {
struct Type
{
};

struct DecodableType
{
};
} // namespace DownOrClose

namespace StopMotion {
struct Type
{
};

struct DecodableType
{
};
} // namespace StopMotion

namespace GoToLiftValue {
struct Type
{
};

struct DecodableType
{
};
} // namespace GoToLiftValue

namespace GoToLiftPercentage {
struct Type
{
};

struct DecodableType
{
};
} // namespace GoToLiftPercentage

namespace GoToTiltValue {
struct Type
{
};

struct DecodableType
{
};
} // namespace GoToTiltValue

namespace GoToTiltPercentage {
struct Type
{
};

struct DecodableType
{
};
} // namespace GoToTiltPercentage

} // namespace Commands
} // namespace WindowCovering
namespace BarrierControl {

namespace Commands {
namespace BarrierControlGoToPercent {
struct Type
{
};

struct DecodableType
{
};
} // namespace BarrierControlGoToPercent

namespace BarrierControlStop {
struct Type
{
};

struct DecodableType
{
};
} // namespace BarrierControlStop

} // namespace Commands
} // namespace BarrierControl
namespace PumpConfigurationAndControl {
// Enum for PumpControlMode
enum class PumpControlMode : uint8_t
{
    PUMP_CONTROL_MODE_CONSTANT_SPEED        = 0x00,
    PUMP_CONTROL_MODE_CONSTANT_PRESSURE     = 0x01,
    PUMP_CONTROL_MODE_PROPORTIONAL_PRESSURE = 0x02,
    PUMP_CONTROL_MODE_CONSTANT_FLOW         = 0x03,
    PUMP_CONTROL_MODE_CONSTANT_TEMPERATURE  = 0x05,
    PUMP_CONTROL_MODE_AUTOMATIC             = 0x07,
};
// Enum for PumpOperationMode
enum class PumpOperationMode : uint8_t
{
    PUMP_OPERATION_MODE_NORMAL  = 0x00,
    PUMP_OPERATION_MODE_MINIMUM = 0x01,
    PUMP_OPERATION_MODE_MAXIMUM = 0x02,
    PUMP_OPERATION_MODE_LOCAL   = 0x03,
};

} // namespace PumpConfigurationAndControl
namespace Thermostat {
// Enum for SetpointAdjustMode
enum class SetpointAdjustMode : uint8_t
{
    SETPOINT_ADJUST_MODE_HEAT_SETPOINT           = 0x00,
    SETPOINT_ADJUST_MODE_COOL_SETPOINT           = 0x01,
    SETPOINT_ADJUST_MODE_HEAT_AND_COOL_SETPOINTS = 0x02,
};

namespace Commands {
namespace SetpointRaiseLower {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetpointRaiseLower

namespace CurrentWeeklySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace CurrentWeeklySchedule

namespace SetWeeklySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetWeeklySchedule

namespace RelayStatusLog {
struct Type
{
};

struct DecodableType
{
};
} // namespace RelayStatusLog

namespace GetWeeklySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetWeeklySchedule

namespace ClearWeeklySchedule {
struct Type
{
};

struct DecodableType
{
};
} // namespace ClearWeeklySchedule

namespace GetRelayStatusLog {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetRelayStatusLog

} // namespace Commands
} // namespace Thermostat
namespace FanControl {

} // namespace FanControl
namespace DehumidificationControl {

} // namespace DehumidificationControl
namespace ThermostatUserInterfaceConfiguration {

} // namespace ThermostatUserInterfaceConfiguration
namespace ColorControl {
// Enum for ColorLoopAction
enum class ColorLoopAction : uint8_t
{
    COLOR_LOOP_ACTION_DEACTIVATE                                  = 0x00,
    COLOR_LOOP_ACTION_ACTIVATE_FROM_COLOR_LOOP_START_ENHANCED_HUE = 0x01,
    COLOR_LOOP_ACTION_ACTIVATE_FROM_ENHANCED_CURRENT_HUE          = 0x02,
};
// Enum for ColorLoopDirection
enum class ColorLoopDirection : uint8_t
{
    COLOR_LOOP_DIRECTION_DECREMENT_HUE = 0x00,
    COLOR_LOOP_DIRECTION_INCREMENT_HUE = 0x01,
};
// Enum for ColorMode
enum class ColorMode : uint8_t
{
    COLOR_MODE_CURRENT_HUE_AND_CURRENT_SATURATION = 0x00,
    COLOR_MODE_CURRENT_X_AND_CURRENT_Y            = 0x01,
    COLOR_MODE_COLOR_TEMPERATURE                  = 0x02,
};
// Enum for HueDirection
enum class HueDirection : uint8_t
{
    HUE_DIRECTION_SHORTEST_DISTANCE = 0x00,
    HUE_DIRECTION_LONGEST_DISTANCE  = 0x01,
    HUE_DIRECTION_UP                = 0x02,
    HUE_DIRECTION_DOWN              = 0x03,
};
// Enum for HueMoveMode
enum class HueMoveMode : uint8_t
{
    HUE_MOVE_MODE_STOP = 0x00,
    HUE_MOVE_MODE_UP   = 0x01,
    HUE_MOVE_MODE_DOWN = 0x03,
};
// Enum for HueStepMode
enum class HueStepMode : uint8_t
{
    HUE_STEP_MODE_UP   = 0x01,
    HUE_STEP_MODE_DOWN = 0x03,
};
// Enum for SaturationMoveMode
enum class SaturationMoveMode : uint8_t
{
    SATURATION_MOVE_MODE_STOP = 0x00,
    SATURATION_MOVE_MODE_UP   = 0x01,
    SATURATION_MOVE_MODE_DOWN = 0x03,
};
// Enum for SaturationStepMode
enum class SaturationStepMode : uint8_t
{
    SATURATION_STEP_MODE_UP   = 0x01,
    SATURATION_STEP_MODE_DOWN = 0x03,
};

namespace Commands {
namespace MoveToHue {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToHue

namespace MoveHue {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveHue

namespace StepHue {
struct Type
{
};

struct DecodableType
{
};
} // namespace StepHue

namespace MoveToSaturation {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToSaturation

namespace MoveSaturation {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveSaturation

namespace StepSaturation {
struct Type
{
};

struct DecodableType
{
};
} // namespace StepSaturation

namespace MoveToHueAndSaturation {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToHueAndSaturation

namespace MoveToColor {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToColor

namespace MoveColor {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveColor

namespace StepColor {
struct Type
{
};

struct DecodableType
{
};
} // namespace StepColor

namespace MoveToColorTemperature {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveToColorTemperature

namespace EnhancedMoveToHue {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedMoveToHue

namespace EnhancedMoveHue {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedMoveHue

namespace EnhancedStepHue {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedStepHue

namespace EnhancedMoveToHueAndSaturation {
struct Type
{
};

struct DecodableType
{
};
} // namespace EnhancedMoveToHueAndSaturation

namespace ColorLoopSet {
struct Type
{
};

struct DecodableType
{
};
} // namespace ColorLoopSet

namespace StopMoveStep {
struct Type
{
};

struct DecodableType
{
};
} // namespace StopMoveStep

namespace MoveColorTemperature {
struct Type
{
};

struct DecodableType
{
};
} // namespace MoveColorTemperature

namespace StepColorTemperature {
struct Type
{
};

struct DecodableType
{
};
} // namespace StepColorTemperature

} // namespace Commands
} // namespace ColorControl
namespace BallastConfiguration {

} // namespace BallastConfiguration
namespace IlluminanceMeasurement {

} // namespace IlluminanceMeasurement
namespace IlluminanceLevelSensing {

} // namespace IlluminanceLevelSensing
namespace TemperatureMeasurement {

} // namespace TemperatureMeasurement
namespace PressureMeasurement {

} // namespace PressureMeasurement
namespace FlowMeasurement {

} // namespace FlowMeasurement
namespace RelativeHumidityMeasurement {

} // namespace RelativeHumidityMeasurement
namespace OccupancySensing {

} // namespace OccupancySensing
namespace CarbonMonoxideConcentrationMeasurement {

} // namespace CarbonMonoxideConcentrationMeasurement
namespace CarbonDioxideConcentrationMeasurement {

} // namespace CarbonDioxideConcentrationMeasurement
namespace EthyleneConcentrationMeasurement {

} // namespace EthyleneConcentrationMeasurement
namespace EthyleneOxideConcentrationMeasurement {

} // namespace EthyleneOxideConcentrationMeasurement
namespace HydrogenConcentrationMeasurement {

} // namespace HydrogenConcentrationMeasurement
namespace HydrogenSulphideConcentrationMeasurement {

} // namespace HydrogenSulphideConcentrationMeasurement
namespace NitricOxideConcentrationMeasurement {

} // namespace NitricOxideConcentrationMeasurement
namespace NitrogenDioxideConcentrationMeasurement {

} // namespace NitrogenDioxideConcentrationMeasurement
namespace OxygenConcentrationMeasurement {

} // namespace OxygenConcentrationMeasurement
namespace OzoneConcentrationMeasurement {

} // namespace OzoneConcentrationMeasurement
namespace SulfurDioxideConcentrationMeasurement {

} // namespace SulfurDioxideConcentrationMeasurement
namespace DissolvedOxygenConcentrationMeasurement {

} // namespace DissolvedOxygenConcentrationMeasurement
namespace BromateConcentrationMeasurement {

} // namespace BromateConcentrationMeasurement
namespace ChloraminesConcentrationMeasurement {

} // namespace ChloraminesConcentrationMeasurement
namespace ChlorineConcentrationMeasurement {

} // namespace ChlorineConcentrationMeasurement
namespace FecalColiformAndEColiConcentrationMeasurement {

} // namespace FecalColiformAndEColiConcentrationMeasurement
namespace FluorideConcentrationMeasurement {

} // namespace FluorideConcentrationMeasurement
namespace HaloaceticAcidsConcentrationMeasurement {

} // namespace HaloaceticAcidsConcentrationMeasurement
namespace TotalTrihalomethanesConcentrationMeasurement {

} // namespace TotalTrihalomethanesConcentrationMeasurement
namespace TotalColiformBacteriaConcentrationMeasurement {

} // namespace TotalColiformBacteriaConcentrationMeasurement
namespace TurbidityConcentrationMeasurement {

} // namespace TurbidityConcentrationMeasurement
namespace CopperConcentrationMeasurement {

} // namespace CopperConcentrationMeasurement
namespace LeadConcentrationMeasurement {

} // namespace LeadConcentrationMeasurement
namespace ManganeseConcentrationMeasurement {

} // namespace ManganeseConcentrationMeasurement
namespace SulfateConcentrationMeasurement {

} // namespace SulfateConcentrationMeasurement
namespace BromodichloromethaneConcentrationMeasurement {

} // namespace BromodichloromethaneConcentrationMeasurement
namespace BromoformConcentrationMeasurement {

} // namespace BromoformConcentrationMeasurement
namespace ChlorodibromomethaneConcentrationMeasurement {

} // namespace ChlorodibromomethaneConcentrationMeasurement
namespace ChloroformConcentrationMeasurement {

} // namespace ChloroformConcentrationMeasurement
namespace SodiumConcentrationMeasurement {

} // namespace SodiumConcentrationMeasurement
namespace IasZone {
// Enum for IasEnrollResponseCode
enum class IasEnrollResponseCode : uint8_t
{
    IAS_ENROLL_RESPONSE_CODE_SUCCESS          = 0x00,
    IAS_ENROLL_RESPONSE_CODE_NOT_SUPPORTED    = 0x01,
    IAS_ENROLL_RESPONSE_CODE_NO_ENROLL_PERMIT = 0x02,
    IAS_ENROLL_RESPONSE_CODE_TOO_MANY_ZONES   = 0x03,
};
// Enum for IasZoneType
enum class IasZoneType : uint16_t
{
    IAS_ZONE_TYPE_STANDARD_CIE              = 0x00,
    IAS_ZONE_TYPE_MOTION_SENSOR             = 0x0D,
    IAS_ZONE_TYPE_CONTACT_SWITCH            = 0x15,
    IAS_ZONE_TYPE_FIRE_SENSOR               = 0x28,
    IAS_ZONE_TYPE_WATER_SENSOR              = 0x2A,
    IAS_ZONE_TYPE_GAS_SENSOR                = 0x2B,
    IAS_ZONE_TYPE_PERSONAL_EMERGENCY_DEVICE = 0x2C,
    IAS_ZONE_TYPE_VIBRATION_MOVEMENT_SENSOR = 0x2D,
    IAS_ZONE_TYPE_REMOTE_CONTROL            = 0x10F,
    IAS_ZONE_TYPE_KEY_FOB                   = 0x115,
    IAS_ZONE_TYPE_KEYPAD                    = 0x21D,
    IAS_ZONE_TYPE_STANDARD_WARNING_DEVICE   = 0x225,
    IAS_ZONE_TYPE_GLASS_BREAK_SENSOR        = 0x226,
    IAS_ZONE_TYPE_CARBON_MONOXIDE_SENSOR    = 0x227,
    IAS_ZONE_TYPE_SECURITY_REPEATER         = 0x229,
    IAS_ZONE_TYPE_INVALID_ZONE_TYPE         = 0xFFFF,
};

namespace Commands {
namespace ZoneEnrollResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ZoneEnrollResponse

namespace ZoneStatusChangeNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace ZoneStatusChangeNotification

namespace InitiateNormalOperationMode {
struct Type
{
};

struct DecodableType
{
};
} // namespace InitiateNormalOperationMode

namespace ZoneEnrollRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace ZoneEnrollRequest

namespace InitiateTestMode {
struct Type
{
};

struct DecodableType
{
};
} // namespace InitiateTestMode

namespace InitiateNormalOperationModeResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace InitiateNormalOperationModeResponse

namespace InitiateTestModeResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace InitiateTestModeResponse

} // namespace Commands
} // namespace IasZone
namespace IasAce {
// Enum for IasAceAlarmStatus
enum class IasAceAlarmStatus : uint8_t
{
    IAS_ACE_ALARM_STATUS_NO_ALARM        = 0x00,
    IAS_ACE_ALARM_STATUS_BURGLAR         = 0x01,
    IAS_ACE_ALARM_STATUS_FIRE            = 0x02,
    IAS_ACE_ALARM_STATUS_EMERGENCY       = 0x03,
    IAS_ACE_ALARM_STATUS_POLICE_PANIC    = 0x04,
    IAS_ACE_ALARM_STATUS_FIRE_PANIC      = 0x05,
    IAS_ACE_ALARM_STATUS_EMERGENCY_PANIC = 0x06,
};
// Enum for IasAceArmMode
enum class IasAceArmMode : uint8_t
{
    IAS_ACE_ARM_MODE_DISARM                     = 0x00,
    IAS_ACE_ARM_MODE_ARM_DAY_HOME_ZONES_ONLY    = 0x01,
    IAS_ACE_ARM_MODE_ARM_NIGHT_SLEEP_ZONES_ONLY = 0x02,
    IAS_ACE_ARM_MODE_ARM_ALL_ZONES              = 0x03,
};
// Enum for IasAceArmNotification
enum class IasAceArmNotification : uint8_t
{
    IAS_ACE_ARM_NOTIFICATION_ALL_ZONES_DISARMED           = 0x00,
    IAS_ACE_ARM_NOTIFICATION_ONLY_DAY_HOME_ZONES_ARMED    = 0x01,
    IAS_ACE_ARM_NOTIFICATION_ONLY_NIGHT_SLEEP_ZONES_ARMED = 0x02,
    IAS_ACE_ARM_NOTIFICATION_ALL_ZONES_ARMED              = 0x03,
    IAS_ACE_ARM_NOTIFICATION_INVALID_ARM_DISARM_CODE      = 0x04,
    IAS_ACE_ARM_NOTIFICATION_NOT_READY_TO_ARM             = 0x05,
    IAS_ACE_ARM_NOTIFICATION_ALREADY_DISARMED             = 0x06,
};
// Enum for IasAceAudibleNotification
enum class IasAceAudibleNotification : uint8_t
{
    IAS_ACE_AUDIBLE_NOTIFICATION_MUTE          = 0x00,
    IAS_ACE_AUDIBLE_NOTIFICATION_DEFAULT_SOUND = 0x01,
};
// Enum for IasAceBypassResult
enum class IasAceBypassResult : uint8_t
{
    IAS_ACE_BYPASS_RESULT_ZONE_BYPASSED           = 0x00,
    IAS_ACE_BYPASS_RESULT_ZONE_NOT_BYPASSED       = 0x01,
    IAS_ACE_BYPASS_RESULT_NOT_ALLOWED             = 0x02,
    IAS_ACE_BYPASS_RESULT_INVALID_ZONE_ID         = 0x03,
    IAS_ACE_BYPASS_RESULT_UNKNOWN_ZONE_ID         = 0x04,
    IAS_ACE_BYPASS_RESULT_INVALID_ARM_DISARM_CODE = 0x05,
};
// Enum for IasAcePanelStatus
enum class IasAcePanelStatus : uint8_t
{
    IAS_ACE_PANEL_STATUS_PANEL_DISARMED   = 0x00,
    IAS_ACE_PANEL_STATUS_ARMED_STAY       = 0x01,
    IAS_ACE_PANEL_STATUS_ARMED_NIGHT      = 0x02,
    IAS_ACE_PANEL_STATUS_ARMED_AWAY       = 0x03,
    IAS_ACE_PANEL_STATUS_EXIT_DELAY       = 0x04,
    IAS_ACE_PANEL_STATUS_ENTRY_DELAY      = 0x05,
    IAS_ACE_PANEL_STATUS_NOT_READY_TO_ARM = 0x06,
    IAS_ACE_PANEL_STATUS_IN_ALARM         = 0x07,
    IAS_ACE_PANEL_STATUS_ARMING_STAY      = 0x08,
    IAS_ACE_PANEL_STATUS_ARMING_NIGHT     = 0x09,
    IAS_ACE_PANEL_STATUS_ARMING_AWAY      = 0x0A,
};
// Enum for IasZoneType
enum class IasZoneType : uint16_t
{
    IAS_ZONE_TYPE_STANDARD_CIE              = 0x00,
    IAS_ZONE_TYPE_MOTION_SENSOR             = 0x0D,
    IAS_ZONE_TYPE_CONTACT_SWITCH            = 0x15,
    IAS_ZONE_TYPE_FIRE_SENSOR               = 0x28,
    IAS_ZONE_TYPE_WATER_SENSOR              = 0x2A,
    IAS_ZONE_TYPE_GAS_SENSOR                = 0x2B,
    IAS_ZONE_TYPE_PERSONAL_EMERGENCY_DEVICE = 0x2C,
    IAS_ZONE_TYPE_VIBRATION_MOVEMENT_SENSOR = 0x2D,
    IAS_ZONE_TYPE_REMOTE_CONTROL            = 0x10F,
    IAS_ZONE_TYPE_KEY_FOB                   = 0x115,
    IAS_ZONE_TYPE_KEYPAD                    = 0x21D,
    IAS_ZONE_TYPE_STANDARD_WARNING_DEVICE   = 0x225,
    IAS_ZONE_TYPE_GLASS_BREAK_SENSOR        = 0x226,
    IAS_ZONE_TYPE_CARBON_MONOXIDE_SENSOR    = 0x227,
    IAS_ZONE_TYPE_SECURITY_REPEATER         = 0x229,
    IAS_ZONE_TYPE_INVALID_ZONE_TYPE         = 0xFFFF,
};

namespace IasAceZoneStatusResult {
enum FieldId
{
    kZoneIdFieldId     = 0,
    kZoneStatusFieldId = 1,
};

struct Type
{
public:
    uint8_t zoneId;
    uint16_t zoneStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace IasAceZoneStatusResult

namespace Commands {
namespace Arm {
struct Type
{
};

struct DecodableType
{
};
} // namespace Arm

namespace ArmResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ArmResponse

namespace Bypass {
struct Type
{
};

struct DecodableType
{
};
} // namespace Bypass

namespace GetZoneIdMapResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetZoneIdMapResponse

namespace Emergency {
struct Type
{
};

struct DecodableType
{
};
} // namespace Emergency

namespace GetZoneInformationResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetZoneInformationResponse

namespace Fire {
struct Type
{
};

struct DecodableType
{
};
} // namespace Fire

namespace ZoneStatusChanged {
struct Type
{
};

struct DecodableType
{
};
} // namespace ZoneStatusChanged

namespace Panic {
struct Type
{
};

struct DecodableType
{
};
} // namespace Panic

namespace PanelStatusChanged {
struct Type
{
};

struct DecodableType
{
};
} // namespace PanelStatusChanged

namespace GetZoneIdMap {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetZoneIdMap

namespace GetPanelStatusResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPanelStatusResponse

namespace GetZoneInformation {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetZoneInformation

namespace SetBypassedZoneList {
struct Type
{
};

struct DecodableType
{
};
} // namespace SetBypassedZoneList

namespace GetPanelStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetPanelStatus

namespace BypassResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace BypassResponse

namespace GetBypassedZoneList {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetBypassedZoneList

namespace GetZoneStatusResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetZoneStatusResponse

namespace GetZoneStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetZoneStatus

} // namespace Commands
} // namespace IasAce
namespace IasWd {

namespace Commands {
namespace StartWarning {
struct Type
{
};

struct DecodableType
{
};
} // namespace StartWarning

namespace Squawk {
struct Type
{
};

struct DecodableType
{
};
} // namespace Squawk

} // namespace Commands
} // namespace IasWd
namespace WakeOnLan {

} // namespace WakeOnLan
namespace TvChannel {
// Enum for TvChannelErrorType
enum class TvChannelErrorType : uint8_t
{
    TV_CHANNEL_ERROR_TYPE_MULTIPLE_MATCHES = 0x00,
    TV_CHANNEL_ERROR_TYPE_NO_MATCHES       = 0x01,
};
// Enum for TvChannelLineupInfoType
enum class TvChannelLineupInfoType : uint8_t
{
    TV_CHANNEL_LINEUP_INFO_TYPE_MSO = 0x00,
};

namespace TvChannelInfo {
enum FieldId
{
    kMajorNumberFieldId       = 0,
    kMinorNumberFieldId       = 1,
    kNameFieldId              = 2,
    kCallSignFieldId          = 3,
    kAffiliateCallSignFieldId = 4,
};

struct Type
{
public:
    uint16_t majorNumber;
    uint16_t minorNumber;
    chip::ByteSpan name;
    chip::ByteSpan callSign;
    chip::ByteSpan affiliateCallSign;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TvChannelInfo
namespace TvChannelLineupInfo {
enum FieldId
{
    kOperatorNameFieldId   = 0,
    kLineupNameFieldId     = 1,
    kPostalCodeFieldId     = 2,
    kLineupInfoTypeFieldId = 3,
};

struct Type
{
public:
    Span<const char> operatorName;
    Span<const char> lineupName;
    Span<const char> postalCode;
    TvChannelLineupInfoType lineupInfoType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TvChannelLineupInfo

namespace Commands {
namespace ChangeChannel {
struct Type
{
};

struct DecodableType
{
};
} // namespace ChangeChannel

namespace ChangeChannelResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace ChangeChannelResponse

namespace ChangeChannelByNumber {
struct Type
{
};

struct DecodableType
{
};
} // namespace ChangeChannelByNumber

namespace SkipChannel {
struct Type
{
};

struct DecodableType
{
};
} // namespace SkipChannel

} // namespace Commands
} // namespace TvChannel
namespace TargetNavigator {
// Enum for NavigateTargetStatus
enum class NavigateTargetStatus : uint8_t
{
    NAVIGATE_TARGET_STATUS_SUCCESS           = 0x00,
    NAVIGATE_TARGET_STATUS_APP_NOT_AVAILABLE = 0x01,
    NAVIGATE_TARGET_STATUS_SYSTEM_BUSY       = 0x02,
};

namespace NavigateTargetTargetInfo {
enum FieldId
{
    kIdentifierFieldId = 0,
    kNameFieldId       = 1,
};

struct Type
{
public:
    uint8_t identifier;
    chip::ByteSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NavigateTargetTargetInfo

namespace Commands {
namespace NavigateTarget {
struct Type
{
};

struct DecodableType
{
};
} // namespace NavigateTarget

namespace NavigateTargetResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace NavigateTargetResponse

} // namespace Commands
} // namespace TargetNavigator
namespace MediaPlayback {
// Enum for MediaPlaybackState
enum class MediaPlaybackState : uint8_t
{
    MEDIA_PLAYBACK_STATE_PLAYING     = 0x00,
    MEDIA_PLAYBACK_STATE_PAUSED      = 0x01,
    MEDIA_PLAYBACK_STATE_NOT_PLAYING = 0x02,
    MEDIA_PLAYBACK_STATE_BUFFERING   = 0x03,
};
// Enum for MediaPlaybackStatus
enum class MediaPlaybackStatus : uint8_t
{
    MEDIA_PLAYBACK_STATUS_SUCCESS                   = 0x00,
    MEDIA_PLAYBACK_STATUS_INVALID_STATE_FOR_COMMAND = 0x01,
    MEDIA_PLAYBACK_STATUS_NOT_ALLOWED               = 0x02,
    MEDIA_PLAYBACK_STATUS_NOT_ACTIVE                = 0x03,
    MEDIA_PLAYBACK_STATUS_SPEED_OUT_OF_RANGE        = 0x04,
    MEDIA_PLAYBACK_STATUS_SEEK_OUT_OF_RANGE         = 0x05,
};

namespace MediaPlaybackPosition {
enum FieldId
{
    kUpdatedAtFieldId = 0,
    kPositionFieldId  = 1,
};

struct Type
{
public:
    uint64_t updatedAt;
    uint64_t position;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace MediaPlaybackPosition

namespace Commands {
namespace MediaPlay {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaPlay

namespace MediaPlayResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaPlayResponse

namespace MediaPause {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaPause

namespace MediaPauseResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaPauseResponse

namespace MediaStop {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaStop

namespace MediaStopResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaStopResponse

namespace MediaStartOver {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaStartOver

namespace MediaStartOverResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaStartOverResponse

namespace MediaPrevious {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaPrevious

namespace MediaPreviousResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaPreviousResponse

namespace MediaNext {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaNext

namespace MediaNextResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaNextResponse

namespace MediaRewind {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaRewind

namespace MediaRewindResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaRewindResponse

namespace MediaFastForward {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaFastForward

namespace MediaFastForwardResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaFastForwardResponse

namespace MediaSkipForward {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaSkipForward

namespace MediaSkipForwardResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaSkipForwardResponse

namespace MediaSkipBackward {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaSkipBackward

namespace MediaSkipBackwardResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaSkipBackwardResponse

namespace MediaSeek {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaSeek

namespace MediaSeekResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace MediaSeekResponse

} // namespace Commands
} // namespace MediaPlayback
namespace MediaInput {
// Enum for MediaInputType
enum class MediaInputType : uint8_t
{
    MEDIA_INPUT_TYPE_INTERNAL  = 0x00,
    MEDIA_INPUT_TYPE_AUX       = 0x01,
    MEDIA_INPUT_TYPE_COAX      = 0x02,
    MEDIA_INPUT_TYPE_COMPOSITE = 0x03,
    MEDIA_INPUT_TYPE_HDMI      = 0x04,
    MEDIA_INPUT_TYPE_INPUT     = 0x05,
    MEDIA_INPUT_TYPE_LINE      = 0x06,
    MEDIA_INPUT_TYPE_OPTICAL   = 0x07,
    MEDIA_INPUT_TYPE_VIDEO     = 0x08,
    MEDIA_INPUT_TYPE_SCART     = 0x09,
    MEDIA_INPUT_TYPE_USB       = 0x0A,
    MEDIA_INPUT_TYPE_OTHER     = 0x0B,
};

namespace MediaInputInfo {
enum FieldId
{
    kIndexFieldId       = 0,
    kInputTypeFieldId   = 1,
    kNameFieldId        = 2,
    kDescriptionFieldId = 3,
};

struct Type
{
public:
    uint8_t index;
    MediaInputType inputType;
    chip::ByteSpan name;
    chip::ByteSpan description;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace MediaInputInfo

namespace Commands {
namespace SelectInput {
struct Type
{
};

struct DecodableType
{
};
} // namespace SelectInput

namespace ShowInputStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace ShowInputStatus

namespace HideInputStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace HideInputStatus

namespace RenameInput {
struct Type
{
};

struct DecodableType
{
};
} // namespace RenameInput

} // namespace Commands
} // namespace MediaInput
namespace LowPower {

namespace Commands {
namespace Sleep {
struct Type
{
};

struct DecodableType
{
};
} // namespace Sleep

} // namespace Commands
} // namespace LowPower
namespace KeypadInput {
// Enum for KeypadInputCecKeyCode
enum class KeypadInputCecKeyCode : uint8_t
{
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT                       = 0x00,
    KEYPAD_INPUT_CEC_KEY_CODE_UP                           = 0x01,
    KEYPAD_INPUT_CEC_KEY_CODE_DOWN                         = 0x02,
    KEYPAD_INPUT_CEC_KEY_CODE_LEFT                         = 0x03,
    KEYPAD_INPUT_CEC_KEY_CODE_RIGHT                        = 0x04,
    KEYPAD_INPUT_CEC_KEY_CODE_RIGHT_UP                     = 0x05,
    KEYPAD_INPUT_CEC_KEY_CODE_RIGHT_DOWN                   = 0x06,
    KEYPAD_INPUT_CEC_KEY_CODE_LEFT_UP                      = 0x07,
    KEYPAD_INPUT_CEC_KEY_CODE_LEFT_DOWN                    = 0x08,
    KEYPAD_INPUT_CEC_KEY_CODE_ROOT_MENU                    = 0x09,
    KEYPAD_INPUT_CEC_KEY_CODE_SETUP_MENU                   = 0x0A,
    KEYPAD_INPUT_CEC_KEY_CODE_CONTENTS_MENU                = 0x0B,
    KEYPAD_INPUT_CEC_KEY_CODE_FAVORITE_MENU                = 0x0C,
    KEYPAD_INPUT_CEC_KEY_CODE_EXIT                         = 0x0D,
    KEYPAD_INPUT_CEC_KEY_CODE_MEDIA_TOP_MENU               = 0x10,
    KEYPAD_INPUT_CEC_KEY_CODE_MEDIA_CONTEXT_SENSITIVE_MENU = 0x11,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER_ENTRY_MODE            = 0x1D,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER11                     = 0x1E,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER12                     = 0x1F,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER0_OR_NUMBER10          = 0x20,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS1                     = 0x21,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS2                     = 0x22,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS3                     = 0x23,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS4                     = 0x24,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS5                     = 0x25,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS6                     = 0x26,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS7                     = 0x27,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS8                     = 0x28,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS9                     = 0x29,
    KEYPAD_INPUT_CEC_KEY_CODE_DOT                          = 0x2A,
    KEYPAD_INPUT_CEC_KEY_CODE_ENTER                        = 0x2B,
    KEYPAD_INPUT_CEC_KEY_CODE_CLEAR                        = 0x2C,
    KEYPAD_INPUT_CEC_KEY_CODE_NEXT_FAVORITE                = 0x2F,
    KEYPAD_INPUT_CEC_KEY_CODE_CHANNEL_UP                   = 0x30,
    KEYPAD_INPUT_CEC_KEY_CODE_CHANNEL_DOWN                 = 0x31,
    KEYPAD_INPUT_CEC_KEY_CODE_PREVIOUS_CHANNEL             = 0x32,
    KEYPAD_INPUT_CEC_KEY_CODE_SOUND_SELECT                 = 0x33,
    KEYPAD_INPUT_CEC_KEY_CODE_INPUT_SELECT                 = 0x34,
    KEYPAD_INPUT_CEC_KEY_CODE_DISPLAY_INFORMATION          = 0x35,
    KEYPAD_INPUT_CEC_KEY_CODE_HELP                         = 0x36,
    KEYPAD_INPUT_CEC_KEY_CODE_PAGE_UP                      = 0x37,
    KEYPAD_INPUT_CEC_KEY_CODE_PAGE_DOWN                    = 0x38,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER                        = 0x40,
    KEYPAD_INPUT_CEC_KEY_CODE_VOLUME_UP                    = 0x41,
    KEYPAD_INPUT_CEC_KEY_CODE_VOLUME_DOWN                  = 0x42,
    KEYPAD_INPUT_CEC_KEY_CODE_MUTE                         = 0x43,
    KEYPAD_INPUT_CEC_KEY_CODE_PLAY                         = 0x44,
    KEYPAD_INPUT_CEC_KEY_CODE_STOP                         = 0x45,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE                        = 0x46,
    KEYPAD_INPUT_CEC_KEY_CODE_RECORD                       = 0x47,
    KEYPAD_INPUT_CEC_KEY_CODE_REWIND                       = 0x48,
    KEYPAD_INPUT_CEC_KEY_CODE_FAST_FORWARD                 = 0x49,
    KEYPAD_INPUT_CEC_KEY_CODE_EJECT                        = 0x4A,
    KEYPAD_INPUT_CEC_KEY_CODE_FORWARD                      = 0x4B,
    KEYPAD_INPUT_CEC_KEY_CODE_BACKWARD                     = 0x4C,
    KEYPAD_INPUT_CEC_KEY_CODE_STOP_RECORD                  = 0x4D,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE_RECORD                 = 0x4E,
    KEYPAD_INPUT_CEC_KEY_CODE_RESERVED                     = 0x4F,
    KEYPAD_INPUT_CEC_KEY_CODE_ANGLE                        = 0x50,
    KEYPAD_INPUT_CEC_KEY_CODE_SUB_PICTURE                  = 0x51,
    KEYPAD_INPUT_CEC_KEY_CODE_VIDEO_ON_DEMAND              = 0x52,
    KEYPAD_INPUT_CEC_KEY_CODE_ELECTRONIC_PROGRAM_GUIDE     = 0x53,
    KEYPAD_INPUT_CEC_KEY_CODE_TIMER_PROGRAMMING            = 0x54,
    KEYPAD_INPUT_CEC_KEY_CODE_INITIAL_CONFIGURATION        = 0x55,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_BROADCAST_TYPE        = 0x56,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_SOUND_PRESENTATION    = 0x57,
    KEYPAD_INPUT_CEC_KEY_CODE_PLAY_FUNCTION                = 0x60,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE_PLAY_FUNCTION          = 0x61,
    KEYPAD_INPUT_CEC_KEY_CODE_RECORD_FUNCTION              = 0x62,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE_RECORD_FUNCTION        = 0x63,
    KEYPAD_INPUT_CEC_KEY_CODE_STOP_FUNCTION                = 0x64,
    KEYPAD_INPUT_CEC_KEY_CODE_MUTE_FUNCTION                = 0x65,
    KEYPAD_INPUT_CEC_KEY_CODE_RESTORE_VOLUME_FUNCTION      = 0x66,
    KEYPAD_INPUT_CEC_KEY_CODE_TUNE_FUNCTION                = 0x67,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_MEDIA_FUNCTION        = 0x68,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_AV_INPUT_FUNCTION     = 0x69,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_AUDIO_INPUT_FUNCTION  = 0x6A,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER_TOGGLE_FUNCTION        = 0x6B,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER_OFF_FUNCTION           = 0x6C,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER_ON_FUNCTION            = 0x6D,
    KEYPAD_INPUT_CEC_KEY_CODE_F1_BLUE                      = 0x71,
    KEYPAD_INPUT_CEC_KEY_CODE_F2_RED                       = 0x72,
    KEYPAD_INPUT_CEC_KEY_CODE_F3_GREEN                     = 0x73,
    KEYPAD_INPUT_CEC_KEY_CODE_F4_YELLOW                    = 0x74,
    KEYPAD_INPUT_CEC_KEY_CODE_F5                           = 0x75,
    KEYPAD_INPUT_CEC_KEY_CODE_DATA                         = 0x76,
};
// Enum for KeypadInputStatus
enum class KeypadInputStatus : uint8_t
{
    KEYPAD_INPUT_STATUS_SUCCESS                      = 0x00,
    KEYPAD_INPUT_STATUS_UNSUPPORTED_KEY              = 0x01,
    KEYPAD_INPUT_STATUS_INVALID_KEY_IN_CURRENT_STATE = 0x02,
};

namespace Commands {
namespace SendKey {
struct Type
{
};

struct DecodableType
{
};
} // namespace SendKey

namespace SendKeyResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace SendKeyResponse

} // namespace Commands
} // namespace KeypadInput
namespace ContentLauncher {
// Enum for ContentLaunchMetricType
enum class ContentLaunchMetricType : uint8_t
{
    CONTENT_LAUNCH_METRIC_TYPE_PIXELS     = 0x00,
    CONTENT_LAUNCH_METRIC_TYPE_PERCENTAGE = 0x01,
};
// Enum for ContentLaunchParameterEnum
enum class ContentLaunchParameterEnum : uint8_t
{
    CONTENT_LAUNCH_PARAMETER_ENUM_ACTOR       = 0x00,
    CONTENT_LAUNCH_PARAMETER_ENUM_CHANNEL     = 0x01,
    CONTENT_LAUNCH_PARAMETER_ENUM_CHARACTER   = 0x02,
    CONTENT_LAUNCH_PARAMETER_ENUM_EVENT       = 0x03,
    CONTENT_LAUNCH_PARAMETER_ENUM_FRANCHISE   = 0x04,
    CONTENT_LAUNCH_PARAMETER_ENUM_GENRE       = 0x05,
    CONTENT_LAUNCH_PARAMETER_ENUM_LEAGUE      = 0x06,
    CONTENT_LAUNCH_PARAMETER_ENUM_POPULARITY  = 0x07,
    CONTENT_LAUNCH_PARAMETER_ENUM_SPORT       = 0x08,
    CONTENT_LAUNCH_PARAMETER_ENUM_SPORTS_TEAM = 0x09,
    CONTENT_LAUNCH_PARAMETER_ENUM_VIDEO       = 0x0A,
};
// Enum for ContentLaunchStatus
enum class ContentLaunchStatus : uint8_t
{
    CONTENT_LAUNCH_STATUS_SUCCESS           = 0x00,
    CONTENT_LAUNCH_STATUS_URL_NOT_AVAILABLE = 0x01,
    CONTENT_LAUNCH_STATUS_AUTH_FAILED       = 0x02,
};
// Enum for ContentLaunchStreamingType
enum class ContentLaunchStreamingType : uint8_t
{
    CONTENT_LAUNCH_STREAMING_TYPE_DASH = 0x00,
    CONTENT_LAUNCH_STREAMING_TYPE_HLS  = 0x01,
};

namespace ContentLaunchAdditionalInfo {
enum FieldId
{
    kNameFieldId  = 0,
    kValueFieldId = 1,
};

struct Type
{
public:
    Span<const char> name;
    Span<const char> value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchAdditionalInfo
namespace ContentLaunchParamater {
enum FieldId
{
    kTypeFieldId           = 0,
    kValueFieldId          = 1,
    kExternalIDListFieldId = 2,
};

struct Type
{
public:
    ContentLaunchParameterEnum type;
    Span<const char> value;
    DataModel::List<ContentLaunchAdditionalInfo::Type> externalIDList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
};

struct DecodableType
{
public:
    ContentLaunchParameterEnum type;
    Span<const char> value;
    DataModel::DecodableList<ContentLaunchAdditionalInfo::DecodableType> externalIDList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchParamater
namespace ContentLaunchBrandingInformation {
enum FieldId
{
    kProviderNameFieldId = 0,
    kBackgroundFieldId   = 1,
    kLogoFieldId         = 2,
    kProgressBarFieldId  = 3,
    kSplashFieldId       = 4,
    kWaterMarkFieldId    = 5,
};

struct Type
{
public:
    Span<const char> providerName;
    uint8_t background;
    uint8_t logo;
    uint8_t progressBar;
    uint8_t splash;
    uint8_t waterMark;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchBrandingInformation
namespace ContentLaunchDimension {
enum FieldId
{
    kWidthFieldId  = 0,
    kHeightFieldId = 1,
    kMetricFieldId = 2,
};

struct Type
{
public:
    Span<const char> width;
    Span<const char> height;
    ContentLaunchMetricType metric;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchDimension
namespace ContentLaunchStyleInformation {
enum FieldId
{
    kImageUrlFieldId = 0,
    kColorFieldId    = 1,
    kSizeFieldId     = 2,
};

struct Type
{
public:
    Span<const char> imageUrl;
    Span<const char> color;
    uint8_t size;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchStyleInformation

namespace Commands {
namespace LaunchContent {
struct Type
{
};

struct DecodableType
{
};
} // namespace LaunchContent

namespace LaunchContentResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace LaunchContentResponse

namespace LaunchURL {
struct Type
{
};

struct DecodableType
{
};
} // namespace LaunchURL

namespace LaunchURLResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace LaunchURLResponse

} // namespace Commands
} // namespace ContentLauncher
namespace AudioOutput {
// Enum for AudioOutputType
enum class AudioOutputType : uint8_t
{
    AUDIO_OUTPUT_TYPE_HDMI      = 0x00,
    AUDIO_OUTPUT_TYPE_BT        = 0x01,
    AUDIO_OUTPUT_TYPE_OPTICAL   = 0x02,
    AUDIO_OUTPUT_TYPE_HEADPHONE = 0x03,
    AUDIO_OUTPUT_TYPE_INTERNAL  = 0x04,
    AUDIO_OUTPUT_TYPE_OTHER     = 0x05,
};

namespace AudioOutputInfo {
enum FieldId
{
    kIndexFieldId      = 0,
    kOutputTypeFieldId = 1,
    kNameFieldId       = 2,
};

struct Type
{
public:
    uint8_t index;
    AudioOutputType outputType;
    chip::ByteSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace AudioOutputInfo

namespace Commands {
namespace SelectOutput {
struct Type
{
};

struct DecodableType
{
};
} // namespace SelectOutput

namespace RenameOutput {
struct Type
{
};

struct DecodableType
{
};
} // namespace RenameOutput

} // namespace Commands
} // namespace AudioOutput
namespace ApplicationLauncher {
// Enum for ApplicationLauncherStatus
enum class ApplicationLauncherStatus : uint8_t
{
    APPLICATION_LAUNCHER_STATUS_SUCCESS           = 0x00,
    APPLICATION_LAUNCHER_STATUS_APP_NOT_AVAILABLE = 0x01,
    APPLICATION_LAUNCHER_STATUS_SYSTEM_BUSY       = 0x02,
};

namespace ApplicationLauncherApp {
enum FieldId
{
    kCatalogVendorIdFieldId = 0,
    kApplicationIdFieldId   = 1,
};

struct Type
{
public:
    uint16_t catalogVendorId;
    Span<const char> applicationId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ApplicationLauncherApp

namespace Commands {
namespace LaunchApp {
struct Type
{
};

struct DecodableType
{
};
} // namespace LaunchApp

namespace LaunchAppResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace LaunchAppResponse

} // namespace Commands
} // namespace ApplicationLauncher
namespace ApplicationBasic {
// Enum for ApplicationBasicStatus
enum class ApplicationBasicStatus : uint8_t
{
    APPLICATION_BASIC_STATUS_STOPPED                  = 0x00,
    APPLICATION_BASIC_STATUS_ACTIVE_VISIBLE_FOCUS     = 0x01,
    APPLICATION_BASIC_STATUS_ACTIVE_HIDDEN            = 0x02,
    APPLICATION_BASIC_STATUS_ACTIVE_VISIBLE_NOT_FOCUS = 0x03,
};

namespace Commands {
namespace ChangeStatus {
struct Type
{
};

struct DecodableType
{
};
} // namespace ChangeStatus

} // namespace Commands
} // namespace ApplicationBasic
namespace AccountLogin {

namespace Commands {
namespace GetSetupPIN {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetSetupPIN

namespace GetSetupPINResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetSetupPINResponse

namespace Login {
struct Type
{
};

struct DecodableType
{
};
} // namespace Login

} // namespace Commands
} // namespace AccountLogin
namespace TestCluster {
// Enum for SimpleEnum
enum class SimpleEnum : uint8_t
{
    SIMPLE_ENUM_UNSPECIFIED = 0x00,
    SIMPLE_ENUM_VALUE_A     = 0x01,
    SIMPLE_ENUM_VALUE_B     = 0x02,
    SIMPLE_ENUM_VALUE_C     = 0x03,
};

namespace SimpleStruct {
enum FieldId
{
    kAFieldId = 0,
    kBFieldId = 1,
    kCFieldId = 2,
    kDFieldId = 3,
    kEFieldId = 4,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleEnum c;
    chip::ByteSpan d;
    Span<const char> e;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SimpleStruct
namespace NestedStruct {
enum FieldId
{
    kAFieldId = 0,
    kBFieldId = 1,
    kCFieldId = 2,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleStruct::Type c;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NestedStruct
namespace NestedStructList {
enum FieldId
{
    kAFieldId = 0,
    kBFieldId = 1,
    kCFieldId = 2,
    kDFieldId = 3,
    kEFieldId = 4,
    kFFieldId = 5,
    kGFieldId = 6,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleStruct::Type c;
    DataModel::List<SimpleStruct::Type> d;
    DataModel::List<uint32_t> e;
    DataModel::List<chip::ByteSpan> f;
    DataModel::List<uint8_t> g;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
};

struct DecodableType
{
public:
    uint8_t a;
    bool b;
    SimpleStruct::DecodableType c;
    DataModel::DecodableList<SimpleStruct::DecodableType> d;
    DataModel::DecodableList<uint32_t> e;
    DataModel::DecodableList<chip::ByteSpan> f;
    DataModel::DecodableList<uint8_t> g;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NestedStructList
namespace DoubleNestedStructList {
enum FieldId
{
    kAFieldId = 0,
};

struct Type
{
public:
    DataModel::List<NestedStructList::Type> a;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<NestedStructList::DecodableType> a;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace DoubleNestedStructList
namespace TestListStructOctet {
enum FieldId
{
    kFabricIndexFieldId     = 0,
    kOperationalCertFieldId = 1,
};

struct Type
{
public:
    uint64_t fabricIndex;
    chip::ByteSpan operationalCert;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TestListStructOctet

namespace Commands {
namespace Test {
struct Type
{
};

struct DecodableType
{
};
} // namespace Test

namespace TestSpecificResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace TestSpecificResponse

namespace TestNotHandled {
struct Type
{
};

struct DecodableType
{
};
} // namespace TestNotHandled

namespace TestAddArgumentsResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace TestAddArgumentsResponse

namespace TestSpecific {
struct Type
{
};

struct DecodableType
{
};
} // namespace TestSpecific

namespace TestUnknownCommand {
struct Type
{
};

struct DecodableType
{
};
} // namespace TestUnknownCommand

namespace TestAddArguments {
struct Type
{
};

struct DecodableType
{
};
} // namespace TestAddArguments

} // namespace Commands
} // namespace TestCluster
namespace Messaging {
// Enum for EventId
enum class EventId : uint8_t
{
    EVENT_ID_METER_COVER_REMOVED                   = 0x00,
    EVENT_ID_METER_COVER_CLOSED                    = 0x01,
    EVENT_ID_STRONG_MAGNETIC_FIELD                 = 0x02,
    EVENT_ID_NO_STRONG_MAGNETIC_FIELD              = 0x03,
    EVENT_ID_BATTERY_FAILURE                       = 0x04,
    EVENT_ID_LOW_BATTERY                           = 0x05,
    EVENT_ID_PROGRAM_MEMORY_ERROR                  = 0x06,
    EVENT_ID_RAM_ERROR                             = 0x07,
    EVENT_ID_NV_MEMORY_ERROR                       = 0x08,
    EVENT_ID_MEASUREMENT_SYSTEM_ERROR              = 0x09,
    EVENT_ID_WATCHDOG_ERROR                        = 0x0A,
    EVENT_ID_SUPPLY_DISCONNECT_FAILURE             = 0x0B,
    EVENT_ID_SUPPLY_CONNECT_FAILURE                = 0x0C,
    EVENT_ID_MEASURMENT_SOFTWARE_CHANGED           = 0x0D,
    EVENT_ID_DST_ENABLED                           = 0x0E,
    EVENT_ID_DST_DISABLED                          = 0x0F,
    EVENT_ID_CLOCK_ADJ_BACKWARD                    = 0x10,
    EVENT_ID_CLOCK_ADJ_FORWARD                     = 0x11,
    EVENT_ID_CLOCK_INVALID                         = 0x12,
    EVENT_ID_COMMS_ERROR_HAN                       = 0x13,
    EVENT_ID_COMMS_OK_HAN                          = 0x14,
    EVENT_ID_FRAUD_ATTEMPT                         = 0x15,
    EVENT_ID_POWER_LOSS                            = 0x16,
    EVENT_ID_INCORRECT_PROTOCOL                    = 0x17,
    EVENT_ID_UNUSUAL_HAN_TRAFFIC                   = 0x18,
    EVENT_ID_UNEXPECTED_CLOCK_CHANGE               = 0x19,
    EVENT_ID_COMMS_USING_UNAUTHENTICATED_COMPONENT = 0x1A,
    EVENT_ID_ERROR_REG_CLEAR                       = 0x1B,
    EVENT_ID_ALARM_REG_CLEAR                       = 0x1C,
    EVENT_ID_UNEXPECTED_HW_RESET                   = 0x1D,
    EVENT_ID_UNEXPECTED_PROGRAM_EXECUTION          = 0x1E,
    EVENT_ID_EVENT_LOG_CLEARED                     = 0x1F,
    EVENT_ID_MANUAL_DISCONNECT                     = 0x20,
    EVENT_ID_MANUAL_CONNECT                        = 0x21,
    EVENT_ID_REMOTE_DISCONNECTION                  = 0x22,
    EVENT_ID_LOCAL_DISCONNECTION                   = 0x23,
    EVENT_ID_LIMIT_THRESHOLD_EXCEEDED              = 0x24,
    EVENT_ID_LIMIT_THRESHOLD_OK                    = 0x25,
    EVENT_ID_LIMIT_THRESHOLD_CHANGED               = 0x26,
    EVENT_ID_MAXIMUM_DEMAND_EXCEEDED               = 0x27,
    EVENT_ID_PROFILE_CLEARED                       = 0x28,
    EVENT_ID_FIRMWARE_READY_FOR_ACTIVATION         = 0x29,
    EVENT_ID_FIRMWARE_ACTIVATED                    = 0x2A,
    EVENT_ID_PATCH_FAILURE                         = 0x2B,
    EVENT_ID_TOU_TARIFF_ACTIVATION                 = 0x2C,
    EVENT_ID_8X8_TARIFFACTIVATED                   = 0x2D,
    EVENT_ID_SINGLE_TARIFF_RATE_ACTIVATED          = 0x2E,
    EVENT_ID_ASYNCHRONOUS_BILLING_OCCURRED         = 0x2F,
    EVENT_ID_SYNCHRONOUS_BILLING_OCCURRED          = 0x30,
    EVENT_ID_INCORRECT_POLARITY                    = 0x80,
    EVENT_ID_CURRENT_NO_VOLTAGE                    = 0x81,
    EVENT_ID_UNDER_VOLTAGE                         = 0x82,
    EVENT_ID_OVER_VOLTAGE                          = 0x83,
    EVENT_ID_NORMAL_VOLTAGE                        = 0x84,
    EVENT_ID_PF_BELOW_THRESHOLD                    = 0x85,
    EVENT_ID_PF_ABOVE_THRESHOLD                    = 0x86,
    EVENT_ID_TERMINAL_COVER_REMOVED                = 0x87,
    EVENT_ID_TERMINAL_COVER_CLOSED                 = 0x88,
    EVENT_ID_REVERSE_FLOW                          = 0xA0,
    EVENT_ID_TILT_TAMPER                           = 0xA1,
    EVENT_ID_BATTERY_COVER_REMOVED                 = 0xA2,
    EVENT_ID_BATTERY_COVER_CLOSED                  = 0xA3,
    EVENT_ID_EXCESS_FLOW                           = 0xA4,
    EVENT_ID_CREDIT_OK                             = 0xC0,
    EVENT_ID_LOW_CREDIT                            = 0xC1,
    EVENT_ID_EMERGENCY_CREDIT_IN_USE               = 0xC0,
    EVENT_ID_EMERGENCY_CREDIT_EXHAUSTED            = 0xC1,
    EVENT_ID_ZERO_CREDIT_EC_NOT_SELECTED           = 0xC2,
    EVENT_ID_SUPPLY_ON                             = 0xC3,
    EVENT_ID_SUPPLY_OFF_AARMED                     = 0xC4,
    EVENT_ID_SUPPLY_OFF                            = 0xC5,
    EVENT_ID_DISCOUNT_APPLIED                      = 0xC6,
    EVENT_ID_MANUFACTURER_SPECIFIC_A               = 0xE0,
    EVENT_ID_MANUFACTURER_SPECIFIC_B               = 0xE1,
    EVENT_ID_MANUFACTURER_SPECIFIC_C               = 0xE2,
    EVENT_ID_MANUFACTURER_SPECIFIC_D               = 0xE3,
    EVENT_ID_MANUFACTURER_SPECIFIC_E               = 0xE4,
    EVENT_ID_MANUFACTURER_SPECIFIC_F               = 0xE5,
    EVENT_ID_MANUFACTURER_SPECIFIC_G               = 0xE6,
    EVENT_ID_MANUFACTURER_SPECIFIC_H               = 0xE7,
    EVENT_ID_MANUFACTURER_SPECIFIC_I               = 0xE8,
};
// Enum for MessagingControlConfirmation
enum class MessagingControlConfirmation : uint8_t
{
    MESSAGING_CONTROL_CONFIRMATION_NOT_REQUIRED = 0x00,
    MESSAGING_CONTROL_CONFIRMATION_REQUIRED     = 0x80,
};
// Enum for MessagingControlEnhancedConfirmation
enum class MessagingControlEnhancedConfirmation : uint8_t
{
    MESSAGING_CONTROL_ENHANCED_CONFIRMATION_NOT_REQUIRED = 0x00,
    MESSAGING_CONTROL_ENHANCED_CONFIRMATION_REQUIRED     = 0x20,
};
// Enum for MessagingControlImportance
enum class MessagingControlImportance : uint8_t
{
    MESSAGING_CONTROL_IMPORTANCE_LOW      = 0x00,
    MESSAGING_CONTROL_IMPORTANCE_MEDIUM   = 0x04,
    MESSAGING_CONTROL_IMPORTANCE_HIGH     = 0x08,
    MESSAGING_CONTROL_IMPORTANCE_CRITICAL = 0x0C,
};
// Enum for MessagingControlTransmission
enum class MessagingControlTransmission : uint8_t
{
    MESSAGING_CONTROL_TRANSMISSION_NORMAL               = 0x00,
    MESSAGING_CONTROL_TRANSMISSION_NORMAL_AND_ANONYMOUS = 0x01,
    MESSAGING_CONTROL_TRANSMISSION_ANONYMOUS            = 0x02,
    MESSAGING_CONTROL_TRANSMISSION_RESERVED             = 0x03,
};

namespace Commands {
namespace DisplayMessage {
struct Type
{
};

struct DecodableType
{
};
} // namespace DisplayMessage

namespace GetLastMessage {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetLastMessage

namespace CancelMessage {
struct Type
{
};

struct DecodableType
{
};
} // namespace CancelMessage

namespace MessageConfirmation {
struct Type
{
};

struct DecodableType
{
};
} // namespace MessageConfirmation

namespace DisplayProtectedMessage {
struct Type
{
};

struct DecodableType
{
};
} // namespace DisplayProtectedMessage

namespace GetMessageCancellation {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetMessageCancellation

namespace CancelAllMessages {
struct Type
{
};

struct DecodableType
{
};
} // namespace CancelAllMessages

} // namespace Commands
} // namespace Messaging
namespace ApplianceIdentification {

} // namespace ApplianceIdentification
namespace MeterIdentification {

} // namespace MeterIdentification
namespace ApplianceEventsAndAlert {
// Enum for EventIdentification
enum class EventIdentification : uint8_t
{
    EVENT_IDENTIFICATION_END_OF_CYCLE        = 0x01,
    EVENT_IDENTIFICATION_TEMPERATURE_REACHED = 0x04,
    EVENT_IDENTIFICATION_END_OF_COOKING      = 0x05,
    EVENT_IDENTIFICATION_SWITCHING_OFF       = 0x06,
    EVENT_IDENTIFICATION_WRONG_DATA          = 0x07,
};

namespace Commands {
namespace GetAlerts {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetAlerts

namespace GetAlertsResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetAlertsResponse

namespace AlertsNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace AlertsNotification

namespace EventsNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace EventsNotification

} // namespace Commands
} // namespace ApplianceEventsAndAlert
namespace ApplianceStatistics {

namespace Commands {
namespace LogNotification {
struct Type
{
};

struct DecodableType
{
};
} // namespace LogNotification

namespace LogRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace LogRequest

namespace LogResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace LogResponse

namespace LogQueueRequest {
struct Type
{
};

struct DecodableType
{
};
} // namespace LogQueueRequest

namespace LogQueueResponse {
struct Type
{
};

struct DecodableType
{
};
} // namespace LogQueueResponse

namespace StatisticsAvailable {
struct Type
{
};

struct DecodableType
{
};
} // namespace StatisticsAvailable

} // namespace Commands
} // namespace ApplianceStatistics
namespace ElectricalMeasurement {

namespace Commands {
namespace GetProfileInfoResponseCommand {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetProfileInfoResponseCommand

namespace GetProfileInfoCommand {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetProfileInfoCommand

namespace GetMeasurementProfileResponseCommand {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetMeasurementProfileResponseCommand

namespace GetMeasurementProfileCommand {
struct Type
{
};

struct DecodableType
{
};
} // namespace GetMeasurementProfileCommand

} // namespace Commands
} // namespace ElectricalMeasurement
namespace Binding {

namespace Commands {
namespace Bind {
struct Type
{
};

struct DecodableType
{
};
} // namespace Bind

namespace Unbind {
struct Type
{
};

struct DecodableType
{
};
} // namespace Unbind

} // namespace Commands
} // namespace Binding
namespace GroupKeyManagement {
// Enum for GroupKeySecurityPolicy
enum class GroupKeySecurityPolicy : uint8_t
{
    GROUP_KEY_SECURITY_POLICY_STANDARD    = 0x00,
    GROUP_KEY_SECURITY_POLICY_LOW_LATENCY = 0x01,
};

namespace GroupKey {
enum FieldId
{
    kVendorIdFieldId               = 0,
    kGroupKeyIndexFieldId          = 1,
    kGroupKeyRootFieldId           = 2,
    kGroupKeyEpochStartTimeFieldId = 3,
    kGroupKeySecurityPolicyFieldId = 4,
};

struct Type
{
public:
    uint16_t vendorId;
    uint16_t groupKeyIndex;
    chip::ByteSpan groupKeyRoot;
    uint64_t groupKeyEpochStartTime;
    GroupKeySecurityPolicy groupKeySecurityPolicy;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace GroupKey
namespace GroupState {
enum FieldId
{
    kVendorIdFieldId         = 0,
    kVendorGroupIdFieldId    = 1,
    kGroupKeySetIndexFieldId = 2,
};

struct Type
{
public:
    uint16_t vendorId;
    uint16_t vendorGroupId;
    uint16_t groupKeySetIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace GroupState

} // namespace GroupKeyManagement
namespace SampleMfgSpecificCluster {

namespace Commands {
namespace CommandOne {
struct Type
{
};

struct DecodableType
{
};
} // namespace CommandOne

} // namespace Commands
} // namespace SampleMfgSpecificCluster
namespace SampleMfgSpecificCluster2 {

namespace Commands {
namespace CommandTwo {
struct Type
{
};

struct DecodableType
{
};
} // namespace CommandTwo

} // namespace Commands
} // namespace SampleMfgSpecificCluster2

} // namespace Clusters
} // namespace app
} // namespace chip
