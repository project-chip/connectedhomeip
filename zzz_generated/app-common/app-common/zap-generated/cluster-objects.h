/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app-common/zap-generated/ids/Attributes.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app-common/zap-generated/ids/Events.h>
#include <app/ConcreteAttributePath.h>
#include <app/EventLoggingTypes.h>
#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/util/basic-types.h>
#include <lib/core/ClusterEnums.h>
#include <lib/support/BitMask.h>
#include <protocols/interaction_model/Constants.h>

namespace chip {
namespace app {
namespace Clusters {

namespace detail {
// Structs shared across multiple clusters.
namespace Structs {

namespace ModeTagStruct {
enum class Fields : uint8_t
{
    kMfgCode = 0,
    kValue   = 1,
};

struct Type
{
public:
    Optional<chip::VendorId> mfgCode;
    uint16_t value = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ModeTagStruct
namespace ModeOptionStruct {
enum class Fields : uint8_t
{
    kLabel    = 0,
    kMode     = 1,
    kModeTags = 2,
};

struct Type
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::List<const Structs::ModeTagStruct::Type> modeTags;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::DecodableList<Structs::ModeTagStruct::DecodableType> modeTags;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ModeOptionStruct
namespace MeasurementAccuracyRangeStruct {
enum class Fields : uint8_t
{
    kRangeMin       = 0,
    kRangeMax       = 1,
    kPercentMax     = 2,
    kPercentMin     = 3,
    kPercentTypical = 4,
    kFixedMax       = 5,
    kFixedMin       = 6,
    kFixedTypical   = 7,
};

struct Type
{
public:
    int64_t rangeMin = static_cast<int64_t>(0);
    int64_t rangeMax = static_cast<int64_t>(0);
    Optional<chip::Percent100ths> percentMax;
    Optional<chip::Percent100ths> percentMin;
    Optional<chip::Percent100ths> percentTypical;
    Optional<uint64_t> fixedMax;
    Optional<uint64_t> fixedMin;
    Optional<uint64_t> fixedTypical;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MeasurementAccuracyRangeStruct
namespace MeasurementAccuracyStruct {
enum class Fields : uint8_t
{
    kMeasurementType  = 0,
    kMeasured         = 1,
    kMinMeasuredValue = 2,
    kMaxMeasuredValue = 3,
    kAccuracyRanges   = 4,
};

struct Type
{
public:
    MeasurementTypeEnum measurementType = static_cast<MeasurementTypeEnum>(0);
    bool measured                       = static_cast<bool>(0);
    int64_t minMeasuredValue            = static_cast<int64_t>(0);
    int64_t maxMeasuredValue            = static_cast<int64_t>(0);
    DataModel::List<const Structs::MeasurementAccuracyRangeStruct::Type> accuracyRanges;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    MeasurementTypeEnum measurementType = static_cast<MeasurementTypeEnum>(0);
    bool measured                       = static_cast<bool>(0);
    int64_t minMeasuredValue            = static_cast<int64_t>(0);
    int64_t maxMeasuredValue            = static_cast<int64_t>(0);
    DataModel::DecodableList<Structs::MeasurementAccuracyRangeStruct::DecodableType> accuracyRanges;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace MeasurementAccuracyStruct
namespace ApplicationStruct {
enum class Fields : uint8_t
{
    kCatalogVendorID = 0,
    kApplicationID   = 1,
};

struct Type
{
public:
    uint16_t catalogVendorID = static_cast<uint16_t>(0);
    chip::CharSpan applicationID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ApplicationStruct
namespace ErrorStateStruct {
enum class Fields : uint8_t
{
    kErrorStateID      = 0,
    kErrorStateLabel   = 1,
    kErrorStateDetails = 2,
};

struct Type
{
public:
    uint8_t errorStateID = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> errorStateLabel;
    Optional<chip::CharSpan> errorStateDetails;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ErrorStateStruct
namespace LabelStruct {
enum class Fields : uint8_t
{
    kLabel = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::CharSpan label;
    chip::CharSpan value;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LabelStruct
namespace OperationalStateStruct {
enum class Fields : uint8_t
{
    kOperationalStateID    = 0,
    kOperationalStateLabel = 1,
};

struct Type
{
public:
    uint8_t operationalStateID = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> operationalStateLabel;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OperationalStateStruct
} // namespace Structs
} // namespace detail

namespace Globals {
namespace Attributes {
namespace GeneratedCommandList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::CommandId>;
    using DecodableType    = DataModel::DecodableList<chip::CommandId>;
    using DecodableArgType = const DataModel::DecodableList<chip::CommandId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::GeneratedCommandList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GeneratedCommandList

namespace AcceptedCommandList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::CommandId>;
    using DecodableType    = DataModel::DecodableList<chip::CommandId>;
    using DecodableArgType = const DataModel::DecodableList<chip::CommandId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::AcceptedCommandList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcceptedCommandList

namespace EventList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::EventId>;
    using DecodableType    = DataModel::DecodableList<chip::EventId>;
    using DecodableArgType = const DataModel::DecodableList<chip::EventId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::EventList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EventList

namespace AttributeList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::AttributeId>;
    using DecodableType    = DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const DataModel::DecodableList<chip::AttributeId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList

namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap

namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

} // namespace Attributes
} // namespace Globals

namespace Identify {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Identify {
struct Type;
struct DecodableType;
} // namespace Identify

namespace TriggerEffect {
struct Type;
struct DecodableType;
} // namespace TriggerEffect

} // namespace Commands

namespace Commands {
namespace Identify {
enum class Fields : uint8_t
{
    kIdentifyTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t identifyTime = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t identifyTime = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Identify
namespace TriggerEffect {
enum class Fields : uint8_t
{
    kEffectIdentifier = 0,
    kEffectVariant    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    EffectVariantEnum effectVariant       = static_cast<EffectVariantEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    EffectVariantEnum effectVariant       = static_cast<EffectVariantEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TriggerEffect
} // namespace Commands

namespace Attributes {

namespace IdentifyTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdentifyTime
namespace IdentifyType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Identify::IdentifyTypeEnum;
    using DecodableType    = chip::app::Clusters::Identify::IdentifyTypeEnum;
    using DecodableArgType = chip::app::Clusters::Identify::IdentifyTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdentifyType
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::IdentifyTime::TypeInfo::DecodableType identifyTime = static_cast<uint16_t>(0);
        Attributes::IdentifyType::TypeInfo::DecodableType identifyType =
            static_cast<chip::app::Clusters::Identify::IdentifyTypeEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Identify
namespace Groups {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddGroup {
struct Type;
struct DecodableType;
} // namespace AddGroup

namespace AddGroupResponse {
struct Type;
struct DecodableType;
} // namespace AddGroupResponse

namespace ViewGroup {
struct Type;
struct DecodableType;
} // namespace ViewGroup

namespace ViewGroupResponse {
struct Type;
struct DecodableType;
} // namespace ViewGroupResponse

namespace GetGroupMembership {
struct Type;
struct DecodableType;
} // namespace GetGroupMembership

namespace GetGroupMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetGroupMembershipResponse

namespace RemoveGroup {
struct Type;
struct DecodableType;
} // namespace RemoveGroup

namespace RemoveGroupResponse {
struct Type;
struct DecodableType;
} // namespace RemoveGroupResponse

namespace RemoveAllGroups {
struct Type;
struct DecodableType;
} // namespace RemoveAllGroups

namespace AddGroupIfIdentifying {
struct Type;
struct DecodableType;
} // namespace AddGroupIfIdentifying

} // namespace Commands

namespace Commands {
namespace AddGroup {
enum class Fields : uint8_t
{
    kGroupID   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::AddGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroup
namespace AddGroupResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupResponse
namespace ViewGroup {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::ViewGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroup
namespace ViewGroupResponse {
enum class Fields : uint8_t
{
    kStatus    = 0,
    kGroupID   = 1,
    kGroupName = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroupResponse
namespace GetGroupMembership {
enum class Fields : uint8_t
{
    kGroupList = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::List<const chip::GroupId> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::DecodableList<chip::GroupId> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembership
namespace GetGroupMembershipResponse {
enum class Fields : uint8_t
{
    kCapacity  = 0,
    kGroupList = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::Nullable<uint8_t> capacity;
    DataModel::List<const chip::GroupId> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::Nullable<uint8_t> capacity;
    DataModel::DecodableList<chip::GroupId> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembershipResponse
namespace RemoveGroup {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::RemoveGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroup
namespace RemoveGroupResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroupResponse
namespace RemoveAllGroups {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllGroups
namespace AddGroupIfIdentifying {
enum class Fields : uint8_t
{
    kGroupID   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupIfIdentifying
} // namespace Commands

namespace Attributes {

namespace NameSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NameSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NameSupport
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NameSupport::TypeInfo::DecodableType nameSupport =
            static_cast<chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Groups
namespace OnOff {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Off {
struct Type;
struct DecodableType;
} // namespace Off

namespace On {
struct Type;
struct DecodableType;
} // namespace On

namespace Toggle {
struct Type;
struct DecodableType;
} // namespace Toggle

namespace OffWithEffect {
struct Type;
struct DecodableType;
} // namespace OffWithEffect

namespace OnWithRecallGlobalScene {
struct Type;
struct DecodableType;
} // namespace OnWithRecallGlobalScene

namespace OnWithTimedOff {
struct Type;
struct DecodableType;
} // namespace OnWithTimedOff

} // namespace Commands

namespace Commands {
namespace Off {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Off::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Off::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Off
namespace On {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::On::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::On::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace On
namespace Toggle {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Toggle
namespace OffWithEffect {
enum class Fields : uint8_t
{
    kEffectIdentifier = 0,
    kEffectVariant    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    uint8_t effectVariant                 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    uint8_t effectVariant                 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OffWithEffect
namespace OnWithRecallGlobalScene {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithRecallGlobalScene
namespace OnWithTimedOff {
enum class Fields : uint8_t
{
    kOnOffControl = 0,
    kOnTime       = 1,
    kOffWaitTime  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    chip::BitMask<OnOffControlBitmap> onOffControl = static_cast<chip::BitMask<OnOffControlBitmap>>(0);
    uint16_t onTime                                = static_cast<uint16_t>(0);
    uint16_t offWaitTime                           = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    chip::BitMask<OnOffControlBitmap> onOffControl = static_cast<chip::BitMask<OnOffControlBitmap>>(0);
    uint16_t onTime                                = static_cast<uint16_t>(0);
    uint16_t offWaitTime                           = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithTimedOff
} // namespace Commands

namespace Attributes {

namespace OnOff {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnOff
namespace GlobalSceneControl {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GlobalSceneControl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GlobalSceneControl
namespace OnTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnTime
namespace OffWaitTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffWaitTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OffWaitTime
namespace StartUpOnOff {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::StartUpOnOffEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::StartUpOnOffEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::StartUpOnOffEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpOnOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpOnOff
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OnOff::TypeInfo::DecodableType onOff                           = static_cast<bool>(0);
        Attributes::GlobalSceneControl::TypeInfo::DecodableType globalSceneControl = static_cast<bool>(0);
        Attributes::OnTime::TypeInfo::DecodableType onTime                         = static_cast<uint16_t>(0);
        Attributes::OffWaitTime::TypeInfo::DecodableType offWaitTime               = static_cast<uint16_t>(0);
        Attributes::StartUpOnOff::TypeInfo::DecodableType startUpOnOff;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OnOff
namespace OnOffSwitchConfiguration {

namespace Attributes {

namespace SwitchType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SwitchType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SwitchType
namespace SwitchActions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SwitchActions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SwitchActions
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SwitchType::TypeInfo::DecodableType switchType       = static_cast<uint8_t>(0);
        Attributes::SwitchActions::TypeInfo::DecodableType switchActions = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OnOffSwitchConfiguration
namespace LevelControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToLevel {
struct Type;
struct DecodableType;
} // namespace MoveToLevel

namespace Move {
struct Type;
struct DecodableType;
} // namespace Move

namespace Step {
struct Type;
struct DecodableType;
} // namespace Step

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace MoveToLevelWithOnOff {
struct Type;
struct DecodableType;
} // namespace MoveToLevelWithOnOff

namespace MoveWithOnOff {
struct Type;
struct DecodableType;
} // namespace MoveWithOnOff

namespace StepWithOnOff {
struct Type;
struct DecodableType;
} // namespace StepWithOnOff

namespace StopWithOnOff {
struct Type;
struct DecodableType;
} // namespace StopWithOnOff

namespace MoveToClosestFrequency {
struct Type;
struct DecodableType;
} // namespace MoveToClosestFrequency

} // namespace Commands

namespace Commands {
namespace MoveToLevel {
enum class Fields : uint8_t
{
    kLevel           = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevel
namespace Move {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Move::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Move::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Move
namespace Step {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Step
namespace Stop {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace MoveToLevelWithOnOff {
enum class Fields : uint8_t
{
    kLevel           = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevelWithOnOff
namespace MoveWithOnOff {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveWithOnOff
namespace StepWithOnOff {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepWithOnOff
namespace StopWithOnOff {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopWithOnOff
namespace MoveToClosestFrequency {
enum class Fields : uint8_t
{
    kFrequency = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToClosestFrequency::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint16_t frequency = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToClosestFrequency::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint16_t frequency = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToClosestFrequency
} // namespace Commands

namespace Attributes {

namespace CurrentLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLevel
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace MinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxLevel
namespace CurrentFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFrequency
namespace MinFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinFrequency
namespace MaxFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxFrequency
namespace Options {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Options::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Options
namespace OnOffTransitionTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOffTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnOffTransitionTime
namespace OnLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnLevel
namespace OnTransitionTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnTransitionTime
namespace OffTransitionTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OffTransitionTime
namespace DefaultMoveRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultMoveRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultMoveRate
namespace StartUpCurrentLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpCurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpCurrentLevel
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentLevel::TypeInfo::DecodableType currentLevel;
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime       = static_cast<uint16_t>(0);
        Attributes::MinLevel::TypeInfo::DecodableType minLevel                 = static_cast<uint8_t>(0);
        Attributes::MaxLevel::TypeInfo::DecodableType maxLevel                 = static_cast<uint8_t>(0);
        Attributes::CurrentFrequency::TypeInfo::DecodableType currentFrequency = static_cast<uint16_t>(0);
        Attributes::MinFrequency::TypeInfo::DecodableType minFrequency         = static_cast<uint16_t>(0);
        Attributes::MaxFrequency::TypeInfo::DecodableType maxFrequency         = static_cast<uint16_t>(0);
        Attributes::Options::TypeInfo::DecodableType options =
            static_cast<chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>>(0);
        Attributes::OnOffTransitionTime::TypeInfo::DecodableType onOffTransitionTime = static_cast<uint16_t>(0);
        Attributes::OnLevel::TypeInfo::DecodableType onLevel;
        Attributes::OnTransitionTime::TypeInfo::DecodableType onTransitionTime;
        Attributes::OffTransitionTime::TypeInfo::DecodableType offTransitionTime;
        Attributes::DefaultMoveRate::TypeInfo::DecodableType defaultMoveRate;
        Attributes::StartUpCurrentLevel::TypeInfo::DecodableType startUpCurrentLevel;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LevelControl
namespace BinaryInputBasic {

namespace Attributes {

namespace ActiveText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ActiveText
namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace Description
namespace InactiveText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InactiveText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace InactiveText
namespace OutOfService {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutOfService::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutOfService
namespace Polarity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Polarity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Polarity
namespace PresentValue {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PresentValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PresentValue
namespace Reliability {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reliability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reliability
namespace StatusFlags {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StatusFlags::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StatusFlags
namespace ApplicationType {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationType
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActiveText::TypeInfo::DecodableType activeText;
        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::InactiveText::TypeInfo::DecodableType inactiveText;
        Attributes::OutOfService::TypeInfo::DecodableType outOfService       = static_cast<bool>(0);
        Attributes::Polarity::TypeInfo::DecodableType polarity               = static_cast<uint8_t>(0);
        Attributes::PresentValue::TypeInfo::DecodableType presentValue       = static_cast<bool>(0);
        Attributes::Reliability::TypeInfo::DecodableType reliability         = static_cast<uint8_t>(0);
        Attributes::StatusFlags::TypeInfo::DecodableType statusFlags         = static_cast<uint8_t>(0);
        Attributes::ApplicationType::TypeInfo::DecodableType applicationType = static_cast<uint32_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace BinaryInputBasic
namespace PulseWidthModulation {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PulseWidthModulation
namespace Descriptor {
namespace Structs {
namespace DeviceTypeStruct {
enum class Fields : uint8_t
{
    kDeviceType = 0,
    kRevision   = 1,
};

struct Type
{
public:
    chip::DeviceTypeId deviceType = static_cast<chip::DeviceTypeId>(0);
    uint16_t revision             = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DeviceTypeStruct
namespace SemanticTagStruct {
enum class Fields : uint8_t
{
    kMfgCode     = 0,
    kNamespaceID = 1,
    kTag         = 2,
    kLabel       = 3,
};

struct Type
{
public:
    DataModel::Nullable<chip::VendorId> mfgCode;
    uint8_t namespaceID = static_cast<uint8_t>(0);
    uint8_t tag         = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<chip::CharSpan>> label;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SemanticTagStruct
} // namespace Structs

namespace Attributes {

namespace DeviceTypeList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Descriptor::Structs::DeviceTypeStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceTypeStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceTypeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceTypeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceTypeList
namespace ServerList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ClusterId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ClusterId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ClusterId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ServerList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ServerList
namespace ClientList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ClusterId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ClusterId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ClusterId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClientList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClientList
namespace PartsList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartsList
namespace TagList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Descriptor::Structs::SemanticTagStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::SemanticTagStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::SemanticTagStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TagList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TagList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DeviceTypeList::TypeInfo::DecodableType deviceTypeList;
        Attributes::ServerList::TypeInfo::DecodableType serverList;
        Attributes::ClientList::TypeInfo::DecodableType clientList;
        Attributes::PartsList::TypeInfo::DecodableType partsList;
        Attributes::TagList::TypeInfo::DecodableType tagList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Descriptor
namespace Binding {
namespace Structs {
namespace TargetStruct {
enum class Fields : uint8_t
{
    kNode        = 1,
    kGroup       = 2,
    kEndpoint    = 3,
    kCluster     = 4,
    kFabricIndex = 254,
};

struct Type
{
public:
    Optional<chip::NodeId> node;
    Optional<chip::GroupId> group;
    Optional<chip::EndpointId> endpoint;
    Optional<chip::ClusterId> cluster;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace TargetStruct
} // namespace Structs

namespace Attributes {

namespace Binding {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Binding::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Binding
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Binding::TypeInfo::DecodableType binding;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Binding
namespace AccessControl {
namespace Structs {
namespace AccessControlTargetStruct {
enum class Fields : uint8_t
{
    kCluster    = 0,
    kEndpoint   = 1,
    kDeviceType = 2,
};

struct Type
{
public:
    DataModel::Nullable<chip::ClusterId> cluster;
    DataModel::Nullable<chip::EndpointId> endpoint;
    DataModel::Nullable<chip::DeviceTypeId> deviceType;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AccessControlTargetStruct
namespace AccessControlEntryStruct {
enum class Fields : uint8_t
{
    kPrivilege   = 1,
    kAuthMode    = 2,
    kSubjects    = 3,
    kTargets     = 4,
    kFabricIndex = 254,
};

struct Type
{
public:
    AccessControlEntryPrivilegeEnum privilege = static_cast<AccessControlEntryPrivilegeEnum>(0);
    AccessControlEntryAuthModeEnum authMode   = static_cast<AccessControlEntryAuthModeEnum>(0);
    DataModel::Nullable<DataModel::List<const uint64_t>> subjects;
    DataModel::Nullable<DataModel::List<const Structs::AccessControlTargetStruct::Type>> targets;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    AccessControlEntryPrivilegeEnum privilege = static_cast<AccessControlEntryPrivilegeEnum>(0);
    AccessControlEntryAuthModeEnum authMode   = static_cast<AccessControlEntryAuthModeEnum>(0);
    DataModel::Nullable<DataModel::DecodableList<uint64_t>> subjects;
    DataModel::Nullable<DataModel::DecodableList<Structs::AccessControlTargetStruct::DecodableType>> targets;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace AccessControlEntryStruct
namespace AccessControlExtensionStruct {
enum class Fields : uint8_t
{
    kData        = 1,
    kFabricIndex = 254,
};

struct Type
{
public:
    chip::ByteSpan data;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace AccessControlExtensionStruct
} // namespace Structs

namespace Attributes {

namespace Acl {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntryStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntryStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessControlEntryStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Acl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Acl
namespace Extension {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlExtensionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessControlExtensionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessControlExtensionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Extension::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Extension
namespace SubjectsPerAccessControlEntry {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SubjectsPerAccessControlEntry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SubjectsPerAccessControlEntry
namespace TargetsPerAccessControlEntry {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetsPerAccessControlEntry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetsPerAccessControlEntry
namespace AccessControlEntriesPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AccessControlEntriesPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AccessControlEntriesPerFabric
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Acl::TypeInfo::DecodableType acl;
        Attributes::Extension::TypeInfo::DecodableType extension;
        Attributes::SubjectsPerAccessControlEntry::TypeInfo::DecodableType subjectsPerAccessControlEntry = static_cast<uint16_t>(0);
        Attributes::TargetsPerAccessControlEntry::TypeInfo::DecodableType targetsPerAccessControlEntry   = static_cast<uint16_t>(0);
        Attributes::AccessControlEntriesPerFabric::TypeInfo::DecodableType accessControlEntriesPerFabric = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace AccessControlEntryChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAdminNodeID     = 1,
    kAdminPasscodeID = 2,
    kChangeType      = 3,
    kLatestValue     = 4,
    kFabricIndex     = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlEntryChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr bool kIsFabricScoped = true;

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlEntryStruct::Type> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlEntryChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlEntryStruct::DecodableType> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AccessControlEntryChanged
namespace AccessControlExtensionChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAdminNodeID     = 1,
    kAdminPasscodeID = 2,
    kChangeType      = 3,
    kLatestValue     = 4,
    kFabricIndex     = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlExtensionChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr bool kIsFabricScoped = true;

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlExtensionStruct::Type> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlExtensionChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlExtensionStruct::DecodableType> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AccessControlExtensionChanged
} // namespace Events
} // namespace AccessControl
namespace Actions {
namespace Structs {
namespace ActionStruct {
enum class Fields : uint8_t
{
    kActionID          = 0,
    kName              = 1,
    kType              = 2,
    kEndpointListID    = 3,
    kSupportedCommands = 4,
    kState             = 5,
};

struct Type
{
public:
    uint16_t actionID = static_cast<uint16_t>(0);
    chip::CharSpan name;
    ActionTypeEnum type                          = static_cast<ActionTypeEnum>(0);
    uint16_t endpointListID                      = static_cast<uint16_t>(0);
    chip::BitMask<CommandBits> supportedCommands = static_cast<chip::BitMask<CommandBits>>(0);
    ActionStateEnum state                        = static_cast<ActionStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ActionStruct
namespace EndpointListStruct {
enum class Fields : uint8_t
{
    kEndpointListID = 0,
    kName           = 1,
    kType           = 2,
    kEndpoints      = 3,
};

struct Type
{
public:
    uint16_t endpointListID = static_cast<uint16_t>(0);
    chip::CharSpan name;
    EndpointListTypeEnum type = static_cast<EndpointListTypeEnum>(0);
    DataModel::List<const chip::EndpointId> endpoints;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint16_t endpointListID = static_cast<uint16_t>(0);
    chip::CharSpan name;
    EndpointListTypeEnum type = static_cast<EndpointListTypeEnum>(0);
    DataModel::DecodableList<chip::EndpointId> endpoints;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace EndpointListStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace InstantAction {
struct Type;
struct DecodableType;
} // namespace InstantAction

namespace InstantActionWithTransition {
struct Type;
struct DecodableType;
} // namespace InstantActionWithTransition

namespace StartAction {
struct Type;
struct DecodableType;
} // namespace StartAction

namespace StartActionWithDuration {
struct Type;
struct DecodableType;
} // namespace StartActionWithDuration

namespace StopAction {
struct Type;
struct DecodableType;
} // namespace StopAction

namespace PauseAction {
struct Type;
struct DecodableType;
} // namespace PauseAction

namespace PauseActionWithDuration {
struct Type;
struct DecodableType;
} // namespace PauseActionWithDuration

namespace ResumeAction {
struct Type;
struct DecodableType;
} // namespace ResumeAction

namespace EnableAction {
struct Type;
struct DecodableType;
} // namespace EnableAction

namespace EnableActionWithDuration {
struct Type;
struct DecodableType;
} // namespace EnableActionWithDuration

namespace DisableAction {
struct Type;
struct DecodableType;
} // namespace DisableAction

namespace DisableActionWithDuration {
struct Type;
struct DecodableType;
} // namespace DisableActionWithDuration

} // namespace Commands

namespace Commands {
namespace InstantAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InstantAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InstantAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InstantAction
namespace InstantActionWithTransition {
enum class Fields : uint8_t
{
    kActionID       = 0,
    kInvokeID       = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InstantActionWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint16_t transitionTime = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InstantActionWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint16_t transitionTime = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InstantActionWithTransition
namespace StartAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartAction
namespace StartActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartActionWithDuration
namespace StopAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopAction
namespace PauseAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseAction
namespace PauseActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseActionWithDuration
namespace ResumeAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResumeAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResumeAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResumeAction
namespace EnableAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableAction
namespace EnableActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableActionWithDuration
namespace DisableAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableAction
namespace DisableActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableActionWithDuration
} // namespace Commands

namespace Attributes {

namespace ActionList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Actions::Structs::ActionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::ActionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::ActionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActionList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActionList
namespace EndpointLists {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Actions::Structs::EndpointListStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::EndpointListStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::EndpointListStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndpointLists::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndpointLists
namespace SetupURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetupURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 512; }
};
} // namespace SetupURL
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActionList::TypeInfo::DecodableType actionList;
        Attributes::EndpointLists::TypeInfo::DecodableType endpointLists;
        Attributes::SetupURL::TypeInfo::DecodableType setupURL;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kNewState = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChanged
namespace ActionFailed {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kNewState = 2,
    kError    = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ActionFailed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);
    ActionErrorEnum error    = static_cast<ActionErrorEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ActionFailed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);
    ActionErrorEnum error    = static_cast<ActionErrorEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ActionFailed
} // namespace Events
} // namespace Actions
namespace BasicInformation {
namespace Structs {
namespace CapabilityMinimaStruct {
enum class Fields : uint8_t
{
    kCaseSessionsPerFabric  = 0,
    kSubscriptionsPerFabric = 1,
};

struct Type
{
public:
    uint16_t caseSessionsPerFabric  = static_cast<uint16_t>(0);
    uint16_t subscriptionsPerFabric = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CapabilityMinimaStruct
namespace ProductAppearanceStruct {
enum class Fields : uint8_t
{
    kFinish       = 0,
    kPrimaryColor = 1,
};

struct Type
{
public:
    ProductFinishEnum finish = static_cast<ProductFinishEnum>(0);
    DataModel::Nullable<ColorEnum> primaryColor;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProductAppearanceStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MfgSpecificPing {
struct Type;
struct DecodableType;
} // namespace MfgSpecificPing

} // namespace Commands

namespace Commands {
namespace MfgSpecificPing {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MfgSpecificPing
} // namespace Commands

namespace Attributes {

namespace DataModelRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataModelRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DataModelRevision
namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace ProductName
namespace ProductID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductID
namespace NodeLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NodeLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace NodeLabel
namespace Location {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Location::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 2; }
};
} // namespace Location
namespace HardwareVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 256; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace SerialNumber
namespace LocalConfigDisabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalConfigDisabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalConfigDisabled
namespace Reachable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reachable
namespace UniqueID {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UniqueID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace UniqueID
namespace CapabilityMinima {
struct TypeInfo
{
    using Type             = chip::app::Clusters::BasicInformation::Structs::CapabilityMinimaStruct::Type;
    using DecodableType    = chip::app::Clusters::BasicInformation::Structs::CapabilityMinimaStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::BasicInformation::Structs::CapabilityMinimaStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CapabilityMinima::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CapabilityMinima
namespace ProductAppearance {
struct TypeInfo
{
    using Type             = chip::app::Clusters::BasicInformation::Structs::ProductAppearanceStruct::Type;
    using DecodableType    = chip::app::Clusters::BasicInformation::Structs::ProductAppearanceStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::BasicInformation::Structs::ProductAppearanceStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductAppearance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductAppearance
namespace SpecificationVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpecificationVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpecificationVersion
namespace MaxPathsPerInvoke {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPathsPerInvoke::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPathsPerInvoke
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DataModelRevision::TypeInfo::DecodableType dataModelRevision = static_cast<uint16_t>(0);
        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID = static_cast<chip::VendorId>(0);
        Attributes::ProductName::TypeInfo::DecodableType productName;
        Attributes::ProductID::TypeInfo::DecodableType productID = static_cast<uint16_t>(0);
        Attributes::NodeLabel::TypeInfo::DecodableType nodeLabel;
        Attributes::Location::TypeInfo::DecodableType location;
        Attributes::HardwareVersion::TypeInfo::DecodableType hardwareVersion = static_cast<uint16_t>(0);
        Attributes::HardwareVersionString::TypeInfo::DecodableType hardwareVersionString;
        Attributes::SoftwareVersion::TypeInfo::DecodableType softwareVersion = static_cast<uint32_t>(0);
        Attributes::SoftwareVersionString::TypeInfo::DecodableType softwareVersionString;
        Attributes::ManufacturingDate::TypeInfo::DecodableType manufacturingDate;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductURL::TypeInfo::DecodableType productURL;
        Attributes::ProductLabel::TypeInfo::DecodableType productLabel;
        Attributes::SerialNumber::TypeInfo::DecodableType serialNumber;
        Attributes::LocalConfigDisabled::TypeInfo::DecodableType localConfigDisabled = static_cast<bool>(0);
        Attributes::Reachable::TypeInfo::DecodableType reachable                     = static_cast<bool>(0);
        Attributes::UniqueID::TypeInfo::DecodableType uniqueID;
        Attributes::CapabilityMinima::TypeInfo::DecodableType capabilityMinima;
        Attributes::ProductAppearance::TypeInfo::DecodableType productAppearance;
        Attributes::SpecificationVersion::TypeInfo::DecodableType specificationVersion = static_cast<uint32_t>(0);
        Attributes::MaxPathsPerInvoke::TypeInfo::DecodableType maxPathsPerInvoke       = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StartUp {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StartUp
namespace ShutDown {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShutDown
namespace Leave {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kFabricIndex = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leave
namespace ReachableChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kReachableNewValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ReachableChanged
} // namespace Events
} // namespace BasicInformation
namespace OtaSoftwareUpdateProvider {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace QueryImage {
struct Type;
struct DecodableType;
} // namespace QueryImage

namespace QueryImageResponse {
struct Type;
struct DecodableType;
} // namespace QueryImageResponse

namespace ApplyUpdateRequest {
struct Type;
struct DecodableType;
} // namespace ApplyUpdateRequest

namespace ApplyUpdateResponse {
struct Type;
struct DecodableType;
} // namespace ApplyUpdateResponse

namespace NotifyUpdateApplied {
struct Type;
struct DecodableType;
} // namespace NotifyUpdateApplied

} // namespace Commands

namespace Commands {
namespace QueryImage {
enum class Fields : uint8_t
{
    kVendorID            = 0,
    kProductID           = 1,
    kSoftwareVersion     = 2,
    kProtocolsSupported  = 3,
    kHardwareVersion     = 4,
    kLocation            = 5,
    kRequestorCanConsent = 6,
    kMetadataForProvider = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::VendorId vendorID  = static_cast<chip::VendorId>(0);
    uint16_t productID       = static_cast<uint16_t>(0);
    uint32_t softwareVersion = static_cast<uint32_t>(0);
    DataModel::List<const DownloadProtocolEnum> protocolsSupported;
    Optional<uint16_t> hardwareVersion;
    Optional<chip::CharSpan> location;
    Optional<bool> requestorCanConsent;
    Optional<chip::ByteSpan> metadataForProvider;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OtaSoftwareUpdateProvider::Commands::QueryImageResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::VendorId vendorID  = static_cast<chip::VendorId>(0);
    uint16_t productID       = static_cast<uint16_t>(0);
    uint32_t softwareVersion = static_cast<uint32_t>(0);
    DataModel::DecodableList<DownloadProtocolEnum> protocolsSupported;
    Optional<uint16_t> hardwareVersion;
    Optional<chip::CharSpan> location;
    Optional<bool> requestorCanConsent;
    Optional<chip::ByteSpan> metadataForProvider;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImage
namespace QueryImageResponse {
enum class Fields : uint8_t
{
    kStatus                = 0,
    kDelayedActionTime     = 1,
    kImageURI              = 2,
    kSoftwareVersion       = 3,
    kSoftwareVersionString = 4,
    kUpdateToken           = 5,
    kUserConsentNeeded     = 6,
    kMetadataForRequestor  = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<uint32_t> delayedActionTime;
    Optional<chip::CharSpan> imageURI;
    Optional<uint32_t> softwareVersion;
    Optional<chip::CharSpan> softwareVersionString;
    Optional<chip::ByteSpan> updateToken;
    Optional<bool> userConsentNeeded;
    Optional<chip::ByteSpan> metadataForRequestor;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<uint32_t> delayedActionTime;
    Optional<chip::CharSpan> imageURI;
    Optional<uint32_t> softwareVersion;
    Optional<chip::CharSpan> softwareVersionString;
    Optional<chip::ByteSpan> updateToken;
    Optional<bool> userConsentNeeded;
    Optional<chip::ByteSpan> metadataForRequestor;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImageResponse
namespace ApplyUpdateRequest {
enum class Fields : uint8_t
{
    kUpdateToken = 0,
    kNewVersion  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateRequest
namespace ApplyUpdateResponse {
enum class Fields : uint8_t
{
    kAction            = 0,
    kDelayedActionTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    ApplyUpdateActionEnum action = static_cast<ApplyUpdateActionEnum>(0);
    uint32_t delayedActionTime   = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    ApplyUpdateActionEnum action = static_cast<ApplyUpdateActionEnum>(0);
    uint32_t delayedActionTime   = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateResponse
namespace NotifyUpdateApplied {
enum class Fields : uint8_t
{
    kUpdateToken     = 0,
    kSoftwareVersion = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NotifyUpdateApplied
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
namespace Structs {
namespace ProviderLocation {
enum class Fields : uint8_t
{
    kProviderNodeID = 1,
    kEndpoint       = 2,
    kFabricIndex    = 254,
};

struct Type
{
public:
    chip::NodeId providerNodeID   = static_cast<chip::NodeId>(0);
    chip::EndpointId endpoint     = static_cast<chip::EndpointId>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace ProviderLocation
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AnnounceOTAProvider {
struct Type;
struct DecodableType;
} // namespace AnnounceOTAProvider

} // namespace Commands

namespace Commands {
namespace AnnounceOTAProvider {
enum class Fields : uint8_t
{
    kProviderNodeID     = 0,
    kVendorID           = 1,
    kAnnouncementReason = 2,
    kMetadataForNode    = 3,
    kEndpoint           = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AnnounceOTAProvider::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    chip::NodeId providerNodeID               = static_cast<chip::NodeId>(0);
    chip::VendorId vendorID                   = static_cast<chip::VendorId>(0);
    AnnouncementReasonEnum announcementReason = static_cast<AnnouncementReasonEnum>(0);
    Optional<chip::ByteSpan> metadataForNode;
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AnnounceOTAProvider::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    chip::NodeId providerNodeID               = static_cast<chip::NodeId>(0);
    chip::VendorId vendorID                   = static_cast<chip::VendorId>(0);
    AnnouncementReasonEnum announcementReason = static_cast<AnnouncementReasonEnum>(0);
    Optional<chip::ByteSpan> metadataForNode;
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AnnounceOTAProvider
} // namespace Commands

namespace Attributes {

namespace DefaultOTAProviders {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOTAProviders::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOTAProviders
namespace UpdatePossible {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdatePossible::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdatePossible
namespace UpdateState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;
    using DecodableType    = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;
    using DecodableArgType = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdateState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdateState
namespace UpdateStateProgress {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdateStateProgress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdateStateProgress
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DefaultOTAProviders::TypeInfo::DecodableType defaultOTAProviders;
        Attributes::UpdatePossible::TypeInfo::DecodableType updatePossible = static_cast<bool>(0);
        Attributes::UpdateState::TypeInfo::DecodableType updateState =
            static_cast<chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum>(0);
        Attributes::UpdateStateProgress::TypeInfo::DecodableType updateStateProgress;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateTransition {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousState         = 0,
    kNewState              = 1,
    kReason                = 2,
    kTargetSoftwareVersion = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr bool kIsFabricScoped = false;

    UpdateStateEnum previousState = static_cast<UpdateStateEnum>(0);
    UpdateStateEnum newState      = static_cast<UpdateStateEnum>(0);
    ChangeReasonEnum reason       = static_cast<ChangeReasonEnum>(0);
    DataModel::Nullable<uint32_t> targetSoftwareVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    UpdateStateEnum previousState = static_cast<UpdateStateEnum>(0);
    UpdateStateEnum newState      = static_cast<UpdateStateEnum>(0);
    ChangeReasonEnum reason       = static_cast<ChangeReasonEnum>(0);
    DataModel::Nullable<uint32_t> targetSoftwareVersion;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateTransition
namespace VersionApplied {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
    kProductID       = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::VersionApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint16_t productID       = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::VersionApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint16_t productID       = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace VersionApplied
namespace DownloadError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
    kBytesDownloaded = 1,
    kProgressPercent = 2,
    kPlatformCode    = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DownloadError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint64_t bytesDownloaded = static_cast<uint64_t>(0);
    DataModel::Nullable<uint8_t> progressPercent;
    DataModel::Nullable<int64_t> platformCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DownloadError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint64_t bytesDownloaded = static_cast<uint64_t>(0);
    DataModel::Nullable<uint8_t> progressPercent;
    DataModel::Nullable<int64_t> platformCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DownloadError
} // namespace Events
} // namespace OtaSoftwareUpdateRequestor
namespace LocalizationConfiguration {

namespace Attributes {

namespace ActiveLocale {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveLocale::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 35; }
};
} // namespace ActiveLocale
namespace SupportedLocales {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedLocales::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedLocales
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActiveLocale::TypeInfo::DecodableType activeLocale;
        Attributes::SupportedLocales::TypeInfo::DecodableType supportedLocales;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LocalizationConfiguration
namespace TimeFormatLocalization {

namespace Attributes {

namespace HourFormat {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeFormatLocalization::HourFormatEnum;
    using DecodableType    = chip::app::Clusters::TimeFormatLocalization::HourFormatEnum;
    using DecodableArgType = chip::app::Clusters::TimeFormatLocalization::HourFormatEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HourFormat::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HourFormat
namespace ActiveCalendarType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum;
    using DecodableType    = chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum;
    using DecodableArgType = chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCalendarType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCalendarType
namespace SupportedCalendarTypes {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedCalendarTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedCalendarTypes
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::HourFormat::TypeInfo::DecodableType hourFormat =
            static_cast<chip::app::Clusters::TimeFormatLocalization::HourFormatEnum>(0);
        Attributes::ActiveCalendarType::TypeInfo::DecodableType activeCalendarType =
            static_cast<chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum>(0);
        Attributes::SupportedCalendarTypes::TypeInfo::DecodableType supportedCalendarTypes;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TimeFormatLocalization
namespace UnitLocalization {

namespace Attributes {

namespace TemperatureUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::UnitLocalization::TempUnitEnum;
    using DecodableType    = chip::app::Clusters::UnitLocalization::TempUnitEnum;
    using DecodableArgType = chip::app::Clusters::UnitLocalization::TempUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureUnit
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureUnit::TypeInfo::DecodableType temperatureUnit =
            static_cast<chip::app::Clusters::UnitLocalization::TempUnitEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace UnitLocalization
namespace PowerSourceConfiguration {

namespace Attributes {

namespace Sources {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Sources::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Sources
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Sources::TypeInfo::DecodableType sources;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PowerSourceConfiguration
namespace PowerSource {
namespace Structs {
namespace BatChargeFaultChangeType {
enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    DataModel::List<const BatChargeFaultEnum> current;
    DataModel::List<const BatChargeFaultEnum> previous;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<BatChargeFaultEnum> current;
    DataModel::DecodableList<BatChargeFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace BatChargeFaultChangeType
namespace BatFaultChangeType {
enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    DataModel::List<const BatFaultEnum> current;
    DataModel::List<const BatFaultEnum> previous;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<BatFaultEnum> current;
    DataModel::DecodableList<BatFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace BatFaultChangeType
namespace WiredFaultChangeType {
enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    DataModel::List<const WiredFaultEnum> current;
    DataModel::List<const WiredFaultEnum> previous;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<WiredFaultEnum> current;
    DataModel::DecodableList<WiredFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace WiredFaultChangeType
} // namespace Structs

namespace Attributes {

namespace Status {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::PowerSourceStatusEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::PowerSourceStatusEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::PowerSourceStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Status
namespace Order {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Order::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Order
namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 60; }
};
} // namespace Description
namespace WiredAssessedInputVoltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedInputVoltage
namespace WiredAssessedInputFrequency {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedInputFrequency
namespace WiredCurrentType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::WiredCurrentTypeEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::WiredCurrentTypeEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::WiredCurrentTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredCurrentType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredCurrentType
namespace WiredAssessedCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedCurrent
namespace WiredNominalVoltage {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredNominalVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredNominalVoltage
namespace WiredMaximumCurrent {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredMaximumCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredMaximumCurrent
namespace WiredPresent {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredPresent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredPresent
namespace ActiveWiredFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::PowerSource::WiredFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::WiredFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::WiredFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveWiredFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveWiredFaults
namespace BatVoltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatVoltage
namespace BatPercentRemaining {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatPercentRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatPercentRemaining
namespace BatTimeRemaining {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatTimeRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatTimeRemaining
namespace BatChargeLevel {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatChargeLevelEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatChargeLevelEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatChargeLevelEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatChargeLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatChargeLevel
namespace BatReplacementNeeded {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatReplacementNeeded::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatReplacementNeeded
namespace BatReplaceability {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatReplaceabilityEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatReplaceabilityEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatReplaceabilityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatReplaceability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatReplaceability
namespace BatPresent {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatPresent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatPresent
namespace ActiveBatFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::PowerSource::BatFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveBatFaults
namespace BatReplacementDescription {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatReplacementDescription::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 60; }
};
} // namespace BatReplacementDescription
namespace BatCommonDesignation {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatCommonDesignationEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatCommonDesignationEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatCommonDesignationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatCommonDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatCommonDesignation
namespace BatANSIDesignation {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatANSIDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 20; }
};
} // namespace BatANSIDesignation
namespace BatIECDesignation {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatIECDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 20; }
};
} // namespace BatIECDesignation
namespace BatApprovedChemistry {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatApprovedChemistryEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatApprovedChemistryEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatApprovedChemistryEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatApprovedChemistry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatApprovedChemistry
namespace BatCapacity {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatCapacity
namespace BatQuantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatQuantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatQuantity
namespace BatChargeState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatChargeStateEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatChargeStateEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatChargeStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatChargeState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatChargeState
namespace BatTimeToFullCharge {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatTimeToFullCharge::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatTimeToFullCharge
namespace BatFunctionalWhileCharging {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatFunctionalWhileCharging::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatFunctionalWhileCharging
namespace BatChargingCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatChargingCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatChargingCurrent
namespace ActiveBatChargeFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::PowerSource::BatChargeFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatChargeFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatChargeFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatChargeFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveBatChargeFaults
namespace EndpointList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndpointList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndpointList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Status::TypeInfo::DecodableType status =
            static_cast<chip::app::Clusters::PowerSource::PowerSourceStatusEnum>(0);
        Attributes::Order::TypeInfo::DecodableType order = static_cast<uint8_t>(0);
        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::WiredAssessedInputVoltage::TypeInfo::DecodableType wiredAssessedInputVoltage;
        Attributes::WiredAssessedInputFrequency::TypeInfo::DecodableType wiredAssessedInputFrequency;
        Attributes::WiredCurrentType::TypeInfo::DecodableType wiredCurrentType =
            static_cast<chip::app::Clusters::PowerSource::WiredCurrentTypeEnum>(0);
        Attributes::WiredAssessedCurrent::TypeInfo::DecodableType wiredAssessedCurrent;
        Attributes::WiredNominalVoltage::TypeInfo::DecodableType wiredNominalVoltage = static_cast<uint32_t>(0);
        Attributes::WiredMaximumCurrent::TypeInfo::DecodableType wiredMaximumCurrent = static_cast<uint32_t>(0);
        Attributes::WiredPresent::TypeInfo::DecodableType wiredPresent               = static_cast<bool>(0);
        Attributes::ActiveWiredFaults::TypeInfo::DecodableType activeWiredFaults;
        Attributes::BatVoltage::TypeInfo::DecodableType batVoltage;
        Attributes::BatPercentRemaining::TypeInfo::DecodableType batPercentRemaining;
        Attributes::BatTimeRemaining::TypeInfo::DecodableType batTimeRemaining;
        Attributes::BatChargeLevel::TypeInfo::DecodableType batChargeLevel =
            static_cast<chip::app::Clusters::PowerSource::BatChargeLevelEnum>(0);
        Attributes::BatReplacementNeeded::TypeInfo::DecodableType batReplacementNeeded = static_cast<bool>(0);
        Attributes::BatReplaceability::TypeInfo::DecodableType batReplaceability =
            static_cast<chip::app::Clusters::PowerSource::BatReplaceabilityEnum>(0);
        Attributes::BatPresent::TypeInfo::DecodableType batPresent = static_cast<bool>(0);
        Attributes::ActiveBatFaults::TypeInfo::DecodableType activeBatFaults;
        Attributes::BatReplacementDescription::TypeInfo::DecodableType batReplacementDescription;
        Attributes::BatCommonDesignation::TypeInfo::DecodableType batCommonDesignation =
            static_cast<chip::app::Clusters::PowerSource::BatCommonDesignationEnum>(0);
        Attributes::BatANSIDesignation::TypeInfo::DecodableType batANSIDesignation;
        Attributes::BatIECDesignation::TypeInfo::DecodableType batIECDesignation;
        Attributes::BatApprovedChemistry::TypeInfo::DecodableType batApprovedChemistry =
            static_cast<chip::app::Clusters::PowerSource::BatApprovedChemistryEnum>(0);
        Attributes::BatCapacity::TypeInfo::DecodableType batCapacity = static_cast<uint32_t>(0);
        Attributes::BatQuantity::TypeInfo::DecodableType batQuantity = static_cast<uint8_t>(0);
        Attributes::BatChargeState::TypeInfo::DecodableType batChargeState =
            static_cast<chip::app::Clusters::PowerSource::BatChargeStateEnum>(0);
        Attributes::BatTimeToFullCharge::TypeInfo::DecodableType batTimeToFullCharge;
        Attributes::BatFunctionalWhileCharging::TypeInfo::DecodableType batFunctionalWhileCharging = static_cast<bool>(0);
        Attributes::BatChargingCurrent::TypeInfo::DecodableType batChargingCurrent;
        Attributes::ActiveBatChargeFaults::TypeInfo::DecodableType activeBatChargeFaults;
        Attributes::EndpointList::TypeInfo::DecodableType endpointList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace WiredFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::WiredFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const WiredFaultEnum> current;
    DataModel::List<const WiredFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::WiredFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

    DataModel::DecodableList<WiredFaultEnum> current;
    DataModel::DecodableList<WiredFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace WiredFaultChange
namespace BatFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const BatFaultEnum> current;
    DataModel::List<const BatFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

    DataModel::DecodableList<BatFaultEnum> current;
    DataModel::DecodableList<BatFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BatFaultChange
namespace BatChargeFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatChargeFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const BatChargeFaultEnum> current;
    DataModel::List<const BatChargeFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatChargeFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

    DataModel::DecodableList<BatChargeFaultEnum> current;
    DataModel::DecodableList<BatChargeFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BatChargeFaultChange
} // namespace Events
} // namespace PowerSource
namespace GeneralCommissioning {
namespace Structs {
namespace BasicCommissioningInfo {
enum class Fields : uint8_t
{
    kFailSafeExpiryLengthSeconds  = 0,
    kMaxCumulativeFailsafeSeconds = 1,
};

struct Type
{
public:
    uint16_t failSafeExpiryLengthSeconds  = static_cast<uint16_t>(0);
    uint16_t maxCumulativeFailsafeSeconds = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace BasicCommissioningInfo
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ArmFailSafe {
struct Type;
struct DecodableType;
} // namespace ArmFailSafe

namespace ArmFailSafeResponse {
struct Type;
struct DecodableType;
} // namespace ArmFailSafeResponse

namespace SetRegulatoryConfig {
struct Type;
struct DecodableType;
} // namespace SetRegulatoryConfig

namespace SetRegulatoryConfigResponse {
struct Type;
struct DecodableType;
} // namespace SetRegulatoryConfigResponse

namespace CommissioningComplete {
struct Type;
struct DecodableType;
} // namespace CommissioningComplete

namespace CommissioningCompleteResponse {
struct Type;
struct DecodableType;
} // namespace CommissioningCompleteResponse

} // namespace Commands

namespace Commands {
namespace ArmFailSafe {
enum class Fields : uint8_t
{
    kExpiryLengthSeconds = 0,
    kBreadcrumb          = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds = static_cast<uint16_t>(0);
    uint64_t breadcrumb          = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds = static_cast<uint16_t>(0);
    uint64_t breadcrumb          = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafe
namespace ArmFailSafeResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafeResponse
namespace SetRegulatoryConfig {
enum class Fields : uint8_t
{
    kNewRegulatoryConfig = 0,
    kCountryCode         = 1,
    kBreadcrumb          = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    RegulatoryLocationTypeEnum newRegulatoryConfig = static_cast<RegulatoryLocationTypeEnum>(0);
    chip::CharSpan countryCode;
    uint64_t breadcrumb = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::SetRegulatoryConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    RegulatoryLocationTypeEnum newRegulatoryConfig = static_cast<RegulatoryLocationTypeEnum>(0);
    chip::CharSpan countryCode;
    uint64_t breadcrumb = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfig
namespace SetRegulatoryConfigResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfigResponse
namespace CommissioningComplete {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningComplete
namespace CommissioningCompleteResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningCompleteResponse
} // namespace Commands

namespace Attributes {

namespace Breadcrumb {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Breadcrumb::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Breadcrumb
namespace BasicCommissioningInfo {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::Type;
    using DecodableType    = chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::DecodableType;
    using DecodableArgType = const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BasicCommissioningInfo::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BasicCommissioningInfo
namespace RegulatoryConfig {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableType    = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableArgType = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RegulatoryConfig::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RegulatoryConfig
namespace LocationCapability {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableType    = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableArgType = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocationCapability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocationCapability
namespace SupportsConcurrentConnection {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportsConcurrentConnection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportsConcurrentConnection
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Breadcrumb::TypeInfo::DecodableType breadcrumb = static_cast<uint64_t>(0);
        Attributes::BasicCommissioningInfo::TypeInfo::DecodableType basicCommissioningInfo;
        Attributes::RegulatoryConfig::TypeInfo::DecodableType regulatoryConfig =
            static_cast<chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum>(0);
        Attributes::LocationCapability::TypeInfo::DecodableType locationCapability =
            static_cast<chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum>(0);
        Attributes::SupportsConcurrentConnection::TypeInfo::DecodableType supportsConcurrentConnection = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace GeneralCommissioning
namespace NetworkCommissioning {
namespace Structs {
namespace NetworkInfoStruct {
enum class Fields : uint8_t
{
    kNetworkID         = 0,
    kConnected         = 1,
    kNetworkIdentifier = 2,
    kClientIdentifier  = 3,
};

struct Type
{
public:
    chip::ByteSpan networkID;
    bool connected = static_cast<bool>(0);
    Optional<DataModel::Nullable<chip::ByteSpan>> networkIdentifier;
    Optional<DataModel::Nullable<chip::ByteSpan>> clientIdentifier;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace NetworkInfoStruct
namespace ThreadInterfaceScanResultStruct {
enum class Fields : uint8_t
{
    kPanId           = 0,
    kExtendedPanId   = 1,
    kNetworkName     = 2,
    kChannel         = 3,
    kVersion         = 4,
    kExtendedAddress = 5,
    kRssi            = 6,
    kLqi             = 7,
};

struct Type
{
public:
    uint16_t panId         = static_cast<uint16_t>(0);
    uint64_t extendedPanId = static_cast<uint64_t>(0);
    chip::CharSpan networkName;
    uint16_t channel = static_cast<uint16_t>(0);
    uint8_t version  = static_cast<uint8_t>(0);
    chip::ByteSpan extendedAddress;
    int8_t rssi = static_cast<int8_t>(0);
    uint8_t lqi = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ThreadInterfaceScanResultStruct
namespace WiFiInterfaceScanResultStruct {
enum class Fields : uint8_t
{
    kSecurity = 0,
    kSsid     = 1,
    kBssid    = 2,
    kChannel  = 3,
    kWiFiBand = 4,
    kRssi     = 5,
};

struct Type
{
public:
    chip::BitMask<WiFiSecurityBitmap> security = static_cast<chip::BitMask<WiFiSecurityBitmap>>(0);
    chip::ByteSpan ssid;
    chip::ByteSpan bssid;
    uint16_t channel      = static_cast<uint16_t>(0);
    WiFiBandEnum wiFiBand = static_cast<WiFiBandEnum>(0);
    int8_t rssi           = static_cast<int8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace WiFiInterfaceScanResultStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ScanNetworks {
struct Type;
struct DecodableType;
} // namespace ScanNetworks

namespace ScanNetworksResponse {
struct Type;
struct DecodableType;
} // namespace ScanNetworksResponse

namespace AddOrUpdateWiFiNetwork {
struct Type;
struct DecodableType;
} // namespace AddOrUpdateWiFiNetwork

namespace AddOrUpdateThreadNetwork {
struct Type;
struct DecodableType;
} // namespace AddOrUpdateThreadNetwork

namespace RemoveNetwork {
struct Type;
struct DecodableType;
} // namespace RemoveNetwork

namespace NetworkConfigResponse {
struct Type;
struct DecodableType;
} // namespace NetworkConfigResponse

namespace ConnectNetwork {
struct Type;
struct DecodableType;
} // namespace ConnectNetwork

namespace ConnectNetworkResponse {
struct Type;
struct DecodableType;
} // namespace ConnectNetworkResponse

namespace ReorderNetwork {
struct Type;
struct DecodableType;
} // namespace ReorderNetwork

namespace QueryIdentity {
struct Type;
struct DecodableType;
} // namespace QueryIdentity

namespace QueryIdentityResponse {
struct Type;
struct DecodableType;
} // namespace QueryIdentityResponse

} // namespace Commands

namespace Commands {
namespace ScanNetworks {
enum class Fields : uint8_t
{
    kSsid       = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    Optional<DataModel::Nullable<chip::ByteSpan>> ssid;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::ScanNetworksResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    Optional<DataModel::Nullable<chip::ByteSpan>> ssid;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworks
namespace ScanNetworksResponse {
enum class Fields : uint8_t
{
    kNetworkingStatus  = 0,
    kDebugText         = 1,
    kWiFiScanResults   = 2,
    kThreadScanResults = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<DataModel::List<const Structs::WiFiInterfaceScanResultStruct::Type>> wiFiScanResults;
    Optional<DataModel::List<const Structs::ThreadInterfaceScanResultStruct::Type>> threadScanResults;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<DataModel::DecodableList<Structs::WiFiInterfaceScanResultStruct::DecodableType>> wiFiScanResults;
    Optional<DataModel::DecodableList<Structs::ThreadInterfaceScanResultStruct::DecodableType>> threadScanResults;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworksResponse
namespace AddOrUpdateWiFiNetwork {
enum class Fields : uint8_t
{
    kSsid             = 0,
    kCredentials      = 1,
    kBreadcrumb       = 2,
    kNetworkIdentity  = 3,
    kClientIdentifier = 4,
    kPossessionNonce  = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    Optional<uint64_t> breadcrumb;
    Optional<chip::ByteSpan> networkIdentity;
    Optional<chip::ByteSpan> clientIdentifier;
    Optional<chip::ByteSpan> possessionNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    Optional<uint64_t> breadcrumb;
    Optional<chip::ByteSpan> networkIdentity;
    Optional<chip::ByteSpan> clientIdentifier;
    Optional<chip::ByteSpan> possessionNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddOrUpdateWiFiNetwork
namespace AddOrUpdateThreadNetwork {
enum class Fields : uint8_t
{
    kOperationalDataset = 0,
    kBreadcrumb         = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddOrUpdateThreadNetwork
namespace RemoveNetwork {
enum class Fields : uint8_t
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveNetwork
namespace NetworkConfigResponse {
enum class Fields : uint8_t
{
    kNetworkingStatus    = 0,
    kDebugText           = 1,
    kNetworkIndex        = 2,
    kClientIdentity      = 3,
    kPossessionSignature = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<uint8_t> networkIndex;
    Optional<chip::ByteSpan> clientIdentity;
    Optional<chip::ByteSpan> possessionSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<uint8_t> networkIndex;
    Optional<chip::ByteSpan> clientIdentity;
    Optional<chip::ByteSpan> possessionSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkConfigResponse
namespace ConnectNetwork {
enum class Fields : uint8_t
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::ConnectNetworkResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConnectNetwork
namespace ConnectNetworkResponse {
enum class Fields : uint8_t
{
    kNetworkingStatus = 0,
    kDebugText        = 1,
    kErrorValue       = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    DataModel::Nullable<int32_t> errorValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    DataModel::Nullable<int32_t> errorValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConnectNetworkResponse
namespace ReorderNetwork {
enum class Fields : uint8_t
{
    kNetworkID    = 0,
    kNetworkIndex = 1,
    kBreadcrumb   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReorderNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint8_t networkIndex = static_cast<uint8_t>(0);
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReorderNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint8_t networkIndex = static_cast<uint8_t>(0);
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReorderNetwork
namespace QueryIdentity {
enum class Fields : uint8_t
{
    kKeyIdentifier   = 0,
    kPossessionNonce = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentity::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan keyIdentifier;
    Optional<chip::ByteSpan> possessionNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::QueryIdentityResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentity::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan keyIdentifier;
    Optional<chip::ByteSpan> possessionNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryIdentity
namespace QueryIdentityResponse {
enum class Fields : uint8_t
{
    kIdentity            = 0,
    kPossessionSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentityResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan identity;
    Optional<chip::ByteSpan> possessionSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentityResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan identity;
    Optional<chip::ByteSpan> possessionSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryIdentityResponse
} // namespace Commands

namespace Attributes {

namespace MaxNetworks {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxNetworks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxNetworks
namespace Networks {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfoStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Networks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Networks
namespace ScanMaxTimeSeconds {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScanMaxTimeSeconds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScanMaxTimeSeconds
namespace ConnectMaxTimeSeconds {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConnectMaxTimeSeconds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ConnectMaxTimeSeconds
namespace InterfaceEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterfaceEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterfaceEnabled
namespace LastNetworkingStatus {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatusEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatusEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatusEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastNetworkingStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastNetworkingStatus
namespace LastNetworkID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastNetworkID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace LastNetworkID
namespace LastConnectErrorValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConnectErrorValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastConnectErrorValue
namespace SupportedWiFiBands {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::NetworkCommissioning::WiFiBandEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::WiFiBandEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::WiFiBandEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedWiFiBands::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedWiFiBands
namespace SupportedThreadFeatures {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedThreadFeatures::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedThreadFeatures
namespace ThreadVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadVersion
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxNetworks::TypeInfo::DecodableType maxNetworks = static_cast<uint8_t>(0);
        Attributes::Networks::TypeInfo::DecodableType networks;
        Attributes::ScanMaxTimeSeconds::TypeInfo::DecodableType scanMaxTimeSeconds       = static_cast<uint8_t>(0);
        Attributes::ConnectMaxTimeSeconds::TypeInfo::DecodableType connectMaxTimeSeconds = static_cast<uint8_t>(0);
        Attributes::InterfaceEnabled::TypeInfo::DecodableType interfaceEnabled           = static_cast<bool>(0);
        Attributes::LastNetworkingStatus::TypeInfo::DecodableType lastNetworkingStatus;
        Attributes::LastNetworkID::TypeInfo::DecodableType lastNetworkID;
        Attributes::LastConnectErrorValue::TypeInfo::DecodableType lastConnectErrorValue;
        Attributes::SupportedWiFiBands::TypeInfo::DecodableType supportedWiFiBands;
        Attributes::SupportedThreadFeatures::TypeInfo::DecodableType supportedThreadFeatures =
            static_cast<chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>>(0);
        Attributes::ThreadVersion::TypeInfo::DecodableType threadVersion = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace NetworkCommissioning
namespace DiagnosticLogs {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RetrieveLogsRequest {
struct Type;
struct DecodableType;
} // namespace RetrieveLogsRequest

namespace RetrieveLogsResponse {
struct Type;
struct DecodableType;
} // namespace RetrieveLogsResponse

} // namespace Commands

namespace Commands {
namespace RetrieveLogsRequest {
enum class Fields : uint8_t
{
    kIntent                 = 0,
    kRequestedProtocol      = 1,
    kTransferFileDesignator = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    IntentEnum intent                      = static_cast<IntentEnum>(0);
    TransferProtocolEnum requestedProtocol = static_cast<TransferProtocolEnum>(0);
    Optional<chip::CharSpan> transferFileDesignator;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DiagnosticLogs::Commands::RetrieveLogsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    IntentEnum intent                      = static_cast<IntentEnum>(0);
    TransferProtocolEnum requestedProtocol = static_cast<TransferProtocolEnum>(0);
    Optional<chip::CharSpan> transferFileDesignator;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsRequest
namespace RetrieveLogsResponse {
enum class Fields : uint8_t
{
    kStatus        = 0,
    kLogContent    = 1,
    kUTCTimeStamp  = 2,
    kTimeSinceBoot = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    chip::ByteSpan logContent;
    Optional<uint64_t> UTCTimeStamp;
    Optional<uint64_t> timeSinceBoot;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    chip::ByteSpan logContent;
    Optional<uint64_t> UTCTimeStamp;
    Optional<uint64_t> timeSinceBoot;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsResponse
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace DiagnosticLogs
namespace GeneralDiagnostics {
namespace Structs {
namespace NetworkInterface {
enum class Fields : uint8_t
{
    kName                            = 0,
    kIsOperational                   = 1,
    kOffPremiseServicesReachableIPv4 = 2,
    kOffPremiseServicesReachableIPv6 = 3,
    kHardwareAddress                 = 4,
    kIPv4Addresses                   = 5,
    kIPv6Addresses                   = 6,
    kType                            = 7,
};

struct Type
{
public:
    chip::CharSpan name;
    bool isOperational = static_cast<bool>(0);
    DataModel::Nullable<bool> offPremiseServicesReachableIPv4;
    DataModel::Nullable<bool> offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    DataModel::List<const chip::ByteSpan> IPv4Addresses;
    DataModel::List<const chip::ByteSpan> IPv6Addresses;
    InterfaceTypeEnum type = static_cast<InterfaceTypeEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan name;
    bool isOperational = static_cast<bool>(0);
    DataModel::Nullable<bool> offPremiseServicesReachableIPv4;
    DataModel::Nullable<bool> offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    DataModel::DecodableList<chip::ByteSpan> IPv4Addresses;
    DataModel::DecodableList<chip::ByteSpan> IPv6Addresses;
    InterfaceTypeEnum type = static_cast<InterfaceTypeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace NetworkInterface
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace TestEventTrigger {
struct Type;
struct DecodableType;
} // namespace TestEventTrigger

namespace TimeSnapshot {
struct Type;
struct DecodableType;
} // namespace TimeSnapshot

namespace TimeSnapshotResponse {
struct Type;
struct DecodableType;
} // namespace TimeSnapshotResponse

namespace PayloadTestRequest {
struct Type;
struct DecodableType;
} // namespace PayloadTestRequest

namespace PayloadTestResponse {
struct Type;
struct DecodableType;
} // namespace PayloadTestResponse

} // namespace Commands

namespace Commands {
namespace TestEventTrigger {
enum class Fields : uint8_t
{
    kEnableKey    = 0,
    kEventTrigger = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEventTrigger::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint64_t eventTrigger = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEventTrigger::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint64_t eventTrigger = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEventTrigger
namespace TimeSnapshot {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshot::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralDiagnostics::Commands::TimeSnapshotResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshot::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimeSnapshot
namespace TimeSnapshotResponse {
enum class Fields : uint8_t
{
    kSystemTimeMs = 0,
    kPosixTimeMs  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshotResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    uint64_t systemTimeMs = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> posixTimeMs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshotResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    uint64_t systemTimeMs = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> posixTimeMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimeSnapshotResponse
namespace PayloadTestRequest {
enum class Fields : uint8_t
{
    kEnableKey = 0,
    kValue     = 1,
    kCount     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint8_t value  = static_cast<uint8_t>(0);
    uint16_t count = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralDiagnostics::Commands::PayloadTestResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint8_t value  = static_cast<uint8_t>(0);
    uint16_t count = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PayloadTestRequest
namespace PayloadTestResponse {
enum class Fields : uint8_t
{
    kPayload = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PayloadTestResponse
} // namespace Commands

namespace Attributes {

namespace NetworkInterfaces {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterface::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterface::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterface::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkInterfaces::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NetworkInterfaces
namespace RebootCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RebootCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RebootCount
namespace UpTime {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpTime
namespace TotalOperationalHours {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalOperationalHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalOperationalHours
namespace BootReason {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralDiagnostics::BootReasonEnum;
    using DecodableType    = chip::app::Clusters::GeneralDiagnostics::BootReasonEnum;
    using DecodableArgType = chip::app::Clusters::GeneralDiagnostics::BootReasonEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BootReason::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BootReason
namespace ActiveHardwareFaults {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::HardwareFaultEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::HardwareFaultEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::HardwareFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveHardwareFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveHardwareFaults
namespace ActiveRadioFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::RadioFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::RadioFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::RadioFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveRadioFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveRadioFaults
namespace ActiveNetworkFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::NetworkFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::NetworkFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::NetworkFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveNetworkFaults
namespace TestEventTriggersEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TestEventTriggersEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TestEventTriggersEnabled
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NetworkInterfaces::TypeInfo::DecodableType networkInterfaces;
        Attributes::RebootCount::TypeInfo::DecodableType rebootCount                     = static_cast<uint16_t>(0);
        Attributes::UpTime::TypeInfo::DecodableType upTime                               = static_cast<uint64_t>(0);
        Attributes::TotalOperationalHours::TypeInfo::DecodableType totalOperationalHours = static_cast<uint32_t>(0);
        Attributes::BootReason::TypeInfo::DecodableType bootReason =
            static_cast<chip::app::Clusters::GeneralDiagnostics::BootReasonEnum>(0);
        Attributes::ActiveHardwareFaults::TypeInfo::DecodableType activeHardwareFaults;
        Attributes::ActiveRadioFaults::TypeInfo::DecodableType activeRadioFaults;
        Attributes::ActiveNetworkFaults::TypeInfo::DecodableType activeNetworkFaults;
        Attributes::TestEventTriggersEnabled::TypeInfo::DecodableType testEventTriggersEnabled = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace HardwareFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const HardwareFaultEnum> current;
    DataModel::List<const HardwareFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<HardwareFaultEnum> current;
    DataModel::DecodableList<HardwareFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace HardwareFaultChange
namespace RadioFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RadioFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const RadioFaultEnum> current;
    DataModel::List<const RadioFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RadioFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<RadioFaultEnum> current;
    DataModel::DecodableList<RadioFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace RadioFaultChange
namespace NetworkFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const NetworkFaultEnum> current;
    DataModel::List<const NetworkFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<NetworkFaultEnum> current;
    DataModel::DecodableList<NetworkFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace NetworkFaultChange
namespace BootReason {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kBootReason = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BootReason::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    BootReasonEnum bootReason = static_cast<BootReasonEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BootReason::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    BootReasonEnum bootReason = static_cast<BootReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BootReason
} // namespace Events
} // namespace GeneralDiagnostics
namespace SoftwareDiagnostics {
namespace Structs {
namespace ThreadMetricsStruct {
enum class Fields : uint8_t
{
    kId               = 0,
    kName             = 1,
    kStackFreeCurrent = 2,
    kStackFreeMinimum = 3,
    kStackSize        = 4,
};

struct Type
{
public:
    uint64_t id = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;
    Optional<uint32_t> stackFreeCurrent;
    Optional<uint32_t> stackFreeMinimum;
    Optional<uint32_t> stackSize;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ThreadMetricsStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetWatermarks {
struct Type;
struct DecodableType;
} // namespace ResetWatermarks

} // namespace Commands

namespace Commands {
namespace ResetWatermarks {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetWatermarks
} // namespace Commands

namespace Attributes {

namespace ThreadMetrics {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetricsStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetricsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetricsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadMetrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadMetrics
namespace CurrentHeapFree {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapFree::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapFree
namespace CurrentHeapUsed {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapUsed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapUsed
namespace CurrentHeapHighWatermark {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapHighWatermark::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapHighWatermark
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ThreadMetrics::TypeInfo::DecodableType threadMetrics;
        Attributes::CurrentHeapFree::TypeInfo::DecodableType currentHeapFree                   = static_cast<uint64_t>(0);
        Attributes::CurrentHeapUsed::TypeInfo::DecodableType currentHeapUsed                   = static_cast<uint64_t>(0);
        Attributes::CurrentHeapHighWatermark::TypeInfo::DecodableType currentHeapHighWatermark = static_cast<uint64_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SoftwareFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kId             = 0,
    kName           = 1,
    kFaultRecording = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SoftwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint64_t id = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> faultRecording;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SoftwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    uint64_t id = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> faultRecording;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SoftwareFault
} // namespace Events
} // namespace SoftwareDiagnostics
namespace ThreadNetworkDiagnostics {
namespace Structs {
namespace NeighborTableStruct {
enum class Fields : uint8_t
{
    kExtAddress       = 0,
    kAge              = 1,
    kRloc16           = 2,
    kLinkFrameCounter = 3,
    kMleFrameCounter  = 4,
    kLqi              = 5,
    kAverageRssi      = 6,
    kLastRssi         = 7,
    kFrameErrorRate   = 8,
    kMessageErrorRate = 9,
    kRxOnWhenIdle     = 10,
    kFullThreadDevice = 11,
    kFullNetworkData  = 12,
    kIsChild          = 13,
};

struct Type
{
public:
    uint64_t extAddress       = static_cast<uint64_t>(0);
    uint32_t age              = static_cast<uint32_t>(0);
    uint16_t rloc16           = static_cast<uint16_t>(0);
    uint32_t linkFrameCounter = static_cast<uint32_t>(0);
    uint32_t mleFrameCounter  = static_cast<uint32_t>(0);
    uint8_t lqi               = static_cast<uint8_t>(0);
    DataModel::Nullable<int8_t> averageRssi;
    DataModel::Nullable<int8_t> lastRssi;
    uint8_t frameErrorRate   = static_cast<uint8_t>(0);
    uint8_t messageErrorRate = static_cast<uint8_t>(0);
    bool rxOnWhenIdle        = static_cast<bool>(0);
    bool fullThreadDevice    = static_cast<bool>(0);
    bool fullNetworkData     = static_cast<bool>(0);
    bool isChild             = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace NeighborTableStruct
namespace OperationalDatasetComponents {
enum class Fields : uint8_t
{
    kActiveTimestampPresent  = 0,
    kPendingTimestampPresent = 1,
    kMasterKeyPresent        = 2,
    kNetworkNamePresent      = 3,
    kExtendedPanIdPresent    = 4,
    kMeshLocalPrefixPresent  = 5,
    kDelayPresent            = 6,
    kPanIdPresent            = 7,
    kChannelPresent          = 8,
    kPskcPresent             = 9,
    kSecurityPolicyPresent   = 10,
    kChannelMaskPresent      = 11,
};

struct Type
{
public:
    bool activeTimestampPresent  = static_cast<bool>(0);
    bool pendingTimestampPresent = static_cast<bool>(0);
    bool masterKeyPresent        = static_cast<bool>(0);
    bool networkNamePresent      = static_cast<bool>(0);
    bool extendedPanIdPresent    = static_cast<bool>(0);
    bool meshLocalPrefixPresent  = static_cast<bool>(0);
    bool delayPresent            = static_cast<bool>(0);
    bool panIdPresent            = static_cast<bool>(0);
    bool channelPresent          = static_cast<bool>(0);
    bool pskcPresent             = static_cast<bool>(0);
    bool securityPolicyPresent   = static_cast<bool>(0);
    bool channelMaskPresent      = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OperationalDatasetComponents
namespace RouteTableStruct {
enum class Fields : uint8_t
{
    kExtAddress      = 0,
    kRloc16          = 1,
    kRouterId        = 2,
    kNextHop         = 3,
    kPathCost        = 4,
    kLQIIn           = 5,
    kLQIOut          = 6,
    kAge             = 7,
    kAllocated       = 8,
    kLinkEstablished = 9,
};

struct Type
{
public:
    uint64_t extAddress  = static_cast<uint64_t>(0);
    uint16_t rloc16      = static_cast<uint16_t>(0);
    uint8_t routerId     = static_cast<uint8_t>(0);
    uint8_t nextHop      = static_cast<uint8_t>(0);
    uint8_t pathCost     = static_cast<uint8_t>(0);
    uint8_t LQIIn        = static_cast<uint8_t>(0);
    uint8_t LQIOut       = static_cast<uint8_t>(0);
    uint8_t age          = static_cast<uint8_t>(0);
    bool allocated       = static_cast<bool>(0);
    bool linkEstablished = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace RouteTableStruct
namespace SecurityPolicy {
enum class Fields : uint8_t
{
    kRotationTime = 0,
    kFlags        = 1,
};

struct Type
{
public:
    uint16_t rotationTime = static_cast<uint16_t>(0);
    uint16_t flags        = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SecurityPolicy
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace Channel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Channel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Channel
namespace RoutingRole {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRoleEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRoleEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRoleEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RoutingRole::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RoutingRole
namespace NetworkName {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace NetworkName
namespace PanId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PanId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PanId
namespace ExtendedPanId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExtendedPanId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExtendedPanId
namespace MeshLocalPrefix {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeshLocalPrefix::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 17; }
};
} // namespace MeshLocalPrefix
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace NeighborTable {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTableStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTableStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTableStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeighborTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeighborTable
namespace RouteTable {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTableStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTableStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTableStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouteTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RouteTable
namespace PartitionId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartitionId
namespace Weighting {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Weighting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Weighting
namespace DataVersion {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DataVersion
namespace StableDataVersion {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StableDataVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StableDataVersion
namespace LeaderRouterId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRouterId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LeaderRouterId
namespace DetachedRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DetachedRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DetachedRoleCount
namespace ChildRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChildRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChildRoleCount
namespace RouterRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouterRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RouterRoleCount
namespace LeaderRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LeaderRoleCount
namespace AttachAttemptCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttachAttemptCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttachAttemptCount
namespace PartitionIdChangeCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionIdChangeCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartitionIdChangeCount
namespace BetterPartitionAttachAttemptCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BetterPartitionAttachAttemptCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BetterPartitionAttachAttemptCount
namespace ParentChangeCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ParentChangeCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ParentChangeCount
namespace TxTotalCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxTotalCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxTotalCount
namespace TxUnicastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxUnicastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxUnicastCount
namespace TxBroadcastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBroadcastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBroadcastCount
namespace TxAckRequestedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckRequestedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxAckRequestedCount
namespace TxAckedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxAckedCount
namespace TxNoAckRequestedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxNoAckRequestedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxNoAckRequestedCount
namespace TxDataCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDataCount
namespace TxDataPollCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataPollCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDataPollCount
namespace TxBeaconCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBeaconCount
namespace TxBeaconRequestCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconRequestCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBeaconRequestCount
namespace TxOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxOtherCount
namespace TxRetryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxRetryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxRetryCount
namespace TxDirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDirectMaxRetryExpiryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDirectMaxRetryExpiryCount
namespace TxIndirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxIndirectMaxRetryExpiryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxIndirectMaxRetryExpiryCount
namespace TxErrCcaCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCcaCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrCcaCount
namespace TxErrAbortCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrAbortCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrAbortCount
namespace TxErrBusyChannelCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrBusyChannelCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrBusyChannelCount
namespace RxTotalCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxTotalCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxTotalCount
namespace RxUnicastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxUnicastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxUnicastCount
namespace RxBroadcastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBroadcastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBroadcastCount
namespace RxDataCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDataCount
namespace RxDataPollCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataPollCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDataPollCount
namespace RxBeaconCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBeaconCount
namespace RxBeaconRequestCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconRequestCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBeaconRequestCount
namespace RxOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxOtherCount
namespace RxAddressFilteredCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxAddressFilteredCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxAddressFilteredCount
namespace RxDestAddrFilteredCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDestAddrFilteredCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDestAddrFilteredCount
namespace RxDuplicatedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDuplicatedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDuplicatedCount
namespace RxErrNoFrameCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrNoFrameCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrNoFrameCount
namespace RxErrUnknownNeighborCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrUnknownNeighborCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrUnknownNeighborCount
namespace RxErrInvalidSrcAddrCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrInvalidSrcAddrCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrInvalidSrcAddrCount
namespace RxErrSecCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrSecCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrSecCount
namespace RxErrFcsCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrFcsCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrFcsCount
namespace RxErrOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrOtherCount
namespace ActiveTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveTimestamp
namespace PendingTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PendingTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PendingTimestamp
namespace Delay {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Delay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Delay
namespace SecurityPolicy {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityPolicy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SecurityPolicy
namespace ChannelPage0Mask {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelPage0Mask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 4; }
};
} // namespace ChannelPage0Mask
namespace OperationalDatasetComponents {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalDatasetComponents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalDatasetComponents
namespace ActiveNetworkFaultsList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFaultEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFaultEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaultsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveNetworkFaultsList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Channel::TypeInfo::DecodableType channel;
        Attributes::RoutingRole::TypeInfo::DecodableType routingRole;
        Attributes::NetworkName::TypeInfo::DecodableType networkName;
        Attributes::PanId::TypeInfo::DecodableType panId;
        Attributes::ExtendedPanId::TypeInfo::DecodableType extendedPanId;
        Attributes::MeshLocalPrefix::TypeInfo::DecodableType meshLocalPrefix;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount = static_cast<uint64_t>(0);
        Attributes::NeighborTable::TypeInfo::DecodableType neighborTable;
        Attributes::RouteTable::TypeInfo::DecodableType routeTable;
        Attributes::PartitionId::TypeInfo::DecodableType partitionId;
        Attributes::Weighting::TypeInfo::DecodableType weighting;
        Attributes::DataVersion::TypeInfo::DecodableType dataVersion;
        Attributes::StableDataVersion::TypeInfo::DecodableType stableDataVersion;
        Attributes::LeaderRouterId::TypeInfo::DecodableType leaderRouterId;
        Attributes::DetachedRoleCount::TypeInfo::DecodableType detachedRoleCount           = static_cast<uint16_t>(0);
        Attributes::ChildRoleCount::TypeInfo::DecodableType childRoleCount                 = static_cast<uint16_t>(0);
        Attributes::RouterRoleCount::TypeInfo::DecodableType routerRoleCount               = static_cast<uint16_t>(0);
        Attributes::LeaderRoleCount::TypeInfo::DecodableType leaderRoleCount               = static_cast<uint16_t>(0);
        Attributes::AttachAttemptCount::TypeInfo::DecodableType attachAttemptCount         = static_cast<uint16_t>(0);
        Attributes::PartitionIdChangeCount::TypeInfo::DecodableType partitionIdChangeCount = static_cast<uint16_t>(0);
        Attributes::BetterPartitionAttachAttemptCount::TypeInfo::DecodableType betterPartitionAttachAttemptCount =
            static_cast<uint16_t>(0);
        Attributes::ParentChangeCount::TypeInfo::DecodableType parentChangeCount                         = static_cast<uint16_t>(0);
        Attributes::TxTotalCount::TypeInfo::DecodableType txTotalCount                                   = static_cast<uint32_t>(0);
        Attributes::TxUnicastCount::TypeInfo::DecodableType txUnicastCount                               = static_cast<uint32_t>(0);
        Attributes::TxBroadcastCount::TypeInfo::DecodableType txBroadcastCount                           = static_cast<uint32_t>(0);
        Attributes::TxAckRequestedCount::TypeInfo::DecodableType txAckRequestedCount                     = static_cast<uint32_t>(0);
        Attributes::TxAckedCount::TypeInfo::DecodableType txAckedCount                                   = static_cast<uint32_t>(0);
        Attributes::TxNoAckRequestedCount::TypeInfo::DecodableType txNoAckRequestedCount                 = static_cast<uint32_t>(0);
        Attributes::TxDataCount::TypeInfo::DecodableType txDataCount                                     = static_cast<uint32_t>(0);
        Attributes::TxDataPollCount::TypeInfo::DecodableType txDataPollCount                             = static_cast<uint32_t>(0);
        Attributes::TxBeaconCount::TypeInfo::DecodableType txBeaconCount                                 = static_cast<uint32_t>(0);
        Attributes::TxBeaconRequestCount::TypeInfo::DecodableType txBeaconRequestCount                   = static_cast<uint32_t>(0);
        Attributes::TxOtherCount::TypeInfo::DecodableType txOtherCount                                   = static_cast<uint32_t>(0);
        Attributes::TxRetryCount::TypeInfo::DecodableType txRetryCount                                   = static_cast<uint32_t>(0);
        Attributes::TxDirectMaxRetryExpiryCount::TypeInfo::DecodableType txDirectMaxRetryExpiryCount     = static_cast<uint32_t>(0);
        Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo::DecodableType txIndirectMaxRetryExpiryCount = static_cast<uint32_t>(0);
        Attributes::TxErrCcaCount::TypeInfo::DecodableType txErrCcaCount                                 = static_cast<uint32_t>(0);
        Attributes::TxErrAbortCount::TypeInfo::DecodableType txErrAbortCount                             = static_cast<uint32_t>(0);
        Attributes::TxErrBusyChannelCount::TypeInfo::DecodableType txErrBusyChannelCount                 = static_cast<uint32_t>(0);
        Attributes::RxTotalCount::TypeInfo::DecodableType rxTotalCount                                   = static_cast<uint32_t>(0);
        Attributes::RxUnicastCount::TypeInfo::DecodableType rxUnicastCount                               = static_cast<uint32_t>(0);
        Attributes::RxBroadcastCount::TypeInfo::DecodableType rxBroadcastCount                           = static_cast<uint32_t>(0);
        Attributes::RxDataCount::TypeInfo::DecodableType rxDataCount                                     = static_cast<uint32_t>(0);
        Attributes::RxDataPollCount::TypeInfo::DecodableType rxDataPollCount                             = static_cast<uint32_t>(0);
        Attributes::RxBeaconCount::TypeInfo::DecodableType rxBeaconCount                                 = static_cast<uint32_t>(0);
        Attributes::RxBeaconRequestCount::TypeInfo::DecodableType rxBeaconRequestCount                   = static_cast<uint32_t>(0);
        Attributes::RxOtherCount::TypeInfo::DecodableType rxOtherCount                                   = static_cast<uint32_t>(0);
        Attributes::RxAddressFilteredCount::TypeInfo::DecodableType rxAddressFilteredCount               = static_cast<uint32_t>(0);
        Attributes::RxDestAddrFilteredCount::TypeInfo::DecodableType rxDestAddrFilteredCount             = static_cast<uint32_t>(0);
        Attributes::RxDuplicatedCount::TypeInfo::DecodableType rxDuplicatedCount                         = static_cast<uint32_t>(0);
        Attributes::RxErrNoFrameCount::TypeInfo::DecodableType rxErrNoFrameCount                         = static_cast<uint32_t>(0);
        Attributes::RxErrUnknownNeighborCount::TypeInfo::DecodableType rxErrUnknownNeighborCount         = static_cast<uint32_t>(0);
        Attributes::RxErrInvalidSrcAddrCount::TypeInfo::DecodableType rxErrInvalidSrcAddrCount           = static_cast<uint32_t>(0);
        Attributes::RxErrSecCount::TypeInfo::DecodableType rxErrSecCount                                 = static_cast<uint32_t>(0);
        Attributes::RxErrFcsCount::TypeInfo::DecodableType rxErrFcsCount                                 = static_cast<uint32_t>(0);
        Attributes::RxErrOtherCount::TypeInfo::DecodableType rxErrOtherCount                             = static_cast<uint32_t>(0);
        Attributes::ActiveTimestamp::TypeInfo::DecodableType activeTimestamp;
        Attributes::PendingTimestamp::TypeInfo::DecodableType pendingTimestamp;
        Attributes::Delay::TypeInfo::DecodableType delay;
        Attributes::SecurityPolicy::TypeInfo::DecodableType securityPolicy;
        Attributes::ChannelPage0Mask::TypeInfo::DecodableType channelPage0Mask;
        Attributes::OperationalDatasetComponents::TypeInfo::DecodableType operationalDatasetComponents;
        Attributes::ActiveNetworkFaultsList::TypeInfo::DecodableType activeNetworkFaultsList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace ConnectionStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kConnectionStatus = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ConnectionStatus
namespace NetworkFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const NetworkFaultEnum> current;
    DataModel::List<const NetworkFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    DataModel::DecodableList<NetworkFaultEnum> current;
    DataModel::DecodableList<NetworkFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace NetworkFaultChange
} // namespace Events
} // namespace ThreadNetworkDiagnostics
namespace WiFiNetworkDiagnostics {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace Bssid {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bssid::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 6; }
};
} // namespace Bssid
namespace SecurityType {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SecurityType
namespace WiFiVersion {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiFiVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiFiVersion
namespace ChannelNumber {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelNumber
namespace Rssi {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Rssi::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Rssi
namespace BeaconLostCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconLostCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BeaconLostCount
namespace BeaconRxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BeaconRxCount
namespace PacketMulticastRxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketMulticastRxCount
namespace PacketMulticastTxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketMulticastTxCount
namespace PacketUnicastRxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketUnicastRxCount
namespace PacketUnicastTxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketUnicastTxCount
namespace CurrentMaxRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMaxRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMaxRate
namespace OverrunCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Bssid::TypeInfo::DecodableType bssid;
        Attributes::SecurityType::TypeInfo::DecodableType securityType;
        Attributes::WiFiVersion::TypeInfo::DecodableType wiFiVersion;
        Attributes::ChannelNumber::TypeInfo::DecodableType channelNumber;
        Attributes::Rssi::TypeInfo::DecodableType rssi;
        Attributes::BeaconLostCount::TypeInfo::DecodableType beaconLostCount;
        Attributes::BeaconRxCount::TypeInfo::DecodableType beaconRxCount;
        Attributes::PacketMulticastRxCount::TypeInfo::DecodableType packetMulticastRxCount;
        Attributes::PacketMulticastTxCount::TypeInfo::DecodableType packetMulticastTxCount;
        Attributes::PacketUnicastRxCount::TypeInfo::DecodableType packetUnicastRxCount;
        Attributes::PacketUnicastTxCount::TypeInfo::DecodableType packetUnicastTxCount;
        Attributes::CurrentMaxRate::TypeInfo::DecodableType currentMaxRate;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace Disconnection {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kReasonCode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Disconnection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t reasonCode = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Disconnection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    uint16_t reasonCode = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Disconnection
namespace AssociationFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAssociationFailureCause = 0,
    kStatus                  = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AssociationFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    AssociationFailureCauseEnum associationFailureCause = static_cast<AssociationFailureCauseEnum>(0);
    uint16_t status                                     = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AssociationFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    AssociationFailureCauseEnum associationFailureCause = static_cast<AssociationFailureCauseEnum>(0);
    uint16_t status                                     = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AssociationFailure
namespace ConnectionStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kConnectionStatus = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ConnectionStatus
} // namespace Events
} // namespace WiFiNetworkDiagnostics
namespace EthernetNetworkDiagnostics {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace PHYRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PHYRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PHYRate
namespace FullDuplex {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FullDuplex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FullDuplex
namespace PacketRxCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketRxCount
namespace PacketTxCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketTxCount
namespace TxErrCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrCount
namespace CollisionCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CollisionCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CollisionCount
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace CarrierDetect {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CarrierDetect::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CarrierDetect
namespace TimeSinceReset {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeSinceReset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeSinceReset
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PHYRate::TypeInfo::DecodableType PHYRate;
        Attributes::FullDuplex::TypeInfo::DecodableType fullDuplex;
        Attributes::PacketRxCount::TypeInfo::DecodableType packetRxCount   = static_cast<uint64_t>(0);
        Attributes::PacketTxCount::TypeInfo::DecodableType packetTxCount   = static_cast<uint64_t>(0);
        Attributes::TxErrCount::TypeInfo::DecodableType txErrCount         = static_cast<uint64_t>(0);
        Attributes::CollisionCount::TypeInfo::DecodableType collisionCount = static_cast<uint64_t>(0);
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount     = static_cast<uint64_t>(0);
        Attributes::CarrierDetect::TypeInfo::DecodableType carrierDetect;
        Attributes::TimeSinceReset::TypeInfo::DecodableType timeSinceReset = static_cast<uint64_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EthernetNetworkDiagnostics
namespace TimeSynchronization {
namespace Structs {
namespace DSTOffsetStruct {
enum class Fields : uint8_t
{
    kOffset        = 0,
    kValidStarting = 1,
    kValidUntil    = 2,
};

struct Type
{
public:
    int32_t offset         = static_cast<int32_t>(0);
    uint64_t validStarting = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> validUntil;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DSTOffsetStruct
namespace FabricScopedTrustedTimeSourceStruct {
enum class Fields : uint8_t
{
    kNodeID   = 0,
    kEndpoint = 1,
};

struct Type
{
public:
    chip::NodeId nodeID       = static_cast<chip::NodeId>(0);
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace FabricScopedTrustedTimeSourceStruct
namespace TimeZoneStruct {
enum class Fields : uint8_t
{
    kOffset  = 0,
    kValidAt = 1,
    kName    = 2,
};

struct Type
{
public:
    int32_t offset   = static_cast<int32_t>(0);
    uint64_t validAt = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TimeZoneStruct
namespace TrustedTimeSourceStruct {
enum class Fields : uint8_t
{
    kFabricIndex = 0,
    kNodeID      = 1,
    kEndpoint    = 2,
};

struct Type
{
public:
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    chip::NodeId nodeID           = static_cast<chip::NodeId>(0);
    chip::EndpointId endpoint     = static_cast<chip::EndpointId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TrustedTimeSourceStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetUTCTime {
struct Type;
struct DecodableType;
} // namespace SetUTCTime

namespace SetTrustedTimeSource {
struct Type;
struct DecodableType;
} // namespace SetTrustedTimeSource

namespace SetTimeZone {
struct Type;
struct DecodableType;
} // namespace SetTimeZone

namespace SetTimeZoneResponse {
struct Type;
struct DecodableType;
} // namespace SetTimeZoneResponse

namespace SetDSTOffset {
struct Type;
struct DecodableType;
} // namespace SetDSTOffset

namespace SetDefaultNTP {
struct Type;
struct DecodableType;
} // namespace SetDefaultNTP

} // namespace Commands

namespace Commands {
namespace SetUTCTime {
enum class Fields : uint8_t
{
    kUTCTime     = 0,
    kGranularity = 1,
    kTimeSource  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUTCTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    uint64_t UTCTime            = static_cast<uint64_t>(0);
    GranularityEnum granularity = static_cast<GranularityEnum>(0);
    Optional<TimeSourceEnum> timeSource;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUTCTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    uint64_t UTCTime            = static_cast<uint64_t>(0);
    GranularityEnum granularity = static_cast<GranularityEnum>(0);
    Optional<TimeSourceEnum> timeSource;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUTCTime
namespace SetTrustedTimeSource {
enum class Fields : uint8_t
{
    kTrustedTimeSource = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<Structs::FabricScopedTrustedTimeSourceStruct::Type> trustedTimeSource;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<Structs::FabricScopedTrustedTimeSourceStruct::DecodableType> trustedTimeSource;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTrustedTimeSource
namespace SetTimeZone {
enum class Fields : uint8_t
{
    kTimeZone = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::List<const Structs::TimeZoneStruct::Type> timeZone;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TimeSynchronization::Commands::SetTimeZoneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::DecodableList<Structs::TimeZoneStruct::DecodableType> timeZone;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTimeZone
namespace SetTimeZoneResponse {
enum class Fields : uint8_t
{
    kDSTOffsetRequired = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    bool DSTOffsetRequired = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    bool DSTOffsetRequired = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTimeZoneResponse
namespace SetDSTOffset {
enum class Fields : uint8_t
{
    kDSTOffset = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetDSTOffset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::List<const Structs::DSTOffsetStruct::Type> DSTOffset;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetDSTOffset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::DecodableList<Structs::DSTOffsetStruct::DecodableType> DSTOffset;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetDSTOffset
namespace SetDefaultNTP {
enum class Fields : uint8_t
{
    kDefaultNTP = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetDefaultNTP::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<chip::CharSpan> defaultNTP;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetDefaultNTP::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<chip::CharSpan> defaultNTP;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetDefaultNTP
} // namespace Commands

namespace Attributes {

namespace UTCTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UTCTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UTCTime
namespace Granularity {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeSynchronization::GranularityEnum;
    using DecodableType    = chip::app::Clusters::TimeSynchronization::GranularityEnum;
    using DecodableArgType = chip::app::Clusters::TimeSynchronization::GranularityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Granularity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Granularity
namespace TimeSource {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeSynchronization::TimeSourceEnum;
    using DecodableType    = chip::app::Clusters::TimeSynchronization::TimeSourceEnum;
    using DecodableArgType = chip::app::Clusters::TimeSynchronization::TimeSourceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeSource
namespace TrustedTimeSource {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::TimeSynchronization::Structs::TrustedTimeSourceStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::TimeSynchronization::Structs::TrustedTimeSourceStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::TimeSynchronization::Structs::TrustedTimeSourceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TrustedTimeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TrustedTimeSource
namespace DefaultNTP {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultNTP::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 128; }
};
} // namespace DefaultNTP
namespace TimeZone {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TimeSynchronization::Structs::TimeZoneStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TimeSynchronization::Structs::TimeZoneStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TimeSynchronization::Structs::TimeZoneStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZone::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZone
namespace DSTOffset {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TimeSynchronization::Structs::DSTOffsetStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TimeSynchronization::Structs::DSTOffsetStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TimeSynchronization::Structs::DSTOffsetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DSTOffset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DSTOffset
namespace LocalTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTime
namespace TimeZoneDatabase {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum;
    using DecodableType    = chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum;
    using DecodableArgType = chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZoneDatabase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZoneDatabase
namespace NTPServerAvailable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NTPServerAvailable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NTPServerAvailable
namespace TimeZoneListMaxSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZoneListMaxSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZoneListMaxSize
namespace DSTOffsetListMaxSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DSTOffsetListMaxSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DSTOffsetListMaxSize
namespace SupportsDNSResolve {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportsDNSResolve::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportsDNSResolve
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::UTCTime::TypeInfo::DecodableType UTCTime;
        Attributes::Granularity::TypeInfo::DecodableType granularity =
            static_cast<chip::app::Clusters::TimeSynchronization::GranularityEnum>(0);
        Attributes::TimeSource::TypeInfo::DecodableType timeSource =
            static_cast<chip::app::Clusters::TimeSynchronization::TimeSourceEnum>(0);
        Attributes::TrustedTimeSource::TypeInfo::DecodableType trustedTimeSource;
        Attributes::DefaultNTP::TypeInfo::DecodableType defaultNTP;
        Attributes::TimeZone::TypeInfo::DecodableType timeZone;
        Attributes::DSTOffset::TypeInfo::DecodableType DSTOffset;
        Attributes::LocalTime::TypeInfo::DecodableType localTime;
        Attributes::TimeZoneDatabase::TypeInfo::DecodableType timeZoneDatabase =
            static_cast<chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum>(0);
        Attributes::NTPServerAvailable::TypeInfo::DecodableType NTPServerAvailable     = static_cast<bool>(0);
        Attributes::TimeZoneListMaxSize::TypeInfo::DecodableType timeZoneListMaxSize   = static_cast<uint8_t>(0);
        Attributes::DSTOffsetListMaxSize::TypeInfo::DecodableType DSTOffsetListMaxSize = static_cast<uint8_t>(0);
        Attributes::SupportsDNSResolve::TypeInfo::DecodableType supportsDNSResolve     = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace DSTTableEmpty {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTTableEmpty::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTTableEmpty::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DSTTableEmpty
namespace DSTStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kDSTOffsetActive = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool DSTOffsetActive = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    bool DSTOffsetActive = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DSTStatus
namespace TimeZoneStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kOffset = 0,
    kName   = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    int32_t offset = static_cast<int32_t>(0);
    Optional<chip::CharSpan> name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    int32_t offset = static_cast<int32_t>(0);
    Optional<chip::CharSpan> name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TimeZoneStatus
namespace TimeFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TimeFailure
namespace MissingTrustedTimeSource {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MissingTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MissingTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MissingTrustedTimeSource
} // namespace Events
} // namespace TimeSynchronization
namespace BridgedDeviceBasicInformation {
namespace Structs {
namespace ProductAppearanceStruct {
enum class Fields : uint8_t
{
    kFinish       = 0,
    kPrimaryColor = 1,
};

struct Type
{
public:
    ProductFinishEnum finish = static_cast<ProductFinishEnum>(0);
    DataModel::Nullable<ColorEnum> primaryColor;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProductAppearanceStruct
} // namespace Structs

namespace Attributes {

namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace ProductName
namespace NodeLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NodeLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace NodeLabel
namespace HardwareVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 256; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace SerialNumber
namespace Reachable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reachable
namespace UniqueID {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UniqueID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace UniqueID
namespace ProductAppearance {
struct TypeInfo
{
    using Type          = chip::app::Clusters::BridgedDeviceBasicInformation::Structs::ProductAppearanceStruct::Type;
    using DecodableType = chip::app::Clusters::BridgedDeviceBasicInformation::Structs::ProductAppearanceStruct::DecodableType;
    using DecodableArgType =
        const chip::app::Clusters::BridgedDeviceBasicInformation::Structs::ProductAppearanceStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductAppearance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductAppearance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID = static_cast<chip::VendorId>(0);
        Attributes::ProductName::TypeInfo::DecodableType productName;
        Attributes::NodeLabel::TypeInfo::DecodableType nodeLabel;
        Attributes::HardwareVersion::TypeInfo::DecodableType hardwareVersion = static_cast<uint16_t>(0);
        Attributes::HardwareVersionString::TypeInfo::DecodableType hardwareVersionString;
        Attributes::SoftwareVersion::TypeInfo::DecodableType softwareVersion = static_cast<uint32_t>(0);
        Attributes::SoftwareVersionString::TypeInfo::DecodableType softwareVersionString;
        Attributes::ManufacturingDate::TypeInfo::DecodableType manufacturingDate;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductURL::TypeInfo::DecodableType productURL;
        Attributes::ProductLabel::TypeInfo::DecodableType productLabel;
        Attributes::SerialNumber::TypeInfo::DecodableType serialNumber;
        Attributes::Reachable::TypeInfo::DecodableType reachable = static_cast<bool>(0);
        Attributes::UniqueID::TypeInfo::DecodableType uniqueID;
        Attributes::ProductAppearance::TypeInfo::DecodableType productAppearance;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StartUp {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StartUp
namespace ShutDown {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShutDown
namespace Leave {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leave
namespace ReachableChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kReachableNewValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ReachableChanged
} // namespace Events
} // namespace BridgedDeviceBasicInformation
namespace Switch {

namespace Attributes {

namespace NumberOfPositions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPositions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPositions
namespace CurrentPosition {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPosition
namespace MultiPressMax {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MultiPressMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MultiPressMax
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NumberOfPositions::TypeInfo::DecodableType numberOfPositions = static_cast<uint8_t>(0);
        Attributes::CurrentPosition::TypeInfo::DecodableType currentPosition     = static_cast<uint8_t>(0);
        Attributes::MultiPressMax::TypeInfo::DecodableType multiPressMax         = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SwitchLatched {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SwitchLatched::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SwitchLatched::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SwitchLatched
namespace InitialPress {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InitialPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InitialPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InitialPress
namespace LongPress {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LongPress
namespace ShortRelease {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShortRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShortRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShortRelease
namespace LongRelease {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LongRelease
namespace MultiPressOngoing {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition                   = 0,
    kCurrentNumberOfPressesCounted = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressOngoing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition                   = static_cast<uint8_t>(0);
    uint8_t currentNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressOngoing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition                   = static_cast<uint8_t>(0);
    uint8_t currentNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MultiPressOngoing
namespace MultiPressComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousPosition            = 0,
    kTotalNumberOfPressesCounted = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t previousPosition            = static_cast<uint8_t>(0);
    uint8_t totalNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition            = static_cast<uint8_t>(0);
    uint8_t totalNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MultiPressComplete
} // namespace Events
} // namespace Switch
namespace AdministratorCommissioning {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace OpenCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace OpenCommissioningWindow

namespace OpenBasicCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace OpenBasicCommissioningWindow

namespace RevokeCommissioning {
struct Type;
struct DecodableType;
} // namespace RevokeCommissioning

} // namespace Commands

namespace Commands {
namespace OpenCommissioningWindow {
enum class Fields : uint8_t
{
    kCommissioningTimeout = 0,
    kPAKEPasscodeVerifier = 1,
    kDiscriminator        = 2,
    kIterations           = 3,
    kSalt                 = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    chip::ByteSpan PAKEPasscodeVerifier;
    uint16_t discriminator = static_cast<uint16_t>(0);
    uint32_t iterations    = static_cast<uint32_t>(0);
    chip::ByteSpan salt;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    chip::ByteSpan PAKEPasscodeVerifier;
    uint16_t discriminator = static_cast<uint16_t>(0);
    uint32_t iterations    = static_cast<uint32_t>(0);
    chip::ByteSpan salt;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenCommissioningWindow
namespace OpenBasicCommissioningWindow {
enum class Fields : uint8_t
{
    kCommissioningTimeout = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenBasicCommissioningWindow
namespace RevokeCommissioning {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RevokeCommissioning
} // namespace Commands

namespace Attributes {

namespace WindowStatus {
struct TypeInfo
{
    using Type             = chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum;
    using DecodableType    = chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum;
    using DecodableArgType = chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindowStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindowStatus
namespace AdminFabricIndex {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::FabricIndex>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::FabricIndex>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::FabricIndex> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AdminFabricIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AdminFabricIndex
namespace AdminVendorId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::VendorId>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::VendorId>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::VendorId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AdminVendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AdminVendorId
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::WindowStatus::TypeInfo::DecodableType windowStatus =
            static_cast<chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum>(0);
        Attributes::AdminFabricIndex::TypeInfo::DecodableType adminFabricIndex;
        Attributes::AdminVendorId::TypeInfo::DecodableType adminVendorId;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace AdministratorCommissioning
namespace OperationalCredentials {
namespace Structs {
namespace FabricDescriptorStruct {
enum class Fields : uint8_t
{
    kRootPublicKey = 1,
    kVendorID      = 2,
    kFabricID      = 3,
    kNodeID        = 4,
    kLabel         = 5,
    kFabricIndex   = 254,
};

struct Type
{
public:
    chip::ByteSpan rootPublicKey;
    chip::VendorId vendorID = static_cast<chip::VendorId>(0);
    chip::FabricId fabricID = static_cast<chip::FabricId>(0);
    chip::NodeId nodeID     = static_cast<chip::NodeId>(0);
    chip::CharSpan label;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace FabricDescriptorStruct
namespace NOCStruct {
enum class Fields : uint8_t
{
    kNoc         = 1,
    kIcac        = 2,
    kFabricIndex = 254,
};

struct Type
{
public:
    chip::ByteSpan noc;
    DataModel::Nullable<chip::ByteSpan> icac;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace NOCStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AttestationRequest {
struct Type;
struct DecodableType;
} // namespace AttestationRequest

namespace AttestationResponse {
struct Type;
struct DecodableType;
} // namespace AttestationResponse

namespace CertificateChainRequest {
struct Type;
struct DecodableType;
} // namespace CertificateChainRequest

namespace CertificateChainResponse {
struct Type;
struct DecodableType;
} // namespace CertificateChainResponse

namespace CSRRequest {
struct Type;
struct DecodableType;
} // namespace CSRRequest

namespace CSRResponse {
struct Type;
struct DecodableType;
} // namespace CSRResponse

namespace AddNOC {
struct Type;
struct DecodableType;
} // namespace AddNOC

namespace UpdateNOC {
struct Type;
struct DecodableType;
} // namespace UpdateNOC

namespace NOCResponse {
struct Type;
struct DecodableType;
} // namespace NOCResponse

namespace UpdateFabricLabel {
struct Type;
struct DecodableType;
} // namespace UpdateFabricLabel

namespace RemoveFabric {
struct Type;
struct DecodableType;
} // namespace RemoveFabric

namespace AddTrustedRootCertificate {
struct Type;
struct DecodableType;
} // namespace AddTrustedRootCertificate

} // namespace Commands

namespace Commands {
namespace AttestationRequest {
enum class Fields : uint8_t
{
    kAttestationNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::AttestationResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationRequest
namespace AttestationResponse {
enum class Fields : uint8_t
{
    kAttestationElements  = 0,
    kAttestationSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan attestationSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan attestationSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationResponse
namespace CertificateChainRequest {
enum class Fields : uint8_t
{
    kCertificateType = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    CertificateChainTypeEnum certificateType = static_cast<CertificateChainTypeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::CertificateChainResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    CertificateChainTypeEnum certificateType = static_cast<CertificateChainTypeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainRequest
namespace CertificateChainResponse {
enum class Fields : uint8_t
{
    kCertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan certificate;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan certificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainResponse
namespace CSRRequest {
enum class Fields : uint8_t
{
    kCSRNonce       = 0,
    kIsForUpdateNOC = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;
    Optional<bool> isForUpdateNOC;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::CSRResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;
    Optional<bool> isForUpdateNOC;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CSRRequest
namespace CSRResponse {
enum class Fields : uint8_t
{
    kNOCSRElements        = 0,
    kAttestationSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CSRResponse
namespace AddNOC {
enum class Fields : uint8_t
{
    kNOCValue         = 0,
    kICACValue        = 1,
    kIPKValue         = 2,
    kCaseAdminSubject = 3,
    kAdminVendorId    = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    chip::ByteSpan IPKValue;
    uint64_t caseAdminSubject    = static_cast<uint64_t>(0);
    chip::VendorId adminVendorId = static_cast<chip::VendorId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    chip::ByteSpan IPKValue;
    uint64_t caseAdminSubject    = static_cast<uint64_t>(0);
    chip::VendorId adminVendorId = static_cast<chip::VendorId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddNOC
namespace UpdateNOC {
enum class Fields : uint8_t
{
    kNOCValue  = 0,
    kICACValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateNOC
namespace NOCResponse {
enum class Fields : uint8_t
{
    kStatusCode  = 0,
    kFabricIndex = 1,
    kDebugText   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    NodeOperationalCertStatusEnum statusCode = static_cast<NodeOperationalCertStatusEnum>(0);
    Optional<chip::FabricIndex> fabricIndex;
    Optional<chip::CharSpan> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    NodeOperationalCertStatusEnum statusCode = static_cast<NodeOperationalCertStatusEnum>(0);
    Optional<chip::FabricIndex> fabricIndex;
    Optional<chip::CharSpan> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NOCResponse
namespace UpdateFabricLabel {
enum class Fields : uint8_t
{
    kLabel = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::CharSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::CharSpan label;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateFabricLabel
namespace RemoveFabric {
enum class Fields : uint8_t
{
    kFabricIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveFabric
namespace AddTrustedRootCertificate {
enum class Fields : uint8_t
{
    kRootCACertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan rootCACertificate;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan rootCACertificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddTrustedRootCertificate
} // namespace Commands

namespace Attributes {

namespace NOCs {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NOCs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NOCs
namespace Fabrics {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptorStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptorStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptorStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Fabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Fabrics
namespace SupportedFabrics {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedFabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedFabrics
namespace CommissionedFabrics {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CommissionedFabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CommissionedFabrics
namespace TrustedRootCertificates {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TrustedRootCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TrustedRootCertificates
namespace CurrentFabricIndex {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFabricIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFabricIndex
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NOCs::TypeInfo::DecodableType NOCs;
        Attributes::Fabrics::TypeInfo::DecodableType fabrics;
        Attributes::SupportedFabrics::TypeInfo::DecodableType supportedFabrics       = static_cast<uint8_t>(0);
        Attributes::CommissionedFabrics::TypeInfo::DecodableType commissionedFabrics = static_cast<uint8_t>(0);
        Attributes::TrustedRootCertificates::TypeInfo::DecodableType trustedRootCertificates;
        Attributes::CurrentFabricIndex::TypeInfo::DecodableType currentFabricIndex = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OperationalCredentials
namespace GroupKeyManagement {
namespace Structs {
namespace GroupInfoMapStruct {
enum class Fields : uint8_t
{
    kGroupId     = 1,
    kEndpoints   = 2,
    kGroupName   = 3,
    kFabricIndex = 254,
};

struct Type
{
public:
    chip::GroupId groupId = static_cast<chip::GroupId>(0);
    DataModel::List<const chip::EndpointId> endpoints;
    Optional<chip::CharSpan> groupName;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    chip::GroupId groupId = static_cast<chip::GroupId>(0);
    DataModel::DecodableList<chip::EndpointId> endpoints;
    Optional<chip::CharSpan> groupName;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace GroupInfoMapStruct
namespace GroupKeyMapStruct {
enum class Fields : uint8_t
{
    kGroupId       = 1,
    kGroupKeySetID = 2,
    kFabricIndex   = 254,
};

struct Type
{
public:
    chip::GroupId groupId         = static_cast<chip::GroupId>(0);
    uint16_t groupKeySetID        = static_cast<uint16_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace GroupKeyMapStruct
namespace GroupKeySetStruct {
enum class Fields : uint8_t
{
    kGroupKeySetID          = 0,
    kGroupKeySecurityPolicy = 1,
    kEpochKey0              = 2,
    kEpochStartTime0        = 3,
    kEpochKey1              = 4,
    kEpochStartTime1        = 5,
    kEpochKey2              = 6,
    kEpochStartTime2        = 7,
};

struct Type
{
public:
    uint16_t groupKeySetID                            = static_cast<uint16_t>(0);
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = static_cast<GroupKeySecurityPolicyEnum>(0);
    DataModel::Nullable<chip::ByteSpan> epochKey0;
    DataModel::Nullable<uint64_t> epochStartTime0;
    DataModel::Nullable<chip::ByteSpan> epochKey1;
    DataModel::Nullable<uint64_t> epochStartTime1;
    DataModel::Nullable<chip::ByteSpan> epochKey2;
    DataModel::Nullable<uint64_t> epochStartTime2;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace GroupKeySetStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace KeySetWrite {
struct Type;
struct DecodableType;
} // namespace KeySetWrite

namespace KeySetRead {
struct Type;
struct DecodableType;
} // namespace KeySetRead

namespace KeySetReadResponse {
struct Type;
struct DecodableType;
} // namespace KeySetReadResponse

namespace KeySetRemove {
struct Type;
struct DecodableType;
} // namespace KeySetRemove

namespace KeySetReadAllIndices {
struct Type;
struct DecodableType;
} // namespace KeySetReadAllIndices

namespace KeySetReadAllIndicesResponse {
struct Type;
struct DecodableType;
} // namespace KeySetReadAllIndicesResponse

} // namespace Commands

namespace Commands {
namespace KeySetWrite {
enum class Fields : uint8_t
{
    kGroupKeySet = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetWrite::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::Type groupKeySet;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetWrite::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::DecodableType groupKeySet;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetWrite
namespace KeySetRead {
enum class Fields : uint8_t
{
    kGroupKeySetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetRead::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetRead::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetRead
namespace KeySetReadResponse {
enum class Fields : uint8_t
{
    kGroupKeySet = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::Type groupKeySet;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::DecodableType groupKeySet;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadResponse
namespace KeySetRemove {
enum class Fields : uint8_t
{
    kGroupKeySetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetRemove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetRemove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetRemove
namespace KeySetReadAllIndices {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndices::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GroupKeyManagement::Commands::KeySetReadAllIndicesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndices::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadAllIndices
namespace KeySetReadAllIndicesResponse {
enum class Fields : uint8_t
{
    kGroupKeySetIDs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndicesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::List<const uint16_t> groupKeySetIDs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndicesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::DecodableList<uint16_t> groupKeySetIDs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadAllIndicesResponse
} // namespace Commands

namespace Attributes {

namespace GroupKeyMap {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupKeyMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GroupKeyMap
namespace GroupTable {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GroupTable
namespace MaxGroupsPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxGroupsPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxGroupsPerFabric
namespace MaxGroupKeysPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxGroupKeysPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxGroupKeysPerFabric
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GroupKeyMap::TypeInfo::DecodableType groupKeyMap;
        Attributes::GroupTable::TypeInfo::DecodableType groupTable;
        Attributes::MaxGroupsPerFabric::TypeInfo::DecodableType maxGroupsPerFabric       = static_cast<uint16_t>(0);
        Attributes::MaxGroupKeysPerFabric::TypeInfo::DecodableType maxGroupKeysPerFabric = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace GroupKeyManagement
namespace FixedLabel {
namespace Structs {
namespace LabelStruct = Clusters::detail::Structs::LabelStruct;
} // namespace Structs

namespace Attributes {

namespace LabelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::FixedLabel::Structs::LabelStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LabelList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LabelList::TypeInfo::DecodableType labelList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FixedLabel
namespace UserLabel {
namespace Structs {
namespace LabelStruct = Clusters::detail::Structs::LabelStruct;
} // namespace Structs

namespace Attributes {

namespace LabelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LabelList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LabelList::TypeInfo::DecodableType labelList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace UserLabel
namespace ProxyConfiguration {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ProxyConfiguration
namespace ProxyDiscovery {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ProxyDiscovery
namespace ProxyValid {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ProxyValid
namespace BooleanState {

namespace Attributes {

namespace StateValue {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StateValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StateValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::StateValue::TypeInfo::DecodableType stateValue = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kStateValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool stateValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

    bool stateValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChange
} // namespace Events
} // namespace BooleanState
namespace IcdManagement {
namespace Structs {
namespace MonitoringRegistrationStruct {
enum class Fields : uint8_t
{
    kCheckInNodeID    = 1,
    kMonitoredSubject = 2,
    kFabricIndex      = 254,
};

struct Type
{
public:
    chip::NodeId checkInNodeID    = static_cast<chip::NodeId>(0);
    uint64_t monitoredSubject     = static_cast<uint64_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace MonitoringRegistrationStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RegisterClient {
struct Type;
struct DecodableType;
} // namespace RegisterClient

namespace RegisterClientResponse {
struct Type;
struct DecodableType;
} // namespace RegisterClientResponse

namespace UnregisterClient {
struct Type;
struct DecodableType;
} // namespace UnregisterClient

namespace StayActiveRequest {
struct Type;
struct DecodableType;
} // namespace StayActiveRequest

namespace StayActiveResponse {
struct Type;
struct DecodableType;
} // namespace StayActiveResponse

} // namespace Commands

namespace Commands {
namespace RegisterClient {
enum class Fields : uint8_t
{
    kCheckInNodeID    = 0,
    kMonitoredSubject = 1,
    kKey              = 2,
    kVerificationKey  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RegisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    uint64_t monitoredSubject  = static_cast<uint64_t>(0);
    chip::ByteSpan key;
    Optional<chip::ByteSpan> verificationKey;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::IcdManagement::Commands::RegisterClientResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RegisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    uint64_t monitoredSubject  = static_cast<uint64_t>(0);
    chip::ByteSpan key;
    Optional<chip::ByteSpan> verificationKey;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RegisterClient
namespace RegisterClientResponse {
enum class Fields : uint8_t
{
    kICDCounter = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RegisterClientResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t ICDCounter = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RegisterClientResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t ICDCounter = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RegisterClientResponse
namespace UnregisterClient {
enum class Fields : uint8_t
{
    kCheckInNodeID   = 0,
    kVerificationKey = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnregisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    Optional<chip::ByteSpan> verificationKey;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnregisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    Optional<chip::ByteSpan> verificationKey;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnregisterClient
namespace StayActiveRequest {
enum class Fields : uint8_t
{
    kStayActiveDuration = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StayActiveRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t stayActiveDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::IcdManagement::Commands::StayActiveResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StayActiveRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t stayActiveDuration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StayActiveRequest
namespace StayActiveResponse {
enum class Fields : uint8_t
{
    kPromisedActiveDuration = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StayActiveResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t promisedActiveDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StayActiveResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t promisedActiveDuration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StayActiveResponse
} // namespace Commands

namespace Attributes {

namespace IdleModeDuration {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdleModeDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdleModeDuration
namespace ActiveModeDuration {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveModeDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveModeDuration
namespace ActiveModeThreshold {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveModeThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveModeThreshold
namespace RegisteredClients {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::IcdManagement::Structs::MonitoringRegistrationStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::IcdManagement::Structs::MonitoringRegistrationStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::IcdManagement::Structs::MonitoringRegistrationStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RegisteredClients::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RegisteredClients
namespace ICDCounter {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ICDCounter::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ICDCounter
namespace ClientsSupportedPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClientsSupportedPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClientsSupportedPerFabric
namespace UserActiveModeTriggerHint {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserActiveModeTriggerHint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserActiveModeTriggerHint
namespace UserActiveModeTriggerInstruction {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserActiveModeTriggerInstruction::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 128; }
};
} // namespace UserActiveModeTriggerInstruction
namespace OperatingMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::IcdManagement::OperatingModeEnum;
    using DecodableType    = chip::app::Clusters::IcdManagement::OperatingModeEnum;
    using DecodableArgType = chip::app::Clusters::IcdManagement::OperatingModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperatingMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperatingMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::IdleModeDuration::TypeInfo::DecodableType idleModeDuration       = static_cast<uint32_t>(0);
        Attributes::ActiveModeDuration::TypeInfo::DecodableType activeModeDuration   = static_cast<uint32_t>(0);
        Attributes::ActiveModeThreshold::TypeInfo::DecodableType activeModeThreshold = static_cast<uint16_t>(0);
        Attributes::RegisteredClients::TypeInfo::DecodableType registeredClients;
        Attributes::ICDCounter::TypeInfo::DecodableType ICDCounter                               = static_cast<uint32_t>(0);
        Attributes::ClientsSupportedPerFabric::TypeInfo::DecodableType clientsSupportedPerFabric = static_cast<uint16_t>(0);
        Attributes::UserActiveModeTriggerHint::TypeInfo::DecodableType userActiveModeTriggerHint =
            static_cast<chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>>(0);
        Attributes::UserActiveModeTriggerInstruction::TypeInfo::DecodableType userActiveModeTriggerInstruction;
        Attributes::OperatingMode::TypeInfo::DecodableType operatingMode =
            static_cast<chip::app::Clusters::IcdManagement::OperatingModeEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace IcdManagement
namespace Timer {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetTimer {
struct Type;
struct DecodableType;
} // namespace SetTimer

namespace ResetTimer {
struct Type;
struct DecodableType;
} // namespace ResetTimer

namespace AddTime {
struct Type;
struct DecodableType;
} // namespace AddTime

namespace ReduceTime {
struct Type;
struct DecodableType;
} // namespace ReduceTime

} // namespace Commands

namespace Commands {
namespace SetTimer {
enum class Fields : uint8_t
{
    kNewTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t newTime = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t newTime = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTimer
namespace ResetTimer {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetTimer
namespace AddTime {
enum class Fields : uint8_t
{
    kAdditionalTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t additionalTime = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t additionalTime = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddTime
namespace ReduceTime {
enum class Fields : uint8_t
{
    kTimeReduction = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReduceTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t timeReduction = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReduceTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t timeReduction = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReduceTime
} // namespace Commands

namespace Attributes {

namespace SetTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetTime
namespace TimeRemaining {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeRemaining
namespace TimerState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Timer::TimerStatusEnum;
    using DecodableType    = chip::app::Clusters::Timer::TimerStatusEnum;
    using DecodableArgType = chip::app::Clusters::Timer::TimerStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimerState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimerState
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SetTime::TypeInfo::DecodableType setTime             = static_cast<uint32_t>(0);
        Attributes::TimeRemaining::TypeInfo::DecodableType timeRemaining = static_cast<uint32_t>(0);
        Attributes::TimerState::TypeInfo::DecodableType timerState = static_cast<chip::app::Clusters::Timer::TimerStatusEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Timer
namespace OvenCavityOperationalState {
namespace Structs {
namespace ErrorStateStruct       = Clusters::detail::Structs::ErrorStateStruct;
namespace OperationalStateStruct = Clusters::detail::Structs::OperationalStateStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace Start {
struct Type;
struct DecodableType;
} // namespace Start

namespace Resume {
struct Type;
struct DecodableType;
} // namespace Resume

namespace OperationalCommandResponse {
struct Type;
struct DecodableType;
} // namespace OperationalCommandResponse

} // namespace Commands

namespace Commands {
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace Start {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Start
namespace Resume {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Resume
namespace OperationalCommandResponse {
enum class Fields : uint8_t
{
    kCommandResponseState = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    Structs::ErrorStateStruct::Type commandResponseState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType commandResponseState;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalCommandResponse
} // namespace Commands

namespace Attributes {

namespace PhaseList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<const chip::CharSpan>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseList
namespace CurrentPhase {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPhase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPhase
namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace OperationalStateList {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::OvenCavityOperationalState::Structs::OperationalStateStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OvenCavityOperationalState::Structs::OperationalStateStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OvenCavityOperationalState::Structs::OperationalStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStateList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStateList
namespace OperationalState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum;
    using DecodableType    = chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum;
    using DecodableArgType = chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalState
namespace OperationalError {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OvenCavityOperationalState::Structs::ErrorStateStruct::Type;
    using DecodableType    = chip::app::Clusters::OvenCavityOperationalState::Structs::ErrorStateStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::OvenCavityOperationalState::Structs::ErrorStateStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalError::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalError
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhaseList::TypeInfo::DecodableType phaseList;
        Attributes::CurrentPhase::TypeInfo::DecodableType currentPhase;
        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::OperationalStateList::TypeInfo::DecodableType operationalStateList;
        Attributes::OperationalState::TypeInfo::DecodableType operationalState =
            static_cast<chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum>(0);
        Attributes::OperationalError::TypeInfo::DecodableType operationalError;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OperationalError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kErrorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::ErrorStateStruct::Type errorState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType errorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationalError
namespace OperationCompletion {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCompletionErrorCode  = 0,
    kTotalOperationalTime = 1,
    kPausedTime           = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationCompletion
} // namespace Events
} // namespace OvenCavityOperationalState
namespace OvenMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OvenMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OvenMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::OvenMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OvenMode
namespace LaundryDryerControls {

namespace Attributes {

namespace SupportedDrynessLevels {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedDrynessLevels::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedDrynessLevels
namespace SelectedDrynessLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedDrynessLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedDrynessLevel
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedDrynessLevels::TypeInfo::DecodableType supportedDrynessLevels;
        Attributes::SelectedDrynessLevel::TypeInfo::DecodableType selectedDrynessLevel;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LaundryDryerControls
namespace ModeSelect {
namespace Structs {
namespace SemanticTagStruct {
enum class Fields : uint8_t
{
    kMfgCode = 0,
    kValue   = 1,
};

struct Type
{
public:
    chip::VendorId mfgCode = static_cast<chip::VendorId>(0);
    uint16_t value         = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SemanticTagStruct
namespace ModeOptionStruct {
enum class Fields : uint8_t
{
    kLabel        = 0,
    kMode         = 1,
    kSemanticTags = 2,
};

struct Type
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::List<const Structs::SemanticTagStruct::Type> semanticTags;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::DecodableList<Structs::SemanticTagStruct::DecodableType> semanticTags;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ModeOptionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
} // namespace Commands

namespace Attributes {

namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace Description
namespace StandardNamespace {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StandardNamespace::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StandardNamespace
namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::StandardNamespace::TypeInfo::DecodableType standardNamespace;
        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ModeSelect
namespace LaundryWasherMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::LaundryWasherMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::LaundryWasherMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryWasherMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::LaundryWasherMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LaundryWasherMode
namespace RefrigeratorAndTemperatureControlledCabinetMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Structs::ModeOptionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RefrigeratorAndTemperatureControlledCabinetMode
namespace LaundryWasherControls {

namespace Attributes {

namespace SpinSpeeds {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpinSpeeds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpinSpeeds
namespace SpinSpeedCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpinSpeedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpinSpeedCurrent
namespace NumberOfRinses {
struct TypeInfo
{
    using Type             = chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum;
    using DecodableType    = chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum;
    using DecodableArgType = chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfRinses::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfRinses
namespace SupportedRinses {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedRinses::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedRinses
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SpinSpeeds::TypeInfo::DecodableType spinSpeeds;
        Attributes::SpinSpeedCurrent::TypeInfo::DecodableType spinSpeedCurrent;
        Attributes::NumberOfRinses::TypeInfo::DecodableType numberOfRinses =
            static_cast<chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum>(0);
        Attributes::SupportedRinses::TypeInfo::DecodableType supportedRinses;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LaundryWasherControls
namespace RvcRunMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcRunMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::RvcRunMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::RvcRunMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::RvcRunMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RvcRunMode
namespace RvcCleanMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcCleanMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::RvcCleanMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::RvcCleanMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::RvcCleanMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RvcCleanMode
namespace TemperatureControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetTemperature {
struct Type;
struct DecodableType;
} // namespace SetTemperature

} // namespace Commands

namespace Commands {
namespace SetTemperature {
enum class Fields : uint8_t
{
    kTargetTemperature      = 0,
    kTargetTemperatureLevel = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }

    Optional<int16_t> targetTemperature;
    Optional<uint8_t> targetTemperatureLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }

    Optional<int16_t> targetTemperature;
    Optional<uint8_t> targetTemperatureLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTemperature
} // namespace Commands

namespace Attributes {

namespace TemperatureSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpoint
namespace MinTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinTemperature
namespace MaxTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxTemperature
namespace Step {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Step::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Step
namespace SelectedTemperatureLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedTemperatureLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedTemperatureLevel
namespace SupportedTemperatureLevels {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedTemperatureLevels::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedTemperatureLevels
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureSetpoint::TypeInfo::DecodableType temperatureSetpoint           = static_cast<int16_t>(0);
        Attributes::MinTemperature::TypeInfo::DecodableType minTemperature                     = static_cast<int16_t>(0);
        Attributes::MaxTemperature::TypeInfo::DecodableType maxTemperature                     = static_cast<int16_t>(0);
        Attributes::Step::TypeInfo::DecodableType step                                         = static_cast<int16_t>(0);
        Attributes::SelectedTemperatureLevel::TypeInfo::DecodableType selectedTemperatureLevel = static_cast<uint8_t>(0);
        Attributes::SupportedTemperatureLevels::TypeInfo::DecodableType supportedTemperatureLevels;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TemperatureControl
namespace RefrigeratorAlarm {

namespace Attributes {

namespace Mask {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mask
namespace State {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::State::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace State
namespace Supported {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Supported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Supported
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Mask::TypeInfo::DecodableType mask =
            static_cast<chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>>(0);
        Attributes::State::TypeInfo::DecodableType state =
            static_cast<chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>>(0);
        Attributes::Supported::TypeInfo::DecodableType supported =
            static_cast<chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace Notify {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActive   = 0,
    kInactive = 1,
    kState    = 2,
    kMask     = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Notify
} // namespace Events
} // namespace RefrigeratorAlarm
namespace DishwasherMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DishwasherMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::DishwasherMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::DishwasherMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::DishwasherMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace DishwasherMode
namespace AirQuality {

namespace Attributes {

namespace AirQuality {
struct TypeInfo
{
    using Type             = chip::app::Clusters::AirQuality::AirQualityEnum;
    using DecodableType    = chip::app::Clusters::AirQuality::AirQualityEnum;
    using DecodableArgType = chip::app::Clusters::AirQuality::AirQualityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AirQuality::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AirQuality
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AirQuality::TypeInfo::DecodableType airQuality =
            static_cast<chip::app::Clusters::AirQuality::AirQualityEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace AirQuality
namespace SmokeCoAlarm {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelfTestRequest {
struct Type;
struct DecodableType;
} // namespace SelfTestRequest

} // namespace Commands

namespace Commands {
namespace SelfTestRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelfTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelfTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelfTestRequest
} // namespace Commands

namespace Attributes {

namespace ExpressedState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpressedState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpressedState
namespace SmokeState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SmokeState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SmokeState
namespace COState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::COState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace COState
namespace BatteryAlert {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAlert::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryAlert
namespace DeviceMuted {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::MuteStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::MuteStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::MuteStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceMuted::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceMuted
namespace TestInProgress {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TestInProgress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TestInProgress
namespace HardwareFaultAlert {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareFaultAlert::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareFaultAlert
namespace EndOfServiceAlert {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndOfServiceAlert::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndOfServiceAlert
namespace InterconnectSmokeAlarm {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterconnectSmokeAlarm::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterconnectSmokeAlarm
namespace InterconnectCOAlarm {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterconnectCOAlarm::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterconnectCOAlarm
namespace ContaminationState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ContaminationState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ContaminationState
namespace SmokeSensitivityLevel {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::SensitivityEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::SensitivityEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::SensitivityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SmokeSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SmokeSensitivityLevel
namespace ExpiryDate {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpiryDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpiryDate
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ExpressedState::TypeInfo::DecodableType expressedState =
            static_cast<chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum>(0);
        Attributes::SmokeState::TypeInfo::DecodableType smokeState =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::COState::TypeInfo::DecodableType COState = static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::BatteryAlert::TypeInfo::DecodableType batteryAlert =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::DeviceMuted::TypeInfo::DecodableType deviceMuted =
            static_cast<chip::app::Clusters::SmokeCoAlarm::MuteStateEnum>(0);
        Attributes::TestInProgress::TypeInfo::DecodableType testInProgress         = static_cast<bool>(0);
        Attributes::HardwareFaultAlert::TypeInfo::DecodableType hardwareFaultAlert = static_cast<bool>(0);
        Attributes::EndOfServiceAlert::TypeInfo::DecodableType endOfServiceAlert =
            static_cast<chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum>(0);
        Attributes::InterconnectSmokeAlarm::TypeInfo::DecodableType interconnectSmokeAlarm =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::InterconnectCOAlarm::TypeInfo::DecodableType interconnectCOAlarm =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::ContaminationState::TypeInfo::DecodableType contaminationState =
            static_cast<chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum>(0);
        Attributes::SmokeSensitivityLevel::TypeInfo::DecodableType smokeSensitivityLevel =
            static_cast<chip::app::Clusters::SmokeCoAlarm::SensitivityEnum>(0);
        Attributes::ExpiryDate::TypeInfo::DecodableType expiryDate = static_cast<uint32_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SmokeAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SmokeAlarm
namespace COAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::COAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::COAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace COAlarm
namespace LowBattery {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LowBattery::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LowBattery::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LowBattery
namespace HardwareFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace HardwareFault
namespace EndOfService {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EndOfService::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EndOfService::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EndOfService
namespace SelfTestComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SelfTestComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SelfTestComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SelfTestComplete
namespace AlarmMuted {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmMuted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmMuted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AlarmMuted
namespace MuteEnded {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MuteEnded::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MuteEnded::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MuteEnded
namespace InterconnectSmokeAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectSmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectSmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InterconnectSmokeAlarm
namespace InterconnectCOAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectCOAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectCOAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InterconnectCOAlarm
namespace AllClear {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AllClear::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AllClear::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AllClear
} // namespace Events
} // namespace SmokeCoAlarm
namespace DishwasherAlarm {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Reset {
struct Type;
struct DecodableType;
} // namespace Reset

namespace ModifyEnabledAlarms {
struct Type;
struct DecodableType;
} // namespace ModifyEnabledAlarms

} // namespace Commands

namespace Commands {
namespace Reset {
enum class Fields : uint8_t
{
    kAlarms = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Reset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> alarms = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Reset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> alarms = static_cast<chip::BitMask<AlarmBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Reset
namespace ModifyEnabledAlarms {
enum class Fields : uint8_t
{
    kMask = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ModifyEnabledAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> mask = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ModifyEnabledAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> mask = static_cast<chip::BitMask<AlarmBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ModifyEnabledAlarms
} // namespace Commands

namespace Attributes {

namespace Mask {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mask
namespace Latch {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Latch::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Latch
namespace State {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::State::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace State
namespace Supported {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Supported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Supported
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Mask::TypeInfo::DecodableType mask =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::Latch::TypeInfo::DecodableType latch =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::State::TypeInfo::DecodableType state =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::Supported::TypeInfo::DecodableType supported =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace Notify {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActive   = 0,
    kInactive = 1,
    kState    = 2,
    kMask     = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Notify
} // namespace Events
} // namespace DishwasherAlarm
namespace MicrowaveOvenMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::MicrowaveOvenMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::MicrowaveOvenMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::MicrowaveOvenMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace MicrowaveOvenMode
namespace MicrowaveOvenControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetCookingParameters {
struct Type;
struct DecodableType;
} // namespace SetCookingParameters

namespace AddMoreTime {
struct Type;
struct DecodableType;
} // namespace AddMoreTime

} // namespace Commands

namespace Commands {
namespace SetCookingParameters {
enum class Fields : uint8_t
{
    kCookMode          = 0,
    kCookTime          = 1,
    kPowerSetting      = 2,
    kWattSettingIndex  = 3,
    kStartAfterSetting = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCookingParameters::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    Optional<uint8_t> cookMode;
    Optional<uint32_t> cookTime;
    Optional<uint8_t> powerSetting;
    Optional<uint8_t> wattSettingIndex;
    Optional<bool> startAfterSetting;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCookingParameters::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    Optional<uint8_t> cookMode;
    Optional<uint32_t> cookTime;
    Optional<uint8_t> powerSetting;
    Optional<uint8_t> wattSettingIndex;
    Optional<bool> startAfterSetting;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCookingParameters
namespace AddMoreTime {
enum class Fields : uint8_t
{
    kTimeToAdd = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddMoreTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    uint32_t timeToAdd = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddMoreTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    uint32_t timeToAdd = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddMoreTime
} // namespace Commands

namespace Attributes {

namespace CookTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CookTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CookTime
namespace MaxCookTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCookTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCookTime
namespace PowerSetting {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerSetting
namespace MinPower {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinPower
namespace MaxPower {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPower
namespace PowerStep {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerStep::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerStep
namespace SupportedWatts {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedWatts::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedWatts
namespace SelectedWattIndex {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedWattIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedWattIndex
namespace WattRating {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WattRating::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WattRating
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CookTime::TypeInfo::DecodableType cookTime         = static_cast<uint32_t>(0);
        Attributes::MaxCookTime::TypeInfo::DecodableType maxCookTime   = static_cast<uint32_t>(0);
        Attributes::PowerSetting::TypeInfo::DecodableType powerSetting = static_cast<uint8_t>(0);
        Attributes::MinPower::TypeInfo::DecodableType minPower         = static_cast<uint8_t>(0);
        Attributes::MaxPower::TypeInfo::DecodableType maxPower         = static_cast<uint8_t>(0);
        Attributes::PowerStep::TypeInfo::DecodableType powerStep       = static_cast<uint8_t>(0);
        Attributes::SupportedWatts::TypeInfo::DecodableType supportedWatts;
        Attributes::SelectedWattIndex::TypeInfo::DecodableType selectedWattIndex = static_cast<uint8_t>(0);
        Attributes::WattRating::TypeInfo::DecodableType wattRating               = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace MicrowaveOvenControl
namespace OperationalState {
namespace Structs {
namespace ErrorStateStruct       = Clusters::detail::Structs::ErrorStateStruct;
namespace OperationalStateStruct = Clusters::detail::Structs::OperationalStateStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace Start {
struct Type;
struct DecodableType;
} // namespace Start

namespace Resume {
struct Type;
struct DecodableType;
} // namespace Resume

namespace OperationalCommandResponse {
struct Type;
struct DecodableType;
} // namespace OperationalCommandResponse

} // namespace Commands

namespace Commands {
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace Start {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Start
namespace Resume {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Resume
namespace OperationalCommandResponse {
enum class Fields : uint8_t
{
    kCommandResponseState = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    Structs::ErrorStateStruct::Type commandResponseState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType commandResponseState;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalCommandResponse
} // namespace Commands

namespace Attributes {

namespace PhaseList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<const chip::CharSpan>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseList
namespace CurrentPhase {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPhase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPhase
namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace OperationalStateList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OperationalState::Structs::OperationalStateStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalState::Structs::OperationalStateStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalState::Structs::OperationalStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStateList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStateList
namespace OperationalState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OperationalState::OperationalStateEnum;
    using DecodableType    = chip::app::Clusters::OperationalState::OperationalStateEnum;
    using DecodableArgType = chip::app::Clusters::OperationalState::OperationalStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalState
namespace OperationalError {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OperationalState::Structs::ErrorStateStruct::Type;
    using DecodableType    = chip::app::Clusters::OperationalState::Structs::ErrorStateStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::OperationalState::Structs::ErrorStateStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalError::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalError
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhaseList::TypeInfo::DecodableType phaseList;
        Attributes::CurrentPhase::TypeInfo::DecodableType currentPhase;
        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::OperationalStateList::TypeInfo::DecodableType operationalStateList;
        Attributes::OperationalState::TypeInfo::DecodableType operationalState =
            static_cast<chip::app::Clusters::OperationalState::OperationalStateEnum>(0);
        Attributes::OperationalError::TypeInfo::DecodableType operationalError;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OperationalError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kErrorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::ErrorStateStruct::Type errorState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType errorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationalError
namespace OperationCompletion {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCompletionErrorCode  = 0,
    kTotalOperationalTime = 1,
    kPausedTime           = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationCompletion
} // namespace Events
} // namespace OperationalState
namespace RvcOperationalState {
namespace Structs {
namespace ErrorStateStruct       = Clusters::detail::Structs::ErrorStateStruct;
namespace OperationalStateStruct = Clusters::detail::Structs::OperationalStateStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Resume {
struct Type;
struct DecodableType;
} // namespace Resume

namespace OperationalCommandResponse {
struct Type;
struct DecodableType;
} // namespace OperationalCommandResponse

namespace GoHome {
struct Type;
struct DecodableType;
} // namespace GoHome

} // namespace Commands

namespace Commands {
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Resume {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Resume
namespace OperationalCommandResponse {
enum class Fields : uint8_t
{
    kCommandResponseState = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    Structs::ErrorStateStruct::Type commandResponseState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType commandResponseState;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalCommandResponse
namespace GoHome {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoHome::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoHome::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoHome
} // namespace Commands

namespace Attributes {

namespace PhaseList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<const chip::CharSpan>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseList
namespace CurrentPhase {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPhase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPhase
namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace OperationalStateList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::RvcOperationalState::Structs::OperationalStateStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::RvcOperationalState::Structs::OperationalStateStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::RvcOperationalState::Structs::OperationalStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStateList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStateList
namespace OperationalState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalState
namespace OperationalError {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RvcOperationalState::Structs::ErrorStateStruct::Type;
    using DecodableType    = chip::app::Clusters::RvcOperationalState::Structs::ErrorStateStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::RvcOperationalState::Structs::ErrorStateStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalError::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalError
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhaseList::TypeInfo::DecodableType phaseList;
        Attributes::CurrentPhase::TypeInfo::DecodableType currentPhase;
        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::OperationalStateList::TypeInfo::DecodableType operationalStateList;
        Attributes::OperationalState::TypeInfo::DecodableType operationalState = static_cast<uint8_t>(0);
        Attributes::OperationalError::TypeInfo::DecodableType operationalError;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OperationalError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kErrorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::ErrorStateStruct::Type errorState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType errorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationalError
namespace OperationCompletion {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCompletionErrorCode  = 0,
    kTotalOperationalTime = 1,
    kPausedTime           = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationCompletion
} // namespace Events
} // namespace RvcOperationalState
namespace ScenesManagement {
namespace Structs {
namespace AttributeValuePair {
enum class Fields : uint8_t
{
    kAttributeID    = 0,
    kAttributeValue = 1,
};

struct Type
{
public:
    chip::AttributeId attributeID = static_cast<chip::AttributeId>(0);
    uint32_t attributeValue       = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AttributeValuePair
namespace ExtensionFieldSet {
enum class Fields : uint8_t
{
    kClusterID          = 0,
    kAttributeValueList = 1,
};

struct Type
{
public:
    chip::ClusterId clusterID = static_cast<chip::ClusterId>(0);
    DataModel::List<const Structs::AttributeValuePair::Type> attributeValueList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::ClusterId clusterID = static_cast<chip::ClusterId>(0);
    DataModel::DecodableList<Structs::AttributeValuePair::DecodableType> attributeValueList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ExtensionFieldSet
namespace SceneInfoStruct {
enum class Fields : uint8_t
{
    kSceneCount        = 0,
    kCurrentScene      = 1,
    kCurrentGroup      = 2,
    kSceneValid        = 3,
    kRemainingCapacity = 4,
    kFabricIndex       = 254,
};

struct Type
{
public:
    uint8_t sceneCount            = static_cast<uint8_t>(0);
    uint8_t currentScene          = static_cast<uint8_t>(0);
    chip::GroupId currentGroup    = static_cast<chip::GroupId>(0);
    bool sceneValid               = static_cast<bool>(0);
    uint8_t remainingCapacity     = static_cast<uint8_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace SceneInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddScene {
struct Type;
struct DecodableType;
} // namespace AddScene

namespace AddSceneResponse {
struct Type;
struct DecodableType;
} // namespace AddSceneResponse

namespace ViewScene {
struct Type;
struct DecodableType;
} // namespace ViewScene

namespace ViewSceneResponse {
struct Type;
struct DecodableType;
} // namespace ViewSceneResponse

namespace RemoveScene {
struct Type;
struct DecodableType;
} // namespace RemoveScene

namespace RemoveSceneResponse {
struct Type;
struct DecodableType;
} // namespace RemoveSceneResponse

namespace RemoveAllScenes {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenes

namespace RemoveAllScenesResponse {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenesResponse

namespace StoreScene {
struct Type;
struct DecodableType;
} // namespace StoreScene

namespace StoreSceneResponse {
struct Type;
struct DecodableType;
} // namespace StoreSceneResponse

namespace RecallScene {
struct Type;
struct DecodableType;
} // namespace RecallScene

namespace GetSceneMembership {
struct Type;
struct DecodableType;
} // namespace GetSceneMembership

namespace GetSceneMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetSceneMembershipResponse

namespace CopyScene {
struct Type;
struct DecodableType;
} // namespace CopyScene

namespace CopySceneResponse {
struct Type;
struct DecodableType;
} // namespace CopySceneResponse

} // namespace Commands

namespace Commands {
namespace AddScene {
enum class Fields : uint8_t
{
    kGroupID            = 0,
    kSceneID            = 1,
    kTransitionTime     = 2,
    kSceneName          = 3,
    kExtensionFieldSets = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID   = static_cast<chip::GroupId>(0);
    uint8_t sceneID         = static_cast<uint8_t>(0);
    uint32_t transitionTime = static_cast<uint32_t>(0);
    chip::CharSpan sceneName;
    DataModel::List<const Structs::ExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::AddSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID   = static_cast<chip::GroupId>(0);
    uint8_t sceneID         = static_cast<uint8_t>(0);
    uint32_t transitionTime = static_cast<uint32_t>(0);
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::ExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddScene
namespace AddSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddSceneResponse
namespace ViewScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::ViewSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewScene
namespace ViewSceneResponse {
enum class Fields : uint8_t
{
    kStatus             = 0,
    kGroupID            = 1,
    kSceneID            = 2,
    kTransitionTime     = 3,
    kSceneName          = 4,
    kExtensionFieldSets = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<uint32_t> transitionTime;
    Optional<chip::CharSpan> sceneName;
    Optional<DataModel::List<const Structs::ExtensionFieldSet::Type>> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<uint32_t> transitionTime;
    Optional<chip::CharSpan> sceneName;
    Optional<DataModel::DecodableList<Structs::ExtensionFieldSet::DecodableType>> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewSceneResponse
namespace RemoveScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::RemoveSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveScene
namespace RemoveSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveSceneResponse
namespace RemoveAllScenes {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::RemoveAllScenesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenes
namespace RemoveAllScenesResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenesResponse
namespace StoreScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::StoreSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreScene
namespace StoreSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreSceneResponse
namespace RecallScene {
enum class Fields : uint8_t
{
    kGroupID        = 0,
    kSceneID        = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RecallScene
namespace GetSceneMembership {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::GetSceneMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembership
namespace GetSceneMembershipResponse {
enum class Fields : uint8_t
{
    kStatus    = 0,
    kCapacity  = 1,
    kGroupID   = 2,
    kSceneList = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    DataModel::Nullable<uint8_t> capacity;
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    Optional<DataModel::List<const uint8_t>> sceneList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    DataModel::Nullable<uint8_t> capacity;
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    Optional<DataModel::DecodableList<uint8_t>> sceneList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembershipResponse
namespace CopyScene {
enum class Fields : uint8_t
{
    kMode                = 0,
    kGroupIdentifierFrom = 1,
    kSceneIdentifierFrom = 2,
    kGroupIdentifierTo   = 3,
    kSceneIdentifierTo   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::BitMask<CopyModeBitmap> mode = static_cast<chip::BitMask<CopyModeBitmap>>(0);
    chip::GroupId groupIdentifierFrom  = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom        = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierTo    = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierTo          = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::CopySceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::BitMask<CopyModeBitmap> mode = static_cast<chip::BitMask<CopyModeBitmap>>(0);
    chip::GroupId groupIdentifierFrom  = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom        = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierTo    = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierTo          = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopyScene
namespace CopySceneResponse {
enum class Fields : uint8_t
{
    kStatus              = 0,
    kGroupIdentifierFrom = 1,
    kSceneIdentifierFrom = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status                    = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierFrom = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status                    = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierFrom = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopySceneResponse
} // namespace Commands

namespace Attributes {

namespace LastConfiguredBy {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::NodeId>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::NodeId>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::NodeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConfiguredBy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastConfiguredBy
namespace SceneTableSize {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SceneTableSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SceneTableSize
namespace FabricSceneInfo {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ScenesManagement::Structs::SceneInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ScenesManagement::Structs::SceneInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ScenesManagement::Structs::SceneInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FabricSceneInfo::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FabricSceneInfo
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LastConfiguredBy::TypeInfo::DecodableType lastConfiguredBy;
        Attributes::SceneTableSize::TypeInfo::DecodableType sceneTableSize = static_cast<uint16_t>(0);
        Attributes::FabricSceneInfo::TypeInfo::DecodableType fabricSceneInfo;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ScenesManagement
namespace HepaFilterMonitoring {
namespace Structs {
namespace ReplacementProductStruct {
enum class Fields : uint8_t
{
    kProductIdentifierType  = 0,
    kProductIdentifierValue = 1,
};

struct Type
{
public:
    ProductIdentifierTypeEnum productIdentifierType = static_cast<ProductIdentifierTypeEnum>(0);
    chip::CharSpan productIdentifierValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ReplacementProductStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCondition {
struct Type;
struct DecodableType;
} // namespace ResetCondition

} // namespace Commands

namespace Commands {
namespace ResetCondition {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCondition
} // namespace Commands

namespace Attributes {

namespace Condition {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Condition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Condition
namespace DegradationDirection {
struct TypeInfo
{
    using Type             = chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum;
    using DecodableType    = chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum;
    using DecodableArgType = chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DegradationDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DegradationDirection
namespace ChangeIndication {
struct TypeInfo
{
    using Type             = chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum;
    using DecodableType    = chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum;
    using DecodableArgType = chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChangeIndication::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChangeIndication
namespace InPlaceIndicator {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InPlaceIndicator::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InPlaceIndicator
namespace LastChangedTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastChangedTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastChangedTime
namespace ReplacementProductList {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::HepaFilterMonitoring::Structs::ReplacementProductStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::HepaFilterMonitoring::Structs::ReplacementProductStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::HepaFilterMonitoring::Structs::ReplacementProductStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReplacementProductList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReplacementProductList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Condition::TypeInfo::DecodableType condition = static_cast<chip::Percent>(0);
        Attributes::DegradationDirection::TypeInfo::DecodableType degradationDirection =
            static_cast<chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum>(0);
        Attributes::ChangeIndication::TypeInfo::DecodableType changeIndication =
            static_cast<chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum>(0);
        Attributes::InPlaceIndicator::TypeInfo::DecodableType inPlaceIndicator = static_cast<bool>(0);
        Attributes::LastChangedTime::TypeInfo::DecodableType lastChangedTime;
        Attributes::ReplacementProductList::TypeInfo::DecodableType replacementProductList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace HepaFilterMonitoring
namespace ActivatedCarbonFilterMonitoring {
namespace Structs {
namespace ReplacementProductStruct {
enum class Fields : uint8_t
{
    kProductIdentifierType  = 0,
    kProductIdentifierValue = 1,
};

struct Type
{
public:
    ProductIdentifierTypeEnum productIdentifierType = static_cast<ProductIdentifierTypeEnum>(0);
    chip::CharSpan productIdentifierValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ReplacementProductStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCondition {
struct Type;
struct DecodableType;
} // namespace ResetCondition

} // namespace Commands

namespace Commands {
namespace ResetCondition {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCondition
} // namespace Commands

namespace Attributes {

namespace Condition {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Condition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Condition
namespace DegradationDirection {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum;
    using DecodableType    = chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum;
    using DecodableArgType = chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DegradationDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DegradationDirection
namespace ChangeIndication {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum;
    using DecodableType    = chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum;
    using DecodableArgType = chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChangeIndication::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChangeIndication
namespace InPlaceIndicator {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InPlaceIndicator::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InPlaceIndicator
namespace LastChangedTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastChangedTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastChangedTime
namespace ReplacementProductList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::ActivatedCarbonFilterMonitoring::Structs::ReplacementProductStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ActivatedCarbonFilterMonitoring::Structs::ReplacementProductStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ActivatedCarbonFilterMonitoring::Structs::ReplacementProductStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReplacementProductList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReplacementProductList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Condition::TypeInfo::DecodableType condition = static_cast<chip::Percent>(0);
        Attributes::DegradationDirection::TypeInfo::DecodableType degradationDirection =
            static_cast<chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum>(0);
        Attributes::ChangeIndication::TypeInfo::DecodableType changeIndication =
            static_cast<chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum>(0);
        Attributes::InPlaceIndicator::TypeInfo::DecodableType inPlaceIndicator = static_cast<bool>(0);
        Attributes::LastChangedTime::TypeInfo::DecodableType lastChangedTime;
        Attributes::ReplacementProductList::TypeInfo::DecodableType replacementProductList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ActivatedCarbonFilterMonitoring
namespace BooleanStateConfiguration {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SuppressAlarm {
struct Type;
struct DecodableType;
} // namespace SuppressAlarm

namespace EnableDisableAlarm {
struct Type;
struct DecodableType;
} // namespace EnableDisableAlarm

} // namespace Commands

namespace Commands {
namespace SuppressAlarm {
enum class Fields : uint8_t
{
    kAlarmsToSuppress = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SuppressAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToSuppress = static_cast<chip::BitMask<AlarmModeBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SuppressAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToSuppress = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SuppressAlarm
namespace EnableDisableAlarm {
enum class Fields : uint8_t
{
    kAlarmsToEnableDisable = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableDisableAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToEnableDisable = static_cast<chip::BitMask<AlarmModeBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableDisableAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToEnableDisable = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableDisableAlarm
} // namespace Commands

namespace Attributes {

namespace CurrentSensitivityLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSensitivityLevel
namespace SupportedSensitivityLevels {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedSensitivityLevels::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedSensitivityLevels
namespace DefaultSensitivityLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultSensitivityLevel
namespace AlarmsActive {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsActive::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsActive
namespace AlarmsSuppressed {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsSuppressed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsSuppressed
namespace AlarmsEnabled {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsEnabled
namespace AlarmsSupported {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsSupported
namespace SensorFault {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SensorFault::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SensorFault
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentSensitivityLevel::TypeInfo::DecodableType currentSensitivityLevel       = static_cast<uint8_t>(0);
        Attributes::SupportedSensitivityLevels::TypeInfo::DecodableType supportedSensitivityLevels = static_cast<uint8_t>(0);
        Attributes::DefaultSensitivityLevel::TypeInfo::DecodableType defaultSensitivityLevel       = static_cast<uint8_t>(0);
        Attributes::AlarmsActive::TypeInfo::DecodableType alarmsActive =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::AlarmsSuppressed::TypeInfo::DecodableType alarmsSuppressed =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::AlarmsEnabled::TypeInfo::DecodableType alarmsEnabled =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::AlarmsSupported::TypeInfo::DecodableType alarmsSupported =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::SensorFault::TypeInfo::DecodableType sensorFault =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace AlarmsStateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAlarmsActive     = 0,
    kAlarmsSuppressed = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmsStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<AlarmModeBitmap> alarmsActive = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    Optional<chip::BitMask<AlarmModeBitmap>> alarmsSuppressed;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmsStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsActive = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    Optional<chip::BitMask<AlarmModeBitmap>> alarmsSuppressed;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AlarmsStateChanged
namespace SensorFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSensorFault = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<SensorFaultBitmap> sensorFault = static_cast<chip::BitMask<SensorFaultBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<SensorFaultBitmap> sensorFault = static_cast<chip::BitMask<SensorFaultBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SensorFault
} // namespace Events
} // namespace BooleanStateConfiguration
namespace ValveConfigurationAndControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Open {
struct Type;
struct DecodableType;
} // namespace Open

namespace Close {
struct Type;
struct DecodableType;
} // namespace Close

} // namespace Commands

namespace Commands {
namespace Open {
enum class Fields : uint8_t
{
    kOpenDuration = 0,
    kTargetLevel  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Open::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    Optional<DataModel::Nullable<uint32_t>> openDuration;
    Optional<chip::Percent> targetLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Open::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    Optional<DataModel::Nullable<uint32_t>> openDuration;
    Optional<chip::Percent> targetLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Open
namespace Close {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Close::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Close::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Close
} // namespace Commands

namespace Attributes {

namespace OpenDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OpenDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OpenDuration
namespace DefaultOpenDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOpenDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOpenDuration
namespace AutoCloseTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AutoCloseTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AutoCloseTime
namespace RemainingDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingDuration
namespace CurrentState {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentState
namespace TargetState {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetState
namespace CurrentLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLevel
namespace TargetLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetLevel
namespace DefaultOpenLevel {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOpenLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOpenLevel
namespace ValveFault {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ValveFault::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ValveFault
namespace LevelStep {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelStep::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelStep
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OpenDuration::TypeInfo::DecodableType openDuration;
        Attributes::DefaultOpenDuration::TypeInfo::DecodableType defaultOpenDuration;
        Attributes::AutoCloseTime::TypeInfo::DecodableType autoCloseTime;
        Attributes::RemainingDuration::TypeInfo::DecodableType remainingDuration;
        Attributes::CurrentState::TypeInfo::DecodableType currentState;
        Attributes::TargetState::TypeInfo::DecodableType targetState;
        Attributes::CurrentLevel::TypeInfo::DecodableType currentLevel;
        Attributes::TargetLevel::TypeInfo::DecodableType targetLevel;
        Attributes::DefaultOpenLevel::TypeInfo::DecodableType defaultOpenLevel = static_cast<chip::Percent>(0);
        Attributes::ValveFault::TypeInfo::DecodableType valveFault =
            static_cast<chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>>(0);
        Attributes::LevelStep::TypeInfo::DecodableType levelStep = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace ValveStateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kValveState = 0,
    kValveLevel = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    ValveStateEnum valveState = static_cast<ValveStateEnum>(0);
    Optional<chip::Percent> valveLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    ValveStateEnum valveState = static_cast<ValveStateEnum>(0);
    Optional<chip::Percent> valveLevel;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ValveStateChanged
namespace ValveFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kValveFault = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<ValveFaultBitmap> valveFault = static_cast<chip::BitMask<ValveFaultBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    chip::BitMask<ValveFaultBitmap> valveFault = static_cast<chip::BitMask<ValveFaultBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ValveFault
} // namespace Events
} // namespace ValveConfigurationAndControl
namespace ElectricalPowerMeasurement {
namespace Structs {
namespace MeasurementAccuracyRangeStruct = Clusters::detail::Structs::MeasurementAccuracyRangeStruct;
namespace MeasurementAccuracyStruct      = Clusters::detail::Structs::MeasurementAccuracyStruct;
namespace HarmonicMeasurementStruct {
enum class Fields : uint8_t
{
    kOrder       = 0,
    kMeasurement = 1,
};

struct Type
{
public:
    uint8_t order = static_cast<uint8_t>(0);
    DataModel::Nullable<int64_t> measurement;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace HarmonicMeasurementStruct
namespace MeasurementRangeStruct {
enum class Fields : uint8_t
{
    kMeasurementType = 0,
    kMin             = 1,
    kMax             = 2,
    kStartTimestamp  = 3,
    kEndTimestamp    = 4,
    kMinTimestamp    = 5,
    kMaxTimestamp    = 6,
    kStartSystime    = 7,
    kEndSystime      = 8,
    kMinSystime      = 9,
    kMaxSystime      = 10,
};

struct Type
{
public:
    MeasurementTypeEnum measurementType = static_cast<MeasurementTypeEnum>(0);
    int64_t min                         = static_cast<int64_t>(0);
    int64_t max                         = static_cast<int64_t>(0);
    Optional<uint32_t> startTimestamp;
    Optional<uint32_t> endTimestamp;
    Optional<uint32_t> minTimestamp;
    Optional<uint32_t> maxTimestamp;
    Optional<uint64_t> startSystime;
    Optional<uint64_t> endSystime;
    Optional<uint64_t> minSystime;
    Optional<uint64_t> maxSystime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MeasurementRangeStruct
} // namespace Structs

namespace Attributes {

namespace PowerMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum;
    using DecodableType    = chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum;
    using DecodableArgType = chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerMode
namespace NumberOfMeasurementTypes {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfMeasurementTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfMeasurementTypes
namespace Accuracy {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementAccuracyStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementAccuracyStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementAccuracyStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Accuracy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Accuracy
namespace Ranges {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementRangeStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementRangeStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementRangeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Ranges::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Ranges
namespace Voltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Voltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Voltage
namespace ActiveCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCurrent
namespace ReactiveCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactiveCurrent
namespace ApparentCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentCurrent
namespace ActivePower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePower
namespace ReactivePower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePower
namespace ApparentPower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPower
namespace RMSVoltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RMSVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RMSVoltage
namespace RMSCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RMSCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RMSCurrent
namespace RMSPower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RMSPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RMSPower
namespace Frequency {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Frequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Frequency
namespace HarmonicCurrents {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<
                    const chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::Type>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
           chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicCurrents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HarmonicCurrents
namespace HarmonicPhases {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<
                    const chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::Type>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
           chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicPhases::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HarmonicPhases
namespace PowerFactor {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactor
namespace NeutralCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeutralCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeutralCurrent
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PowerMode::TypeInfo::DecodableType powerMode =
            static_cast<chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum>(0);
        Attributes::NumberOfMeasurementTypes::TypeInfo::DecodableType numberOfMeasurementTypes = static_cast<uint8_t>(0);
        Attributes::Accuracy::TypeInfo::DecodableType accuracy;
        Attributes::Ranges::TypeInfo::DecodableType ranges;
        Attributes::Voltage::TypeInfo::DecodableType voltage;
        Attributes::ActiveCurrent::TypeInfo::DecodableType activeCurrent;
        Attributes::ReactiveCurrent::TypeInfo::DecodableType reactiveCurrent;
        Attributes::ApparentCurrent::TypeInfo::DecodableType apparentCurrent;
        Attributes::ActivePower::TypeInfo::DecodableType activePower;
        Attributes::ReactivePower::TypeInfo::DecodableType reactivePower;
        Attributes::ApparentPower::TypeInfo::DecodableType apparentPower;
        Attributes::RMSVoltage::TypeInfo::DecodableType RMSVoltage;
        Attributes::RMSCurrent::TypeInfo::DecodableType RMSCurrent;
        Attributes::RMSPower::TypeInfo::DecodableType RMSPower;
        Attributes::Frequency::TypeInfo::DecodableType frequency;
        Attributes::HarmonicCurrents::TypeInfo::DecodableType harmonicCurrents;
        Attributes::HarmonicPhases::TypeInfo::DecodableType harmonicPhases;
        Attributes::PowerFactor::TypeInfo::DecodableType powerFactor;
        Attributes::NeutralCurrent::TypeInfo::DecodableType neutralCurrent;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace MeasurementPeriodRanges {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kRanges = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MeasurementPeriodRanges::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const Structs::MeasurementRangeStruct::Type> ranges;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MeasurementPeriodRanges::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }

    DataModel::DecodableList<Structs::MeasurementRangeStruct::DecodableType> ranges;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MeasurementPeriodRanges
} // namespace Events
} // namespace ElectricalPowerMeasurement
namespace ElectricalEnergyMeasurement {
namespace Structs {
namespace MeasurementAccuracyRangeStruct = Clusters::detail::Structs::MeasurementAccuracyRangeStruct;
namespace MeasurementAccuracyStruct      = Clusters::detail::Structs::MeasurementAccuracyStruct;
namespace CumulativeEnergyResetStruct {
enum class Fields : uint8_t
{
    kImportedResetTimestamp = 0,
    kExportedResetTimestamp = 1,
    kImportedResetSystime   = 2,
    kExportedResetSystime   = 3,
};

struct Type
{
public:
    Optional<DataModel::Nullable<uint32_t>> importedResetTimestamp;
    Optional<DataModel::Nullable<uint32_t>> exportedResetTimestamp;
    Optional<DataModel::Nullable<uint64_t>> importedResetSystime;
    Optional<DataModel::Nullable<uint64_t>> exportedResetSystime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CumulativeEnergyResetStruct
namespace EnergyMeasurementStruct {
enum class Fields : uint8_t
{
    kEnergy         = 0,
    kStartTimestamp = 1,
    kEndTimestamp   = 2,
    kStartSystime   = 3,
    kEndSystime     = 4,
};

struct Type
{
public:
    int64_t energy = static_cast<int64_t>(0);
    Optional<uint32_t> startTimestamp;
    Optional<uint32_t> endTimestamp;
    Optional<uint64_t> startSystime;
    Optional<uint64_t> endSystime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace EnergyMeasurementStruct
} // namespace Structs

namespace Attributes {

namespace Accuracy {
struct TypeInfo
{
    using Type          = chip::app::Clusters::ElectricalEnergyMeasurement::Structs::MeasurementAccuracyStruct::Type;
    using DecodableType = chip::app::Clusters::ElectricalEnergyMeasurement::Structs::MeasurementAccuracyStruct::DecodableType;
    using DecodableArgType =
        const chip::app::Clusters::ElectricalEnergyMeasurement::Structs::MeasurementAccuracyStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Accuracy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Accuracy
namespace CumulativeEnergyImported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CumulativeEnergyImported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CumulativeEnergyImported
namespace CumulativeEnergyExported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CumulativeEnergyExported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CumulativeEnergyExported
namespace PeriodicEnergyImported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeriodicEnergyImported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeriodicEnergyImported
namespace PeriodicEnergyExported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeriodicEnergyExported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeriodicEnergyExported
namespace CumulativeEnergyReset {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::CumulativeEnergyResetStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::CumulativeEnergyResetStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::CumulativeEnergyResetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CumulativeEnergyReset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CumulativeEnergyReset
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Accuracy::TypeInfo::DecodableType accuracy;
        Attributes::CumulativeEnergyImported::TypeInfo::DecodableType cumulativeEnergyImported;
        Attributes::CumulativeEnergyExported::TypeInfo::DecodableType cumulativeEnergyExported;
        Attributes::PeriodicEnergyImported::TypeInfo::DecodableType periodicEnergyImported;
        Attributes::PeriodicEnergyExported::TypeInfo::DecodableType periodicEnergyExported;
        Attributes::CumulativeEnergyReset::TypeInfo::DecodableType cumulativeEnergyReset;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace CumulativeEnergyMeasured {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kEnergyImported = 0,
    kEnergyExported = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::CumulativeEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<Structs::EnergyMeasurementStruct::Type> energyImported;
    Optional<Structs::EnergyMeasurementStruct::Type> energyExported;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::CumulativeEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }

    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyImported;
    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyExported;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace CumulativeEnergyMeasured
namespace PeriodicEnergyMeasured {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kEnergyImported = 0,
    kEnergyExported = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PeriodicEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<Structs::EnergyMeasurementStruct::Type> energyImported;
    Optional<Structs::EnergyMeasurementStruct::Type> energyExported;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PeriodicEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }

    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyImported;
    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyExported;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PeriodicEnergyMeasured
} // namespace Events
} // namespace ElectricalEnergyMeasurement
namespace DemandResponseLoadControl {
namespace Structs {
namespace HeatingSourceControlStruct {
enum class Fields : uint8_t
{
    kHeatingSource = 0,
};

struct Type
{
public:
    HeatingSourceEnum heatingSource = static_cast<HeatingSourceEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace HeatingSourceControlStruct
namespace PowerSavingsControlStruct {
enum class Fields : uint8_t
{
    kPowerSavings = 0,
};

struct Type
{
public:
    chip::Percent powerSavings = static_cast<chip::Percent>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PowerSavingsControlStruct
namespace DutyCycleControlStruct {
enum class Fields : uint8_t
{
    kDutyCycle = 0,
};

struct Type
{
public:
    chip::Percent dutyCycle = static_cast<chip::Percent>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DutyCycleControlStruct
namespace AverageLoadControlStruct {
enum class Fields : uint8_t
{
    kLoadAdjustment = 0,
};

struct Type
{
public:
    int8_t loadAdjustment = static_cast<int8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AverageLoadControlStruct
namespace TemperatureControlStruct {
enum class Fields : uint8_t
{
    kCoolingTempOffset   = 0,
    kHeatingtTempOffset  = 1,
    kCoolingTempSetpoint = 2,
    kHeatingTempSetpoint = 3,
};

struct Type
{
public:
    Optional<DataModel::Nullable<uint16_t>> coolingTempOffset;
    Optional<DataModel::Nullable<uint16_t>> heatingtTempOffset;
    Optional<DataModel::Nullable<int16_t>> coolingTempSetpoint;
    Optional<DataModel::Nullable<int16_t>> heatingTempSetpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TemperatureControlStruct
namespace LoadControlEventTransitionStruct {
enum class Fields : uint8_t
{
    kDuration             = 0,
    kControl              = 1,
    kTemperatureControl   = 2,
    kAverageLoadControl   = 3,
    kDutyCycleControl     = 4,
    kPowerSavingsControl  = 5,
    kHeatingSourceControl = 6,
};

struct Type
{
public:
    uint16_t duration                                   = static_cast<uint16_t>(0);
    chip::BitMask<EventTransitionControlBitmap> control = static_cast<chip::BitMask<EventTransitionControlBitmap>>(0);
    Optional<Structs::TemperatureControlStruct::Type> temperatureControl;
    Optional<Structs::AverageLoadControlStruct::Type> averageLoadControl;
    Optional<Structs::DutyCycleControlStruct::Type> dutyCycleControl;
    Optional<Structs::PowerSavingsControlStruct::Type> powerSavingsControl;
    Optional<Structs::HeatingSourceControlStruct::Type> heatingSourceControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LoadControlEventTransitionStruct
namespace LoadControlEventStruct {
enum class Fields : uint8_t
{
    kEventID         = 0,
    kProgramID       = 1,
    kControl         = 2,
    kDeviceClass     = 3,
    kEnrollmentGroup = 4,
    kCriticality     = 5,
    kStartTime       = 6,
    kTransitions     = 7,
};

struct Type
{
public:
    chip::ByteSpan eventID;
    DataModel::Nullable<chip::ByteSpan> programID;
    chip::BitMask<EventControlBitmap> control    = static_cast<chip::BitMask<EventControlBitmap>>(0);
    chip::BitMask<DeviceClassBitmap> deviceClass = static_cast<chip::BitMask<DeviceClassBitmap>>(0);
    Optional<uint8_t> enrollmentGroup;
    CriticalityLevelEnum criticality = static_cast<CriticalityLevelEnum>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::List<const Structs::LoadControlEventTransitionStruct::Type> transitions;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::ByteSpan eventID;
    DataModel::Nullable<chip::ByteSpan> programID;
    chip::BitMask<EventControlBitmap> control    = static_cast<chip::BitMask<EventControlBitmap>>(0);
    chip::BitMask<DeviceClassBitmap> deviceClass = static_cast<chip::BitMask<DeviceClassBitmap>>(0);
    Optional<uint8_t> enrollmentGroup;
    CriticalityLevelEnum criticality = static_cast<CriticalityLevelEnum>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::DecodableList<Structs::LoadControlEventTransitionStruct::DecodableType> transitions;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace LoadControlEventStruct
namespace LoadControlProgramStruct {
enum class Fields : uint8_t
{
    kProgramID             = 0,
    kName                  = 1,
    kEnrollmentGroup       = 2,
    kRandomStartMinutes    = 3,
    kRandomDurationMinutes = 4,
};

struct Type
{
public:
    chip::ByteSpan programID;
    chip::CharSpan name;
    DataModel::Nullable<uint8_t> enrollmentGroup;
    DataModel::Nullable<uint8_t> randomStartMinutes;
    DataModel::Nullable<uint8_t> randomDurationMinutes;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LoadControlProgramStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RegisterLoadControlProgramRequest {
struct Type;
struct DecodableType;
} // namespace RegisterLoadControlProgramRequest

namespace UnregisterLoadControlProgramRequest {
struct Type;
struct DecodableType;
} // namespace UnregisterLoadControlProgramRequest

namespace AddLoadControlEventRequest {
struct Type;
struct DecodableType;
} // namespace AddLoadControlEventRequest

namespace RemoveLoadControlEventRequest {
struct Type;
struct DecodableType;
} // namespace RemoveLoadControlEventRequest

namespace ClearLoadControlEventsRequest {
struct Type;
struct DecodableType;
} // namespace ClearLoadControlEventsRequest

} // namespace Commands

namespace Commands {
namespace RegisterLoadControlProgramRequest {
enum class Fields : uint8_t
{
    kLoadControlProgram = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RegisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlProgramStruct::Type loadControlProgram;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RegisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlProgramStruct::DecodableType loadControlProgram;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RegisterLoadControlProgramRequest
namespace UnregisterLoadControlProgramRequest {
enum class Fields : uint8_t
{
    kLoadControlProgramID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnregisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan loadControlProgramID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnregisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan loadControlProgramID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnregisterLoadControlProgramRequest
namespace AddLoadControlEventRequest {
enum class Fields : uint8_t
{
    kEvent = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlEventStruct::Type event;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlEventStruct::DecodableType event;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddLoadControlEventRequest
namespace RemoveLoadControlEventRequest {
enum class Fields : uint8_t
{
    kEventID       = 0,
    kCancelControl = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan eventID;
    chip::BitMask<CancelControlBitmap> cancelControl = static_cast<chip::BitMask<CancelControlBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan eventID;
    chip::BitMask<CancelControlBitmap> cancelControl = static_cast<chip::BitMask<CancelControlBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveLoadControlEventRequest
namespace ClearLoadControlEventsRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearLoadControlEventsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearLoadControlEventsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearLoadControlEventsRequest
} // namespace Commands

namespace Attributes {

namespace LoadControlPrograms {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlProgramStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlProgramStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlProgramStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LoadControlPrograms::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LoadControlPrograms
namespace NumberOfLoadControlPrograms {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfLoadControlPrograms::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfLoadControlPrograms
namespace Events {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Events::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Events
namespace ActiveEvents {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveEvents
namespace NumberOfEventsPerProgram {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfEventsPerProgram::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfEventsPerProgram
namespace NumberOfTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfTransitions
namespace DefaultRandomStart {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultRandomStart::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultRandomStart
namespace DefaultRandomDuration {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultRandomDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultRandomDuration
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LoadControlPrograms::TypeInfo::DecodableType loadControlPrograms;
        Attributes::NumberOfLoadControlPrograms::TypeInfo::DecodableType numberOfLoadControlPrograms = static_cast<uint8_t>(0);
        Attributes::Events::TypeInfo::DecodableType events;
        Attributes::ActiveEvents::TypeInfo::DecodableType activeEvents;
        Attributes::NumberOfEventsPerProgram::TypeInfo::DecodableType numberOfEventsPerProgram = static_cast<uint8_t>(0);
        Attributes::NumberOfTransitions::TypeInfo::DecodableType numberOfTransitions           = static_cast<uint8_t>(0);
        Attributes::DefaultRandomStart::TypeInfo::DecodableType defaultRandomStart             = static_cast<uint8_t>(0);
        Attributes::DefaultRandomDuration::TypeInfo::DecodableType defaultRandomDuration       = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace LoadControlEventStatusChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kEventID              = 0,
    kTransitionIndex      = 1,
    kStatus               = 2,
    kCriticality          = 3,
    kControl              = 4,
    kTemperatureControl   = 5,
    kAverageLoadControl   = 6,
    kDutyCycleControl     = 7,
    kPowerSavingsControl  = 8,
    kHeatingSourceControl = 9,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoadControlEventStatusChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan eventID;
    DataModel::Nullable<uint8_t> transitionIndex;
    LoadControlEventStatusEnum status         = static_cast<LoadControlEventStatusEnum>(0);
    CriticalityLevelEnum criticality          = static_cast<CriticalityLevelEnum>(0);
    chip::BitMask<EventControlBitmap> control = static_cast<chip::BitMask<EventControlBitmap>>(0);
    Optional<DataModel::Nullable<Structs::TemperatureControlStruct::Type>> temperatureControl;
    Optional<DataModel::Nullable<Structs::AverageLoadControlStruct::Type>> averageLoadControl;
    Optional<DataModel::Nullable<Structs::DutyCycleControlStruct::Type>> dutyCycleControl;
    Optional<DataModel::Nullable<Structs::PowerSavingsControlStruct::Type>> powerSavingsControl;
    Optional<DataModel::Nullable<Structs::HeatingSourceControlStruct::Type>> heatingSourceControl;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoadControlEventStatusChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan eventID;
    DataModel::Nullable<uint8_t> transitionIndex;
    LoadControlEventStatusEnum status         = static_cast<LoadControlEventStatusEnum>(0);
    CriticalityLevelEnum criticality          = static_cast<CriticalityLevelEnum>(0);
    chip::BitMask<EventControlBitmap> control = static_cast<chip::BitMask<EventControlBitmap>>(0);
    Optional<DataModel::Nullable<Structs::TemperatureControlStruct::DecodableType>> temperatureControl;
    Optional<DataModel::Nullable<Structs::AverageLoadControlStruct::DecodableType>> averageLoadControl;
    Optional<DataModel::Nullable<Structs::DutyCycleControlStruct::DecodableType>> dutyCycleControl;
    Optional<DataModel::Nullable<Structs::PowerSavingsControlStruct::DecodableType>> powerSavingsControl;
    Optional<DataModel::Nullable<Structs::HeatingSourceControlStruct::DecodableType>> heatingSourceControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LoadControlEventStatusChange
} // namespace Events
} // namespace DemandResponseLoadControl
namespace Messages {
namespace Structs {
namespace MessageResponseOptionStruct {
enum class Fields : uint8_t
{
    kMessageResponseID = 0,
    kLabel             = 1,
};

struct Type
{
public:
    Optional<uint32_t> messageResponseID;
    Optional<chip::CharSpan> label;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MessageResponseOptionStruct
namespace MessageStruct {
enum class Fields : uint8_t
{
    kMessageID      = 0,
    kPriority       = 1,
    kMessageControl = 2,
    kStartTime      = 3,
    kDuration       = 4,
    kMessageText    = 5,
    kResponses      = 6,
};

struct Type
{
public:
    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::List<const Structs::MessageResponseOptionStruct::Type>> responses;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::DecodableList<Structs::MessageResponseOptionStruct::DecodableType>> responses;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace MessageStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace PresentMessagesRequest {
struct Type;
struct DecodableType;
} // namespace PresentMessagesRequest

namespace CancelMessagesRequest {
struct Type;
struct DecodableType;
} // namespace CancelMessagesRequest

} // namespace Commands

namespace Commands {
namespace PresentMessagesRequest {
enum class Fields : uint8_t
{
    kMessageID      = 0,
    kPriority       = 1,
    kMessageControl = 2,
    kStartTime      = 3,
    kDuration       = 4,
    kMessageText    = 5,
    kResponses      = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PresentMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::List<const Structs::MessageResponseOptionStruct::Type>> responses;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PresentMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::DecodableList<Structs::MessageResponseOptionStruct::DecodableType>> responses;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PresentMessagesRequest
namespace CancelMessagesRequest {
enum class Fields : uint8_t
{
    kMessageIDs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    DataModel::List<const chip::ByteSpan> messageIDs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    DataModel::DecodableList<chip::ByteSpan> messageIDs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelMessagesRequest
} // namespace Commands

namespace Attributes {

namespace Messages {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Messages::Structs::MessageStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Messages::Structs::MessageStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Messages::Structs::MessageStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Messages::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Messages
namespace ActiveMessageIDs {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveMessageIDs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveMessageIDs
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Messages::TypeInfo::DecodableType messages;
        Attributes::ActiveMessageIDs::TypeInfo::DecodableType activeMessageIDs;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace MessageQueued {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kMessageID = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageQueued::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan messageID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageQueued::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MessageQueued
namespace MessagePresented {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kMessageID = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessagePresented::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan messageID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessagePresented::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MessagePresented
namespace MessageComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kMessageID                = 0,
    kResponseID               = 1,
    kReply                    = 2,
    kFutureMessagesPreference = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan messageID;
    Optional<DataModel::Nullable<uint32_t>> responseID;
    Optional<DataModel::Nullable<chip::CharSpan>> reply;
    DataModel::Nullable<FutureMessagePreferenceEnum> futureMessagesPreference;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;
    Optional<DataModel::Nullable<uint32_t>> responseID;
    Optional<DataModel::Nullable<chip::CharSpan>> reply;
    DataModel::Nullable<FutureMessagePreferenceEnum> futureMessagesPreference;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MessageComplete
} // namespace Events
} // namespace Messages
namespace DeviceEnergyManagement {
namespace Structs {
namespace CostStruct {
enum class Fields : uint8_t
{
    kCostType      = 0,
    kValue         = 1,
    kDecimalPoints = 2,
    kCurrency      = 3,
};

struct Type
{
public:
    CostTypeEnum costType = static_cast<CostTypeEnum>(0);
    int32_t value         = static_cast<int32_t>(0);
    uint8_t decimalPoints = static_cast<uint8_t>(0);
    Optional<uint16_t> currency;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CostStruct
namespace SlotStruct {
enum class Fields : uint8_t
{
    kMinDuration           = 0,
    kMaxDuration           = 1,
    kDefaultDuration       = 2,
    kElapsedSlotTime       = 3,
    kRemainingSlotTime     = 4,
    kSlotIsPauseable       = 5,
    kMinPauseDuration      = 6,
    kMaxPauseDuration      = 7,
    kManufacturerESAState  = 8,
    kNominalPower          = 9,
    kMinPower              = 10,
    kMaxPower              = 11,
    kNominalEnergy         = 12,
    kCosts                 = 13,
    kMinPowerAdjustment    = 14,
    kMaxPowerAdjustment    = 15,
    kMinDurationAdjustment = 16,
    kMaxDurationAdjustment = 17,
};

struct Type
{
public:
    uint32_t minDuration       = static_cast<uint32_t>(0);
    uint32_t maxDuration       = static_cast<uint32_t>(0);
    uint32_t defaultDuration   = static_cast<uint32_t>(0);
    uint32_t elapsedSlotTime   = static_cast<uint32_t>(0);
    uint32_t remainingSlotTime = static_cast<uint32_t>(0);
    Optional<bool> slotIsPauseable;
    Optional<uint32_t> minPauseDuration;
    Optional<uint32_t> maxPauseDuration;
    Optional<uint16_t> manufacturerESAState;
    Optional<int64_t> nominalPower;
    Optional<int64_t> minPower;
    Optional<int64_t> maxPower;
    Optional<int64_t> nominalEnergy;
    Optional<DataModel::List<const Structs::CostStruct::Type>> costs;
    Optional<int64_t> minPowerAdjustment;
    Optional<int64_t> maxPowerAdjustment;
    Optional<uint32_t> minDurationAdjustment;
    Optional<uint32_t> maxDurationAdjustment;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint32_t minDuration       = static_cast<uint32_t>(0);
    uint32_t maxDuration       = static_cast<uint32_t>(0);
    uint32_t defaultDuration   = static_cast<uint32_t>(0);
    uint32_t elapsedSlotTime   = static_cast<uint32_t>(0);
    uint32_t remainingSlotTime = static_cast<uint32_t>(0);
    Optional<bool> slotIsPauseable;
    Optional<uint32_t> minPauseDuration;
    Optional<uint32_t> maxPauseDuration;
    Optional<uint16_t> manufacturerESAState;
    Optional<int64_t> nominalPower;
    Optional<int64_t> minPower;
    Optional<int64_t> maxPower;
    Optional<int64_t> nominalEnergy;
    Optional<DataModel::DecodableList<Structs::CostStruct::DecodableType>> costs;
    Optional<int64_t> minPowerAdjustment;
    Optional<int64_t> maxPowerAdjustment;
    Optional<uint32_t> minDurationAdjustment;
    Optional<uint32_t> maxDurationAdjustment;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace SlotStruct
namespace ForecastStruct {
enum class Fields : uint8_t
{
    kForecastId           = 0,
    kActiveSlotNumber     = 1,
    kStartTime            = 2,
    kEndTime              = 3,
    kEarliestStartTime    = 4,
    kLatestEndTime        = 5,
    kIsPauseable          = 6,
    kSlots                = 7,
    kForecastUpdateReason = 8,
};

struct Type
{
public:
    uint16_t forecastId = static_cast<uint16_t>(0);
    DataModel::Nullable<uint16_t> activeSlotNumber;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    Optional<DataModel::Nullable<uint32_t>> earliestStartTime;
    Optional<uint32_t> latestEndTime;
    bool isPauseable = static_cast<bool>(0);
    DataModel::List<const Structs::SlotStruct::Type> slots;
    ForecastUpdateReasonEnum forecastUpdateReason = static_cast<ForecastUpdateReasonEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint16_t forecastId = static_cast<uint16_t>(0);
    DataModel::Nullable<uint16_t> activeSlotNumber;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    Optional<DataModel::Nullable<uint32_t>> earliestStartTime;
    Optional<uint32_t> latestEndTime;
    bool isPauseable = static_cast<bool>(0);
    DataModel::DecodableList<Structs::SlotStruct::DecodableType> slots;
    ForecastUpdateReasonEnum forecastUpdateReason = static_cast<ForecastUpdateReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ForecastStruct
namespace ConstraintsStruct {
enum class Fields : uint8_t
{
    kStartTime     = 0,
    kDuration      = 1,
    kNominalPower  = 2,
    kMaximumEnergy = 3,
    kLoadControl   = 4,
};

struct Type
{
public:
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t duration  = static_cast<uint32_t>(0);
    Optional<int64_t> nominalPower;
    Optional<int64_t> maximumEnergy;
    Optional<int8_t> loadControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ConstraintsStruct
namespace PowerAdjustStruct {
enum class Fields : uint8_t
{
    kMinPower    = 0,
    kMaxPower    = 1,
    kMinDuration = 2,
    kMaxDuration = 3,
};

struct Type
{
public:
    int64_t minPower     = static_cast<int64_t>(0);
    int64_t maxPower     = static_cast<int64_t>(0);
    uint32_t minDuration = static_cast<uint32_t>(0);
    uint32_t maxDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PowerAdjustStruct
namespace SlotAdjustmentStruct {
enum class Fields : uint8_t
{
    kSlotIndex    = 0,
    kNominalPower = 1,
    kDuration     = 2,
};

struct Type
{
public:
    uint8_t slotIndex    = static_cast<uint8_t>(0);
    int64_t nominalPower = static_cast<int64_t>(0);
    uint32_t duration    = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SlotAdjustmentStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace PowerAdjustRequest {
struct Type;
struct DecodableType;
} // namespace PowerAdjustRequest

namespace CancelPowerAdjustRequest {
struct Type;
struct DecodableType;
} // namespace CancelPowerAdjustRequest

namespace StartTimeAdjustRequest {
struct Type;
struct DecodableType;
} // namespace StartTimeAdjustRequest

namespace PauseRequest {
struct Type;
struct DecodableType;
} // namespace PauseRequest

namespace ResumeRequest {
struct Type;
struct DecodableType;
} // namespace ResumeRequest

namespace ModifyForecastRequest {
struct Type;
struct DecodableType;
} // namespace ModifyForecastRequest

namespace RequestConstraintBasedForecast {
struct Type;
struct DecodableType;
} // namespace RequestConstraintBasedForecast

namespace CancelRequest {
struct Type;
struct DecodableType;
} // namespace CancelRequest

} // namespace Commands

namespace Commands {
namespace PowerAdjustRequest {
enum class Fields : uint8_t
{
    kPower    = 0,
    kDuration = 1,
    kCause    = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    int64_t power             = static_cast<int64_t>(0);
    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    int64_t power             = static_cast<int64_t>(0);
    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerAdjustRequest
namespace CancelPowerAdjustRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelPowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelPowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelPowerAdjustRequest
namespace StartTimeAdjustRequest {
enum class Fields : uint8_t
{
    kRequestedStartTime = 0,
    kCause              = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartTimeAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t requestedStartTime = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause   = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartTimeAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t requestedStartTime = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause   = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartTimeAdjustRequest
namespace PauseRequest {
enum class Fields : uint8_t
{
    kDuration = 0,
    kCause    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseRequest
namespace ResumeRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResumeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResumeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResumeRequest
namespace ModifyForecastRequest {
enum class Fields : uint8_t
{
    kForecastId      = 0,
    kSlotAdjustments = 1,
    kCause           = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ModifyForecastRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t forecastId = static_cast<uint32_t>(0);
    DataModel::List<const Structs::SlotAdjustmentStruct::Type> slotAdjustments;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ModifyForecastRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t forecastId = static_cast<uint32_t>(0);
    DataModel::DecodableList<Structs::SlotAdjustmentStruct::DecodableType> slotAdjustments;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ModifyForecastRequest
namespace RequestConstraintBasedForecast {
enum class Fields : uint8_t
{
    kConstraints = 0,
    kCause       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RequestConstraintBasedForecast::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    DataModel::List<const Structs::ConstraintsStruct::Type> constraints;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RequestConstraintBasedForecast::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    DataModel::DecodableList<Structs::ConstraintsStruct::DecodableType> constraints;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RequestConstraintBasedForecast
namespace CancelRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelRequest
} // namespace Commands

namespace Attributes {

namespace ESAType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum;
    using DecodableType    = chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum;
    using DecodableArgType = chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ESAType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ESAType
namespace ESACanGenerate {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ESACanGenerate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ESACanGenerate
namespace ESAState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum;
    using DecodableType    = chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum;
    using DecodableArgType = chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ESAState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ESAState
namespace AbsMinPower {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinPower
namespace AbsMaxPower {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxPower
namespace PowerAdjustmentCapability {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::DataModel::List<const chip::app::Clusters::DeviceEnergyManagement::Structs::PowerAdjustStruct::Type>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
           chip::app::Clusters::DeviceEnergyManagement::Structs::PowerAdjustStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
        chip::app::Clusters::DeviceEnergyManagement::Structs::PowerAdjustStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerAdjustmentCapability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerAdjustmentCapability
namespace Forecast {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::ForecastStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::ForecastStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::ForecastStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Forecast::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Forecast
namespace OptOutState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum;
    using DecodableType    = chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum;
    using DecodableArgType = chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OptOutState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OptOutState
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ESAType::TypeInfo::DecodableType ESAType =
            static_cast<chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum>(0);
        Attributes::ESACanGenerate::TypeInfo::DecodableType ESACanGenerate = static_cast<bool>(0);
        Attributes::ESAState::TypeInfo::DecodableType ESAState =
            static_cast<chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum>(0);
        Attributes::AbsMinPower::TypeInfo::DecodableType absMinPower = static_cast<int64_t>(0);
        Attributes::AbsMaxPower::TypeInfo::DecodableType absMaxPower = static_cast<int64_t>(0);
        Attributes::PowerAdjustmentCapability::TypeInfo::DecodableType powerAdjustmentCapability;
        Attributes::Forecast::TypeInfo::DecodableType forecast;
        Attributes::OptOutState::TypeInfo::DecodableType optOutState =
            static_cast<chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace PowerAdjustStart {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustStart::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustStart::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerAdjustStart
namespace PowerAdjustEnd {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCause     = 0,
    kDuration  = 1,
    kEnergyUse = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustEnd::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CauseEnum cause   = static_cast<CauseEnum>(0);
    uint32_t duration = static_cast<uint32_t>(0);
    int64_t energyUse = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustEnd::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CauseEnum cause   = static_cast<CauseEnum>(0);
    uint32_t duration = static_cast<uint32_t>(0);
    int64_t energyUse = static_cast<int64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerAdjustEnd
namespace Paused {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Paused::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Paused::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Paused
namespace Resumed {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCause = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Resumed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CauseEnum cause = static_cast<CauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Resumed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CauseEnum cause = static_cast<CauseEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Resumed
} // namespace Events
} // namespace DeviceEnergyManagement
namespace EnergyEvse {
namespace Structs {
namespace ChargingTargetStruct {
enum class Fields : uint8_t
{
    kTargetTimeMinutesPastMidnight = 0,
    kTargetSoC                     = 1,
    kAddedEnergy                   = 2,
};

struct Type
{
public:
    uint16_t targetTimeMinutesPastMidnight = static_cast<uint16_t>(0);
    Optional<chip::Percent> targetSoC;
    Optional<int64_t> addedEnergy;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChargingTargetStruct
namespace ChargingTargetScheduleStruct {
enum class Fields : uint8_t
{
    kDayOfWeekForSequence = 0,
    kChargingTargets      = 1,
};

struct Type
{
public:
    chip::BitMask<TargetDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<TargetDayOfWeekBitmap>>(0);
    DataModel::List<const Structs::ChargingTargetStruct::Type> chargingTargets;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::BitMask<TargetDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<TargetDayOfWeekBitmap>>(0);
    DataModel::DecodableList<Structs::ChargingTargetStruct::DecodableType> chargingTargets;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ChargingTargetScheduleStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetTargetsResponse {
struct Type;
struct DecodableType;
} // namespace GetTargetsResponse

namespace Disable {
struct Type;
struct DecodableType;
} // namespace Disable

namespace EnableCharging {
struct Type;
struct DecodableType;
} // namespace EnableCharging

namespace EnableDischarging {
struct Type;
struct DecodableType;
} // namespace EnableDischarging

namespace StartDiagnostics {
struct Type;
struct DecodableType;
} // namespace StartDiagnostics

namespace SetTargets {
struct Type;
struct DecodableType;
} // namespace SetTargets

namespace GetTargets {
struct Type;
struct DecodableType;
} // namespace GetTargets

namespace ClearTargets {
struct Type;
struct DecodableType;
} // namespace ClearTargets

} // namespace Commands

namespace Commands {
namespace GetTargetsResponse {
enum class Fields : uint8_t
{
    kChargingTargetSchedules = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetTargetsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::List<const Structs::ChargingTargetScheduleStruct::Type> chargingTargetSchedules;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetTargetsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::DecodableList<Structs::ChargingTargetScheduleStruct::DecodableType> chargingTargetSchedules;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetTargetsResponse
namespace Disable {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Disable
namespace EnableCharging {
enum class Fields : uint8_t
{
    kChargingEnabledUntil = 0,
    kMinimumChargeCurrent = 1,
    kMaximumChargeCurrent = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableCharging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> chargingEnabledUntil;
    int64_t minimumChargeCurrent = static_cast<int64_t>(0);
    int64_t maximumChargeCurrent = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableCharging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> chargingEnabledUntil;
    int64_t minimumChargeCurrent = static_cast<int64_t>(0);
    int64_t maximumChargeCurrent = static_cast<int64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableCharging
namespace EnableDischarging {
enum class Fields : uint8_t
{
    kDischargingEnabledUntil = 0,
    kMaximumDischargeCurrent = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableDischarging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> dischargingEnabledUntil;
    int64_t maximumDischargeCurrent = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableDischarging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> dischargingEnabledUntil;
    int64_t maximumDischargeCurrent = static_cast<int64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableDischarging
namespace StartDiagnostics {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartDiagnostics::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartDiagnostics::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartDiagnostics
namespace SetTargets {
enum class Fields : uint8_t
{
    kChargingTargetSchedules = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::List<const Structs::ChargingTargetScheduleStruct::Type> chargingTargetSchedules;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::DecodableList<Structs::ChargingTargetScheduleStruct::DecodableType> chargingTargetSchedules;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTargets
namespace GetTargets {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::EnergyEvse::Commands::GetTargetsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetTargets
namespace ClearTargets {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearTargets
} // namespace Commands

namespace Attributes {

namespace State {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::EnergyEvse::StateEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::EnergyEvse::StateEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::EnergyEvse::StateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::State::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace State
namespace SupplyState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::EnergyEvse::SupplyStateEnum;
    using DecodableType    = chip::app::Clusters::EnergyEvse::SupplyStateEnum;
    using DecodableArgType = chip::app::Clusters::EnergyEvse::SupplyStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupplyState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupplyState
namespace FaultState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::EnergyEvse::FaultStateEnum;
    using DecodableType    = chip::app::Clusters::EnergyEvse::FaultStateEnum;
    using DecodableArgType = chip::app::Clusters::EnergyEvse::FaultStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FaultState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FaultState
namespace ChargingEnabledUntil {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChargingEnabledUntil::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChargingEnabledUntil
namespace DischargingEnabledUntil {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DischargingEnabledUntil::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DischargingEnabledUntil
namespace CircuitCapacity {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CircuitCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CircuitCapacity
namespace MinimumChargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinimumChargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinimumChargeCurrent
namespace MaximumChargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaximumChargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaximumChargeCurrent
namespace MaximumDischargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaximumDischargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaximumDischargeCurrent
namespace UserMaximumChargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserMaximumChargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserMaximumChargeCurrent
namespace RandomizationDelayWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RandomizationDelayWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RandomizationDelayWindow
namespace NextChargeStartTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeStartTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeStartTime
namespace NextChargeTargetTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeTargetTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeTargetTime
namespace NextChargeRequiredEnergy {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeRequiredEnergy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeRequiredEnergy
namespace NextChargeTargetSoC {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeTargetSoC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeTargetSoC
namespace ApproximateEVEfficiency {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApproximateEVEfficiency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApproximateEVEfficiency
namespace StateOfCharge {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StateOfCharge::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StateOfCharge
namespace BatteryCapacity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryCapacity
namespace VehicleID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VehicleID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VehicleID
namespace SessionID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionID
namespace SessionDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionDuration
namespace SessionEnergyCharged {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionEnergyCharged::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionEnergyCharged
namespace SessionEnergyDischarged {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionEnergyDischarged::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionEnergyDischarged
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::State::TypeInfo::DecodableType state;
        Attributes::SupplyState::TypeInfo::DecodableType supplyState =
            static_cast<chip::app::Clusters::EnergyEvse::SupplyStateEnum>(0);
        Attributes::FaultState::TypeInfo::DecodableType faultState =
            static_cast<chip::app::Clusters::EnergyEvse::FaultStateEnum>(0);
        Attributes::ChargingEnabledUntil::TypeInfo::DecodableType chargingEnabledUntil;
        Attributes::DischargingEnabledUntil::TypeInfo::DecodableType dischargingEnabledUntil;
        Attributes::CircuitCapacity::TypeInfo::DecodableType circuitCapacity                   = static_cast<int64_t>(0);
        Attributes::MinimumChargeCurrent::TypeInfo::DecodableType minimumChargeCurrent         = static_cast<int64_t>(0);
        Attributes::MaximumChargeCurrent::TypeInfo::DecodableType maximumChargeCurrent         = static_cast<int64_t>(0);
        Attributes::MaximumDischargeCurrent::TypeInfo::DecodableType maximumDischargeCurrent   = static_cast<int64_t>(0);
        Attributes::UserMaximumChargeCurrent::TypeInfo::DecodableType userMaximumChargeCurrent = static_cast<int64_t>(0);
        Attributes::RandomizationDelayWindow::TypeInfo::DecodableType randomizationDelayWindow = static_cast<uint32_t>(0);
        Attributes::NextChargeStartTime::TypeInfo::DecodableType nextChargeStartTime;
        Attributes::NextChargeTargetTime::TypeInfo::DecodableType nextChargeTargetTime;
        Attributes::NextChargeRequiredEnergy::TypeInfo::DecodableType nextChargeRequiredEnergy;
        Attributes::NextChargeTargetSoC::TypeInfo::DecodableType nextChargeTargetSoC;
        Attributes::ApproximateEVEfficiency::TypeInfo::DecodableType approximateEVEfficiency;
        Attributes::StateOfCharge::TypeInfo::DecodableType stateOfCharge;
        Attributes::BatteryCapacity::TypeInfo::DecodableType batteryCapacity;
        Attributes::VehicleID::TypeInfo::DecodableType vehicleID;
        Attributes::SessionID::TypeInfo::DecodableType sessionID;
        Attributes::SessionDuration::TypeInfo::DecodableType sessionDuration;
        Attributes::SessionEnergyCharged::TypeInfo::DecodableType sessionEnergyCharged;
        Attributes::SessionEnergyDischarged::TypeInfo::DecodableType sessionEnergyDischarged;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace EVConnected {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVConnected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVConnected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EVConnected
namespace EVNotDetected {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID               = 0,
    kState                   = 1,
    kSessionDuration         = 2,
    kSessionEnergyCharged    = 3,
    kSessionEnergyDischarged = 4,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVNotDetected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID           = static_cast<uint32_t>(0);
    StateEnum state              = static_cast<StateEnum>(0);
    uint32_t sessionDuration     = static_cast<uint32_t>(0);
    int64_t sessionEnergyCharged = static_cast<int64_t>(0);
    Optional<int64_t> sessionEnergyDischarged;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVNotDetected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID           = static_cast<uint32_t>(0);
    StateEnum state              = static_cast<StateEnum>(0);
    uint32_t sessionDuration     = static_cast<uint32_t>(0);
    int64_t sessionEnergyCharged = static_cast<int64_t>(0);
    Optional<int64_t> sessionEnergyDischarged;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EVNotDetected
namespace EnergyTransferStarted {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID      = 0,
    kState          = 1,
    kMaximumCurrent = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStarted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID     = static_cast<uint32_t>(0);
    StateEnum state        = static_cast<StateEnum>(0);
    int64_t maximumCurrent = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStarted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID     = static_cast<uint32_t>(0);
    StateEnum state        = static_cast<StateEnum>(0);
    int64_t maximumCurrent = static_cast<int64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EnergyTransferStarted
namespace EnergyTransferStopped {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID         = 0,
    kState             = 1,
    kReason            = 2,
    kEnergyTransferred = 4,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStopped::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID                     = static_cast<uint32_t>(0);
    StateEnum state                        = static_cast<StateEnum>(0);
    EnergyTransferStoppedReasonEnum reason = static_cast<EnergyTransferStoppedReasonEnum>(0);
    int64_t energyTransferred              = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStopped::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID                     = static_cast<uint32_t>(0);
    StateEnum state                        = static_cast<StateEnum>(0);
    EnergyTransferStoppedReasonEnum reason = static_cast<EnergyTransferStoppedReasonEnum>(0);
    int64_t energyTransferred              = static_cast<int64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EnergyTransferStopped
namespace Fault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSessionID               = 0,
    kState                   = 1,
    kFaultStatePreviousState = 2,
    kFaultStateCurrentState  = 4,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Fault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::Nullable<uint32_t> sessionID;
    StateEnum state                        = static_cast<StateEnum>(0);
    FaultStateEnum faultStatePreviousState = static_cast<FaultStateEnum>(0);
    FaultStateEnum faultStateCurrentState  = static_cast<FaultStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Fault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> sessionID;
    StateEnum state                        = static_cast<StateEnum>(0);
    FaultStateEnum faultStatePreviousState = static_cast<FaultStateEnum>(0);
    FaultStateEnum faultStateCurrentState  = static_cast<FaultStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Fault
namespace Rfid {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kUid = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Rfid::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan uid;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Rfid::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    chip::ByteSpan uid;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Rfid
} // namespace Events
} // namespace EnergyEvse
namespace EnergyPreference {
namespace Structs {
namespace BalanceStruct {
enum class Fields : uint8_t
{
    kStep  = 0,
    kLabel = 1,
};

struct Type
{
public:
    chip::Percent step = static_cast<chip::Percent>(0);
    Optional<chip::CharSpan> label;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace BalanceStruct
} // namespace Structs

namespace Attributes {

namespace EnergyBalances {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyBalances::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnergyBalances
namespace CurrentEnergyBalance {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentEnergyBalance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentEnergyBalance
namespace EnergyPriorities {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::EnergyPreference::EnergyPriorityEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::EnergyPriorityEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::EnergyPriorityEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyPriorities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnergyPriorities
namespace LowPowerModeSensitivities {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LowPowerModeSensitivities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LowPowerModeSensitivities
namespace CurrentLowPowerModeSensitivity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLowPowerModeSensitivity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLowPowerModeSensitivity
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::EnergyBalances::TypeInfo::DecodableType energyBalances;
        Attributes::CurrentEnergyBalance::TypeInfo::DecodableType currentEnergyBalance = static_cast<uint8_t>(0);
        Attributes::EnergyPriorities::TypeInfo::DecodableType energyPriorities;
        Attributes::LowPowerModeSensitivities::TypeInfo::DecodableType lowPowerModeSensitivities;
        Attributes::CurrentLowPowerModeSensitivity::TypeInfo::DecodableType currentLowPowerModeSensitivity =
            static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EnergyPreference
namespace PowerTopology {

namespace Attributes {

namespace AvailableEndpoints {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailableEndpoints::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailableEndpoints
namespace ActiveEndpoints {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveEndpoints::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveEndpoints
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AvailableEndpoints::TypeInfo::DecodableType availableEndpoints;
        Attributes::ActiveEndpoints::TypeInfo::DecodableType activeEndpoints;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PowerTopology
namespace EnergyEvseMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::EnergyEvseMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EnergyEvseMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyEvseMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyEvseMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EnergyEvseMode
namespace DeviceEnergyManagementMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DeviceEnergyManagementMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::DeviceEnergyManagementMode::Structs::ModeOptionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DeviceEnergyManagementMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DeviceEnergyManagementMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace DeviceEnergyManagementMode
namespace DoorLock {
namespace Structs {
namespace CredentialStruct {
enum class Fields : uint8_t
{
    kCredentialType  = 0,
    kCredentialIndex = 1,
};

struct Type
{
public:
    CredentialTypeEnum credentialType = static_cast<CredentialTypeEnum>(0);
    uint16_t credentialIndex          = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CredentialStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LockDoor {
struct Type;
struct DecodableType;
} // namespace LockDoor

namespace UnlockDoor {
struct Type;
struct DecodableType;
} // namespace UnlockDoor

namespace UnlockWithTimeout {
struct Type;
struct DecodableType;
} // namespace UnlockWithTimeout

namespace SetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeekDaySchedule

namespace GetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeekDaySchedule

namespace GetWeekDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeekDayScheduleResponse

namespace ClearWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeekDaySchedule

namespace SetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetYearDaySchedule

namespace GetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetYearDaySchedule

namespace GetYearDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetYearDayScheduleResponse

namespace ClearYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearYearDaySchedule

namespace SetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace SetHolidaySchedule

namespace GetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace GetHolidaySchedule

namespace GetHolidayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetHolidayScheduleResponse

namespace ClearHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearHolidaySchedule

namespace SetUser {
struct Type;
struct DecodableType;
} // namespace SetUser

namespace GetUser {
struct Type;
struct DecodableType;
} // namespace GetUser

namespace GetUserResponse {
struct Type;
struct DecodableType;
} // namespace GetUserResponse

namespace ClearUser {
struct Type;
struct DecodableType;
} // namespace ClearUser

namespace SetCredential {
struct Type;
struct DecodableType;
} // namespace SetCredential

namespace SetCredentialResponse {
struct Type;
struct DecodableType;
} // namespace SetCredentialResponse

namespace GetCredentialStatus {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatus

namespace GetCredentialStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatusResponse

namespace ClearCredential {
struct Type;
struct DecodableType;
} // namespace ClearCredential

namespace UnboltDoor {
struct Type;
struct DecodableType;
} // namespace UnboltDoor

namespace SetAliroReaderConfig {
struct Type;
struct DecodableType;
} // namespace SetAliroReaderConfig

namespace ClearAliroReaderConfig {
struct Type;
struct DecodableType;
} // namespace ClearAliroReaderConfig

} // namespace Commands

namespace Commands {
namespace LockDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LockDoor
namespace UnlockDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockDoor
namespace UnlockWithTimeout {
enum class Fields : uint8_t
{
    kTimeout = 0,
    kPINCode = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockWithTimeout
namespace SetWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kDaysMask     = 2,
    kStartHour    = 3,
    kStartMinute  = 4,
    kEndHour      = 5,
    kEndMinute    = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex                = static_cast<uint8_t>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    chip::BitMask<DaysMaskMap> daysMask = static_cast<chip::BitMask<DaysMaskMap>>(0);
    uint8_t startHour                   = static_cast<uint8_t>(0);
    uint8_t startMinute                 = static_cast<uint8_t>(0);
    uint8_t endHour                     = static_cast<uint8_t>(0);
    uint8_t endMinute                   = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex                = static_cast<uint8_t>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    chip::BitMask<DaysMaskMap> daysMask = static_cast<chip::BitMask<DaysMaskMap>>(0);
    uint8_t startHour                   = static_cast<uint8_t>(0);
    uint8_t startMinute                 = static_cast<uint8_t>(0);
    uint8_t endHour                     = static_cast<uint8_t>(0);
    uint8_t endMinute                   = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeekDaySchedule
namespace GetWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDaySchedule
namespace GetWeekDayScheduleResponse {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kStatus       = 2,
    kDaysMask     = 3,
    kStartHour    = 4,
    kStartMinute  = 5,
    kEndHour      = 6,
    kEndMinute    = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<chip::BitMask<DaysMaskMap>> daysMask;
    Optional<uint8_t> startHour;
    Optional<uint8_t> startMinute;
    Optional<uint8_t> endHour;
    Optional<uint8_t> endMinute;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<chip::BitMask<DaysMaskMap>> daysMask;
    Optional<uint8_t> startHour;
    Optional<uint8_t> startMinute;
    Optional<uint8_t> endHour;
    Optional<uint8_t> endMinute;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDayScheduleResponse
namespace ClearWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeekDaySchedule
namespace SetYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex    = static_cast<uint8_t>(0);
    uint16_t userIndex      = static_cast<uint16_t>(0);
    uint32_t localStartTime = static_cast<uint32_t>(0);
    uint32_t localEndTime   = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex    = static_cast<uint8_t>(0);
    uint16_t userIndex      = static_cast<uint16_t>(0);
    uint32_t localStartTime = static_cast<uint32_t>(0);
    uint32_t localEndTime   = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetYearDaySchedule
namespace GetYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDaySchedule
namespace GetYearDayScheduleResponse {
enum class Fields : uint8_t
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kStatus         = 2,
    kLocalStartTime = 3,
    kLocalEndTime   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDayScheduleResponse
namespace ClearYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearYearDaySchedule
namespace SetHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex   = 0,
    kLocalStartTime = 1,
    kLocalEndTime   = 2,
    kOperatingMode  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex            = static_cast<uint8_t>(0);
    uint32_t localStartTime         = static_cast<uint32_t>(0);
    uint32_t localEndTime           = static_cast<uint32_t>(0);
    OperatingModeEnum operatingMode = static_cast<OperatingModeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex            = static_cast<uint8_t>(0);
    uint32_t localStartTime         = static_cast<uint32_t>(0);
    uint32_t localEndTime           = static_cast<uint32_t>(0);
    OperatingModeEnum operatingMode = static_cast<OperatingModeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetHolidaySchedule
namespace GetHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetHolidayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidaySchedule
namespace GetHolidayScheduleResponse {
enum class Fields : uint8_t
{
    kHolidayIndex   = 0,
    kStatus         = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
    kOperatingMode  = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    Optional<OperatingModeEnum> operatingMode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    Optional<OperatingModeEnum> operatingMode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidayScheduleResponse
namespace ClearHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearHolidaySchedule
namespace SetUser {
enum class Fields : uint8_t
{
    kOperationType  = 0,
    kUserIndex      = 1,
    kUserName       = 2,
    kUserUniqueID   = 3,
    kUserStatus     = 4,
    kUserType       = 5,
    kCredentialRule = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUser
namespace GetUser {
enum class Fields : uint8_t
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetUserResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUser
namespace GetUserResponse {
enum class Fields : uint8_t
{
    kUserIndex               = 0,
    kUserName                = 1,
    kUserUniqueID            = 2,
    kUserStatus              = 3,
    kUserType                = 4,
    kCredentialRule          = 5,
    kCredentials             = 6,
    kCreatorFabricIndex      = 7,
    kLastModifiedFabricIndex = 8,
    kNextUserIndex           = 9,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextUserIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextUserIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserResponse
namespace ClearUser {
enum class Fields : uint8_t
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearUser
namespace SetCredential {
enum class Fields : uint8_t
{
    kOperationType  = 0,
    kCredential     = 1,
    kCredentialData = 2,
    kUserIndex      = 3,
    kUserStatus     = 4,
    kUserType       = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    Structs::CredentialStruct::Type credential;
    chip::ByteSpan credentialData;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    Structs::CredentialStruct::DecodableType credential;
    chip::ByteSpan credentialData;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredential
namespace SetCredentialResponse {
enum class Fields : uint8_t
{
    kStatus              = 0,
    kUserIndex           = 1,
    kNextCredentialIndex = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status = static_cast<DlStatus>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status = static_cast<DlStatus>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredentialResponse
namespace GetCredentialStatus {
enum class Fields : uint8_t
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::CredentialStruct::Type credential;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::CredentialStruct::DecodableType credential;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatus
namespace GetCredentialStatusResponse {
enum class Fields : uint8_t
{
    kCredentialExists        = 0,
    kUserIndex               = 1,
    kCreatorFabricIndex      = 2,
    kLastModifiedFabricIndex = 3,
    kNextCredentialIndex     = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists = static_cast<bool>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists = static_cast<bool>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatusResponse
namespace ClearCredential {
enum class Fields : uint8_t
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataModel::Nullable<Structs::CredentialStruct::Type> credential;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataModel::Nullable<Structs::CredentialStruct::DecodableType> credential;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearCredential
namespace UnboltDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnboltDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnboltDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnboltDoor
namespace SetAliroReaderConfig {
enum class Fields : uint8_t
{
    kSigningKey        = 0,
    kVerificationKey   = 1,
    kGroupIdentifier   = 2,
    kGroupResolvingKey = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    chip::ByteSpan signingKey;
    chip::ByteSpan verificationKey;
    chip::ByteSpan groupIdentifier;
    Optional<chip::ByteSpan> groupResolvingKey;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    chip::ByteSpan signingKey;
    chip::ByteSpan verificationKey;
    chip::ByteSpan groupIdentifier;
    Optional<chip::ByteSpan> groupResolvingKey;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetAliroReaderConfig
namespace ClearAliroReaderConfig {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAliroReaderConfig
} // namespace Commands

namespace Attributes {

namespace LockState {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LockState
namespace LockType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DoorLock::DlLockType;
    using DecodableType    = chip::app::Clusters::DoorLock::DlLockType;
    using DecodableArgType = chip::app::Clusters::DoorLock::DlLockType;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LockType
namespace ActuatorEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActuatorEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActuatorEnabled
namespace DoorState {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorState
namespace DoorOpenEvents {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorOpenEvents
namespace DoorClosedEvents {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorClosedEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorClosedEvents
namespace OpenPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OpenPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OpenPeriod
namespace NumberOfTotalUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfTotalUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfTotalUsersSupported
namespace NumberOfPINUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPINUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPINUsersSupported
namespace NumberOfRFIDUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfRFIDUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfRFIDUsersSupported
namespace NumberOfWeekDaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeekDaySchedulesSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfWeekDaySchedulesSupportedPerUser
namespace NumberOfYearDaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfYearDaySchedulesSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfYearDaySchedulesSupportedPerUser
namespace NumberOfHolidaySchedulesSupported {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfHolidaySchedulesSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfHolidaySchedulesSupported
namespace MaxPINCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPINCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPINCodeLength
namespace MinPINCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinPINCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinPINCodeLength
namespace MaxRFIDCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxRFIDCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxRFIDCodeLength
namespace MinRFIDCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinRFIDCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinRFIDCodeLength
namespace CredentialRulesSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CredentialRulesSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CredentialRulesSupport
namespace NumberOfCredentialsSupportedPerUser {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfCredentialsSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfCredentialsSupportedPerUser
namespace Language {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Language::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 3; }
};
} // namespace Language
namespace LEDSettings {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LEDSettings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LEDSettings
namespace AutoRelockTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AutoRelockTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AutoRelockTime
namespace SoundVolume {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoundVolume::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoundVolume
namespace OperatingMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DoorLock::OperatingModeEnum;
    using DecodableType    = chip::app::Clusters::DoorLock::OperatingModeEnum;
    using DecodableArgType = chip::app::Clusters::DoorLock::OperatingModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperatingMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperatingMode
namespace SupportedOperatingModes {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedOperatingModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedOperatingModes
namespace DefaultConfigurationRegister {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultConfigurationRegister::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultConfigurationRegister
namespace EnableLocalProgramming {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableLocalProgramming::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableLocalProgramming
namespace EnableOneTouchLocking {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableOneTouchLocking::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableOneTouchLocking
namespace EnableInsideStatusLED {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableInsideStatusLED::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableInsideStatusLED
namespace EnablePrivacyModeButton {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnablePrivacyModeButton::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnablePrivacyModeButton
namespace LocalProgrammingFeatures {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalProgrammingFeatures::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalProgrammingFeatures
namespace WrongCodeEntryLimit {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WrongCodeEntryLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WrongCodeEntryLimit
namespace UserCodeTemporaryDisableTime {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserCodeTemporaryDisableTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserCodeTemporaryDisableTime
namespace SendPINOverTheAir {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SendPINOverTheAir::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SendPINOverTheAir
namespace RequirePINforRemoteOperation {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RequirePINforRemoteOperation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RequirePINforRemoteOperation
namespace ExpiringUserTimeout {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpiringUserTimeout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpiringUserTimeout
namespace AliroReaderVerificationKey {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroReaderVerificationKey::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 65; }
};
} // namespace AliroReaderVerificationKey
namespace AliroReaderGroupIdentifier {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroReaderGroupIdentifier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace AliroReaderGroupIdentifier
namespace AliroReaderGroupSubIdentifier {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroReaderGroupSubIdentifier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace AliroReaderGroupSubIdentifier
namespace AliroExpeditedTransactionSupportedProtocolVersions {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroExpeditedTransactionSupportedProtocolVersions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AliroExpeditedTransactionSupportedProtocolVersions
namespace AliroGroupResolvingKey {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroGroupResolvingKey::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace AliroGroupResolvingKey
namespace AliroSupportedBLEUWBProtocolVersions {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroSupportedBLEUWBProtocolVersions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AliroSupportedBLEUWBProtocolVersions
namespace AliroBLEAdvertisingVersion {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroBLEAdvertisingVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AliroBLEAdvertisingVersion
namespace NumberOfAliroCredentialIssuerKeysSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfAliroCredentialIssuerKeysSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfAliroCredentialIssuerKeysSupported
namespace NumberOfAliroEndpointKeysSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfAliroEndpointKeysSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfAliroEndpointKeysSupported
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LockState::TypeInfo::DecodableType lockState;
        Attributes::LockType::TypeInfo::DecodableType lockType = static_cast<chip::app::Clusters::DoorLock::DlLockType>(0);
        Attributes::ActuatorEnabled::TypeInfo::DecodableType actuatorEnabled = static_cast<bool>(0);
        Attributes::DoorState::TypeInfo::DecodableType doorState;
        Attributes::DoorOpenEvents::TypeInfo::DecodableType doorOpenEvents                           = static_cast<uint32_t>(0);
        Attributes::DoorClosedEvents::TypeInfo::DecodableType doorClosedEvents                       = static_cast<uint32_t>(0);
        Attributes::OpenPeriod::TypeInfo::DecodableType openPeriod                                   = static_cast<uint16_t>(0);
        Attributes::NumberOfTotalUsersSupported::TypeInfo::DecodableType numberOfTotalUsersSupported = static_cast<uint16_t>(0);
        Attributes::NumberOfPINUsersSupported::TypeInfo::DecodableType numberOfPINUsersSupported     = static_cast<uint16_t>(0);
        Attributes::NumberOfRFIDUsersSupported::TypeInfo::DecodableType numberOfRFIDUsersSupported   = static_cast<uint16_t>(0);
        Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo::DecodableType numberOfWeekDaySchedulesSupportedPerUser =
            static_cast<uint8_t>(0);
        Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo::DecodableType numberOfYearDaySchedulesSupportedPerUser =
            static_cast<uint8_t>(0);
        Attributes::NumberOfHolidaySchedulesSupported::TypeInfo::DecodableType numberOfHolidaySchedulesSupported =
            static_cast<uint8_t>(0);
        Attributes::MaxPINCodeLength::TypeInfo::DecodableType maxPINCodeLength   = static_cast<uint8_t>(0);
        Attributes::MinPINCodeLength::TypeInfo::DecodableType minPINCodeLength   = static_cast<uint8_t>(0);
        Attributes::MaxRFIDCodeLength::TypeInfo::DecodableType maxRFIDCodeLength = static_cast<uint8_t>(0);
        Attributes::MinRFIDCodeLength::TypeInfo::DecodableType minRFIDCodeLength = static_cast<uint8_t>(0);
        Attributes::CredentialRulesSupport::TypeInfo::DecodableType credentialRulesSupport =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>>(0);
        Attributes::NumberOfCredentialsSupportedPerUser::TypeInfo::DecodableType numberOfCredentialsSupportedPerUser =
            static_cast<uint8_t>(0);
        Attributes::Language::TypeInfo::DecodableType language;
        Attributes::LEDSettings::TypeInfo::DecodableType LEDSettings       = static_cast<uint8_t>(0);
        Attributes::AutoRelockTime::TypeInfo::DecodableType autoRelockTime = static_cast<uint32_t>(0);
        Attributes::SoundVolume::TypeInfo::DecodableType soundVolume       = static_cast<uint8_t>(0);
        Attributes::OperatingMode::TypeInfo::DecodableType operatingMode =
            static_cast<chip::app::Clusters::DoorLock::OperatingModeEnum>(0);
        Attributes::SupportedOperatingModes::TypeInfo::DecodableType supportedOperatingModes =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>>(0);
        Attributes::DefaultConfigurationRegister::TypeInfo::DecodableType defaultConfigurationRegister =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>>(0);
        Attributes::EnableLocalProgramming::TypeInfo::DecodableType enableLocalProgramming   = static_cast<bool>(0);
        Attributes::EnableOneTouchLocking::TypeInfo::DecodableType enableOneTouchLocking     = static_cast<bool>(0);
        Attributes::EnableInsideStatusLED::TypeInfo::DecodableType enableInsideStatusLED     = static_cast<bool>(0);
        Attributes::EnablePrivacyModeButton::TypeInfo::DecodableType enablePrivacyModeButton = static_cast<bool>(0);
        Attributes::LocalProgrammingFeatures::TypeInfo::DecodableType localProgrammingFeatures =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>>(0);
        Attributes::WrongCodeEntryLimit::TypeInfo::DecodableType wrongCodeEntryLimit                   = static_cast<uint8_t>(0);
        Attributes::UserCodeTemporaryDisableTime::TypeInfo::DecodableType userCodeTemporaryDisableTime = static_cast<uint8_t>(0);
        Attributes::SendPINOverTheAir::TypeInfo::DecodableType sendPINOverTheAir                       = static_cast<bool>(0);
        Attributes::RequirePINforRemoteOperation::TypeInfo::DecodableType requirePINforRemoteOperation = static_cast<bool>(0);
        Attributes::ExpiringUserTimeout::TypeInfo::DecodableType expiringUserTimeout                   = static_cast<uint16_t>(0);
        Attributes::AliroReaderVerificationKey::TypeInfo::DecodableType aliroReaderVerificationKey;
        Attributes::AliroReaderGroupIdentifier::TypeInfo::DecodableType aliroReaderGroupIdentifier;
        Attributes::AliroReaderGroupSubIdentifier::TypeInfo::DecodableType aliroReaderGroupSubIdentifier;
        Attributes::AliroExpeditedTransactionSupportedProtocolVersions::TypeInfo::DecodableType
            aliroExpeditedTransactionSupportedProtocolVersions;
        Attributes::AliroGroupResolvingKey::TypeInfo::DecodableType aliroGroupResolvingKey;
        Attributes::AliroSupportedBLEUWBProtocolVersions::TypeInfo::DecodableType aliroSupportedBLEUWBProtocolVersions;
        Attributes::AliroBLEAdvertisingVersion::TypeInfo::DecodableType aliroBLEAdvertisingVersion = static_cast<uint8_t>(0);
        Attributes::NumberOfAliroCredentialIssuerKeysSupported::TypeInfo::DecodableType numberOfAliroCredentialIssuerKeysSupported =
            static_cast<uint16_t>(0);
        Attributes::NumberOfAliroEndpointKeysSupported::TypeInfo::DecodableType numberOfAliroEndpointKeysSupported =
            static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace DoorLockAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmCode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorLockAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmCodeEnum alarmCode = static_cast<AlarmCodeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorLockAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    AlarmCodeEnum alarmCode = static_cast<AlarmCodeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DoorLockAlarm
namespace DoorStateChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kDoorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorStateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    DoorStateEnum doorState = static_cast<DoorStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorStateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DoorStateEnum doorState = static_cast<DoorStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DoorStateChange
namespace LockOperation {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kLockOperationType = 0,
    kOperationSource   = 1,
    kUserIndex         = 2,
    kFabricIndex       = 3,
    kSourceNode        = 4,
    kCredentials       = 5,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>>> credentials;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>>> credentials;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockOperation
namespace LockOperationError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kLockOperationType = 0,
    kOperationSource   = 1,
    kOperationError    = 2,
    kUserIndex         = 3,
    kFabricIndex       = 4,
    kSourceNode        = 5,
    kCredentials       = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperationError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    OperationErrorEnum operationError       = static_cast<OperationErrorEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>>> credentials;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperationError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    OperationErrorEnum operationError       = static_cast<OperationErrorEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>>> credentials;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockOperationError
namespace LockUserChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kLockDataType      = 0,
    kDataOperationType = 1,
    kOperationSource   = 2,
    kUserIndex         = 3,
    kFabricIndex       = 4,
    kSourceNode        = 5,
    kDataIndex         = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockUserChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    LockDataTypeEnum lockDataType           = static_cast<LockDataTypeEnum>(0);
    DataOperationTypeEnum dataOperationType = static_cast<DataOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    DataModel::Nullable<uint16_t> dataIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockUserChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    LockDataTypeEnum lockDataType           = static_cast<LockDataTypeEnum>(0);
    DataOperationTypeEnum dataOperationType = static_cast<DataOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    DataModel::Nullable<uint16_t> dataIndex;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockUserChange
} // namespace Events
} // namespace DoorLock
namespace WindowCovering {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace UpOrOpen {
struct Type;
struct DecodableType;
} // namespace UpOrOpen

namespace DownOrClose {
struct Type;
struct DecodableType;
} // namespace DownOrClose

namespace StopMotion {
struct Type;
struct DecodableType;
} // namespace StopMotion

namespace GoToLiftValue {
struct Type;
struct DecodableType;
} // namespace GoToLiftValue

namespace GoToLiftPercentage {
struct Type;
struct DecodableType;
} // namespace GoToLiftPercentage

namespace GoToTiltValue {
struct Type;
struct DecodableType;
} // namespace GoToTiltValue

namespace GoToTiltPercentage {
struct Type;
struct DecodableType;
} // namespace GoToTiltPercentage

} // namespace Commands

namespace Commands {
namespace UpOrOpen {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpOrOpen
namespace DownOrClose {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DownOrClose
namespace StopMotion {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMotion
namespace GoToLiftValue {
enum class Fields : uint8_t
{
    kLiftValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t liftValue = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t liftValue = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftValue
namespace GoToLiftPercentage {
enum class Fields : uint8_t
{
    kLiftPercent100thsValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths liftPercent100thsValue = static_cast<chip::Percent100ths>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths liftPercent100thsValue = static_cast<chip::Percent100ths>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftPercentage
namespace GoToTiltValue {
enum class Fields : uint8_t
{
    kTiltValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t tiltValue = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t tiltValue = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltValue
namespace GoToTiltPercentage {
enum class Fields : uint8_t
{
    kTiltPercent100thsValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths tiltPercent100thsValue = static_cast<chip::Percent100ths>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths tiltPercent100thsValue = static_cast<chip::Percent100ths>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltPercentage
} // namespace Commands

namespace Attributes {

namespace Type {
struct TypeInfo
{
    using Type             = chip::app::Clusters::WindowCovering::Type;
    using DecodableType    = chip::app::Clusters::WindowCovering::Type;
    using DecodableArgType = chip::app::Clusters::WindowCovering::Type;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Type::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Type
namespace PhysicalClosedLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimitLift
namespace PhysicalClosedLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimitTilt
namespace CurrentPositionLift {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLift
namespace CurrentPositionTilt {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTilt
namespace NumberOfActuationsLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfActuationsLift
namespace NumberOfActuationsTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfActuationsTilt
namespace ConfigStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConfigStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ConfigStatus
namespace CurrentPositionLiftPercentage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLiftPercentage
namespace CurrentPositionTiltPercentage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTiltPercentage
namespace OperationalStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStatus
namespace TargetPositionLiftPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionLiftPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetPositionLiftPercent100ths
namespace TargetPositionTiltPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionTiltPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetPositionTiltPercent100ths
namespace EndProductType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::WindowCovering::EndProductType;
    using DecodableType    = chip::app::Clusters::WindowCovering::EndProductType;
    using DecodableArgType = chip::app::Clusters::WindowCovering::EndProductType;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndProductType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndProductType
namespace CurrentPositionLiftPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLiftPercent100ths
namespace CurrentPositionTiltPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTiltPercent100ths
namespace InstalledOpenLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledOpenLimitLift
namespace InstalledClosedLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledClosedLimitLift
namespace InstalledOpenLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledOpenLimitTilt
namespace InstalledClosedLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledClosedLimitTilt
namespace Mode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::Mode>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::Mode>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::Mode>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mode
namespace SafetyStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SafetyStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SafetyStatus
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Type::TypeInfo::DecodableType type = static_cast<chip::app::Clusters::WindowCovering::Type>(0);
        Attributes::PhysicalClosedLimitLift::TypeInfo::DecodableType physicalClosedLimitLift = static_cast<uint16_t>(0);
        Attributes::PhysicalClosedLimitTilt::TypeInfo::DecodableType physicalClosedLimitTilt = static_cast<uint16_t>(0);
        Attributes::CurrentPositionLift::TypeInfo::DecodableType currentPositionLift;
        Attributes::CurrentPositionTilt::TypeInfo::DecodableType currentPositionTilt;
        Attributes::NumberOfActuationsLift::TypeInfo::DecodableType numberOfActuationsLift = static_cast<uint16_t>(0);
        Attributes::NumberOfActuationsTilt::TypeInfo::DecodableType numberOfActuationsTilt = static_cast<uint16_t>(0);
        Attributes::ConfigStatus::TypeInfo::DecodableType configStatus =
            static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>>(0);
        Attributes::CurrentPositionLiftPercentage::TypeInfo::DecodableType currentPositionLiftPercentage;
        Attributes::CurrentPositionTiltPercentage::TypeInfo::DecodableType currentPositionTiltPercentage;
        Attributes::OperationalStatus::TypeInfo::DecodableType operationalStatus =
            static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>>(0);
        Attributes::TargetPositionLiftPercent100ths::TypeInfo::DecodableType targetPositionLiftPercent100ths;
        Attributes::TargetPositionTiltPercent100ths::TypeInfo::DecodableType targetPositionTiltPercent100ths;
        Attributes::EndProductType::TypeInfo::DecodableType endProductType =
            static_cast<chip::app::Clusters::WindowCovering::EndProductType>(0);
        Attributes::CurrentPositionLiftPercent100ths::TypeInfo::DecodableType currentPositionLiftPercent100ths;
        Attributes::CurrentPositionTiltPercent100ths::TypeInfo::DecodableType currentPositionTiltPercent100ths;
        Attributes::InstalledOpenLimitLift::TypeInfo::DecodableType installedOpenLimitLift     = static_cast<uint16_t>(0);
        Attributes::InstalledClosedLimitLift::TypeInfo::DecodableType installedClosedLimitLift = static_cast<uint16_t>(0);
        Attributes::InstalledOpenLimitTilt::TypeInfo::DecodableType installedOpenLimitTilt     = static_cast<uint16_t>(0);
        Attributes::InstalledClosedLimitTilt::TypeInfo::DecodableType installedClosedLimitTilt = static_cast<uint16_t>(0);
        Attributes::Mode::TypeInfo::DecodableType mode = static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::Mode>>(0);
        Attributes::SafetyStatus::TypeInfo::DecodableType safetyStatus =
            static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WindowCovering
namespace BarrierControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace BarrierControlGoToPercent {
struct Type;
struct DecodableType;
} // namespace BarrierControlGoToPercent

namespace BarrierControlStop {
struct Type;
struct DecodableType;
} // namespace BarrierControlStop

} // namespace Commands

namespace Commands {
namespace BarrierControlGoToPercent {
enum class Fields : uint8_t
{
    kPercentOpen = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlGoToPercent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    uint8_t percentOpen = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlGoToPercent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    uint8_t percentOpen = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BarrierControlGoToPercent
namespace BarrierControlStop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BarrierControlStop
} // namespace Commands

namespace Attributes {

namespace BarrierMovingState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierMovingState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierMovingState
namespace BarrierSafetyStatus {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierSafetyStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierSafetyStatus
namespace BarrierCapabilities {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCapabilities
namespace BarrierOpenEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierOpenEvents
namespace BarrierCloseEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCloseEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCloseEvents
namespace BarrierCommandOpenEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCommandOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCommandOpenEvents
namespace BarrierCommandCloseEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCommandCloseEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCommandCloseEvents
namespace BarrierOpenPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierOpenPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierOpenPeriod
namespace BarrierClosePeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierClosePeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierClosePeriod
namespace BarrierPosition {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierPosition
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::BarrierMovingState::TypeInfo::DecodableType barrierMovingState               = static_cast<uint8_t>(0);
        Attributes::BarrierSafetyStatus::TypeInfo::DecodableType barrierSafetyStatus             = static_cast<uint16_t>(0);
        Attributes::BarrierCapabilities::TypeInfo::DecodableType barrierCapabilities             = static_cast<uint8_t>(0);
        Attributes::BarrierOpenEvents::TypeInfo::DecodableType barrierOpenEvents                 = static_cast<uint16_t>(0);
        Attributes::BarrierCloseEvents::TypeInfo::DecodableType barrierCloseEvents               = static_cast<uint16_t>(0);
        Attributes::BarrierCommandOpenEvents::TypeInfo::DecodableType barrierCommandOpenEvents   = static_cast<uint16_t>(0);
        Attributes::BarrierCommandCloseEvents::TypeInfo::DecodableType barrierCommandCloseEvents = static_cast<uint16_t>(0);
        Attributes::BarrierOpenPeriod::TypeInfo::DecodableType barrierOpenPeriod                 = static_cast<uint16_t>(0);
        Attributes::BarrierClosePeriod::TypeInfo::DecodableType barrierClosePeriod               = static_cast<uint16_t>(0);
        Attributes::BarrierPosition::TypeInfo::DecodableType barrierPosition                     = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace BarrierControl
namespace PumpConfigurationAndControl {

namespace Attributes {

namespace MaxPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPressure
namespace MaxSpeed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxSpeed
namespace MaxFlow {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxFlow
namespace MinConstPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstPressure
namespace MaxConstPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstPressure
namespace MinCompPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCompPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinCompPressure
namespace MaxCompPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCompPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCompPressure
namespace MinConstSpeed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstSpeed
namespace MaxConstSpeed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstSpeed
namespace MinConstFlow {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstFlow
namespace MaxConstFlow {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstFlow
namespace MinConstTemp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstTemp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstTemp
namespace MaxConstTemp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstTemp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstTemp
namespace PumpStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PumpStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PumpStatus
namespace EffectiveOperationMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveOperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EffectiveOperationMode
namespace EffectiveControlMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveControlMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EffectiveControlMode
namespace Capacity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Capacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Capacity
namespace Speed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Speed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Speed
namespace LifetimeRunningHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeRunningHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LifetimeRunningHours
namespace Power {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Power::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Power
namespace LifetimeEnergyConsumed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeEnergyConsumed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LifetimeEnergyConsumed
namespace OperationMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationMode
namespace ControlMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ControlMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxPressure::TypeInfo::DecodableType maxPressure;
        Attributes::MaxSpeed::TypeInfo::DecodableType maxSpeed;
        Attributes::MaxFlow::TypeInfo::DecodableType maxFlow;
        Attributes::MinConstPressure::TypeInfo::DecodableType minConstPressure;
        Attributes::MaxConstPressure::TypeInfo::DecodableType maxConstPressure;
        Attributes::MinCompPressure::TypeInfo::DecodableType minCompPressure;
        Attributes::MaxCompPressure::TypeInfo::DecodableType maxCompPressure;
        Attributes::MinConstSpeed::TypeInfo::DecodableType minConstSpeed;
        Attributes::MaxConstSpeed::TypeInfo::DecodableType maxConstSpeed;
        Attributes::MinConstFlow::TypeInfo::DecodableType minConstFlow;
        Attributes::MaxConstFlow::TypeInfo::DecodableType maxConstFlow;
        Attributes::MinConstTemp::TypeInfo::DecodableType minConstTemp;
        Attributes::MaxConstTemp::TypeInfo::DecodableType maxConstTemp;
        Attributes::PumpStatus::TypeInfo::DecodableType pumpStatus =
            static_cast<chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>>(0);
        Attributes::EffectiveOperationMode::TypeInfo::DecodableType effectiveOperationMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum>(0);
        Attributes::EffectiveControlMode::TypeInfo::DecodableType effectiveControlMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum>(0);
        Attributes::Capacity::TypeInfo::DecodableType capacity;
        Attributes::Speed::TypeInfo::DecodableType speed;
        Attributes::LifetimeRunningHours::TypeInfo::DecodableType lifetimeRunningHours;
        Attributes::Power::TypeInfo::DecodableType power;
        Attributes::LifetimeEnergyConsumed::TypeInfo::DecodableType lifetimeEnergyConsumed;
        Attributes::OperationMode::TypeInfo::DecodableType operationMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum>(0);
        Attributes::ControlMode::TypeInfo::DecodableType controlMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SupplyVoltageLow {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SupplyVoltageLow
namespace SupplyVoltageHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SupplyVoltageHigh
namespace PowerMissingPhase {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerMissingPhase::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerMissingPhase::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerMissingPhase
namespace SystemPressureLow {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SystemPressureLow
namespace SystemPressureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SystemPressureHigh
namespace DryRunning {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DryRunning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DryRunning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DryRunning
namespace MotorTemperatureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MotorTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MotorTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MotorTemperatureHigh
namespace PumpMotorFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpMotorFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpMotorFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PumpMotorFatalFailure
namespace ElectronicTemperatureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicTemperatureHigh
namespace PumpBlocked {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpBlocked::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpBlocked::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PumpBlocked
namespace SensorFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SensorFailure
namespace ElectronicNonFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicNonFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicNonFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicNonFatalFailure
namespace ElectronicFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicFatalFailure
namespace GeneralFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::GeneralFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::GeneralFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace GeneralFault
namespace Leakage {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leakage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leakage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leakage
namespace AirDetection {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AirDetection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AirDetection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AirDetection
namespace TurbineOperation {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TurbineOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TurbineOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TurbineOperation
} // namespace Events
} // namespace PumpConfigurationAndControl
namespace Thermostat {
namespace Structs {
namespace ScheduleTransitionStruct {
enum class Fields : uint8_t
{
    kDayOfWeek       = 0,
    kTransitionTime  = 1,
    kPresetHandle    = 2,
    kSystemMode      = 3,
    kCoolingSetpoint = 4,
    kHeatingSetpoint = 5,
};

struct Type
{
public:
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeek = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    uint16_t transitionTime                          = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> presetHandle;
    Optional<SystemModeEnum> systemMode;
    Optional<int16_t> coolingSetpoint;
    Optional<int16_t> heatingSetpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ScheduleTransitionStruct
namespace ScheduleStruct {
enum class Fields : uint8_t
{
    kScheduleHandle = 0,
    kSystemMode     = 1,
    kName           = 2,
    kPresetHandle   = 3,
    kTransitions    = 4,
    kBuiltIn        = 5,
};

struct Type
{
public:
    DataModel::Nullable<chip::ByteSpan> scheduleHandle;
    SystemModeEnum systemMode = static_cast<SystemModeEnum>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> presetHandle;
    DataModel::List<const Structs::ScheduleTransitionStruct::Type> transitions;
    Optional<DataModel::Nullable<bool>> builtIn;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<chip::ByteSpan> scheduleHandle;
    SystemModeEnum systemMode = static_cast<SystemModeEnum>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> presetHandle;
    DataModel::DecodableList<Structs::ScheduleTransitionStruct::DecodableType> transitions;
    Optional<DataModel::Nullable<bool>> builtIn;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ScheduleStruct
namespace PresetStruct {
enum class Fields : uint8_t
{
    kPresetHandle    = 0,
    kPresetScenario  = 1,
    kName            = 2,
    kCoolingSetpoint = 3,
    kHeatingSetpoint = 4,
    kBuiltIn         = 5,
};

struct Type
{
public:
    DataModel::Nullable<chip::ByteSpan> presetHandle;
    PresetScenarioEnum presetScenario = static_cast<PresetScenarioEnum>(0);
    Optional<DataModel::Nullable<chip::CharSpan>> name;
    Optional<int16_t> coolingSetpoint;
    Optional<int16_t> heatingSetpoint;
    DataModel::Nullable<bool> builtIn;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PresetStruct
namespace PresetTypeStruct {
enum class Fields : uint8_t
{
    kPresetScenario     = 0,
    kNumberOfPresets    = 1,
    kPresetTypeFeatures = 2,
};

struct Type
{
public:
    PresetScenarioEnum presetScenario                          = static_cast<PresetScenarioEnum>(0);
    uint8_t numberOfPresets                                    = static_cast<uint8_t>(0);
    chip::BitMask<PresetTypeFeaturesBitmap> presetTypeFeatures = static_cast<chip::BitMask<PresetTypeFeaturesBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PresetTypeStruct
namespace QueuedPresetStruct {
enum class Fields : uint8_t
{
    kPresetHandle        = 0,
    kTransitionTimestamp = 1,
};

struct Type
{
public:
    DataModel::Nullable<chip::ByteSpan> presetHandle;
    DataModel::Nullable<uint32_t> transitionTimestamp;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace QueuedPresetStruct
namespace ScheduleTypeStruct {
enum class Fields : uint8_t
{
    kSystemMode           = 0,
    kNumberOfSchedules    = 1,
    kScheduleTypeFeatures = 2,
};

struct Type
{
public:
    SystemModeEnum systemMode                                      = static_cast<SystemModeEnum>(0);
    uint8_t numberOfSchedules                                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleTypeFeaturesBitmap> scheduleTypeFeatures = static_cast<chip::BitMask<ScheduleTypeFeaturesBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ScheduleTypeStruct
namespace WeeklyScheduleTransitionStruct {
enum class Fields : uint8_t
{
    kTransitionTime = 0,
    kHeatSetpoint   = 1,
    kCoolSetpoint   = 2,
};

struct Type
{
public:
    uint16_t transitionTime = static_cast<uint16_t>(0);
    DataModel::Nullable<int16_t> heatSetpoint;
    DataModel::Nullable<int16_t> coolSetpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace WeeklyScheduleTransitionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetpointRaiseLower {
struct Type;
struct DecodableType;
} // namespace SetpointRaiseLower

namespace GetWeeklyScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeeklyScheduleResponse

namespace SetWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeeklySchedule

namespace GetWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeeklySchedule

namespace ClearWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeeklySchedule

namespace SetActiveScheduleRequest {
struct Type;
struct DecodableType;
} // namespace SetActiveScheduleRequest

namespace SetActivePresetRequest {
struct Type;
struct DecodableType;
} // namespace SetActivePresetRequest

namespace StartPresetsSchedulesEditRequest {
struct Type;
struct DecodableType;
} // namespace StartPresetsSchedulesEditRequest

namespace CancelPresetsSchedulesEditRequest {
struct Type;
struct DecodableType;
} // namespace CancelPresetsSchedulesEditRequest

namespace CommitPresetsSchedulesRequest {
struct Type;
struct DecodableType;
} // namespace CommitPresetsSchedulesRequest

namespace CancelSetActivePresetRequest {
struct Type;
struct DecodableType;
} // namespace CancelSetActivePresetRequest

namespace SetTemperatureSetpointHoldPolicy {
struct Type;
struct DecodableType;
} // namespace SetTemperatureSetpointHoldPolicy

} // namespace Commands

namespace Commands {
namespace SetpointRaiseLower {
enum class Fields : uint8_t
{
    kMode   = 0,
    kAmount = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    SetpointRaiseLowerModeEnum mode = static_cast<SetpointRaiseLowerModeEnum>(0);
    int8_t amount                   = static_cast<int8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    SetpointRaiseLowerModeEnum mode = static_cast<SetpointRaiseLowerModeEnum>(0);
    int8_t amount                   = static_cast<int8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetpointRaiseLower
namespace GetWeeklyScheduleResponse {
enum class Fields : uint8_t
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kTransitions                    = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklyScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::List<const Structs::WeeklyScheduleTransitionStruct::Type> transitions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklyScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::DecodableList<Structs::WeeklyScheduleTransitionStruct::DecodableType> transitions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklyScheduleResponse
namespace SetWeeklySchedule {
enum class Fields : uint8_t
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kTransitions                    = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::List<const Structs::WeeklyScheduleTransitionStruct::Type> transitions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::DecodableList<Structs::WeeklyScheduleTransitionStruct::DecodableType> transitions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeeklySchedule
namespace GetWeeklySchedule {
enum class Fields : uint8_t
{
    kDaysToReturn = 0,
    kModeToReturn = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitMask<ScheduleDayOfWeekBitmap> daysToReturn = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeToReturn      = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Thermostat::Commands::GetWeeklyScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitMask<ScheduleDayOfWeekBitmap> daysToReturn = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeToReturn      = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklySchedule
namespace ClearWeeklySchedule {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeeklySchedule
namespace SetActiveScheduleRequest {
enum class Fields : uint8_t
{
    kScheduleHandle = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetActiveScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::ByteSpan scheduleHandle;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetActiveScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::ByteSpan scheduleHandle;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetActiveScheduleRequest
namespace SetActivePresetRequest {
enum class Fields : uint8_t
{
    kPresetHandle = 0,
    kDelayMinutes = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetActivePresetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::ByteSpan presetHandle;
    Optional<uint16_t> delayMinutes;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetActivePresetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::ByteSpan presetHandle;
    Optional<uint16_t> delayMinutes;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetActivePresetRequest
namespace StartPresetsSchedulesEditRequest {
enum class Fields : uint8_t
{
    kTimeoutSeconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartPresetsSchedulesEditRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint16_t timeoutSeconds = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartPresetsSchedulesEditRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint16_t timeoutSeconds = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartPresetsSchedulesEditRequest
namespace CancelPresetsSchedulesEditRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelPresetsSchedulesEditRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelPresetsSchedulesEditRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelPresetsSchedulesEditRequest
namespace CommitPresetsSchedulesRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommitPresetsSchedulesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommitPresetsSchedulesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommitPresetsSchedulesRequest
namespace CancelSetActivePresetRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelSetActivePresetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelSetActivePresetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelSetActivePresetRequest
namespace SetTemperatureSetpointHoldPolicy {
enum class Fields : uint8_t
{
    kTemperatureSetpointHoldPolicy = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTemperatureSetpointHoldPolicy::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitMask<TemperatureSetpointHoldPolicyBitmap> temperatureSetpointHoldPolicy =
        static_cast<chip::BitMask<TemperatureSetpointHoldPolicyBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTemperatureSetpointHoldPolicy::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitMask<TemperatureSetpointHoldPolicyBitmap> temperatureSetpointHoldPolicy =
        static_cast<chip::BitMask<TemperatureSetpointHoldPolicyBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTemperatureSetpointHoldPolicy
} // namespace Commands

namespace Attributes {

namespace LocalTemperature {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTemperature
namespace OutdoorTemperature {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutdoorTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutdoorTemperature
namespace Occupancy {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Occupancy
namespace AbsMinHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinHeatSetpointLimit
namespace AbsMaxHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxHeatSetpointLimit
namespace AbsMinCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinCoolSetpointLimit
namespace AbsMaxCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxCoolSetpointLimit
namespace PICoolingDemand {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PICoolingDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PICoolingDemand
namespace PIHeatingDemand {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIHeatingDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIHeatingDemand
namespace HVACSystemTypeConfiguration {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HVACSystemTypeConfiguration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HVACSystemTypeConfiguration
namespace LocalTemperatureCalibration {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperatureCalibration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTemperatureCalibration
namespace OccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedCoolingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedCoolingSetpoint
namespace OccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedHeatingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedHeatingSetpoint
namespace UnoccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedCoolingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedCoolingSetpoint
namespace UnoccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedHeatingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedHeatingSetpoint
namespace MinHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinHeatSetpointLimit
namespace MaxHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxHeatSetpointLimit
namespace MinCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinCoolSetpointLimit
namespace MaxCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCoolSetpointLimit
namespace MinSetpointDeadBand {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinSetpointDeadBand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinSetpointDeadBand
namespace RemoteSensing {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemoteSensing::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemoteSensing
namespace ControlSequenceOfOperation {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlSequenceOfOperation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ControlSequenceOfOperation
namespace SystemMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::SystemModeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::SystemModeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::SystemModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SystemMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SystemMode
namespace ThermostatRunningMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ThermostatRunningModeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ThermostatRunningModeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ThermostatRunningModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatRunningMode
namespace StartOfWeek {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::StartOfWeekEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::StartOfWeekEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::StartOfWeekEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartOfWeek::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartOfWeek
namespace NumberOfWeeklyTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeeklyTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfWeeklyTransitions
namespace NumberOfDailyTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfDailyTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfDailyTransitions
namespace TemperatureSetpointHold {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHold
namespace TemperatureSetpointHoldDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHoldDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHoldDuration
namespace ThermostatProgrammingOperationMode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatProgrammingOperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatProgrammingOperationMode
namespace ThermostatRunningState {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatRunningState
namespace SetpointChangeSource {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::SetpointChangeSourceEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::SetpointChangeSourceEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::SetpointChangeSourceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeSource
namespace SetpointChangeAmount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeAmount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeAmount
namespace SetpointChangeSourceTimestamp {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSourceTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeSourceTimestamp
namespace OccupiedSetback {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedSetback::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedSetback
namespace OccupiedSetbackMin {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedSetbackMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedSetbackMin
namespace OccupiedSetbackMax {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedSetbackMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedSetbackMax
namespace UnoccupiedSetback {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedSetback::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedSetback
namespace UnoccupiedSetbackMin {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedSetbackMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedSetbackMin
namespace UnoccupiedSetbackMax {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedSetbackMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedSetbackMax
namespace EmergencyHeatDelta {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EmergencyHeatDelta::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EmergencyHeatDelta
namespace ACType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACTypeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACTypeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACType
namespace ACCapacity {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCapacity
namespace ACRefrigerantType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACRefrigerantType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACRefrigerantType
namespace ACCompressorType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACCompressorTypeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACCompressorTypeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACCompressorTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCompressorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCompressorType
namespace ACErrorCode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACErrorCode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACErrorCode
namespace ACLouverPosition {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACLouverPositionEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACLouverPositionEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACLouverPositionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACLouverPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACLouverPosition
namespace ACCoilTemperature {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCoilTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCoilTemperature
namespace ACCapacityformat {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACCapacityFormatEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACCapacityFormatEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACCapacityFormatEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCapacityformat::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCapacityformat
namespace PresetTypes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::PresetTypeStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetTypeStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetTypeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PresetTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PresetTypes
namespace ScheduleTypes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::ScheduleTypeStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleTypeStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleTypeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduleTypes
namespace NumberOfPresets {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPresets::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPresets
namespace NumberOfSchedules {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfSchedules::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfSchedules
namespace NumberOfScheduleTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfScheduleTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfScheduleTransitions
namespace NumberOfScheduleTransitionPerDay {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfScheduleTransitionPerDay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfScheduleTransitionPerDay
namespace ActivePresetHandle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePresetHandle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ActivePresetHandle
namespace ActiveScheduleHandle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveScheduleHandle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ActiveScheduleHandle
namespace Presets {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::PresetStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Presets::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Presets
namespace Schedules {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::ScheduleStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Schedules::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Schedules
namespace PresetsSchedulesEditable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PresetsSchedulesEditable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PresetsSchedulesEditable
namespace TemperatureSetpointHoldPolicy {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::TemperatureSetpointHoldPolicyBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::TemperatureSetpointHoldPolicyBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::TemperatureSetpointHoldPolicyBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHoldPolicy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHoldPolicy
namespace SetpointHoldExpiryTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointHoldExpiryTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointHoldExpiryTimestamp
namespace QueuedPreset {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::Thermostat::Structs::QueuedPresetStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::Thermostat::Structs::QueuedPresetStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::Thermostat::Structs::QueuedPresetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::QueuedPreset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace QueuedPreset
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LocalTemperature::TypeInfo::DecodableType localTemperature;
        Attributes::OutdoorTemperature::TypeInfo::DecodableType outdoorTemperature;
        Attributes::Occupancy::TypeInfo::DecodableType occupancy                                     = static_cast<uint8_t>(0);
        Attributes::AbsMinHeatSetpointLimit::TypeInfo::DecodableType absMinHeatSetpointLimit         = static_cast<int16_t>(0);
        Attributes::AbsMaxHeatSetpointLimit::TypeInfo::DecodableType absMaxHeatSetpointLimit         = static_cast<int16_t>(0);
        Attributes::AbsMinCoolSetpointLimit::TypeInfo::DecodableType absMinCoolSetpointLimit         = static_cast<int16_t>(0);
        Attributes::AbsMaxCoolSetpointLimit::TypeInfo::DecodableType absMaxCoolSetpointLimit         = static_cast<int16_t>(0);
        Attributes::PICoolingDemand::TypeInfo::DecodableType PICoolingDemand                         = static_cast<uint8_t>(0);
        Attributes::PIHeatingDemand::TypeInfo::DecodableType PIHeatingDemand                         = static_cast<uint8_t>(0);
        Attributes::HVACSystemTypeConfiguration::TypeInfo::DecodableType HVACSystemTypeConfiguration = static_cast<uint8_t>(0);
        Attributes::LocalTemperatureCalibration::TypeInfo::DecodableType localTemperatureCalibration = static_cast<int8_t>(0);
        Attributes::OccupiedCoolingSetpoint::TypeInfo::DecodableType occupiedCoolingSetpoint         = static_cast<int16_t>(0);
        Attributes::OccupiedHeatingSetpoint::TypeInfo::DecodableType occupiedHeatingSetpoint         = static_cast<int16_t>(0);
        Attributes::UnoccupiedCoolingSetpoint::TypeInfo::DecodableType unoccupiedCoolingSetpoint     = static_cast<int16_t>(0);
        Attributes::UnoccupiedHeatingSetpoint::TypeInfo::DecodableType unoccupiedHeatingSetpoint     = static_cast<int16_t>(0);
        Attributes::MinHeatSetpointLimit::TypeInfo::DecodableType minHeatSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MaxHeatSetpointLimit::TypeInfo::DecodableType maxHeatSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MinCoolSetpointLimit::TypeInfo::DecodableType minCoolSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MaxCoolSetpointLimit::TypeInfo::DecodableType maxCoolSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MinSetpointDeadBand::TypeInfo::DecodableType minSetpointDeadBand                 = static_cast<int8_t>(0);
        Attributes::RemoteSensing::TypeInfo::DecodableType remoteSensing =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>>(0);
        Attributes::ControlSequenceOfOperation::TypeInfo::DecodableType controlSequenceOfOperation =
            static_cast<chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum>(0);
        Attributes::SystemMode::TypeInfo::DecodableType systemMode =
            static_cast<chip::app::Clusters::Thermostat::SystemModeEnum>(0);
        Attributes::ThermostatRunningMode::TypeInfo::DecodableType thermostatRunningMode =
            static_cast<chip::app::Clusters::Thermostat::ThermostatRunningModeEnum>(0);
        Attributes::StartOfWeek::TypeInfo::DecodableType startOfWeek =
            static_cast<chip::app::Clusters::Thermostat::StartOfWeekEnum>(0);
        Attributes::NumberOfWeeklyTransitions::TypeInfo::DecodableType numberOfWeeklyTransitions = static_cast<uint8_t>(0);
        Attributes::NumberOfDailyTransitions::TypeInfo::DecodableType numberOfDailyTransitions   = static_cast<uint8_t>(0);
        Attributes::TemperatureSetpointHold::TypeInfo::DecodableType temperatureSetpointHold =
            static_cast<chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum>(0);
        Attributes::TemperatureSetpointHoldDuration::TypeInfo::DecodableType temperatureSetpointHoldDuration;
        Attributes::ThermostatProgrammingOperationMode::TypeInfo::DecodableType thermostatProgrammingOperationMode =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>>(0);
        Attributes::ThermostatRunningState::TypeInfo::DecodableType thermostatRunningState =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>>(0);
        Attributes::SetpointChangeSource::TypeInfo::DecodableType setpointChangeSource =
            static_cast<chip::app::Clusters::Thermostat::SetpointChangeSourceEnum>(0);
        Attributes::SetpointChangeAmount::TypeInfo::DecodableType setpointChangeAmount;
        Attributes::SetpointChangeSourceTimestamp::TypeInfo::DecodableType setpointChangeSourceTimestamp = static_cast<uint32_t>(0);
        Attributes::OccupiedSetback::TypeInfo::DecodableType occupiedSetback;
        Attributes::OccupiedSetbackMin::TypeInfo::DecodableType occupiedSetbackMin;
        Attributes::OccupiedSetbackMax::TypeInfo::DecodableType occupiedSetbackMax;
        Attributes::UnoccupiedSetback::TypeInfo::DecodableType unoccupiedSetback;
        Attributes::UnoccupiedSetbackMin::TypeInfo::DecodableType unoccupiedSetbackMin;
        Attributes::UnoccupiedSetbackMax::TypeInfo::DecodableType unoccupiedSetbackMax;
        Attributes::EmergencyHeatDelta::TypeInfo::DecodableType emergencyHeatDelta = static_cast<uint8_t>(0);
        Attributes::ACType::TypeInfo::DecodableType ACType         = static_cast<chip::app::Clusters::Thermostat::ACTypeEnum>(0);
        Attributes::ACCapacity::TypeInfo::DecodableType ACCapacity = static_cast<uint16_t>(0);
        Attributes::ACRefrigerantType::TypeInfo::DecodableType ACRefrigerantType =
            static_cast<chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum>(0);
        Attributes::ACCompressorType::TypeInfo::DecodableType ACCompressorType =
            static_cast<chip::app::Clusters::Thermostat::ACCompressorTypeEnum>(0);
        Attributes::ACErrorCode::TypeInfo::DecodableType ACErrorCode =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>>(0);
        Attributes::ACLouverPosition::TypeInfo::DecodableType ACLouverPosition =
            static_cast<chip::app::Clusters::Thermostat::ACLouverPositionEnum>(0);
        Attributes::ACCoilTemperature::TypeInfo::DecodableType ACCoilTemperature;
        Attributes::ACCapacityformat::TypeInfo::DecodableType ACCapacityformat =
            static_cast<chip::app::Clusters::Thermostat::ACCapacityFormatEnum>(0);
        Attributes::PresetTypes::TypeInfo::DecodableType presetTypes;
        Attributes::ScheduleTypes::TypeInfo::DecodableType scheduleTypes;
        Attributes::NumberOfPresets::TypeInfo::DecodableType numberOfPresets                         = static_cast<uint8_t>(0);
        Attributes::NumberOfSchedules::TypeInfo::DecodableType numberOfSchedules                     = static_cast<uint8_t>(0);
        Attributes::NumberOfScheduleTransitions::TypeInfo::DecodableType numberOfScheduleTransitions = static_cast<uint8_t>(0);
        Attributes::NumberOfScheduleTransitionPerDay::TypeInfo::DecodableType numberOfScheduleTransitionPerDay;
        Attributes::ActivePresetHandle::TypeInfo::DecodableType activePresetHandle;
        Attributes::ActiveScheduleHandle::TypeInfo::DecodableType activeScheduleHandle;
        Attributes::Presets::TypeInfo::DecodableType presets;
        Attributes::Schedules::TypeInfo::DecodableType schedules;
        Attributes::PresetsSchedulesEditable::TypeInfo::DecodableType presetsSchedulesEditable = static_cast<bool>(0);
        Attributes::TemperatureSetpointHoldPolicy::TypeInfo::DecodableType temperatureSetpointHoldPolicy =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::TemperatureSetpointHoldPolicyBitmap>>(0);
        Attributes::SetpointHoldExpiryTimestamp::TypeInfo::DecodableType setpointHoldExpiryTimestamp;
        Attributes::QueuedPreset::TypeInfo::DecodableType queuedPreset;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Thermostat
namespace FanControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Step {
struct Type;
struct DecodableType;
} // namespace Step

} // namespace Commands

namespace Commands {
namespace Step {
enum class Fields : uint8_t
{
    kDirection = 0,
    kWrap      = 1,
    kLowestOff = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

    StepDirectionEnum direction = static_cast<StepDirectionEnum>(0);
    Optional<bool> wrap;
    Optional<bool> lowestOff;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

    StepDirectionEnum direction = static_cast<StepDirectionEnum>(0);
    Optional<bool> wrap;
    Optional<bool> lowestOff;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Step
} // namespace Commands

namespace Attributes {

namespace FanMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FanControl::FanModeEnum;
    using DecodableType    = chip::app::Clusters::FanControl::FanModeEnum;
    using DecodableArgType = chip::app::Clusters::FanControl::FanModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FanMode
namespace FanModeSequence {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FanControl::FanModeSequenceEnum;
    using DecodableType    = chip::app::Clusters::FanControl::FanModeSequenceEnum;
    using DecodableArgType = chip::app::Clusters::FanControl::FanModeSequenceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanModeSequence::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FanModeSequence
namespace PercentSetting {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PercentSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PercentSetting
namespace PercentCurrent {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PercentCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PercentCurrent
namespace SpeedMax {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeedMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeedMax
namespace SpeedSetting {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeedSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeedSetting
namespace SpeedCurrent {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeedCurrent
namespace RockSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RockSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RockSupport
namespace RockSetting {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RockSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RockSetting
namespace WindSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindSupport
namespace WindSetting {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindSetting
namespace AirflowDirection {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FanControl::AirflowDirectionEnum;
    using DecodableType    = chip::app::Clusters::FanControl::AirflowDirectionEnum;
    using DecodableArgType = chip::app::Clusters::FanControl::AirflowDirectionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AirflowDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AirflowDirection
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::FanMode::TypeInfo::DecodableType fanMode = static_cast<chip::app::Clusters::FanControl::FanModeEnum>(0);
        Attributes::FanModeSequence::TypeInfo::DecodableType fanModeSequence =
            static_cast<chip::app::Clusters::FanControl::FanModeSequenceEnum>(0);
        Attributes::PercentSetting::TypeInfo::DecodableType percentSetting;
        Attributes::PercentCurrent::TypeInfo::DecodableType percentCurrent = static_cast<chip::Percent>(0);
        Attributes::SpeedMax::TypeInfo::DecodableType speedMax             = static_cast<uint8_t>(0);
        Attributes::SpeedSetting::TypeInfo::DecodableType speedSetting;
        Attributes::SpeedCurrent::TypeInfo::DecodableType speedCurrent = static_cast<uint8_t>(0);
        Attributes::RockSupport::TypeInfo::DecodableType rockSupport =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>>(0);
        Attributes::RockSetting::TypeInfo::DecodableType rockSetting =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>>(0);
        Attributes::WindSupport::TypeInfo::DecodableType windSupport =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>>(0);
        Attributes::WindSetting::TypeInfo::DecodableType windSetting =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>>(0);
        Attributes::AirflowDirection::TypeInfo::DecodableType airflowDirection =
            static_cast<chip::app::Clusters::FanControl::AirflowDirectionEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FanControl
namespace ThermostatUserInterfaceConfiguration {

namespace Attributes {

namespace TemperatureDisplayMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum;
    using DecodableType    = chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum;
    using DecodableArgType = chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureDisplayMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureDisplayMode
namespace KeypadLockout {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum;
    using DecodableType    = chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum;
    using DecodableArgType = chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadLockout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace KeypadLockout
namespace ScheduleProgrammingVisibility {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum;
    using DecodableType    = chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum;
    using DecodableArgType = chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleProgrammingVisibility::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduleProgrammingVisibility
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureDisplayMode::TypeInfo::DecodableType temperatureDisplayMode =
            static_cast<chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum>(0);
        Attributes::KeypadLockout::TypeInfo::DecodableType keypadLockout =
            static_cast<chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum>(0);
        Attributes::ScheduleProgrammingVisibility::TypeInfo::DecodableType scheduleProgrammingVisibility =
            static_cast<chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ThermostatUserInterfaceConfiguration
namespace ColorControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToHue {
struct Type;
struct DecodableType;
} // namespace MoveToHue

namespace MoveHue {
struct Type;
struct DecodableType;
} // namespace MoveHue

namespace StepHue {
struct Type;
struct DecodableType;
} // namespace StepHue

namespace MoveToSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToSaturation

namespace MoveSaturation {
struct Type;
struct DecodableType;
} // namespace MoveSaturation

namespace StepSaturation {
struct Type;
struct DecodableType;
} // namespace StepSaturation

namespace MoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToHueAndSaturation

namespace MoveToColor {
struct Type;
struct DecodableType;
} // namespace MoveToColor

namespace MoveColor {
struct Type;
struct DecodableType;
} // namespace MoveColor

namespace StepColor {
struct Type;
struct DecodableType;
} // namespace StepColor

namespace MoveToColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveToColorTemperature

namespace EnhancedMoveToHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHue

namespace EnhancedMoveHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveHue

namespace EnhancedStepHue {
struct Type;
struct DecodableType;
} // namespace EnhancedStepHue

namespace EnhancedMoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHueAndSaturation

namespace ColorLoopSet {
struct Type;
struct DecodableType;
} // namespace ColorLoopSet

namespace StopMoveStep {
struct Type;
struct DecodableType;
} // namespace StopMoveStep

namespace MoveColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveColorTemperature

namespace StepColorTemperature {
struct Type;
struct DecodableType;
} // namespace StepColorTemperature

} // namespace Commands

namespace Commands {
namespace MoveToHue {
enum class Fields : uint8_t
{
    kHue             = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue             = static_cast<uint8_t>(0);
    HueDirection direction  = static_cast<HueDirection>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue             = static_cast<uint8_t>(0);
    HueDirection direction  = static_cast<HueDirection>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHue
namespace MoveHue {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode    = static_cast<HueMoveMode>(0);
    uint8_t rate            = static_cast<uint8_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode    = static_cast<HueMoveMode>(0);
    uint8_t rate            = static_cast<uint8_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveHue
namespace StepHue {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode    = static_cast<HueStepMode>(0);
    uint8_t stepSize        = static_cast<uint8_t>(0);
    uint8_t transitionTime  = static_cast<uint8_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode    = static_cast<HueStepMode>(0);
    uint8_t stepSize        = static_cast<uint8_t>(0);
    uint8_t transitionTime  = static_cast<uint8_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepHue
namespace MoveToSaturation {
enum class Fields : uint8_t
{
    kSaturation      = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation      = static_cast<uint8_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation      = static_cast<uint8_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToSaturation
namespace MoveSaturation {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationMoveMode moveMode = static_cast<SaturationMoveMode>(0);
    uint8_t rate                = static_cast<uint8_t>(0);
    uint8_t optionsMask         = static_cast<uint8_t>(0);
    uint8_t optionsOverride     = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationMoveMode moveMode = static_cast<SaturationMoveMode>(0);
    uint8_t rate                = static_cast<uint8_t>(0);
    uint8_t optionsMask         = static_cast<uint8_t>(0);
    uint8_t optionsOverride     = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveSaturation
namespace StepSaturation {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationStepMode stepMode = static_cast<SaturationStepMode>(0);
    uint8_t stepSize            = static_cast<uint8_t>(0);
    uint8_t transitionTime      = static_cast<uint8_t>(0);
    uint8_t optionsMask         = static_cast<uint8_t>(0);
    uint8_t optionsOverride     = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationStepMode stepMode = static_cast<SaturationStepMode>(0);
    uint8_t stepSize            = static_cast<uint8_t>(0);
    uint8_t transitionTime      = static_cast<uint8_t>(0);
    uint8_t optionsMask         = static_cast<uint8_t>(0);
    uint8_t optionsOverride     = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepSaturation
namespace MoveToHueAndSaturation {
enum class Fields : uint8_t
{
    kHue             = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue             = static_cast<uint8_t>(0);
    uint8_t saturation      = static_cast<uint8_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue             = static_cast<uint8_t>(0);
    uint8_t saturation      = static_cast<uint8_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHueAndSaturation
namespace MoveToColor {
enum class Fields : uint8_t
{
    kColorX          = 0,
    kColorY          = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX         = static_cast<uint16_t>(0);
    uint16_t colorY         = static_cast<uint16_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX         = static_cast<uint16_t>(0);
    uint16_t colorY         = static_cast<uint16_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColor
namespace MoveColor {
enum class Fields : uint8_t
{
    kRateX           = 0,
    kRateY           = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX           = static_cast<int16_t>(0);
    int16_t rateY           = static_cast<int16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX           = static_cast<int16_t>(0);
    int16_t rateY           = static_cast<int16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColor
namespace StepColor {
enum class Fields : uint8_t
{
    kStepX           = 0,
    kStepY           = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX           = static_cast<int16_t>(0);
    int16_t stepY           = static_cast<int16_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX           = static_cast<int16_t>(0);
    int16_t stepY           = static_cast<int16_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColor
namespace MoveToColorTemperature {
enum class Fields : uint8_t
{
    kColorTemperatureMireds = 0,
    kTransitionTime         = 1,
    kOptionsMask            = 2,
    kOptionsOverride        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperatureMireds = static_cast<uint16_t>(0);
    uint16_t transitionTime         = static_cast<uint16_t>(0);
    uint8_t optionsMask             = static_cast<uint8_t>(0);
    uint8_t optionsOverride         = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperatureMireds = static_cast<uint16_t>(0);
    uint16_t transitionTime         = static_cast<uint16_t>(0);
    uint8_t optionsMask             = static_cast<uint8_t>(0);
    uint8_t optionsOverride         = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColorTemperature
namespace EnhancedMoveToHue {
enum class Fields : uint8_t
{
    kEnhancedHue     = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue    = static_cast<uint16_t>(0);
    HueDirection direction  = static_cast<HueDirection>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue    = static_cast<uint16_t>(0);
    HueDirection direction  = static_cast<HueDirection>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHue
namespace EnhancedMoveHue {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode    = static_cast<HueMoveMode>(0);
    uint16_t rate           = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode    = static_cast<HueMoveMode>(0);
    uint16_t rate           = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveHue
namespace EnhancedStepHue {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode    = static_cast<HueStepMode>(0);
    uint16_t stepSize       = static_cast<uint16_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode    = static_cast<HueStepMode>(0);
    uint16_t stepSize       = static_cast<uint16_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedStepHue
namespace EnhancedMoveToHueAndSaturation {
enum class Fields : uint8_t
{
    kEnhancedHue     = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue    = static_cast<uint16_t>(0);
    uint8_t saturation      = static_cast<uint8_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue    = static_cast<uint16_t>(0);
    uint8_t saturation      = static_cast<uint8_t>(0);
    uint16_t transitionTime = static_cast<uint16_t>(0);
    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHueAndSaturation
namespace ColorLoopSet {
enum class Fields : uint8_t
{
    kUpdateFlags     = 0,
    kAction          = 1,
    kDirection       = 2,
    kTime            = 3,
    kStartHue        = 4,
    kOptionsMask     = 5,
    kOptionsOverride = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<ColorLoopUpdateFlags> updateFlags = static_cast<chip::BitMask<ColorLoopUpdateFlags>>(0);
    ColorLoopAction action                          = static_cast<ColorLoopAction>(0);
    ColorLoopDirection direction                    = static_cast<ColorLoopDirection>(0);
    uint16_t time                                   = static_cast<uint16_t>(0);
    uint16_t startHue                               = static_cast<uint16_t>(0);
    uint8_t optionsMask                             = static_cast<uint8_t>(0);
    uint8_t optionsOverride                         = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<ColorLoopUpdateFlags> updateFlags = static_cast<chip::BitMask<ColorLoopUpdateFlags>>(0);
    ColorLoopAction action                          = static_cast<ColorLoopAction>(0);
    ColorLoopDirection direction                    = static_cast<ColorLoopDirection>(0);
    uint16_t time                                   = static_cast<uint16_t>(0);
    uint16_t startHue                               = static_cast<uint16_t>(0);
    uint8_t optionsMask                             = static_cast<uint8_t>(0);
    uint8_t optionsOverride                         = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ColorLoopSet
namespace StopMoveStep {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t optionsMask     = static_cast<uint8_t>(0);
    uint8_t optionsOverride = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMoveStep
namespace MoveColorTemperature {
enum class Fields : uint8_t
{
    kMoveMode                      = 0,
    kRate                          = 1,
    kColorTemperatureMinimumMireds = 2,
    kColorTemperatureMaximumMireds = 3,
    kOptionsMask                   = 4,
    kOptionsOverride               = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode                   = static_cast<HueMoveMode>(0);
    uint16_t rate                          = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds = static_cast<uint16_t>(0);
    uint8_t optionsMask                    = static_cast<uint8_t>(0);
    uint8_t optionsOverride                = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode                   = static_cast<HueMoveMode>(0);
    uint16_t rate                          = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds = static_cast<uint16_t>(0);
    uint8_t optionsMask                    = static_cast<uint8_t>(0);
    uint8_t optionsOverride                = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColorTemperature
namespace StepColorTemperature {
enum class Fields : uint8_t
{
    kStepMode                      = 0,
    kStepSize                      = 1,
    kTransitionTime                = 2,
    kColorTemperatureMinimumMireds = 3,
    kColorTemperatureMaximumMireds = 4,
    kOptionsMask                   = 5,
    kOptionsOverride               = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode                   = static_cast<HueStepMode>(0);
    uint16_t stepSize                      = static_cast<uint16_t>(0);
    uint16_t transitionTime                = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds = static_cast<uint16_t>(0);
    uint8_t optionsMask                    = static_cast<uint8_t>(0);
    uint8_t optionsOverride                = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode                   = static_cast<HueStepMode>(0);
    uint16_t stepSize                      = static_cast<uint16_t>(0);
    uint16_t transitionTime                = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds = static_cast<uint16_t>(0);
    uint8_t optionsMask                    = static_cast<uint8_t>(0);
    uint8_t optionsOverride                = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColorTemperature
} // namespace Commands

namespace Attributes {

namespace CurrentHue {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHue
namespace CurrentSaturation {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSaturation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSaturation
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace CurrentX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentX
namespace CurrentY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentY
namespace DriftCompensation {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DriftCompensation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DriftCompensation
namespace CompensationText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompensationText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 254; }
};
} // namespace CompensationText
namespace ColorTemperatureMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTemperatureMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTemperatureMireds
namespace ColorMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorMode
namespace Options {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Options::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Options
namespace NumberOfPrimaries {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPrimaries::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPrimaries
namespace Primary1X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1X
namespace Primary1Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1Y
namespace Primary1Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1Intensity
namespace Primary2X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2X
namespace Primary2Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2Y
namespace Primary2Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2Intensity
namespace Primary3X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3X
namespace Primary3Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3Y
namespace Primary3Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3Intensity
namespace Primary4X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4X
namespace Primary4Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4Y
namespace Primary4Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4Intensity
namespace Primary5X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5X
namespace Primary5Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5Y
namespace Primary5Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5Intensity
namespace Primary6X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6X
namespace Primary6Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6Y
namespace Primary6Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6Intensity
namespace WhitePointX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WhitePointX
namespace WhitePointY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WhitePointY
namespace ColorPointRX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRX
namespace ColorPointRY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRY
namespace ColorPointRIntensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRIntensity
namespace ColorPointGX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGX
namespace ColorPointGY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGY
namespace ColorPointGIntensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGIntensity
namespace ColorPointBX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBX
namespace ColorPointBY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBY
namespace ColorPointBIntensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBIntensity
namespace EnhancedCurrentHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedCurrentHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnhancedCurrentHue
namespace EnhancedColorMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedColorMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnhancedColorMode
namespace ColorLoopActive {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopActive::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopActive
namespace ColorLoopDirection {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopDirection
namespace ColorLoopTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopTime
namespace ColorLoopStartEnhancedHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStartEnhancedHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopStartEnhancedHue
namespace ColorLoopStoredEnhancedHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStoredEnhancedHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopStoredEnhancedHue
namespace ColorCapabilities {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorCapabilities
namespace ColorTempPhysicalMinMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMinMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTempPhysicalMinMireds
namespace ColorTempPhysicalMaxMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMaxMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTempPhysicalMaxMireds
namespace CoupleColorTempToLevelMinMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CoupleColorTempToLevelMinMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CoupleColorTempToLevelMinMireds
namespace StartUpColorTemperatureMireds {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpColorTemperatureMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpColorTemperatureMireds
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentHue::TypeInfo::DecodableType currentHue               = static_cast<uint8_t>(0);
        Attributes::CurrentSaturation::TypeInfo::DecodableType currentSaturation = static_cast<uint8_t>(0);
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime         = static_cast<uint16_t>(0);
        Attributes::CurrentX::TypeInfo::DecodableType currentX                   = static_cast<uint16_t>(0);
        Attributes::CurrentY::TypeInfo::DecodableType currentY                   = static_cast<uint16_t>(0);
        Attributes::DriftCompensation::TypeInfo::DecodableType driftCompensation = static_cast<uint8_t>(0);
        Attributes::CompensationText::TypeInfo::DecodableType compensationText;
        Attributes::ColorTemperatureMireds::TypeInfo::DecodableType colorTemperatureMireds = static_cast<uint16_t>(0);
        Attributes::ColorMode::TypeInfo::DecodableType colorMode                           = static_cast<uint8_t>(0);
        Attributes::Options::TypeInfo::DecodableType options                               = static_cast<uint8_t>(0);
        Attributes::NumberOfPrimaries::TypeInfo::DecodableType numberOfPrimaries;
        Attributes::Primary1X::TypeInfo::DecodableType primary1X = static_cast<uint16_t>(0);
        Attributes::Primary1Y::TypeInfo::DecodableType primary1Y = static_cast<uint16_t>(0);
        Attributes::Primary1Intensity::TypeInfo::DecodableType primary1Intensity;
        Attributes::Primary2X::TypeInfo::DecodableType primary2X = static_cast<uint16_t>(0);
        Attributes::Primary2Y::TypeInfo::DecodableType primary2Y = static_cast<uint16_t>(0);
        Attributes::Primary2Intensity::TypeInfo::DecodableType primary2Intensity;
        Attributes::Primary3X::TypeInfo::DecodableType primary3X = static_cast<uint16_t>(0);
        Attributes::Primary3Y::TypeInfo::DecodableType primary3Y = static_cast<uint16_t>(0);
        Attributes::Primary3Intensity::TypeInfo::DecodableType primary3Intensity;
        Attributes::Primary4X::TypeInfo::DecodableType primary4X = static_cast<uint16_t>(0);
        Attributes::Primary4Y::TypeInfo::DecodableType primary4Y = static_cast<uint16_t>(0);
        Attributes::Primary4Intensity::TypeInfo::DecodableType primary4Intensity;
        Attributes::Primary5X::TypeInfo::DecodableType primary5X = static_cast<uint16_t>(0);
        Attributes::Primary5Y::TypeInfo::DecodableType primary5Y = static_cast<uint16_t>(0);
        Attributes::Primary5Intensity::TypeInfo::DecodableType primary5Intensity;
        Attributes::Primary6X::TypeInfo::DecodableType primary6X = static_cast<uint16_t>(0);
        Attributes::Primary6Y::TypeInfo::DecodableType primary6Y = static_cast<uint16_t>(0);
        Attributes::Primary6Intensity::TypeInfo::DecodableType primary6Intensity;
        Attributes::WhitePointX::TypeInfo::DecodableType whitePointX   = static_cast<uint16_t>(0);
        Attributes::WhitePointY::TypeInfo::DecodableType whitePointY   = static_cast<uint16_t>(0);
        Attributes::ColorPointRX::TypeInfo::DecodableType colorPointRX = static_cast<uint16_t>(0);
        Attributes::ColorPointRY::TypeInfo::DecodableType colorPointRY = static_cast<uint16_t>(0);
        Attributes::ColorPointRIntensity::TypeInfo::DecodableType colorPointRIntensity;
        Attributes::ColorPointGX::TypeInfo::DecodableType colorPointGX = static_cast<uint16_t>(0);
        Attributes::ColorPointGY::TypeInfo::DecodableType colorPointGY = static_cast<uint16_t>(0);
        Attributes::ColorPointGIntensity::TypeInfo::DecodableType colorPointGIntensity;
        Attributes::ColorPointBX::TypeInfo::DecodableType colorPointBX = static_cast<uint16_t>(0);
        Attributes::ColorPointBY::TypeInfo::DecodableType colorPointBY = static_cast<uint16_t>(0);
        Attributes::ColorPointBIntensity::TypeInfo::DecodableType colorPointBIntensity;
        Attributes::EnhancedCurrentHue::TypeInfo::DecodableType enhancedCurrentHue                 = static_cast<uint16_t>(0);
        Attributes::EnhancedColorMode::TypeInfo::DecodableType enhancedColorMode                   = static_cast<uint8_t>(0);
        Attributes::ColorLoopActive::TypeInfo::DecodableType colorLoopActive                       = static_cast<uint8_t>(0);
        Attributes::ColorLoopDirection::TypeInfo::DecodableType colorLoopDirection                 = static_cast<uint8_t>(0);
        Attributes::ColorLoopTime::TypeInfo::DecodableType colorLoopTime                           = static_cast<uint16_t>(0);
        Attributes::ColorLoopStartEnhancedHue::TypeInfo::DecodableType colorLoopStartEnhancedHue   = static_cast<uint16_t>(0);
        Attributes::ColorLoopStoredEnhancedHue::TypeInfo::DecodableType colorLoopStoredEnhancedHue = static_cast<uint16_t>(0);
        Attributes::ColorCapabilities::TypeInfo::DecodableType colorCapabilities                   = static_cast<uint16_t>(0);
        Attributes::ColorTempPhysicalMinMireds::TypeInfo::DecodableType colorTempPhysicalMinMireds = static_cast<uint16_t>(0);
        Attributes::ColorTempPhysicalMaxMireds::TypeInfo::DecodableType colorTempPhysicalMaxMireds = static_cast<uint16_t>(0);
        Attributes::CoupleColorTempToLevelMinMireds::TypeInfo::DecodableType coupleColorTempToLevelMinMireds =
            static_cast<uint16_t>(0);
        Attributes::StartUpColorTemperatureMireds::TypeInfo::DecodableType startUpColorTemperatureMireds;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ColorControl
namespace BallastConfiguration {

namespace Attributes {

namespace PhysicalMinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalMinLevel
namespace PhysicalMaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalMaxLevel
namespace BallastStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BallastStatus
namespace MinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxLevel
namespace IntrinsicBallastFactor {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IntrinsicBallastFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IntrinsicBallastFactor
namespace BallastFactorAdjustment {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastFactorAdjustment::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BallastFactorAdjustment
namespace LampQuantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampQuantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampQuantity
namespace LampType {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace LampType
namespace LampManufacturer {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampManufacturer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace LampManufacturer
namespace LampRatedHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampRatedHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampRatedHours
namespace LampBurnHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampBurnHours
namespace LampAlarmMode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampAlarmMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampAlarmMode
namespace LampBurnHoursTripPoint {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHoursTripPoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampBurnHoursTripPoint
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhysicalMinLevel::TypeInfo::DecodableType physicalMinLevel = static_cast<uint8_t>(0);
        Attributes::PhysicalMaxLevel::TypeInfo::DecodableType physicalMaxLevel = static_cast<uint8_t>(0);
        Attributes::BallastStatus::TypeInfo::DecodableType ballastStatus =
            static_cast<chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>>(0);
        Attributes::MinLevel::TypeInfo::DecodableType minLevel = static_cast<uint8_t>(0);
        Attributes::MaxLevel::TypeInfo::DecodableType maxLevel = static_cast<uint8_t>(0);
        Attributes::IntrinsicBallastFactor::TypeInfo::DecodableType intrinsicBallastFactor;
        Attributes::BallastFactorAdjustment::TypeInfo::DecodableType ballastFactorAdjustment;
        Attributes::LampQuantity::TypeInfo::DecodableType lampQuantity = static_cast<uint8_t>(0);
        Attributes::LampType::TypeInfo::DecodableType lampType;
        Attributes::LampManufacturer::TypeInfo::DecodableType lampManufacturer;
        Attributes::LampRatedHours::TypeInfo::DecodableType lampRatedHours;
        Attributes::LampBurnHours::TypeInfo::DecodableType lampBurnHours;
        Attributes::LampAlarmMode::TypeInfo::DecodableType lampAlarmMode =
            static_cast<chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>>(0);
        Attributes::LampBurnHoursTripPoint::TypeInfo::DecodableType lampBurnHoursTripPoint;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace BallastConfiguration
namespace IlluminanceMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace LightSensorType {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorTypeEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorTypeEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorTypeEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LightSensorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LightSensorType
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::LightSensorType::TypeInfo::DecodableType lightSensorType;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace IlluminanceMeasurement
namespace TemperatureMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TemperatureMeasurement
namespace PressureMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace ScaledValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScaledValue
namespace MinScaledValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinScaledValue
namespace MaxScaledValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxScaledValue
namespace ScaledTolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledTolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScaledTolerance
namespace Scale {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Scale::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Scale
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::ScaledValue::TypeInfo::DecodableType scaledValue;
        Attributes::MinScaledValue::TypeInfo::DecodableType minScaledValue;
        Attributes::MaxScaledValue::TypeInfo::DecodableType maxScaledValue;
        Attributes::ScaledTolerance::TypeInfo::DecodableType scaledTolerance = static_cast<uint16_t>(0);
        Attributes::Scale::TypeInfo::DecodableType scale                     = static_cast<int8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PressureMeasurement
namespace FlowMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FlowMeasurement
namespace RelativeHumidityMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RelativeHumidityMeasurement
namespace OccupancySensing {

namespace Attributes {

namespace Occupancy {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Occupancy
namespace OccupancySensorType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum;
    using DecodableType    = chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum;
    using DecodableArgType = chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupancySensorType
namespace OccupancySensorTypeBitmap {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorTypeBitmap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupancySensorTypeBitmap
namespace PIROccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIROccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIROccupiedToUnoccupiedDelay
namespace PIRUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIRUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIRUnoccupiedToOccupiedDelay
namespace PIRUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIRUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIRUnoccupiedToOccupiedThreshold
namespace UltrasonicOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicOccupiedToUnoccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicUnoccupiedToOccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicUnoccupiedToOccupiedThreshold
namespace PhysicalContactOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactOccupiedToUnoccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedThreshold
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Occupancy::TypeInfo::DecodableType occupancy =
            static_cast<chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>>(0);
        Attributes::OccupancySensorType::TypeInfo::DecodableType occupancySensorType =
            static_cast<chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum>(0);
        Attributes::OccupancySensorTypeBitmap::TypeInfo::DecodableType occupancySensorTypeBitmap =
            static_cast<chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>>(0);
        Attributes::PIROccupiedToUnoccupiedDelay::TypeInfo::DecodableType PIROccupiedToUnoccupiedDelay = static_cast<uint16_t>(0);
        Attributes::PIRUnoccupiedToOccupiedDelay::TypeInfo::DecodableType PIRUnoccupiedToOccupiedDelay = static_cast<uint16_t>(0);
        Attributes::PIRUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType PIRUnoccupiedToOccupiedThreshold =
            static_cast<uint8_t>(0);
        Attributes::UltrasonicOccupiedToUnoccupiedDelay::TypeInfo::DecodableType ultrasonicOccupiedToUnoccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::UltrasonicUnoccupiedToOccupiedDelay::TypeInfo::DecodableType ultrasonicUnoccupiedToOccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::UltrasonicUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType ultrasonicUnoccupiedToOccupiedThreshold =
            static_cast<uint8_t>(0);
        Attributes::PhysicalContactOccupiedToUnoccupiedDelay::TypeInfo::DecodableType physicalContactOccupiedToUnoccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::PhysicalContactUnoccupiedToOccupiedDelay::TypeInfo::DecodableType physicalContactUnoccupiedToOccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType
            physicalContactUnoccupiedToOccupiedThreshold = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OccupancySensing
namespace CarbonMonoxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace CarbonMonoxideConcentrationMeasurement
namespace CarbonDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace CarbonDioxideConcentrationMeasurement
namespace NitrogenDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace NitrogenDioxideConcentrationMeasurement
namespace OzoneConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OzoneConcentrationMeasurement
namespace Pm25ConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Pm25ConcentrationMeasurement
namespace FormaldehydeConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FormaldehydeConcentrationMeasurement
namespace Pm1ConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Pm1ConcentrationMeasurement
namespace Pm10ConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Pm10ConcentrationMeasurement
namespace TotalVolatileOrganicCompoundsConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TotalVolatileOrganicCompoundsConcentrationMeasurement
namespace RadonConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RadonConcentrationMeasurement
namespace WiFiNetworkManagement {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace NetworkPassphraseRequest {
struct Type;
struct DecodableType;
} // namespace NetworkPassphraseRequest

namespace NetworkPassphraseResponse {
struct Type;
struct DecodableType;
} // namespace NetworkPassphraseResponse

} // namespace Commands

namespace Commands {
namespace NetworkPassphraseRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::WiFiNetworkManagement::Commands::NetworkPassphraseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkPassphraseRequest
namespace NetworkPassphraseResponse {
enum class Fields : uint8_t
{
    kPassphrase = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    chip::ByteSpan passphrase;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    chip::ByteSpan passphrase;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkPassphraseResponse
} // namespace Commands

namespace Attributes {

namespace Ssid {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Ssid::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace Ssid
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Ssid::TypeInfo::DecodableType ssid;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WiFiNetworkManagement
namespace WakeOnLan {

namespace Attributes {

namespace MACAddress {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MACAddress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 12; }
};
} // namespace MACAddress
namespace LinkLocalAddress {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LinkLocalAddress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace LinkLocalAddress
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MACAddress::TypeInfo::DecodableType MACAddress;
        Attributes::LinkLocalAddress::TypeInfo::DecodableType linkLocalAddress;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WakeOnLan
namespace Channel {
namespace Structs {
namespace ProgramCastStruct {
enum class Fields : uint8_t
{
    kName = 0,
    kRole = 1,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan role;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProgramCastStruct
namespace ProgramCategoryStruct {
enum class Fields : uint8_t
{
    kCategory    = 0,
    kSubCategory = 1,
};

struct Type
{
public:
    chip::CharSpan category;
    Optional<chip::CharSpan> subCategory;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProgramCategoryStruct
namespace SeriesInfoStruct {
enum class Fields : uint8_t
{
    kSeason  = 0,
    kEpisode = 1,
};

struct Type
{
public:
    chip::CharSpan season;
    chip::CharSpan episode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SeriesInfoStruct
namespace ChannelInfoStruct {
enum class Fields : uint8_t
{
    kMajorNumber       = 0,
    kMinorNumber       = 1,
    kName              = 2,
    kCallSign          = 3,
    kAffiliateCallSign = 4,
    kIdentifier        = 5,
    kType              = 6,
};

struct Type
{
public:
    uint16_t majorNumber = static_cast<uint16_t>(0);
    uint16_t minorNumber = static_cast<uint16_t>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::CharSpan> callSign;
    Optional<chip::CharSpan> affiliateCallSign;
    Optional<chip::CharSpan> identifier;
    Optional<ChannelTypeEnum> type;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChannelInfoStruct
namespace ProgramStruct {
enum class Fields : uint8_t
{
    kIdentifier           = 0,
    kChannel              = 1,
    kStartTime            = 2,
    kEndTime              = 3,
    kTitle                = 4,
    kSubtitle             = 5,
    kDescription          = 6,
    kAudioLanguages       = 7,
    kRatings              = 8,
    kThumbnailUrl         = 9,
    kPosterArtUrl         = 10,
    kDvbiUrl              = 11,
    kReleaseDate          = 12,
    kParentalGuidanceText = 13,
    kRecordingFlag        = 14,
    kSeriesInfo           = 15,
    kCategoryList         = 16,
    kCastList             = 17,
    kExternalIDList       = 18,
};

struct Type
{
public:
    chip::CharSpan identifier;
    Structs::ChannelInfoStruct::Type channel;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    chip::CharSpan title;
    Optional<chip::CharSpan> subtitle;
    Optional<chip::CharSpan> description;
    Optional<DataModel::List<const chip::CharSpan>> audioLanguages;
    Optional<DataModel::List<const chip::CharSpan>> ratings;
    Optional<chip::CharSpan> thumbnailUrl;
    Optional<chip::CharSpan> posterArtUrl;
    Optional<chip::CharSpan> dvbiUrl;
    Optional<chip::CharSpan> releaseDate;
    Optional<chip::CharSpan> parentalGuidanceText;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::Nullable<Structs::SeriesInfoStruct::Type>> seriesInfo;
    Optional<DataModel::List<const Structs::ProgramCategoryStruct::Type>> categoryList;
    Optional<DataModel::List<const Structs::ProgramCastStruct::Type>> castList;
    Optional<DataModel::List<const Structs::ProgramCastStruct::Type>> externalIDList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan identifier;
    Structs::ChannelInfoStruct::DecodableType channel;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    chip::CharSpan title;
    Optional<chip::CharSpan> subtitle;
    Optional<chip::CharSpan> description;
    Optional<DataModel::DecodableList<chip::CharSpan>> audioLanguages;
    Optional<DataModel::DecodableList<chip::CharSpan>> ratings;
    Optional<chip::CharSpan> thumbnailUrl;
    Optional<chip::CharSpan> posterArtUrl;
    Optional<chip::CharSpan> dvbiUrl;
    Optional<chip::CharSpan> releaseDate;
    Optional<chip::CharSpan> parentalGuidanceText;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::Nullable<Structs::SeriesInfoStruct::DecodableType>> seriesInfo;
    Optional<DataModel::DecodableList<Structs::ProgramCategoryStruct::DecodableType>> categoryList;
    Optional<DataModel::DecodableList<Structs::ProgramCastStruct::DecodableType>> castList;
    Optional<DataModel::DecodableList<Structs::ProgramCastStruct::DecodableType>> externalIDList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ProgramStruct
namespace PageTokenStruct {
enum class Fields : uint8_t
{
    kLimit  = 0,
    kAfter  = 1,
    kBefore = 2,
};

struct Type
{
public:
    Optional<uint16_t> limit;
    Optional<chip::CharSpan> after;
    Optional<chip::CharSpan> before;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PageTokenStruct
namespace ChannelPagingStruct {
enum class Fields : uint8_t
{
    kPreviousToken = 0,
    kNextToken     = 1,
};

struct Type
{
public:
    Optional<DataModel::Nullable<Structs::PageTokenStruct::Type>> previousToken;
    Optional<DataModel::Nullable<Structs::PageTokenStruct::Type>> nextToken;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChannelPagingStruct
namespace AdditionalInfoStruct {
enum class Fields : uint8_t
{
    kName  = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan value;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AdditionalInfoStruct
namespace LineupInfoStruct {
enum class Fields : uint8_t
{
    kOperatorName   = 0,
    kLineupName     = 1,
    kPostalCode     = 2,
    kLineupInfoType = 3,
};

struct Type
{
public:
    chip::CharSpan operatorName;
    Optional<chip::CharSpan> lineupName;
    Optional<chip::CharSpan> postalCode;
    LineupInfoTypeEnum lineupInfoType = static_cast<LineupInfoTypeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LineupInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeChannel {
struct Type;
struct DecodableType;
} // namespace ChangeChannel

namespace ChangeChannelResponse {
struct Type;
struct DecodableType;
} // namespace ChangeChannelResponse

namespace ChangeChannelByNumber {
struct Type;
struct DecodableType;
} // namespace ChangeChannelByNumber

namespace SkipChannel {
struct Type;
struct DecodableType;
} // namespace SkipChannel

namespace GetProgramGuide {
struct Type;
struct DecodableType;
} // namespace GetProgramGuide

namespace ProgramGuideResponse {
struct Type;
struct DecodableType;
} // namespace ProgramGuideResponse

namespace RecordProgram {
struct Type;
struct DecodableType;
} // namespace RecordProgram

namespace CancelRecordProgram {
struct Type;
struct DecodableType;
} // namespace CancelRecordProgram

} // namespace Commands

namespace Commands {
namespace ChangeChannel {
enum class Fields : uint8_t
{
    kMatch = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan match;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Channel::Commands::ChangeChannelResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan match;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannel
namespace ChangeChannelResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelResponse
namespace ChangeChannelByNumber {
enum class Fields : uint8_t
{
    kMajorNumber = 0,
    kMinorNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t majorNumber = static_cast<uint16_t>(0);
    uint16_t minorNumber = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t majorNumber = static_cast<uint16_t>(0);
    uint16_t minorNumber = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelByNumber
namespace SkipChannel {
enum class Fields : uint8_t
{
    kCount = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    int16_t count = static_cast<int16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    int16_t count = static_cast<int16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipChannel
namespace GetProgramGuide {
enum class Fields : uint8_t
{
    kStartTime      = 0,
    kEndTime        = 1,
    kChannelList    = 2,
    kPageToken      = 3,
    kRecordingFlag  = 4,
    kExternalIDList = 5,
    kData           = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetProgramGuide::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Optional<uint32_t> startTime;
    Optional<uint32_t> endTime;
    Optional<DataModel::List<const Structs::ChannelInfoStruct::Type>> channelList;
    Optional<Structs::PageTokenStruct::Type> pageToken;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::List<const Structs::AdditionalInfoStruct::Type>> externalIDList;
    Optional<chip::ByteSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Channel::Commands::ProgramGuideResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetProgramGuide::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Optional<uint32_t> startTime;
    Optional<uint32_t> endTime;
    Optional<DataModel::DecodableList<Structs::ChannelInfoStruct::DecodableType>> channelList;
    Optional<Structs::PageTokenStruct::DecodableType> pageToken;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType>> externalIDList;
    Optional<chip::ByteSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProgramGuide
namespace ProgramGuideResponse {
enum class Fields : uint8_t
{
    kPaging      = 0,
    kProgramList = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProgramGuideResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Structs::ChannelPagingStruct::Type paging;
    DataModel::List<const Structs::ProgramStruct::Type> programList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProgramGuideResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Structs::ChannelPagingStruct::DecodableType paging;
    DataModel::DecodableList<Structs::ProgramStruct::DecodableType> programList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProgramGuideResponse
namespace RecordProgram {
enum class Fields : uint8_t
{
    kProgramIdentifier  = 0,
    kShouldRecordSeries = 1,
    kExternalIDList     = 2,
    kData               = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::List<const Structs::AdditionalInfoStruct::Type> externalIDList;
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType> externalIDList;
    chip::ByteSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RecordProgram
namespace CancelRecordProgram {
enum class Fields : uint8_t
{
    kProgramIdentifier  = 0,
    kShouldRecordSeries = 1,
    kExternalIDList     = 2,
    kData               = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelRecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::List<const Structs::AdditionalInfoStruct::Type> externalIDList;
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelRecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType> externalIDList;
    chip::ByteSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelRecordProgram
} // namespace Commands

namespace Attributes {

namespace ChannelList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Channel::Structs::ChannelInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelList
namespace Lineup {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfoStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Lineup::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Lineup
namespace CurrentChannel {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentChannel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentChannel
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ChannelList::TypeInfo::DecodableType channelList;
        Attributes::Lineup::TypeInfo::DecodableType lineup;
        Attributes::CurrentChannel::TypeInfo::DecodableType currentChannel;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Channel
namespace TargetNavigator {
namespace Structs {
namespace TargetInfoStruct {
enum class Fields : uint8_t
{
    kIdentifier = 0,
    kName       = 1,
};

struct Type
{
public:
    uint8_t identifier = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TargetInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace NavigateTarget {
struct Type;
struct DecodableType;
} // namespace NavigateTarget

namespace NavigateTargetResponse {
struct Type;
struct DecodableType;
} // namespace NavigateTargetResponse

} // namespace Commands

namespace Commands {
namespace NavigateTarget {
enum class Fields : uint8_t
{
    kTarget = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    uint8_t target = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    uint8_t target = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTarget
namespace NavigateTargetResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTargetResponse
} // namespace Commands

namespace Attributes {

namespace TargetList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TargetNavigator::Structs::TargetInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetList
namespace CurrentTarget {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentTarget::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentTarget
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TargetList::TypeInfo::DecodableType targetList;
        Attributes::CurrentTarget::TypeInfo::DecodableType currentTarget = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace TargetUpdated {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kTargetList    = 0,
    kCurrentTarget = 1,
    kData          = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TargetUpdated::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const Structs::TargetInfoStruct::Type> targetList;
    uint8_t currentTarget = static_cast<uint8_t>(0);
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TargetUpdated::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    DataModel::DecodableList<Structs::TargetInfoStruct::DecodableType> targetList;
    uint8_t currentTarget = static_cast<uint8_t>(0);
    chip::ByteSpan data;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TargetUpdated
} // namespace Events
} // namespace TargetNavigator
namespace MediaPlayback {
namespace Structs {
namespace TrackAttributesStruct {
enum class Fields : uint8_t
{
    kLanguageCode = 0,
    kDisplayName  = 1,
};

struct Type
{
public:
    chip::CharSpan languageCode;
    Optional<DataModel::Nullable<chip::CharSpan>> displayName;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TrackAttributesStruct
namespace TrackStruct {
enum class Fields : uint8_t
{
    kId              = 0,
    kTrackAttributes = 1,
};

struct Type
{
public:
    chip::CharSpan id;
    DataModel::Nullable<Structs::TrackAttributesStruct::Type> trackAttributes;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TrackStruct
namespace PlaybackPositionStruct {
enum class Fields : uint8_t
{
    kUpdatedAt = 0,
    kPosition  = 1,
};

struct Type
{
public:
    uint64_t updatedAt = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> position;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PlaybackPositionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Play {
struct Type;
struct DecodableType;
} // namespace Play

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace StartOver {
struct Type;
struct DecodableType;
} // namespace StartOver

namespace Previous {
struct Type;
struct DecodableType;
} // namespace Previous

namespace Next {
struct Type;
struct DecodableType;
} // namespace Next

namespace Rewind {
struct Type;
struct DecodableType;
} // namespace Rewind

namespace FastForward {
struct Type;
struct DecodableType;
} // namespace FastForward

namespace SkipForward {
struct Type;
struct DecodableType;
} // namespace SkipForward

namespace SkipBackward {
struct Type;
struct DecodableType;
} // namespace SkipBackward

namespace PlaybackResponse {
struct Type;
struct DecodableType;
} // namespace PlaybackResponse

namespace Seek {
struct Type;
struct DecodableType;
} // namespace Seek

namespace ActivateAudioTrack {
struct Type;
struct DecodableType;
} // namespace ActivateAudioTrack

namespace ActivateTextTrack {
struct Type;
struct DecodableType;
} // namespace ActivateTextTrack

namespace DeactivateTextTrack {
struct Type;
struct DecodableType;
} // namespace DeactivateTextTrack

} // namespace Commands

namespace Commands {
namespace Play {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Play::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Play::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Play
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace StartOver {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartOver::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartOver::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartOver
namespace Previous {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Previous::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Previous::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Previous
namespace Next {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Next::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Next::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Next
namespace Rewind {
enum class Fields : uint8_t
{
    kAudioAdvanceUnmuted = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Rewind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Rewind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Rewind
namespace FastForward {
enum class Fields : uint8_t
{
    kAudioAdvanceUnmuted = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FastForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FastForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FastForward
namespace SkipForward {
enum class Fields : uint8_t
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipForward
namespace SkipBackward {
enum class Fields : uint8_t
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipBackward
namespace PlaybackResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PlaybackResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PlaybackResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PlaybackResponse
namespace Seek {
enum class Fields : uint8_t
{
    kPosition = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Seek::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t position = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Seek::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t position = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Seek
namespace ActivateAudioTrack {
enum class Fields : uint8_t
{
    kTrackID          = 0,
    kAudioOutputIndex = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ActivateAudioTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ActivateAudioTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ActivateAudioTrack
namespace ActivateTextTrack {
enum class Fields : uint8_t
{
    kTrackID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ActivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ActivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ActivateTextTrack
namespace DeactivateTextTrack {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DeactivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DeactivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DeactivateTextTrack
} // namespace Commands

namespace Attributes {

namespace CurrentState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::MediaPlayback::PlaybackStateEnum;
    using DecodableType    = chip::app::Clusters::MediaPlayback::PlaybackStateEnum;
    using DecodableArgType = chip::app::Clusters::MediaPlayback::PlaybackStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentState
namespace StartTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartTime
namespace Duration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Duration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Duration
namespace SampledPosition {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPositionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPositionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPositionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SampledPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SampledPosition
namespace PlaybackSpeed {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PlaybackSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PlaybackSpeed
namespace SeekRangeEnd {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeEnd::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SeekRangeEnd
namespace SeekRangeStart {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeStart::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SeekRangeStart
namespace ActiveAudioTrack {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveAudioTrack::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveAudioTrack
namespace AvailableAudioTracks {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::DataModel::List<const chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailableAudioTracks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailableAudioTracks
namespace ActiveTextTrack {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveTextTrack::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveTextTrack
namespace AvailableTextTracks {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::DataModel::List<const chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailableTextTracks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailableTextTracks
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentState::TypeInfo::DecodableType currentState =
            static_cast<chip::app::Clusters::MediaPlayback::PlaybackStateEnum>(0);
        Attributes::StartTime::TypeInfo::DecodableType startTime;
        Attributes::Duration::TypeInfo::DecodableType duration;
        Attributes::SampledPosition::TypeInfo::DecodableType sampledPosition;
        Attributes::PlaybackSpeed::TypeInfo::DecodableType playbackSpeed = static_cast<float>(0);
        Attributes::SeekRangeEnd::TypeInfo::DecodableType seekRangeEnd;
        Attributes::SeekRangeStart::TypeInfo::DecodableType seekRangeStart;
        Attributes::ActiveAudioTrack::TypeInfo::DecodableType activeAudioTrack;
        Attributes::AvailableAudioTracks::TypeInfo::DecodableType availableAudioTracks;
        Attributes::ActiveTextTrack::TypeInfo::DecodableType activeTextTrack;
        Attributes::AvailableTextTracks::TypeInfo::DecodableType availableTextTracks;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrentState        = 0,
    kStartTime           = 1,
    kDuration            = 2,
    kSampledPosition     = 3,
    kPlaybackSpeed       = 4,
    kSeekRangeEnd        = 5,
    kSeekRangeStart      = 6,
    kData                = 7,
    kAudioAdvanceUnmuted = 8,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr bool kIsFabricScoped = false;

    PlaybackStateEnum currentState = static_cast<PlaybackStateEnum>(0);
    uint64_t startTime             = static_cast<uint64_t>(0);
    uint64_t duration              = static_cast<uint64_t>(0);
    Structs::PlaybackPositionStruct::Type sampledPosition;
    float playbackSpeed     = static_cast<float>(0);
    uint64_t seekRangeEnd   = static_cast<uint64_t>(0);
    uint64_t seekRangeStart = static_cast<uint64_t>(0);
    Optional<chip::ByteSpan> data;
    bool audioAdvanceUnmuted = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    PlaybackStateEnum currentState = static_cast<PlaybackStateEnum>(0);
    uint64_t startTime             = static_cast<uint64_t>(0);
    uint64_t duration              = static_cast<uint64_t>(0);
    Structs::PlaybackPositionStruct::DecodableType sampledPosition;
    float playbackSpeed     = static_cast<float>(0);
    uint64_t seekRangeEnd   = static_cast<uint64_t>(0);
    uint64_t seekRangeStart = static_cast<uint64_t>(0);
    Optional<chip::ByteSpan> data;
    bool audioAdvanceUnmuted = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChanged
} // namespace Events
} // namespace MediaPlayback
namespace MediaInput {
namespace Structs {
namespace InputInfoStruct {
enum class Fields : uint8_t
{
    kIndex       = 0,
    kInputType   = 1,
    kName        = 2,
    kDescription = 3,
};

struct Type
{
public:
    uint8_t index           = static_cast<uint8_t>(0);
    InputTypeEnum inputType = static_cast<InputTypeEnum>(0);
    chip::CharSpan name;
    chip::CharSpan description;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace InputInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectInput {
struct Type;
struct DecodableType;
} // namespace SelectInput

namespace ShowInputStatus {
struct Type;
struct DecodableType;
} // namespace ShowInputStatus

namespace HideInputStatus {
struct Type;
struct DecodableType;
} // namespace HideInputStatus

namespace RenameInput {
struct Type;
struct DecodableType;
} // namespace RenameInput

} // namespace Commands

namespace Commands {
namespace SelectInput {
enum class Fields : uint8_t
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectInput
namespace ShowInputStatus {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShowInputStatus
namespace HideInputStatus {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideInputStatus
namespace RenameInput {
enum class Fields : uint8_t
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameInput
} // namespace Commands

namespace Attributes {

namespace InputList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::MediaInput::Structs::InputInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InputList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InputList
namespace CurrentInput {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentInput::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentInput
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::InputList::TypeInfo::DecodableType inputList;
        Attributes::CurrentInput::TypeInfo::DecodableType currentInput = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace MediaInput
namespace LowPower {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Sleep {
struct Type;
struct DecodableType;
} // namespace Sleep

} // namespace Commands

namespace Commands {
namespace Sleep {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Sleep
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LowPower
namespace KeypadInput {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SendKey {
struct Type;
struct DecodableType;
} // namespace SendKey

namespace SendKeyResponse {
struct Type;
struct DecodableType;
} // namespace SendKeyResponse

} // namespace Commands

namespace Commands {
namespace SendKey {
enum class Fields : uint8_t
{
    kKeyCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    CECKeyCodeEnum keyCode = static_cast<CECKeyCodeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    CECKeyCodeEnum keyCode = static_cast<CECKeyCodeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKey
namespace SendKeyResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKeyResponse
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace KeypadInput
namespace ContentLauncher {
namespace Structs {
namespace DimensionStruct {
enum class Fields : uint8_t
{
    kWidth  = 0,
    kHeight = 1,
    kMetric = 2,
};

struct Type
{
public:
    double width          = static_cast<double>(0);
    double height         = static_cast<double>(0);
    MetricTypeEnum metric = static_cast<MetricTypeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DimensionStruct
namespace TrackPreferenceStruct {
enum class Fields : uint8_t
{
    kLanguageCode     = 0,
    kCharacteristics  = 1,
    kAudioOutputIndex = 2,
};

struct Type
{
public:
    chip::CharSpan languageCode;
    Optional<DataModel::List<const CharacteristicEnum>> characteristics;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan languageCode;
    Optional<DataModel::DecodableList<CharacteristicEnum>> characteristics;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TrackPreferenceStruct
namespace PlaybackPreferencesStruct {
enum class Fields : uint8_t
{
    kPlaybackPosition = 0,
    kTextTrack        = 1,
    kAudioTracks      = 2,
};

struct Type
{
public:
    uint64_t playbackPosition = static_cast<uint64_t>(0);
    Structs::TrackPreferenceStruct::Type textTrack;
    Optional<DataModel::List<const Structs::TrackPreferenceStruct::Type>> audioTracks;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint64_t playbackPosition = static_cast<uint64_t>(0);
    Structs::TrackPreferenceStruct::DecodableType textTrack;
    Optional<DataModel::DecodableList<Structs::TrackPreferenceStruct::DecodableType>> audioTracks;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace PlaybackPreferencesStruct
namespace AdditionalInfoStruct {
enum class Fields : uint8_t
{
    kName  = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan value;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AdditionalInfoStruct
namespace ParameterStruct {
enum class Fields : uint8_t
{
    kType           = 0,
    kValue          = 1,
    kExternalIDList = 2,
};

struct Type
{
public:
    ParameterEnum type = static_cast<ParameterEnum>(0);
    chip::CharSpan value;
    Optional<DataModel::List<const Structs::AdditionalInfoStruct::Type>> externalIDList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    ParameterEnum type = static_cast<ParameterEnum>(0);
    chip::CharSpan value;
    Optional<DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType>> externalIDList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ParameterStruct
namespace ContentSearchStruct {
enum class Fields : uint8_t
{
    kParameterList = 0,
};

struct Type
{
public:
    DataModel::List<const Structs::ParameterStruct::Type> parameterList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<Structs::ParameterStruct::DecodableType> parameterList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ContentSearchStruct
namespace StyleInformationStruct {
enum class Fields : uint8_t
{
    kImageURL = 0,
    kColor    = 1,
    kSize     = 2,
};

struct Type
{
public:
    Optional<chip::CharSpan> imageURL;
    Optional<chip::CharSpan> color;
    Optional<Structs::DimensionStruct::Type> size;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace StyleInformationStruct
namespace BrandingInformationStruct {
enum class Fields : uint8_t
{
    kProviderName = 0,
    kBackground   = 1,
    kLogo         = 2,
    kProgressBar  = 3,
    kSplash       = 4,
    kWaterMark    = 5,
};

struct Type
{
public:
    chip::CharSpan providerName;
    Optional<Structs::StyleInformationStruct::Type> background;
    Optional<Structs::StyleInformationStruct::Type> logo;
    Optional<Structs::StyleInformationStruct::Type> progressBar;
    Optional<Structs::StyleInformationStruct::Type> splash;
    Optional<Structs::StyleInformationStruct::Type> waterMark;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace BrandingInformationStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LaunchContent {
struct Type;
struct DecodableType;
} // namespace LaunchContent

namespace LaunchURL {
struct Type;
struct DecodableType;
} // namespace LaunchURL

namespace LauncherResponse {
struct Type;
struct DecodableType;
} // namespace LauncherResponse

} // namespace Commands

namespace Commands {
namespace LaunchContent {
enum class Fields : uint8_t
{
    kSearch              = 0,
    kAutoPlay            = 1,
    kData                = 2,
    kPlaybackPreferences = 3,
    kUseCurrentContext   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    Structs::ContentSearchStruct::Type search;
    bool autoPlay = static_cast<bool>(0);
    Optional<chip::CharSpan> data;
    Optional<Structs::PlaybackPreferencesStruct::Type> playbackPreferences;
    Optional<bool> useCurrentContext;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    Structs::ContentSearchStruct::DecodableType search;
    bool autoPlay = static_cast<bool>(0);
    Optional<chip::CharSpan> data;
    Optional<Structs::PlaybackPreferencesStruct::DecodableType> playbackPreferences;
    Optional<bool> useCurrentContext;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchContent
namespace LaunchURL {
enum class Fields : uint8_t
{
    kContentURL          = 0,
    kDisplayString       = 1,
    kBrandingInformation = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    chip::CharSpan contentURL;
    Optional<chip::CharSpan> displayString;
    Optional<Structs::BrandingInformationStruct::Type> brandingInformation;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    chip::CharSpan contentURL;
    Optional<chip::CharSpan> displayString;
    Optional<Structs::BrandingInformationStruct::DecodableType> brandingInformation;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchURL
namespace LauncherResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LauncherResponse
} // namespace Commands

namespace Attributes {

namespace AcceptHeader {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcceptHeader::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcceptHeader
namespace SupportedStreamingProtocols {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedStreamingProtocols::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedStreamingProtocols
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AcceptHeader::TypeInfo::DecodableType acceptHeader;
        Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType supportedStreamingProtocols =
            static_cast<chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ContentLauncher
namespace AudioOutput {
namespace Structs {
namespace OutputInfoStruct {
enum class Fields : uint8_t
{
    kIndex      = 0,
    kOutputType = 1,
    kName       = 2,
};

struct Type
{
public:
    uint8_t index             = static_cast<uint8_t>(0);
    OutputTypeEnum outputType = static_cast<OutputTypeEnum>(0);
    chip::CharSpan name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OutputInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectOutput {
struct Type;
struct DecodableType;
} // namespace SelectOutput

namespace RenameOutput {
struct Type;
struct DecodableType;
} // namespace RenameOutput

} // namespace Commands

namespace Commands {
namespace SelectOutput {
enum class Fields : uint8_t
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectOutput
namespace RenameOutput {
enum class Fields : uint8_t
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameOutput
} // namespace Commands

namespace Attributes {

namespace OutputList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AudioOutput::Structs::OutputInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutputList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutputList
namespace CurrentOutput {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentOutput::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentOutput
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OutputList::TypeInfo::DecodableType outputList;
        Attributes::CurrentOutput::TypeInfo::DecodableType currentOutput = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace AudioOutput
namespace ApplicationLauncher {
namespace Structs {
namespace ApplicationStruct = Clusters::detail::Structs::ApplicationStruct;
namespace ApplicationEPStruct {
enum class Fields : uint8_t
{
    kApplication = 0,
    kEndpoint    = 1,
};

struct Type
{
public:
    Structs::ApplicationStruct::Type application;
    Optional<chip::EndpointId> endpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ApplicationEPStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LaunchApp {
struct Type;
struct DecodableType;
} // namespace LaunchApp

namespace StopApp {
struct Type;
struct DecodableType;
} // namespace StopApp

namespace HideApp {
struct Type;
struct DecodableType;
} // namespace HideApp

namespace LauncherResponse {
struct Type;
struct DecodableType;
} // namespace LauncherResponse

} // namespace Commands

namespace Commands {
namespace LaunchApp {
enum class Fields : uint8_t
{
    kApplication = 0,
    kData        = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::Type> application;
    Optional<chip::ByteSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::DecodableType> application;
    Optional<chip::ByteSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchApp
namespace StopApp {
enum class Fields : uint8_t
{
    kApplication = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::Type> application;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::DecodableType> application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopApp
namespace HideApp {
enum class Fields : uint8_t
{
    kApplication = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::Type> application;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::DecodableType> application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideApp
namespace LauncherResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::ByteSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::ByteSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LauncherResponse
} // namespace Commands

namespace Attributes {

namespace CatalogList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CatalogList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CatalogList
namespace CurrentApp {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEPStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEPStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEPStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentApp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentApp
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CatalogList::TypeInfo::DecodableType catalogList;
        Attributes::CurrentApp::TypeInfo::DecodableType currentApp;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ApplicationLauncher
namespace ApplicationBasic {
namespace Structs {
namespace ApplicationStruct = Clusters::detail::Structs::ApplicationStruct;
} // namespace Structs

namespace Attributes {

namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ApplicationName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 256; }
};
} // namespace ApplicationName
namespace ProductID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductID
namespace Application {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ApplicationBasic::Structs::ApplicationStruct::Type;
    using DecodableType    = chip::app::Clusters::ApplicationBasic::Structs::ApplicationStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::ApplicationBasic::Structs::ApplicationStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Application::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Application
namespace Status {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum;
    using DecodableType    = chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum;
    using DecodableArgType = chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Status
namespace ApplicationVersion {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace ApplicationVersion
namespace AllowedVendorList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::VendorId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::VendorId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::VendorId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AllowedVendorList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AllowedVendorList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID = static_cast<chip::VendorId>(0);
        Attributes::ApplicationName::TypeInfo::DecodableType applicationName;
        Attributes::ProductID::TypeInfo::DecodableType productID = static_cast<uint16_t>(0);
        Attributes::Application::TypeInfo::DecodableType application;
        Attributes::Status::TypeInfo::DecodableType status =
            static_cast<chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum>(0);
        Attributes::ApplicationVersion::TypeInfo::DecodableType applicationVersion;
        Attributes::AllowedVendorList::TypeInfo::DecodableType allowedVendorList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ApplicationBasic
namespace AccountLogin {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetSetupPIN {
struct Type;
struct DecodableType;
} // namespace GetSetupPIN

namespace GetSetupPINResponse {
struct Type;
struct DecodableType;
} // namespace GetSetupPINResponse

namespace Login {
struct Type;
struct DecodableType;
} // namespace Login

namespace Logout {
struct Type;
struct DecodableType;
} // namespace Logout

} // namespace Commands

namespace Commands {
namespace GetSetupPIN {
enum class Fields : uint8_t
{
    kTempAccountIdentifier = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPIN
namespace GetSetupPINResponse {
enum class Fields : uint8_t
{
    kSetupPIN = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan setupPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan setupPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPINResponse
namespace Login {
enum class Fields : uint8_t
{
    kTempAccountIdentifier = 0,
    kSetupPIN              = 1,
    kNode                  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Login::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    chip::CharSpan setupPIN;
    Optional<chip::NodeId> node;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Login::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    chip::CharSpan setupPIN;
    Optional<chip::NodeId> node;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Login
namespace Logout {
enum class Fields : uint8_t
{
    kNode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Logout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    Optional<chip::NodeId> node;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Logout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    Optional<chip::NodeId> node;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Logout
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace LoggedOut {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kNode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoggedOut::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<chip::NodeId> node;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoggedOut::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    Optional<chip::NodeId> node;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LoggedOut
} // namespace Events
} // namespace AccountLogin
namespace ContentControl {
namespace Structs {
namespace RatingNameStruct {
enum class Fields : uint8_t
{
    kRatingName     = 0,
    kRatingNameDesc = 1,
};

struct Type
{
public:
    chip::CharSpan ratingName;
    Optional<chip::CharSpan> ratingNameDesc;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace RatingNameStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace UpdatePIN {
struct Type;
struct DecodableType;
} // namespace UpdatePIN

namespace ResetPIN {
struct Type;
struct DecodableType;
} // namespace ResetPIN

namespace ResetPINResponse {
struct Type;
struct DecodableType;
} // namespace ResetPINResponse

namespace Enable {
struct Type;
struct DecodableType;
} // namespace Enable

namespace Disable {
struct Type;
struct DecodableType;
} // namespace Disable

namespace AddBonusTime {
struct Type;
struct DecodableType;
} // namespace AddBonusTime

namespace SetScreenDailyTime {
struct Type;
struct DecodableType;
} // namespace SetScreenDailyTime

namespace BlockUnratedContent {
struct Type;
struct DecodableType;
} // namespace BlockUnratedContent

namespace UnblockUnratedContent {
struct Type;
struct DecodableType;
} // namespace UnblockUnratedContent

namespace SetOnDemandRatingThreshold {
struct Type;
struct DecodableType;
} // namespace SetOnDemandRatingThreshold

namespace SetScheduledContentRatingThreshold {
struct Type;
struct DecodableType;
} // namespace SetScheduledContentRatingThreshold

} // namespace Commands

namespace Commands {
namespace UpdatePIN {
enum class Fields : uint8_t
{
    kOldPIN = 0,
    kNewPIN = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdatePIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> oldPIN;
    chip::CharSpan newPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdatePIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> oldPIN;
    chip::CharSpan newPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdatePIN
namespace ResetPIN {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentControl::Commands::ResetPINResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetPIN
namespace ResetPINResponse {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetPINResponse
namespace Enable {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Enable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Enable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Enable
namespace Disable {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Disable
namespace AddBonusTime {
enum class Fields : uint8_t
{
    kPINCode   = 0,
    kBonusTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddBonusTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> PINCode;
    Optional<uint32_t> bonusTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddBonusTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> PINCode;
    Optional<uint32_t> bonusTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddBonusTime
namespace SetScreenDailyTime {
enum class Fields : uint8_t
{
    kScreenTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetScreenDailyTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    uint32_t screenTime = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetScreenDailyTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    uint32_t screenTime = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetScreenDailyTime
namespace BlockUnratedContent {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BlockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BlockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BlockUnratedContent
namespace UnblockUnratedContent {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnblockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnblockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnblockUnratedContent
namespace SetOnDemandRatingThreshold {
enum class Fields : uint8_t
{
    kRating = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetOnDemandRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetOnDemandRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetOnDemandRatingThreshold
namespace SetScheduledContentRatingThreshold {
enum class Fields : uint8_t
{
    kRating = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetScheduledContentRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetScheduledContentRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetScheduledContentRatingThreshold
} // namespace Commands

namespace Attributes {

namespace Enabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enabled
namespace OnDemandRatings {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ContentControl::Structs::RatingNameStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnDemandRatings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnDemandRatings
namespace OnDemandRatingThreshold {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnDemandRatingThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 8; }
};
} // namespace OnDemandRatingThreshold
namespace ScheduledContentRatings {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ContentControl::Structs::RatingNameStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduledContentRatings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduledContentRatings
namespace ScheduledContentRatingThreshold {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduledContentRatingThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 8; }
};
} // namespace ScheduledContentRatingThreshold
namespace ScreenDailyTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScreenDailyTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScreenDailyTime
namespace RemainingScreenTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingScreenTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingScreenTime
namespace BlockUnrated {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BlockUnrated::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BlockUnrated
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Enabled::TypeInfo::DecodableType enabled = static_cast<bool>(0);
        Attributes::OnDemandRatings::TypeInfo::DecodableType onDemandRatings;
        Attributes::OnDemandRatingThreshold::TypeInfo::DecodableType onDemandRatingThreshold;
        Attributes::ScheduledContentRatings::TypeInfo::DecodableType scheduledContentRatings;
        Attributes::ScheduledContentRatingThreshold::TypeInfo::DecodableType scheduledContentRatingThreshold;
        Attributes::ScreenDailyTime::TypeInfo::DecodableType screenDailyTime         = static_cast<uint32_t>(0);
        Attributes::RemainingScreenTime::TypeInfo::DecodableType remainingScreenTime = static_cast<uint32_t>(0);
        Attributes::BlockUnrated::TypeInfo::DecodableType blockUnrated               = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace RemainingScreenTimeExpired {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RemainingScreenTimeExpired::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RemainingScreenTimeExpired::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace RemainingScreenTimeExpired
} // namespace Events
} // namespace ContentControl
namespace ContentAppObserver {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ContentAppMessage {
struct Type;
struct DecodableType;
} // namespace ContentAppMessage

namespace ContentAppMessageResponse {
struct Type;
struct DecodableType;
} // namespace ContentAppMessageResponse

} // namespace Commands

namespace Commands {
namespace ContentAppMessage {
enum class Fields : uint8_t
{
    kData         = 0,
    kEncodingHint = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    Optional<chip::CharSpan> data;
    chip::CharSpan encodingHint;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentAppObserver::Commands::ContentAppMessageResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    Optional<chip::CharSpan> data;
    chip::CharSpan encodingHint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ContentAppMessage
namespace ContentAppMessageResponse {
enum class Fields : uint8_t
{
    kStatus       = 0,
    kData         = 1,
    kEncodingHint = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    Optional<chip::CharSpan> encodingHint;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    Optional<chip::CharSpan> encodingHint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ContentAppMessageResponse
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ContentAppObserver
namespace ElectricalMeasurement {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetProfileInfoResponseCommand {
struct Type;
struct DecodableType;
} // namespace GetProfileInfoResponseCommand

namespace GetProfileInfoCommand {
struct Type;
struct DecodableType;
} // namespace GetProfileInfoCommand

namespace GetMeasurementProfileResponseCommand {
struct Type;
struct DecodableType;
} // namespace GetMeasurementProfileResponseCommand

namespace GetMeasurementProfileCommand {
struct Type;
struct DecodableType;
} // namespace GetMeasurementProfileCommand

} // namespace Commands

namespace Commands {
namespace GetProfileInfoResponseCommand {
enum class Fields : uint8_t
{
    kProfileCount          = 0,
    kProfileIntervalPeriod = 1,
    kMaxNumberOfIntervals  = 2,
    kListOfAttributes      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint8_t profileCount          = static_cast<uint8_t>(0);
    uint8_t profileIntervalPeriod = static_cast<uint8_t>(0);
    uint8_t maxNumberOfIntervals  = static_cast<uint8_t>(0);
    DataModel::List<const uint16_t> listOfAttributes;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint8_t profileCount          = static_cast<uint8_t>(0);
    uint8_t profileIntervalPeriod = static_cast<uint8_t>(0);
    uint8_t maxNumberOfIntervals  = static_cast<uint8_t>(0);
    DataModel::DecodableList<uint16_t> listOfAttributes;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProfileInfoResponseCommand
namespace GetProfileInfoCommand {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProfileInfoCommand
namespace GetMeasurementProfileResponseCommand {
enum class Fields : uint8_t
{
    kStartTime                  = 0,
    kStatus                     = 1,
    kProfileIntervalPeriod      = 2,
    kNumberOfIntervalsDelivered = 3,
    kAttributeId                = 4,
    kIntervals                  = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint32_t startTime                 = static_cast<uint32_t>(0);
    uint8_t status                     = static_cast<uint8_t>(0);
    uint8_t profileIntervalPeriod      = static_cast<uint8_t>(0);
    uint8_t numberOfIntervalsDelivered = static_cast<uint8_t>(0);
    uint16_t attributeId               = static_cast<uint16_t>(0);
    DataModel::List<const uint8_t> intervals;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint32_t startTime                 = static_cast<uint32_t>(0);
    uint8_t status                     = static_cast<uint8_t>(0);
    uint8_t profileIntervalPeriod      = static_cast<uint8_t>(0);
    uint8_t numberOfIntervalsDelivered = static_cast<uint8_t>(0);
    uint16_t attributeId               = static_cast<uint16_t>(0);
    DataModel::DecodableList<uint8_t> intervals;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMeasurementProfileResponseCommand
namespace GetMeasurementProfileCommand {
enum class Fields : uint8_t
{
    kAttributeId       = 0,
    kStartTime         = 1,
    kNumberOfIntervals = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint16_t attributeId      = static_cast<uint16_t>(0);
    uint32_t startTime        = static_cast<uint32_t>(0);
    uint8_t numberOfIntervals = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint16_t attributeId      = static_cast<uint16_t>(0);
    uint32_t startTime        = static_cast<uint32_t>(0);
    uint8_t numberOfIntervals = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMeasurementProfileCommand
} // namespace Commands

namespace Attributes {

namespace MeasurementType {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementType
namespace DcVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltage
namespace DcVoltageMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageMin
namespace DcVoltageMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageMax
namespace DcCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrent
namespace DcCurrentMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentMin
namespace DcCurrentMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentMax
namespace DcPower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPower
namespace DcPowerMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerMin
namespace DcPowerMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerMax
namespace DcVoltageMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageMultiplier
namespace DcVoltageDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageDivisor
namespace DcCurrentMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentMultiplier
namespace DcCurrentDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentDivisor
namespace DcPowerMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerMultiplier
namespace DcPowerDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerDivisor
namespace AcFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequency
namespace AcFrequencyMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyMin
namespace AcFrequencyMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyMax
namespace NeutralCurrent {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeutralCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeutralCurrent
namespace TotalActivePower {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalActivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalActivePower
namespace TotalReactivePower {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalReactivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalReactivePower
namespace TotalApparentPower {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalApparentPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalApparentPower
namespace Measured1stHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured1stHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured1stHarmonicCurrent
namespace Measured3rdHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured3rdHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured3rdHarmonicCurrent
namespace Measured5thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured5thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured5thHarmonicCurrent
namespace Measured7thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured7thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured7thHarmonicCurrent
namespace Measured9thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured9thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured9thHarmonicCurrent
namespace Measured11thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured11thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured11thHarmonicCurrent
namespace MeasuredPhase1stHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase1stHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase1stHarmonicCurrent
namespace MeasuredPhase3rdHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase3rdHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase3rdHarmonicCurrent
namespace MeasuredPhase5thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase5thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase5thHarmonicCurrent
namespace MeasuredPhase7thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase7thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase7thHarmonicCurrent
namespace MeasuredPhase9thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase9thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase9thHarmonicCurrent
namespace MeasuredPhase11thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase11thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase11thHarmonicCurrent
namespace AcFrequencyMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyMultiplier
namespace AcFrequencyDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyDivisor
namespace PowerMultiplier {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerMultiplier
namespace PowerDivisor {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerDivisor
namespace HarmonicCurrentMultiplier {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HarmonicCurrentMultiplier
namespace PhaseHarmonicCurrentMultiplier {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseHarmonicCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseHarmonicCurrentMultiplier
namespace InstantaneousVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousVoltage
namespace InstantaneousLineCurrent {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousLineCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousLineCurrent
namespace InstantaneousActiveCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousActiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousActiveCurrent
namespace InstantaneousReactiveCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousReactiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousReactiveCurrent
namespace InstantaneousPower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousPower
namespace RmsVoltage {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltage
namespace RmsVoltageMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMin
namespace RmsVoltageMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMax
namespace RmsCurrent {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrent
namespace RmsCurrentMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMin
namespace RmsCurrentMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMax
namespace ActivePower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePower
namespace ActivePowerMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMin
namespace ActivePowerMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMax
namespace ReactivePower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePower
namespace ApparentPower {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPower
namespace PowerFactor {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactor
namespace AverageRmsVoltageMeasurementPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsVoltageMeasurementPeriod
namespace AverageRmsUnderVoltageCounter {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounter::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltageCounter
namespace RmsExtremeOverVoltagePeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltagePeriod
namespace RmsExtremeUnderVoltagePeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltagePeriod
namespace RmsVoltageSagPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSagPeriod
namespace RmsVoltageSwellPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwellPeriod
namespace AcVoltageMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcVoltageMultiplier
namespace AcVoltageDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcVoltageDivisor
namespace AcCurrentMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCurrentMultiplier
namespace AcCurrentDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCurrentDivisor
namespace AcPowerMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcPowerMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcPowerMultiplier
namespace AcPowerDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcPowerDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcPowerDivisor
namespace OverloadAlarmsMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverloadAlarmsMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverloadAlarmsMask
namespace VoltageOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VoltageOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VoltageOverload
namespace CurrentOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentOverload
namespace AcOverloadAlarmsMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcOverloadAlarmsMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcOverloadAlarmsMask
namespace AcVoltageOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcVoltageOverload
namespace AcCurrentOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCurrentOverload
namespace AcActivePowerOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcActivePowerOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcActivePowerOverload
namespace AcReactivePowerOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcReactivePowerOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcReactivePowerOverload
namespace AverageRmsOverVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsOverVoltage
namespace AverageRmsUnderVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltage
namespace RmsExtremeOverVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltage
namespace RmsExtremeUnderVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltage
namespace RmsVoltageSag {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSag::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSag
namespace RmsVoltageSwell {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwell::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwell
namespace LineCurrentPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LineCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LineCurrentPhaseB
namespace ActiveCurrentPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCurrentPhaseB
namespace ReactiveCurrentPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactiveCurrentPhaseB
namespace RmsVoltagePhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltagePhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltagePhaseB
namespace RmsVoltageMinPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMinPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMinPhaseB
namespace RmsVoltageMaxPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMaxPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMaxPhaseB
namespace RmsCurrentPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentPhaseB
namespace RmsCurrentMinPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMinPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMinPhaseB
namespace RmsCurrentMaxPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMaxPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMaxPhaseB
namespace ActivePowerPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerPhaseB
namespace ActivePowerMinPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMinPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMinPhaseB
namespace ActivePowerMaxPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMaxPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMaxPhaseB
namespace ReactivePowerPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePowerPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePowerPhaseB
namespace ApparentPowerPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPowerPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPowerPhaseB
namespace PowerFactorPhaseB {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactorPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactorPhaseB
namespace AverageRmsVoltageMeasurementPeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsVoltageMeasurementPeriodPhaseB
namespace AverageRmsOverVoltageCounterPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltageCounterPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsOverVoltageCounterPhaseB
namespace AverageRmsUnderVoltageCounterPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounterPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltageCounterPhaseB
namespace RmsExtremeOverVoltagePeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltagePeriodPhaseB
namespace RmsExtremeUnderVoltagePeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltagePeriodPhaseB
namespace RmsVoltageSagPeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSagPeriodPhaseB
namespace RmsVoltageSwellPeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwellPeriodPhaseB
namespace LineCurrentPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LineCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LineCurrentPhaseC
namespace ActiveCurrentPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCurrentPhaseC
namespace ReactiveCurrentPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactiveCurrentPhaseC
namespace RmsVoltagePhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltagePhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltagePhaseC
namespace RmsVoltageMinPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMinPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMinPhaseC
namespace RmsVoltageMaxPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMaxPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMaxPhaseC
namespace RmsCurrentPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentPhaseC
namespace RmsCurrentMinPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMinPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMinPhaseC
namespace RmsCurrentMaxPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMaxPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMaxPhaseC
namespace ActivePowerPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerPhaseC
namespace ActivePowerMinPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMinPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMinPhaseC
namespace ActivePowerMaxPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMaxPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMaxPhaseC
namespace ReactivePowerPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePowerPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePowerPhaseC
namespace ApparentPowerPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPowerPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPowerPhaseC
namespace PowerFactorPhaseC {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactorPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactorPhaseC
namespace AverageRmsVoltageMeasurementPeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsVoltageMeasurementPeriodPhaseC
namespace AverageRmsOverVoltageCounterPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltageCounterPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsOverVoltageCounterPhaseC
namespace AverageRmsUnderVoltageCounterPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounterPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltageCounterPhaseC
namespace RmsExtremeOverVoltagePeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltagePeriodPhaseC
namespace RmsExtremeUnderVoltagePeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltagePeriodPhaseC
namespace RmsVoltageSagPeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSagPeriodPhaseC
namespace RmsVoltageSwellPeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwellPeriodPhaseC
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasurementType::TypeInfo::DecodableType measurementType                         = static_cast<uint32_t>(0);
        Attributes::DcVoltage::TypeInfo::DecodableType dcVoltage                                     = static_cast<int16_t>(0);
        Attributes::DcVoltageMin::TypeInfo::DecodableType dcVoltageMin                               = static_cast<int16_t>(0);
        Attributes::DcVoltageMax::TypeInfo::DecodableType dcVoltageMax                               = static_cast<int16_t>(0);
        Attributes::DcCurrent::TypeInfo::DecodableType dcCurrent                                     = static_cast<int16_t>(0);
        Attributes::DcCurrentMin::TypeInfo::DecodableType dcCurrentMin                               = static_cast<int16_t>(0);
        Attributes::DcCurrentMax::TypeInfo::DecodableType dcCurrentMax                               = static_cast<int16_t>(0);
        Attributes::DcPower::TypeInfo::DecodableType dcPower                                         = static_cast<int16_t>(0);
        Attributes::DcPowerMin::TypeInfo::DecodableType dcPowerMin                                   = static_cast<int16_t>(0);
        Attributes::DcPowerMax::TypeInfo::DecodableType dcPowerMax                                   = static_cast<int16_t>(0);
        Attributes::DcVoltageMultiplier::TypeInfo::DecodableType dcVoltageMultiplier                 = static_cast<uint16_t>(0);
        Attributes::DcVoltageDivisor::TypeInfo::DecodableType dcVoltageDivisor                       = static_cast<uint16_t>(0);
        Attributes::DcCurrentMultiplier::TypeInfo::DecodableType dcCurrentMultiplier                 = static_cast<uint16_t>(0);
        Attributes::DcCurrentDivisor::TypeInfo::DecodableType dcCurrentDivisor                       = static_cast<uint16_t>(0);
        Attributes::DcPowerMultiplier::TypeInfo::DecodableType dcPowerMultiplier                     = static_cast<uint16_t>(0);
        Attributes::DcPowerDivisor::TypeInfo::DecodableType dcPowerDivisor                           = static_cast<uint16_t>(0);
        Attributes::AcFrequency::TypeInfo::DecodableType acFrequency                                 = static_cast<uint16_t>(0);
        Attributes::AcFrequencyMin::TypeInfo::DecodableType acFrequencyMin                           = static_cast<uint16_t>(0);
        Attributes::AcFrequencyMax::TypeInfo::DecodableType acFrequencyMax                           = static_cast<uint16_t>(0);
        Attributes::NeutralCurrent::TypeInfo::DecodableType neutralCurrent                           = static_cast<uint16_t>(0);
        Attributes::TotalActivePower::TypeInfo::DecodableType totalActivePower                       = static_cast<int32_t>(0);
        Attributes::TotalReactivePower::TypeInfo::DecodableType totalReactivePower                   = static_cast<int32_t>(0);
        Attributes::TotalApparentPower::TypeInfo::DecodableType totalApparentPower                   = static_cast<uint32_t>(0);
        Attributes::Measured1stHarmonicCurrent::TypeInfo::DecodableType measured1stHarmonicCurrent   = static_cast<int16_t>(0);
        Attributes::Measured3rdHarmonicCurrent::TypeInfo::DecodableType measured3rdHarmonicCurrent   = static_cast<int16_t>(0);
        Attributes::Measured5thHarmonicCurrent::TypeInfo::DecodableType measured5thHarmonicCurrent   = static_cast<int16_t>(0);
        Attributes::Measured7thHarmonicCurrent::TypeInfo::DecodableType measured7thHarmonicCurrent   = static_cast<int16_t>(0);
        Attributes::Measured9thHarmonicCurrent::TypeInfo::DecodableType measured9thHarmonicCurrent   = static_cast<int16_t>(0);
        Attributes::Measured11thHarmonicCurrent::TypeInfo::DecodableType measured11thHarmonicCurrent = static_cast<int16_t>(0);
        Attributes::MeasuredPhase1stHarmonicCurrent::TypeInfo::DecodableType measuredPhase1stHarmonicCurrent =
            static_cast<int16_t>(0);
        Attributes::MeasuredPhase3rdHarmonicCurrent::TypeInfo::DecodableType measuredPhase3rdHarmonicCurrent =
            static_cast<int16_t>(0);
        Attributes::MeasuredPhase5thHarmonicCurrent::TypeInfo::DecodableType measuredPhase5thHarmonicCurrent =
            static_cast<int16_t>(0);
        Attributes::MeasuredPhase7thHarmonicCurrent::TypeInfo::DecodableType measuredPhase7thHarmonicCurrent =
            static_cast<int16_t>(0);
        Attributes::MeasuredPhase9thHarmonicCurrent::TypeInfo::DecodableType measuredPhase9thHarmonicCurrent =
            static_cast<int16_t>(0);
        Attributes::MeasuredPhase11thHarmonicCurrent::TypeInfo::DecodableType measuredPhase11thHarmonicCurrent =
            static_cast<int16_t>(0);
        Attributes::AcFrequencyMultiplier::TypeInfo::DecodableType acFrequencyMultiplier         = static_cast<uint16_t>(0);
        Attributes::AcFrequencyDivisor::TypeInfo::DecodableType acFrequencyDivisor               = static_cast<uint16_t>(0);
        Attributes::PowerMultiplier::TypeInfo::DecodableType powerMultiplier                     = static_cast<uint32_t>(0);
        Attributes::PowerDivisor::TypeInfo::DecodableType powerDivisor                           = static_cast<uint32_t>(0);
        Attributes::HarmonicCurrentMultiplier::TypeInfo::DecodableType harmonicCurrentMultiplier = static_cast<int8_t>(0);
        Attributes::PhaseHarmonicCurrentMultiplier::TypeInfo::DecodableType phaseHarmonicCurrentMultiplier = static_cast<int8_t>(0);
        Attributes::InstantaneousVoltage::TypeInfo::DecodableType instantaneousVoltage                 = static_cast<int16_t>(0);
        Attributes::InstantaneousLineCurrent::TypeInfo::DecodableType instantaneousLineCurrent         = static_cast<uint16_t>(0);
        Attributes::InstantaneousActiveCurrent::TypeInfo::DecodableType instantaneousActiveCurrent     = static_cast<int16_t>(0);
        Attributes::InstantaneousReactiveCurrent::TypeInfo::DecodableType instantaneousReactiveCurrent = static_cast<int16_t>(0);
        Attributes::InstantaneousPower::TypeInfo::DecodableType instantaneousPower                     = static_cast<int16_t>(0);
        Attributes::RmsVoltage::TypeInfo::DecodableType rmsVoltage                                     = static_cast<uint16_t>(0);
        Attributes::RmsVoltageMin::TypeInfo::DecodableType rmsVoltageMin                               = static_cast<uint16_t>(0);
        Attributes::RmsVoltageMax::TypeInfo::DecodableType rmsVoltageMax                               = static_cast<uint16_t>(0);
        Attributes::RmsCurrent::TypeInfo::DecodableType rmsCurrent                                     = static_cast<uint16_t>(0);
        Attributes::RmsCurrentMin::TypeInfo::DecodableType rmsCurrentMin                               = static_cast<uint16_t>(0);
        Attributes::RmsCurrentMax::TypeInfo::DecodableType rmsCurrentMax                               = static_cast<uint16_t>(0);
        Attributes::ActivePower::TypeInfo::DecodableType activePower                                   = static_cast<int16_t>(0);
        Attributes::ActivePowerMin::TypeInfo::DecodableType activePowerMin                             = static_cast<int16_t>(0);
        Attributes::ActivePowerMax::TypeInfo::DecodableType activePowerMax                             = static_cast<int16_t>(0);
        Attributes::ReactivePower::TypeInfo::DecodableType reactivePower                               = static_cast<int16_t>(0);
        Attributes::ApparentPower::TypeInfo::DecodableType apparentPower                               = static_cast<uint16_t>(0);
        Attributes::PowerFactor::TypeInfo::DecodableType powerFactor                                   = static_cast<int8_t>(0);
        Attributes::AverageRmsVoltageMeasurementPeriod::TypeInfo::DecodableType averageRmsVoltageMeasurementPeriod =
            static_cast<uint16_t>(0);
        Attributes::AverageRmsUnderVoltageCounter::TypeInfo::DecodableType averageRmsUnderVoltageCounter = static_cast<uint16_t>(0);
        Attributes::RmsExtremeOverVoltagePeriod::TypeInfo::DecodableType rmsExtremeOverVoltagePeriod     = static_cast<uint16_t>(0);
        Attributes::RmsExtremeUnderVoltagePeriod::TypeInfo::DecodableType rmsExtremeUnderVoltagePeriod   = static_cast<uint16_t>(0);
        Attributes::RmsVoltageSagPeriod::TypeInfo::DecodableType rmsVoltageSagPeriod                     = static_cast<uint16_t>(0);
        Attributes::RmsVoltageSwellPeriod::TypeInfo::DecodableType rmsVoltageSwellPeriod                 = static_cast<uint16_t>(0);
        Attributes::AcVoltageMultiplier::TypeInfo::DecodableType acVoltageMultiplier                     = static_cast<uint16_t>(0);
        Attributes::AcVoltageDivisor::TypeInfo::DecodableType acVoltageDivisor                           = static_cast<uint16_t>(0);
        Attributes::AcCurrentMultiplier::TypeInfo::DecodableType acCurrentMultiplier                     = static_cast<uint16_t>(0);
        Attributes::AcCurrentDivisor::TypeInfo::DecodableType acCurrentDivisor                           = static_cast<uint16_t>(0);
        Attributes::AcPowerMultiplier::TypeInfo::DecodableType acPowerMultiplier                         = static_cast<uint16_t>(0);
        Attributes::AcPowerDivisor::TypeInfo::DecodableType acPowerDivisor                               = static_cast<uint16_t>(0);
        Attributes::OverloadAlarmsMask::TypeInfo::DecodableType overloadAlarmsMask                       = static_cast<uint8_t>(0);
        Attributes::VoltageOverload::TypeInfo::DecodableType voltageOverload                             = static_cast<int16_t>(0);
        Attributes::CurrentOverload::TypeInfo::DecodableType currentOverload                             = static_cast<int16_t>(0);
        Attributes::AcOverloadAlarmsMask::TypeInfo::DecodableType acOverloadAlarmsMask                   = static_cast<uint16_t>(0);
        Attributes::AcVoltageOverload::TypeInfo::DecodableType acVoltageOverload                         = static_cast<int16_t>(0);
        Attributes::AcCurrentOverload::TypeInfo::DecodableType acCurrentOverload                         = static_cast<int16_t>(0);
        Attributes::AcActivePowerOverload::TypeInfo::DecodableType acActivePowerOverload                 = static_cast<int16_t>(0);
        Attributes::AcReactivePowerOverload::TypeInfo::DecodableType acReactivePowerOverload             = static_cast<int16_t>(0);
        Attributes::AverageRmsOverVoltage::TypeInfo::DecodableType averageRmsOverVoltage                 = static_cast<int16_t>(0);
        Attributes::AverageRmsUnderVoltage::TypeInfo::DecodableType averageRmsUnderVoltage               = static_cast<int16_t>(0);
        Attributes::RmsExtremeOverVoltage::TypeInfo::DecodableType rmsExtremeOverVoltage                 = static_cast<int16_t>(0);
        Attributes::RmsExtremeUnderVoltage::TypeInfo::DecodableType rmsExtremeUnderVoltage               = static_cast<int16_t>(0);
        Attributes::RmsVoltageSag::TypeInfo::DecodableType rmsVoltageSag                                 = static_cast<int16_t>(0);
        Attributes::RmsVoltageSwell::TypeInfo::DecodableType rmsVoltageSwell                             = static_cast<int16_t>(0);
        Attributes::LineCurrentPhaseB::TypeInfo::DecodableType lineCurrentPhaseB                         = static_cast<uint16_t>(0);
        Attributes::ActiveCurrentPhaseB::TypeInfo::DecodableType activeCurrentPhaseB                     = static_cast<int16_t>(0);
        Attributes::ReactiveCurrentPhaseB::TypeInfo::DecodableType reactiveCurrentPhaseB                 = static_cast<int16_t>(0);
        Attributes::RmsVoltagePhaseB::TypeInfo::DecodableType rmsVoltagePhaseB                           = static_cast<uint16_t>(0);
        Attributes::RmsVoltageMinPhaseB::TypeInfo::DecodableType rmsVoltageMinPhaseB                     = static_cast<uint16_t>(0);
        Attributes::RmsVoltageMaxPhaseB::TypeInfo::DecodableType rmsVoltageMaxPhaseB                     = static_cast<uint16_t>(0);
        Attributes::RmsCurrentPhaseB::TypeInfo::DecodableType rmsCurrentPhaseB                           = static_cast<uint16_t>(0);
        Attributes::RmsCurrentMinPhaseB::TypeInfo::DecodableType rmsCurrentMinPhaseB                     = static_cast<uint16_t>(0);
        Attributes::RmsCurrentMaxPhaseB::TypeInfo::DecodableType rmsCurrentMaxPhaseB                     = static_cast<uint16_t>(0);
        Attributes::ActivePowerPhaseB::TypeInfo::DecodableType activePowerPhaseB                         = static_cast<int16_t>(0);
        Attributes::ActivePowerMinPhaseB::TypeInfo::DecodableType activePowerMinPhaseB                   = static_cast<int16_t>(0);
        Attributes::ActivePowerMaxPhaseB::TypeInfo::DecodableType activePowerMaxPhaseB                   = static_cast<int16_t>(0);
        Attributes::ReactivePowerPhaseB::TypeInfo::DecodableType reactivePowerPhaseB                     = static_cast<int16_t>(0);
        Attributes::ApparentPowerPhaseB::TypeInfo::DecodableType apparentPowerPhaseB                     = static_cast<uint16_t>(0);
        Attributes::PowerFactorPhaseB::TypeInfo::DecodableType powerFactorPhaseB                         = static_cast<int8_t>(0);
        Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::TypeInfo::DecodableType averageRmsVoltageMeasurementPeriodPhaseB =
            static_cast<uint16_t>(0);
        Attributes::AverageRmsOverVoltageCounterPhaseB::TypeInfo::DecodableType averageRmsOverVoltageCounterPhaseB =
            static_cast<uint16_t>(0);
        Attributes::AverageRmsUnderVoltageCounterPhaseB::TypeInfo::DecodableType averageRmsUnderVoltageCounterPhaseB =
            static_cast<uint16_t>(0);
        Attributes::RmsExtremeOverVoltagePeriodPhaseB::TypeInfo::DecodableType rmsExtremeOverVoltagePeriodPhaseB =
            static_cast<uint16_t>(0);
        Attributes::RmsExtremeUnderVoltagePeriodPhaseB::TypeInfo::DecodableType rmsExtremeUnderVoltagePeriodPhaseB =
            static_cast<uint16_t>(0);
        Attributes::RmsVoltageSagPeriodPhaseB::TypeInfo::DecodableType rmsVoltageSagPeriodPhaseB     = static_cast<uint16_t>(0);
        Attributes::RmsVoltageSwellPeriodPhaseB::TypeInfo::DecodableType rmsVoltageSwellPeriodPhaseB = static_cast<uint16_t>(0);
        Attributes::LineCurrentPhaseC::TypeInfo::DecodableType lineCurrentPhaseC                     = static_cast<uint16_t>(0);
        Attributes::ActiveCurrentPhaseC::TypeInfo::DecodableType activeCurrentPhaseC                 = static_cast<int16_t>(0);
        Attributes::ReactiveCurrentPhaseC::TypeInfo::DecodableType reactiveCurrentPhaseC             = static_cast<int16_t>(0);
        Attributes::RmsVoltagePhaseC::TypeInfo::DecodableType rmsVoltagePhaseC                       = static_cast<uint16_t>(0);
        Attributes::RmsVoltageMinPhaseC::TypeInfo::DecodableType rmsVoltageMinPhaseC                 = static_cast<uint16_t>(0);
        Attributes::RmsVoltageMaxPhaseC::TypeInfo::DecodableType rmsVoltageMaxPhaseC                 = static_cast<uint16_t>(0);
        Attributes::RmsCurrentPhaseC::TypeInfo::DecodableType rmsCurrentPhaseC                       = static_cast<uint16_t>(0);
        Attributes::RmsCurrentMinPhaseC::TypeInfo::DecodableType rmsCurrentMinPhaseC                 = static_cast<uint16_t>(0);
        Attributes::RmsCurrentMaxPhaseC::TypeInfo::DecodableType rmsCurrentMaxPhaseC                 = static_cast<uint16_t>(0);
        Attributes::ActivePowerPhaseC::TypeInfo::DecodableType activePowerPhaseC                     = static_cast<int16_t>(0);
        Attributes::ActivePowerMinPhaseC::TypeInfo::DecodableType activePowerMinPhaseC               = static_cast<int16_t>(0);
        Attributes::ActivePowerMaxPhaseC::TypeInfo::DecodableType activePowerMaxPhaseC               = static_cast<int16_t>(0);
        Attributes::ReactivePowerPhaseC::TypeInfo::DecodableType reactivePowerPhaseC                 = static_cast<int16_t>(0);
        Attributes::ApparentPowerPhaseC::TypeInfo::DecodableType apparentPowerPhaseC                 = static_cast<uint16_t>(0);
        Attributes::PowerFactorPhaseC::TypeInfo::DecodableType powerFactorPhaseC                     = static_cast<int8_t>(0);
        Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::TypeInfo::DecodableType averageRmsVoltageMeasurementPeriodPhaseC =
            static_cast<uint16_t>(0);
        Attributes::AverageRmsOverVoltageCounterPhaseC::TypeInfo::DecodableType averageRmsOverVoltageCounterPhaseC =
            static_cast<uint16_t>(0);
        Attributes::AverageRmsUnderVoltageCounterPhaseC::TypeInfo::DecodableType averageRmsUnderVoltageCounterPhaseC =
            static_cast<uint16_t>(0);
        Attributes::RmsExtremeOverVoltagePeriodPhaseC::TypeInfo::DecodableType rmsExtremeOverVoltagePeriodPhaseC =
            static_cast<uint16_t>(0);
        Attributes::RmsExtremeUnderVoltagePeriodPhaseC::TypeInfo::DecodableType rmsExtremeUnderVoltagePeriodPhaseC =
            static_cast<uint16_t>(0);
        Attributes::RmsVoltageSagPeriodPhaseC::TypeInfo::DecodableType rmsVoltageSagPeriodPhaseC     = static_cast<uint16_t>(0);
        Attributes::RmsVoltageSwellPeriodPhaseC::TypeInfo::DecodableType rmsVoltageSwellPeriodPhaseC = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ElectricalMeasurement
namespace UnitTesting {
namespace Structs {
namespace SimpleStruct {
enum class Fields : uint8_t
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
    kE = 4,
    kF = 5,
    kG = 6,
    kH = 7,
};

struct Type
{
public:
    uint8_t a    = static_cast<uint8_t>(0);
    bool b       = static_cast<bool>(0);
    SimpleEnum c = static_cast<SimpleEnum>(0);
    chip::ByteSpan d;
    chip::CharSpan e;
    chip::BitMask<SimpleBitmap> f = static_cast<chip::BitMask<SimpleBitmap>>(0);
    float g                       = static_cast<float>(0);
    double h                      = static_cast<double>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SimpleStruct
namespace TestFabricScoped {
enum class Fields : uint8_t
{
    kFabricSensitiveInt8u                 = 1,
    kOptionalFabricSensitiveInt8u         = 2,
    kNullableFabricSensitiveInt8u         = 3,
    kNullableOptionalFabricSensitiveInt8u = 4,
    kFabricSensitiveCharString            = 5,
    kFabricSensitiveStruct                = 6,
    kFabricSensitiveInt8uList             = 7,
    kFabricIndex                          = 254,
};

struct Type
{
public:
    uint8_t fabricSensitiveInt8u = static_cast<uint8_t>(0);
    Optional<uint8_t> optionalFabricSensitiveInt8u;
    DataModel::Nullable<uint8_t> nullableFabricSensitiveInt8u;
    Optional<DataModel::Nullable<uint8_t>> nullableOptionalFabricSensitiveInt8u;
    chip::CharSpan fabricSensitiveCharString;
    Structs::SimpleStruct::Type fabricSensitiveStruct;
    DataModel::List<const uint8_t> fabricSensitiveInt8uList;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    uint8_t fabricSensitiveInt8u = static_cast<uint8_t>(0);
    Optional<uint8_t> optionalFabricSensitiveInt8u;
    DataModel::Nullable<uint8_t> nullableFabricSensitiveInt8u;
    Optional<DataModel::Nullable<uint8_t>> nullableOptionalFabricSensitiveInt8u;
    chip::CharSpan fabricSensitiveCharString;
    Structs::SimpleStruct::DecodableType fabricSensitiveStruct;
    DataModel::DecodableList<uint8_t> fabricSensitiveInt8uList;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace TestFabricScoped
namespace NullablesAndOptionalsStruct {
enum class Fields : uint8_t
{
    kNullableInt            = 0,
    kOptionalInt            = 1,
    kNullableOptionalInt    = 2,
    kNullableString         = 3,
    kOptionalString         = 4,
    kNullableOptionalString = 5,
    kNullableStruct         = 6,
    kOptionalStruct         = 7,
    kNullableOptionalStruct = 8,
    kNullableList           = 9,
    kOptionalList           = 10,
    kNullableOptionalList   = 11,
};

struct Type
{
public:
    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace NullablesAndOptionalsStruct
namespace NestedStruct {
enum class Fields : uint8_t
{
    kA = 0,
    kB = 1,
    kC = 2,
};

struct Type
{
public:
    uint8_t a = static_cast<uint8_t>(0);
    bool b    = static_cast<bool>(0);
    Structs::SimpleStruct::Type c;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace NestedStruct
namespace NestedStructList {
enum class Fields : uint8_t
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
    kE = 4,
    kF = 5,
    kG = 6,
};

struct Type
{
public:
    uint8_t a = static_cast<uint8_t>(0);
    bool b    = static_cast<bool>(0);
    Structs::SimpleStruct::Type c;
    DataModel::List<const Structs::SimpleStruct::Type> d;
    DataModel::List<const uint32_t> e;
    DataModel::List<const chip::ByteSpan> f;
    DataModel::List<const uint8_t> g;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint8_t a = static_cast<uint8_t>(0);
    bool b    = static_cast<bool>(0);
    Structs::SimpleStruct::DecodableType c;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> d;
    DataModel::DecodableList<uint32_t> e;
    DataModel::DecodableList<chip::ByteSpan> f;
    DataModel::DecodableList<uint8_t> g;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace NestedStructList
namespace DoubleNestedStructList {
enum class Fields : uint8_t
{
    kA = 0,
};

struct Type
{
public:
    DataModel::List<const Structs::NestedStructList::Type> a;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<Structs::NestedStructList::DecodableType> a;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace DoubleNestedStructList
namespace TestListStructOctet {
enum class Fields : uint8_t
{
    kMember1 = 0,
    kMember2 = 1,
};

struct Type
{
public:
    uint64_t member1 = static_cast<uint64_t>(0);
    chip::ByteSpan member2;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TestListStructOctet
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Test {
struct Type;
struct DecodableType;
} // namespace Test

namespace TestSpecificResponse {
struct Type;
struct DecodableType;
} // namespace TestSpecificResponse

namespace TestNotHandled {
struct Type;
struct DecodableType;
} // namespace TestNotHandled

namespace TestAddArgumentsResponse {
struct Type;
struct DecodableType;
} // namespace TestAddArgumentsResponse

namespace TestSpecific {
struct Type;
struct DecodableType;
} // namespace TestSpecific

namespace TestSimpleArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentResponse

namespace TestUnknownCommand {
struct Type;
struct DecodableType;
} // namespace TestUnknownCommand

namespace TestStructArrayArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentResponse

namespace TestAddArguments {
struct Type;
struct DecodableType;
} // namespace TestAddArguments

namespace TestListInt8UReverseResponse {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseResponse

namespace TestSimpleArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentRequest

namespace TestEnumsResponse {
struct Type;
struct DecodableType;
} // namespace TestEnumsResponse

namespace TestStructArrayArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentRequest

namespace TestNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalResponse

namespace TestStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArgumentRequest

namespace TestComplexNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalResponse

namespace TestNestedStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructArgumentRequest

namespace BooleanResponse {
struct Type;
struct DecodableType;
} // namespace BooleanResponse

namespace TestListStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListStructArgumentRequest

namespace SimpleStructResponse {
struct Type;
struct DecodableType;
} // namespace SimpleStructResponse

namespace TestListInt8UArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UArgumentRequest

namespace TestEmitTestEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventResponse

namespace TestNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructListArgumentRequest

namespace TestEmitTestFabricScopedEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestFabricScopedEventResponse

namespace TestListNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListNestedStructListArgumentRequest

namespace TestBatchHelperResponse {
struct Type;
struct DecodableType;
} // namespace TestBatchHelperResponse

namespace TestListInt8UReverseRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseRequest

namespace TestEnumsRequest {
struct Type;
struct DecodableType;
} // namespace TestEnumsRequest

namespace TestNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalRequest

namespace TestComplexNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalRequest

namespace SimpleStructEchoRequest {
struct Type;
struct DecodableType;
} // namespace SimpleStructEchoRequest

namespace TimedInvokeRequest {
struct Type;
struct DecodableType;
} // namespace TimedInvokeRequest

namespace TestSimpleOptionalArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleOptionalArgumentRequest

namespace TestEmitTestEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventRequest

namespace TestEmitTestFabricScopedEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestFabricScopedEventRequest

namespace TestBatchHelperRequest {
struct Type;
struct DecodableType;
} // namespace TestBatchHelperRequest

namespace TestSecondBatchHelperRequest {
struct Type;
struct DecodableType;
} // namespace TestSecondBatchHelperRequest

namespace TestDifferentVendorMeiRequest {
struct Type;
struct DecodableType;
} // namespace TestDifferentVendorMeiRequest

namespace TestDifferentVendorMeiResponse {
struct Type;
struct DecodableType;
} // namespace TestDifferentVendorMeiResponse

} // namespace Commands

namespace Commands {
namespace Test {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Test
namespace TestSpecificResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecificResponse
namespace TestNotHandled {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNotHandled
namespace TestAddArgumentsResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArgumentsResponse
namespace TestSpecific {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestSpecificResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecific
namespace TestSimpleArgumentResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool returnValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool returnValue = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentResponse
namespace TestUnknownCommand {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestUnknownCommand
namespace TestStructArrayArgumentResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentResponse
namespace TestAddArguments {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestAddArgumentsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArguments
namespace TestListInt8UReverseResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseResponse
namespace TestSimpleArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool arg1 = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestSimpleArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool arg1 = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentRequest
namespace TestEnumsResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsResponse
namespace TestStructArrayArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestStructArrayArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentRequest
namespace TestNullableOptionalResponse {
enum class Fields : uint8_t
{
    kWasPresent    = 0,
    kWasNull       = 1,
    kValue         = 2,
    kOriginalValue = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool wasPresent = static_cast<bool>(0);
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool wasPresent = static_cast<bool>(0);
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalResponse
namespace TestStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArgumentRequest
namespace TestComplexNullableOptionalResponse {
enum class Fields : uint8_t
{
    kNullableIntWasNull               = 0,
    kNullableIntValue                 = 1,
    kOptionalIntWasPresent            = 2,
    kOptionalIntValue                 = 3,
    kNullableOptionalIntWasPresent    = 4,
    kNullableOptionalIntWasNull       = 5,
    kNullableOptionalIntValue         = 6,
    kNullableStringWasNull            = 7,
    kNullableStringValue              = 8,
    kOptionalStringWasPresent         = 9,
    kOptionalStringValue              = 10,
    kNullableOptionalStringWasPresent = 11,
    kNullableOptionalStringWasNull    = 12,
    kNullableOptionalStringValue      = 13,
    kNullableStructWasNull            = 14,
    kNullableStructValue              = 15,
    kOptionalStructWasPresent         = 16,
    kOptionalStructValue              = 17,
    kNullableOptionalStructWasPresent = 18,
    kNullableOptionalStructWasNull    = 19,
    kNullableOptionalStructValue      = 20,
    kNullableListWasNull              = 21,
    kNullableListValue                = 22,
    kOptionalListWasPresent           = 23,
    kOptionalListValue                = 24,
    kNullableOptionalListWasPresent   = 25,
    kNullableOptionalListWasNull      = 26,
    kNullableOptionalListValue        = 27,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool nullableIntWasNull = static_cast<bool>(0);
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent = static_cast<bool>(0);
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull = static_cast<bool>(0);
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent = static_cast<bool>(0);
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::Type> nullableStructValue;
    bool optionalStructWasPresent = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::Type> optionalStructValue;
    bool nullableOptionalStructWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::Type> nullableOptionalStructValue;
    bool nullableListWasNull = static_cast<bool>(0);
    Optional<DataModel::List<const SimpleEnum>> nullableListValue;
    bool optionalListWasPresent = static_cast<bool>(0);
    Optional<DataModel::List<const SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::List<const SimpleEnum>> nullableOptionalListValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool nullableIntWasNull = static_cast<bool>(0);
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent = static_cast<bool>(0);
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull = static_cast<bool>(0);
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent = static_cast<bool>(0);
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::DecodableType> nullableStructValue;
    bool optionalStructWasPresent = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::DecodableType> optionalStructValue;
    bool nullableOptionalStructWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::DecodableType> nullableOptionalStructValue;
    bool nullableListWasNull = static_cast<bool>(0);
    Optional<DataModel::DecodableList<SimpleEnum>> nullableListValue;
    bool optionalListWasPresent = static_cast<bool>(0);
    Optional<DataModel::DecodableList<SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::DecodableList<SimpleEnum>> nullableOptionalListValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalResponse
namespace TestNestedStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructArgumentRequest
namespace BooleanResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool value = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool value = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BooleanResponse
namespace TestListStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::SimpleStruct::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListStructArgumentRequest
namespace SimpleStructResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructResponse
namespace TestListInt8UArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UArgumentRequest
namespace TestEmitTestEventResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventResponse
namespace TestNestedStructListArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStructList::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStructList::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructListArgumentRequest
namespace TestEmitTestFabricScopedEventResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestFabricScopedEventResponse
namespace TestListNestedStructListArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListNestedStructListArgumentRequest
namespace TestBatchHelperResponse {
enum class Fields : uint8_t
{
    kBuffer = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan buffer;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan buffer;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestBatchHelperResponse
namespace TestListInt8UReverseRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestListInt8UReverseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseRequest
namespace TestEnumsRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEnumsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsRequest
namespace TestNullableOptionalRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalRequest
namespace TestComplexNullableOptionalRequest {
enum class Fields : uint8_t
{
    kNullableInt            = 0,
    kOptionalInt            = 1,
    kNullableOptionalInt    = 2,
    kNullableString         = 3,
    kOptionalString         = 4,
    kNullableOptionalString = 5,
    kNullableStruct         = 6,
    kOptionalStruct         = 7,
    kNullableOptionalStruct = 8,
    kNullableList           = 9,
    kOptionalList           = 10,
    kNullableOptionalList   = 11,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestComplexNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalRequest
namespace SimpleStructEchoRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::SimpleStructResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructEchoRequest
namespace TimedInvokeRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimedInvokeRequest
namespace TestSimpleOptionalArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<bool> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<bool> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleOptionalArgumentRequest
namespace TestEmitTestEventRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEmitTestEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventRequest
namespace TestEmitTestFabricScopedEventRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEmitTestFabricScopedEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestFabricScopedEventRequest
namespace TestBatchHelperRequest {
enum class Fields : uint8_t
{
    kSleepBeforeResponseTimeMs = 0,
    kSizeOfResponseBuffer      = 1,
    kFillCharacter             = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestBatchHelperResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestBatchHelperRequest
namespace TestSecondBatchHelperRequest {
enum class Fields : uint8_t
{
    kSleepBeforeResponseTimeMs = 0,
    kSizeOfResponseBuffer      = 1,
    kFillCharacter             = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSecondBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestBatchHelperResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSecondBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSecondBatchHelperRequest
namespace TestDifferentVendorMeiRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestDifferentVendorMeiResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestDifferentVendorMeiRequest
namespace TestDifferentVendorMeiResponse {
enum class Fields : uint8_t
{
    kArg1        = 0,
    kEventNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1         = static_cast<uint8_t>(0);
    uint64_t eventNumber = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1         = static_cast<uint8_t>(0);
    uint64_t eventNumber = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestDifferentVendorMeiResponse
} // namespace Commands

namespace Attributes {

namespace Boolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Boolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Boolean
namespace Bitmap8 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap8
namespace Bitmap16 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap16
namespace Bitmap32 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap32::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap32
namespace Bitmap64 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap64::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap64
namespace Int8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int8u
namespace Int16u {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int16u
namespace Int24u {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int24u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int24u
namespace Int32u {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int32u
namespace Int40u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int40u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int40u
namespace Int48u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int48u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int48u
namespace Int56u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int56u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int56u
namespace Int64u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int64u
namespace Int8s {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int8s
namespace Int16s {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int16s
namespace Int24s {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int24s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int24s
namespace Int32s {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int32s
namespace Int40s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int40s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int40s
namespace Int48s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int48s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int48s
namespace Int56s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int56s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int56s
namespace Int64s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int64s
namespace Enum8 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enum8
namespace Enum16 {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enum16
namespace FloatSingle {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FloatSingle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FloatSingle
namespace FloatDouble {
struct TypeInfo
{
    using Type             = double;
    using DecodableType    = double;
    using DecodableArgType = double;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FloatDouble::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FloatDouble
namespace OctetString {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace OctetString
namespace ListInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListInt8u
namespace ListOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListOctetString
namespace ListStructOctetString {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::UnitTesting::Structs::TestListStructOctet::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestListStructOctet::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestListStructOctet::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListStructOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListStructOctetString
namespace LongOctetString {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 1000; }
};
} // namespace LongOctetString
namespace CharString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace CharString
namespace LongCharString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongCharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 1000; }
};
} // namespace LongCharString
namespace EpochUs {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochUs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EpochUs
namespace EpochS {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochS::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EpochS
namespace VendorId {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorId
namespace ListNullablesAndOptionalsStruct {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::UnitTesting::Structs::NullablesAndOptionalsStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::NullablesAndOptionalsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::UnitTesting::Structs::NullablesAndOptionalsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListNullablesAndOptionalsStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListNullablesAndOptionalsStruct
namespace EnumAttr {
struct TypeInfo
{
    using Type             = chip::app::Clusters::UnitTesting::SimpleEnum;
    using DecodableType    = chip::app::Clusters::UnitTesting::SimpleEnum;
    using DecodableArgType = chip::app::Clusters::UnitTesting::SimpleEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnumAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnumAttr
namespace StructAttr {
struct TypeInfo
{
    using Type             = chip::app::Clusters::UnitTesting::Structs::SimpleStruct::Type;
    using DecodableType    = chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StructAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StructAttr
namespace RangeRestrictedInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt8u
namespace RangeRestrictedInt8s {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt8s
namespace RangeRestrictedInt16u {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt16u
namespace RangeRestrictedInt16s {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt16s
namespace ListLongOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListLongOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListLongOctetString
namespace ListFabricScoped {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::UnitTesting::Structs::TestFabricScoped::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestFabricScoped::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestFabricScoped::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListFabricScoped::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListFabricScoped
namespace TimedWriteBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimedWriteBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return true; }
};
} // namespace TimedWriteBoolean
namespace GeneralErrorBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GeneralErrorBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GeneralErrorBoolean
namespace ClusterErrorBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterErrorBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterErrorBoolean
namespace Unsupported {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Unsupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Unsupported
namespace NullableBoolean {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBoolean
namespace NullableBitmap8 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap8
namespace NullableBitmap16 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap16
namespace NullableBitmap32 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap32::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap32
namespace NullableBitmap64 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap64::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap64
namespace NullableInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt8u
namespace NullableInt16u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt16u
namespace NullableInt24u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt24u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt24u
namespace NullableInt32u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt32u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt32u
namespace NullableInt40u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt40u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt40u
namespace NullableInt48u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt48u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt48u
namespace NullableInt56u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt56u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt56u
namespace NullableInt64u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt64u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt64u
namespace NullableInt8s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt8s
namespace NullableInt16s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt16s
namespace NullableInt24s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt24s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt24s
namespace NullableInt32s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt32s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt32s
namespace NullableInt40s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt40s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt40s
namespace NullableInt48s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt48s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt48s
namespace NullableInt56s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt56s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt56s
namespace NullableInt64s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt64s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt64s
namespace NullableEnum8 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnum8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnum8
namespace NullableEnum16 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnum16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnum16
namespace NullableFloatSingle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableFloatSingle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableFloatSingle
namespace NullableFloatDouble {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<double>;
    using DecodableType    = chip::app::DataModel::Nullable<double>;
    using DecodableArgType = const chip::app::DataModel::Nullable<double> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableFloatDouble::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableFloatDouble
namespace NullableOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace NullableOctetString
namespace NullableCharString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableCharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace NullableCharString
namespace NullableEnumAttr {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnumAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnumAttr
namespace NullableStruct {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::Structs::SimpleStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableStruct
namespace NullableRangeRestrictedInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt8u
namespace NullableRangeRestrictedInt8s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt8s
namespace NullableRangeRestrictedInt16u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt16u
namespace NullableRangeRestrictedInt16s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt16s
namespace WriteOnlyInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WriteOnlyInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WriteOnlyInt8u
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace ClusterRevision
namespace MeiInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeiInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeiInt8u

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Boolean::TypeInfo::DecodableType boolean = static_cast<bool>(0);
        Attributes::Bitmap8::TypeInfo::DecodableType bitmap8 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>>(0);
        Attributes::Bitmap16::TypeInfo::DecodableType bitmap16 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>>(0);
        Attributes::Bitmap32::TypeInfo::DecodableType bitmap32 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>>(0);
        Attributes::Bitmap64::TypeInfo::DecodableType bitmap64 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>>(0);
        Attributes::Int8u::TypeInfo::DecodableType int8u             = static_cast<uint8_t>(0);
        Attributes::Int16u::TypeInfo::DecodableType int16u           = static_cast<uint16_t>(0);
        Attributes::Int24u::TypeInfo::DecodableType int24u           = static_cast<uint32_t>(0);
        Attributes::Int32u::TypeInfo::DecodableType int32u           = static_cast<uint32_t>(0);
        Attributes::Int40u::TypeInfo::DecodableType int40u           = static_cast<uint64_t>(0);
        Attributes::Int48u::TypeInfo::DecodableType int48u           = static_cast<uint64_t>(0);
        Attributes::Int56u::TypeInfo::DecodableType int56u           = static_cast<uint64_t>(0);
        Attributes::Int64u::TypeInfo::DecodableType int64u           = static_cast<uint64_t>(0);
        Attributes::Int8s::TypeInfo::DecodableType int8s             = static_cast<int8_t>(0);
        Attributes::Int16s::TypeInfo::DecodableType int16s           = static_cast<int16_t>(0);
        Attributes::Int24s::TypeInfo::DecodableType int24s           = static_cast<int32_t>(0);
        Attributes::Int32s::TypeInfo::DecodableType int32s           = static_cast<int32_t>(0);
        Attributes::Int40s::TypeInfo::DecodableType int40s           = static_cast<int64_t>(0);
        Attributes::Int48s::TypeInfo::DecodableType int48s           = static_cast<int64_t>(0);
        Attributes::Int56s::TypeInfo::DecodableType int56s           = static_cast<int64_t>(0);
        Attributes::Int64s::TypeInfo::DecodableType int64s           = static_cast<int64_t>(0);
        Attributes::Enum8::TypeInfo::DecodableType enum8             = static_cast<uint8_t>(0);
        Attributes::Enum16::TypeInfo::DecodableType enum16           = static_cast<uint16_t>(0);
        Attributes::FloatSingle::TypeInfo::DecodableType floatSingle = static_cast<float>(0);
        Attributes::FloatDouble::TypeInfo::DecodableType floatDouble = static_cast<double>(0);
        Attributes::OctetString::TypeInfo::DecodableType octetString;
        Attributes::ListInt8u::TypeInfo::DecodableType listInt8u;
        Attributes::ListOctetString::TypeInfo::DecodableType listOctetString;
        Attributes::ListStructOctetString::TypeInfo::DecodableType listStructOctetString;
        Attributes::LongOctetString::TypeInfo::DecodableType longOctetString;
        Attributes::CharString::TypeInfo::DecodableType charString;
        Attributes::LongCharString::TypeInfo::DecodableType longCharString;
        Attributes::EpochUs::TypeInfo::DecodableType epochUs   = static_cast<uint64_t>(0);
        Attributes::EpochS::TypeInfo::DecodableType epochS     = static_cast<uint32_t>(0);
        Attributes::VendorId::TypeInfo::DecodableType vendorId = static_cast<chip::VendorId>(0);
        Attributes::ListNullablesAndOptionalsStruct::TypeInfo::DecodableType listNullablesAndOptionalsStruct;
        Attributes::EnumAttr::TypeInfo::DecodableType enumAttr = static_cast<chip::app::Clusters::UnitTesting::SimpleEnum>(0);
        Attributes::StructAttr::TypeInfo::DecodableType structAttr;
        Attributes::RangeRestrictedInt8u::TypeInfo::DecodableType rangeRestrictedInt8u   = static_cast<uint8_t>(0);
        Attributes::RangeRestrictedInt8s::TypeInfo::DecodableType rangeRestrictedInt8s   = static_cast<int8_t>(0);
        Attributes::RangeRestrictedInt16u::TypeInfo::DecodableType rangeRestrictedInt16u = static_cast<uint16_t>(0);
        Attributes::RangeRestrictedInt16s::TypeInfo::DecodableType rangeRestrictedInt16s = static_cast<int16_t>(0);
        Attributes::ListLongOctetString::TypeInfo::DecodableType listLongOctetString;
        Attributes::ListFabricScoped::TypeInfo::DecodableType listFabricScoped;
        Attributes::TimedWriteBoolean::TypeInfo::DecodableType timedWriteBoolean     = static_cast<bool>(0);
        Attributes::GeneralErrorBoolean::TypeInfo::DecodableType generalErrorBoolean = static_cast<bool>(0);
        Attributes::ClusterErrorBoolean::TypeInfo::DecodableType clusterErrorBoolean = static_cast<bool>(0);
        Attributes::Unsupported::TypeInfo::DecodableType unsupported                 = static_cast<bool>(0);
        Attributes::NullableBoolean::TypeInfo::DecodableType nullableBoolean;
        Attributes::NullableBitmap8::TypeInfo::DecodableType nullableBitmap8;
        Attributes::NullableBitmap16::TypeInfo::DecodableType nullableBitmap16;
        Attributes::NullableBitmap32::TypeInfo::DecodableType nullableBitmap32;
        Attributes::NullableBitmap64::TypeInfo::DecodableType nullableBitmap64;
        Attributes::NullableInt8u::TypeInfo::DecodableType nullableInt8u;
        Attributes::NullableInt16u::TypeInfo::DecodableType nullableInt16u;
        Attributes::NullableInt24u::TypeInfo::DecodableType nullableInt24u;
        Attributes::NullableInt32u::TypeInfo::DecodableType nullableInt32u;
        Attributes::NullableInt40u::TypeInfo::DecodableType nullableInt40u;
        Attributes::NullableInt48u::TypeInfo::DecodableType nullableInt48u;
        Attributes::NullableInt56u::TypeInfo::DecodableType nullableInt56u;
        Attributes::NullableInt64u::TypeInfo::DecodableType nullableInt64u;
        Attributes::NullableInt8s::TypeInfo::DecodableType nullableInt8s;
        Attributes::NullableInt16s::TypeInfo::DecodableType nullableInt16s;
        Attributes::NullableInt24s::TypeInfo::DecodableType nullableInt24s;
        Attributes::NullableInt32s::TypeInfo::DecodableType nullableInt32s;
        Attributes::NullableInt40s::TypeInfo::DecodableType nullableInt40s;
        Attributes::NullableInt48s::TypeInfo::DecodableType nullableInt48s;
        Attributes::NullableInt56s::TypeInfo::DecodableType nullableInt56s;
        Attributes::NullableInt64s::TypeInfo::DecodableType nullableInt64s;
        Attributes::NullableEnum8::TypeInfo::DecodableType nullableEnum8;
        Attributes::NullableEnum16::TypeInfo::DecodableType nullableEnum16;
        Attributes::NullableFloatSingle::TypeInfo::DecodableType nullableFloatSingle;
        Attributes::NullableFloatDouble::TypeInfo::DecodableType nullableFloatDouble;
        Attributes::NullableOctetString::TypeInfo::DecodableType nullableOctetString;
        Attributes::NullableCharString::TypeInfo::DecodableType nullableCharString;
        Attributes::NullableEnumAttr::TypeInfo::DecodableType nullableEnumAttr;
        Attributes::NullableStruct::TypeInfo::DecodableType nullableStruct;
        Attributes::NullableRangeRestrictedInt8u::TypeInfo::DecodableType nullableRangeRestrictedInt8u;
        Attributes::NullableRangeRestrictedInt8s::TypeInfo::DecodableType nullableRangeRestrictedInt8s;
        Attributes::NullableRangeRestrictedInt16u::TypeInfo::DecodableType nullableRangeRestrictedInt16u;
        Attributes::NullableRangeRestrictedInt16s::TypeInfo::DecodableType nullableRangeRestrictedInt16s;
        Attributes::WriteOnlyInt8u::TypeInfo::DecodableType writeOnlyInt8u = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
        Attributes::MeiInt8u::TypeInfo::DecodableType meiInt8u               = static_cast<uint8_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace TestEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kArg1 = 1,
    kArg2 = 2,
    kArg3 = 3,
    kArg4 = 4,
    kArg5 = 5,
    kArg6 = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);
    Structs::SimpleStruct::Type arg4;
    DataModel::List<const Structs::SimpleStruct::Type> arg5;
    DataModel::List<const SimpleEnum> arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);
    Structs::SimpleStruct::DecodableType arg4;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg5;
    DataModel::DecodableList<SimpleEnum> arg6;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestEvent
namespace TestFabricScopedEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kFabricIndex = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestFabricScopedEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestFabricScopedEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestFabricScopedEvent
namespace TestDifferentVendorMeiEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kArg1 = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestDifferentVendorMeiEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestDifferentVendorMeiEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestDifferentVendorMeiEvent
} // namespace Events
} // namespace UnitTesting
namespace FaultInjection {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace FailAtFault {
struct Type;
struct DecodableType;
} // namespace FailAtFault

namespace FailRandomlyAtFault {
struct Type;
struct DecodableType;
} // namespace FailRandomlyAtFault

} // namespace Commands

namespace Commands {
namespace FailAtFault {
enum class Fields : uint8_t
{
    kType           = 0,
    kId             = 1,
    kNumCallsToSkip = 2,
    kNumCallsToFail = 3,
    kTakeMutex      = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FailAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type          = static_cast<FaultType>(0);
    uint32_t id             = static_cast<uint32_t>(0);
    uint32_t numCallsToSkip = static_cast<uint32_t>(0);
    uint32_t numCallsToFail = static_cast<uint32_t>(0);
    bool takeMutex          = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FailAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type          = static_cast<FaultType>(0);
    uint32_t id             = static_cast<uint32_t>(0);
    uint32_t numCallsToSkip = static_cast<uint32_t>(0);
    uint32_t numCallsToFail = static_cast<uint32_t>(0);
    bool takeMutex          = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FailAtFault
namespace FailRandomlyAtFault {
enum class Fields : uint8_t
{
    kType       = 0,
    kId         = 1,
    kPercentage = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FailRandomlyAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type     = static_cast<FaultType>(0);
    uint32_t id        = static_cast<uint32_t>(0);
    uint8_t percentage = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FailRandomlyAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type     = static_cast<FaultType>(0);
    uint32_t id        = static_cast<uint32_t>(0);
    uint8_t percentage = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FailRandomlyAtFault
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FaultInjection
namespace SampleMei {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Ping {
struct Type;
struct DecodableType;
} // namespace Ping

namespace AddArgumentsResponse {
struct Type;
struct DecodableType;
} // namespace AddArgumentsResponse

namespace AddArguments {
struct Type;
struct DecodableType;
} // namespace AddArguments

} // namespace Commands

namespace Commands {
namespace Ping {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Ping::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Ping::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Ping
namespace AddArgumentsResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddArgumentsResponse
namespace AddArguments {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::SampleMei::Commands::AddArgumentsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddArguments
} // namespace Commands

namespace Attributes {

namespace FlipFlop {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FlipFlop::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FlipFlop
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace AcceptedCommandList
namespace EventList {
struct TypeInfo : public Clusters::Globals::Attributes::EventList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace EventList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::FlipFlop::TypeInfo::DecodableType flipFlop = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::EventList::TypeInfo::DecodableType eventList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace PingCountEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCount       = 1,
    kFabricIndex = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PingCountEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
    static constexpr bool kIsFabricScoped = true;

    uint32_t count                = static_cast<uint32_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PingCountEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint32_t count                = static_cast<uint32_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PingCountEvent
} // namespace Events
} // namespace SampleMei

} // namespace Clusters

bool CommandNeedsTimedInvoke(ClusterId aCluster, CommandId aCommand);
bool CommandIsFabricScoped(ClusterId aCluster, CommandId aCommand);

} // namespace app
} // namespace chip
