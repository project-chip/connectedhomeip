/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app-common/zap-generated/enums.h>
#include <app-common/zap-generated/ids/Attributes.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/util/basic-types.h>
#include <lib/support/BitFlags.h>
#include <protocols/interaction_model/Constants.h>

namespace chip {
namespace app {
namespace Clusters {

namespace PowerConfiguration {

namespace Attributes {
namespace MainsVoltage {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltage::Id; }
};
} // namespace MainsVoltage
namespace MainsFrequency {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsFrequency::Id; }
};
} // namespace MainsFrequency
namespace MainsAlarmMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsAlarmMask::Id; }
};
} // namespace MainsAlarmMask
namespace MainsVoltageMinThreshold {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltageMinThreshold::Id; }
};
} // namespace MainsVoltageMinThreshold
namespace MainsVoltageMaxThreshold {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltageMaxThreshold::Id; }
};
} // namespace MainsVoltageMaxThreshold
namespace MainsVoltageDwellTrip {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltageDwellTrip::Id; }
};
} // namespace MainsVoltageDwellTrip
namespace BatteryVoltage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltage::Id; }
};
} // namespace BatteryVoltage
namespace BatteryPercentageRemaining {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageRemaining::Id; }
};
} // namespace BatteryPercentageRemaining
namespace BatteryManufacturer {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryManufacturer::Id; }
};
} // namespace BatteryManufacturer
namespace BatterySize {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatterySize::Id; }
};
} // namespace BatterySize
namespace BatteryAhrRating {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAhrRating::Id; }
};
} // namespace BatteryAhrRating
namespace BatteryQuantity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryQuantity::Id; }
};
} // namespace BatteryQuantity
namespace BatteryRatedVoltage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryRatedVoltage::Id; }
};
} // namespace BatteryRatedVoltage
namespace BatteryAlarmMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAlarmMask::Id; }
};
} // namespace BatteryAlarmMask
namespace BatteryVoltageMinThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageMinThreshold::Id; }
};
} // namespace BatteryVoltageMinThreshold
namespace BatteryVoltageThreshold1 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageThreshold1::Id; }
};
} // namespace BatteryVoltageThreshold1
namespace BatteryVoltageThreshold2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageThreshold2::Id; }
};
} // namespace BatteryVoltageThreshold2
namespace BatteryVoltageThreshold3 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageThreshold3::Id; }
};
} // namespace BatteryVoltageThreshold3
namespace BatteryPercentageMinThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageMinThreshold::Id; }
};
} // namespace BatteryPercentageMinThreshold
namespace BatteryPercentageThreshold1 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageThreshold1::Id; }
};
} // namespace BatteryPercentageThreshold1
namespace BatteryPercentageThreshold2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageThreshold2::Id; }
};
} // namespace BatteryPercentageThreshold2
namespace BatteryPercentageThreshold3 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageThreshold3::Id; }
};
} // namespace BatteryPercentageThreshold3
namespace BatteryAlarmState {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAlarmState::Id; }
};
} // namespace BatteryAlarmState
namespace Battery2Voltage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Voltage::Id; }
};
} // namespace Battery2Voltage
namespace Battery2PercentageRemaining {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageRemaining::Id; }
};
} // namespace Battery2PercentageRemaining
namespace Battery2Manufacturer {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Manufacturer::Id; }
};
} // namespace Battery2Manufacturer
namespace Battery2Size {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Size::Id; }
};
} // namespace Battery2Size
namespace Battery2AhrRating {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2AhrRating::Id; }
};
} // namespace Battery2AhrRating
namespace Battery2Quantity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Quantity::Id; }
};
} // namespace Battery2Quantity
namespace Battery2RatedVoltage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2RatedVoltage::Id; }
};
} // namespace Battery2RatedVoltage
namespace Battery2AlarmMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2AlarmMask::Id; }
};
} // namespace Battery2AlarmMask
namespace Battery2VoltageMinThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageMinThreshold::Id; }
};
} // namespace Battery2VoltageMinThreshold
namespace Battery2VoltageThreshold1 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageThreshold1::Id; }
};
} // namespace Battery2VoltageThreshold1
namespace Battery2VoltageThreshold2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageThreshold2::Id; }
};
} // namespace Battery2VoltageThreshold2
namespace Battery2VoltageThreshold3 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageThreshold3::Id; }
};
} // namespace Battery2VoltageThreshold3
namespace Battery2PercentageMinThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageMinThreshold::Id; }
};
} // namespace Battery2PercentageMinThreshold
namespace Battery2PercentageThreshold1 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageThreshold1::Id; }
};
} // namespace Battery2PercentageThreshold1
namespace Battery2PercentageThreshold2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageThreshold2::Id; }
};
} // namespace Battery2PercentageThreshold2
namespace Battery2PercentageThreshold3 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageThreshold3::Id; }
};
} // namespace Battery2PercentageThreshold3
namespace Battery2AlarmState {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2AlarmState::Id; }
};
} // namespace Battery2AlarmState
namespace Battery3Voltage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Voltage::Id; }
};
} // namespace Battery3Voltage
namespace Battery3PercentageRemaining {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageRemaining::Id; }
};
} // namespace Battery3PercentageRemaining
namespace Battery3Manufacturer {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Manufacturer::Id; }
};
} // namespace Battery3Manufacturer
namespace Battery3Size {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Size::Id; }
};
} // namespace Battery3Size
namespace Battery3AhrRating {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3AhrRating::Id; }
};
} // namespace Battery3AhrRating
namespace Battery3Quantity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Quantity::Id; }
};
} // namespace Battery3Quantity
namespace Battery3RatedVoltage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3RatedVoltage::Id; }
};
} // namespace Battery3RatedVoltage
namespace Battery3AlarmMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3AlarmMask::Id; }
};
} // namespace Battery3AlarmMask
namespace Battery3VoltageMinThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageMinThreshold::Id; }
};
} // namespace Battery3VoltageMinThreshold
namespace Battery3VoltageThreshold1 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageThreshold1::Id; }
};
} // namespace Battery3VoltageThreshold1
namespace Battery3VoltageThreshold2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageThreshold2::Id; }
};
} // namespace Battery3VoltageThreshold2
namespace Battery3VoltageThreshold3 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageThreshold3::Id; }
};
} // namespace Battery3VoltageThreshold3
namespace Battery3PercentageMinThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageMinThreshold::Id; }
};
} // namespace Battery3PercentageMinThreshold
namespace Battery3PercentageThreshold1 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageThreshold1::Id; }
};
} // namespace Battery3PercentageThreshold1
namespace Battery3PercentageThreshold2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageThreshold2::Id; }
};
} // namespace Battery3PercentageThreshold2
namespace Battery3PercentageThreshold3 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageThreshold3::Id; }
};
} // namespace Battery3PercentageThreshold3
namespace Battery3AlarmState {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3AlarmState::Id; }
};
} // namespace Battery3AlarmState
} // namespace Attributes
} // namespace PowerConfiguration
namespace DeviceTemperatureConfiguration {

namespace Attributes {
namespace CurrentTemperature {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentTemperature::Id; }
};
} // namespace CurrentTemperature
namespace MinTempExperienced {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinTempExperienced::Id; }
};
} // namespace MinTempExperienced
namespace MaxTempExperienced {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxTempExperienced::Id; }
};
} // namespace MaxTempExperienced
namespace OverTempTotalDwell {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverTempTotalDwell::Id; }
};
} // namespace OverTempTotalDwell
namespace DeviceTempAlarmMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceTempAlarmMask::Id; }
};
} // namespace DeviceTempAlarmMask
namespace LowTempThreshold {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LowTempThreshold::Id; }
};
} // namespace LowTempThreshold
namespace HighTempThreshold {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HighTempThreshold::Id; }
};
} // namespace HighTempThreshold
namespace LowTempDwellTripPoint {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LowTempDwellTripPoint::Id; }
};
} // namespace LowTempDwellTripPoint
namespace HighTempDwellTripPoint {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HighTempDwellTripPoint::Id; }
};
} // namespace HighTempDwellTripPoint
} // namespace Attributes
} // namespace DeviceTemperatureConfiguration
namespace Identify {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IdentifyEffectIdentifier
enum class IdentifyEffectIdentifier : uint8_t
{
    kBlink         = 0x00,
    kBreathe       = 0x01,
    kOkay          = 0x02,
    kChannelChange = 0x0B,
    kFinishEffect  = 0xFE,
    kStopEffect    = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IdentifyEffectIdentifier             = EmberAfIdentifyEffectIdentifier;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IdentifyEffectVariant
enum class IdentifyEffectVariant : uint8_t
{
    kDefault = 0x00,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IdentifyEffectVariant                = EmberAfIdentifyEffectVariant;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IdentifyIdentifyType
enum class IdentifyIdentifyType : uint8_t
{
    kNone         = 0x00,
    kVisibleLight = 0x01,
    kVisibleLED   = 0x02,
    kAudibleBeep  = 0x03,
    kDisplay      = 0x04,
    kActuator     = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IdentifyIdentifyType                 = EmberAfIdentifyIdentifyType;
#endif

namespace Commands {
namespace Identify {
enum class Fields
{
    kIdentifyTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    uint16_t identifyTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    uint16_t identifyTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Identify
namespace IdentifyQueryResponse {
enum class Fields
{
    kTimeout = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return IdentifyQueryResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    uint16_t timeout;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return IdentifyQueryResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    uint16_t timeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace IdentifyQueryResponse
namespace IdentifyQuery {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return IdentifyQuery::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return IdentifyQuery::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace IdentifyQuery
namespace TriggerEffect {
enum class Fields
{
    kEffectIdentifier = 0,
    kEffectVariant    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    IdentifyEffectIdentifier effectIdentifier;
    IdentifyEffectVariant effectVariant;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Identify::Id; }

    IdentifyEffectIdentifier effectIdentifier;
    IdentifyEffectVariant effectVariant;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TriggerEffect
} // namespace Commands

namespace Attributes {
namespace IdentifyTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyTime::Id; }
};
} // namespace IdentifyTime
namespace IdentifyType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyType::Id; }
};
} // namespace IdentifyType
} // namespace Attributes
} // namespace Identify
namespace Groups {

namespace Commands {
namespace AddGroup {
enum class Fields
{
    kGroupId   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;
    chip::Span<const char> groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;
    chip::Span<const char> groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroup
namespace AddGroupResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t status;
    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupResponse
namespace ViewGroup {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroup
namespace ViewGroupResponse {
enum class Fields
{
    kStatus    = 0,
    kGroupId   = 1,
    kGroupName = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    chip::Span<const char> groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    chip::Span<const char> groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroupResponse
namespace GetGroupMembership {
enum class Fields
{
    kGroupCount = 0,
    kGroupList  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t groupCount;
    DataModel::List<uint16_t> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t groupCount;
    DataModel::DecodableList<uint16_t> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembership
namespace GetGroupMembershipResponse {
enum class Fields
{
    kCapacity   = 0,
    kGroupCount = 1,
    kGroupList  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t capacity;
    uint8_t groupCount;
    DataModel::List<uint16_t> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t capacity;
    uint8_t groupCount;
    DataModel::DecodableList<uint16_t> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembershipResponse
namespace RemoveGroup {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroup
namespace RemoveGroupResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t status;
    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroupResponse
namespace RemoveAllGroups {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllGroups
namespace AddGroupIfIdentifying {
enum class Fields
{
    kGroupId   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;
    chip::Span<const char> groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Groups::Id; }

    uint16_t groupId;
    chip::Span<const char> groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupIfIdentifying
} // namespace Commands

namespace Attributes {
namespace NameSupport {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NameSupport::Id; }
};
} // namespace NameSupport
} // namespace Attributes
} // namespace Groups
namespace Scenes {

// Bitmap for ScenesCopyMode
enum class ScenesCopyMode : uint8_t
{
    kCopyAllScenes = 0,
};

namespace Structs {
namespace SceneExtensionFieldSet {
enum class Fields
{
    kClusterId = 0,
    kLength    = 1,
    kValue     = 2,
};

struct Type
{
public:
    chip::ClusterId clusterId;
    uint8_t length;
    uint8_t value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SceneExtensionFieldSet
} // namespace Structs

namespace Commands {
namespace AddScene {
enum class Fields
{
    kGroupId            = 0,
    kSceneId            = 1,
    kTransitionTime     = 2,
    kSceneName          = 3,
    kExtensionFieldSets = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::List<Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddScene
namespace AddSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddSceneResponse
namespace ViewScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewScene
namespace ViewSceneResponse {
enum class Fields
{
    kStatus             = 0,
    kGroupId            = 1,
    kSceneId            = 2,
    kTransitionTime     = 3,
    kSceneName          = 4,
    kExtensionFieldSets = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::List<Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewSceneResponse
namespace RemoveScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveScene
namespace RemoveSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveSceneResponse
namespace RemoveAllScenes {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenes
namespace RemoveAllScenesResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenesResponse
namespace StoreScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreScene
namespace StoreSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreSceneResponse
namespace RecallScene {
enum class Fields
{
    kGroupId        = 0,
    kSceneId        = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RecallScene
namespace GetSceneMembership {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembership
namespace GetSceneMembershipResponse {
enum class Fields
{
    kStatus     = 0,
    kCapacity   = 1,
    kGroupId    = 2,
    kSceneCount = 3,
    kSceneList  = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint8_t capacity;
    uint16_t groupId;
    uint8_t sceneCount;
    DataModel::List<uint8_t> sceneList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint8_t capacity;
    uint16_t groupId;
    uint8_t sceneCount;
    DataModel::DecodableList<uint8_t> sceneList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembershipResponse
namespace EnhancedAddScene {
enum class Fields
{
    kGroupId            = 0,
    kSceneId            = 1,
    kTransitionTime     = 2,
    kSceneName          = 3,
    kExtensionFieldSets = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedAddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::List<Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedAddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedAddScene
namespace EnhancedAddSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedAddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedAddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedAddSceneResponse
namespace EnhancedViewScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedViewScene
namespace EnhancedViewSceneResponse {
enum class Fields
{
    kStatus             = 0,
    kGroupId            = 1,
    kSceneId            = 2,
    kTransitionTime     = 3,
    kSceneName          = 4,
    kExtensionFieldSets = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::List<Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::Span<const char> sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedViewSceneResponse
namespace CopyScene {
enum class Fields
{
    kMode        = 0,
    kGroupIdFrom = 1,
    kSceneIdFrom = 2,
    kGroupIdTo   = 3,
    kSceneIdTo   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    BitFlags<ScenesCopyMode> mode;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;
    uint16_t groupIdTo;
    uint8_t sceneIdTo;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    BitFlags<ScenesCopyMode> mode;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;
    uint16_t groupIdTo;
    uint8_t sceneIdTo;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopyScene
namespace CopySceneResponse {
enum class Fields
{
    kStatus      = 0,
    kGroupIdFrom = 1,
    kSceneIdFrom = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Scenes::Id; }

    uint8_t status;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopySceneResponse
} // namespace Commands

namespace Attributes {
namespace SceneCount {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SceneCount::Id; }
};
} // namespace SceneCount
namespace CurrentScene {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentScene::Id; }
};
} // namespace CurrentScene
namespace CurrentGroup {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentGroup::Id; }
};
} // namespace CurrentGroup
namespace SceneValid {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SceneValid::Id; }
};
} // namespace SceneValid
namespace NameSupport {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NameSupport::Id; }
};
} // namespace NameSupport
namespace LastConfiguredBy {
struct TypeInfo
{
    using Type          = chip::NodeId;
    using DecodableType = chip::NodeId;

    static constexpr ClusterId GetClusterId() { return Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConfiguredBy::Id; }
};
} // namespace LastConfiguredBy
} // namespace Attributes
} // namespace Scenes
namespace OnOff {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OnOffDelayedAllOffEffectVariant
enum class OnOffDelayedAllOffEffectVariant : uint8_t
{
    kFadeToOffIn0p8Seconds                                = 0x00,
    kNoFade                                               = 0x01,
    k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OnOffDelayedAllOffEffectVariant      = EmberAfOnOffDelayedAllOffEffectVariant;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OnOffDyingLightEffectVariant
enum class OnOffDyingLightEffectVariant : uint8_t
{
    k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second = 0x00,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OnOffDyingLightEffectVariant         = EmberAfOnOffDyingLightEffectVariant;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OnOffEffectIdentifier
enum class OnOffEffectIdentifier : uint8_t
{
    kDelayedAllOff = 0x00,
    kDyingLight    = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OnOffEffectIdentifier                = EmberAfOnOffEffectIdentifier;
#endif

// Bitmap for OnOffControl
enum class OnOffControl : uint8_t
{
    kAcceptOnlyWhenOn = 0,
};

namespace Commands {
namespace Off {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Off::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Off::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Off
namespace SampleMfgSpecificOffWithTransition {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificOffWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificOffWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SampleMfgSpecificOffWithTransition
namespace On {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return On::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return On::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace On
namespace SampleMfgSpecificOnWithTransition {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificOnWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificOnWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SampleMfgSpecificOnWithTransition
namespace SampleMfgSpecificOnWithTransition2 {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificOnWithTransition2::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificOnWithTransition2::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SampleMfgSpecificOnWithTransition2
namespace Toggle {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Toggle
namespace SampleMfgSpecificToggleWithTransition {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificToggleWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificToggleWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SampleMfgSpecificToggleWithTransition
namespace SampleMfgSpecificToggleWithTransition2 {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificToggleWithTransition2::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SampleMfgSpecificToggleWithTransition2::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SampleMfgSpecificToggleWithTransition2
namespace OffWithEffect {
enum class Fields
{
    kEffectId      = 0,
    kEffectVariant = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    OnOffEffectIdentifier effectId;
    OnOffDelayedAllOffEffectVariant effectVariant;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    OnOffEffectIdentifier effectId;
    OnOffDelayedAllOffEffectVariant effectVariant;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OffWithEffect
namespace OnWithRecallGlobalScene {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithRecallGlobalScene
namespace OnWithTimedOff {
enum class Fields
{
    kOnOffControl = 0,
    kOnTime       = 1,
    kOffWaitTime  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    BitFlags<OnOffControl> onOffControl;
    uint16_t onTime;
    uint16_t offWaitTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return OnOff::Id; }

    BitFlags<OnOffControl> onOffControl;
    uint16_t onTime;
    uint16_t offWaitTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithTimedOff
} // namespace Commands

namespace Attributes {
namespace OnOff {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOff::Id; }
};
} // namespace OnOff
namespace SampleMfgSpecificAttribute0x00000x1002 {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SampleMfgSpecificAttribute0x00000x1002::Id; }
};
} // namespace SampleMfgSpecificAttribute0x00000x1002
namespace SampleMfgSpecificAttribute0x00000x1049 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SampleMfgSpecificAttribute0x00000x1049::Id; }
};
} // namespace SampleMfgSpecificAttribute0x00000x1049
namespace SampleMfgSpecificAttribute0x00010x1002 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SampleMfgSpecificAttribute0x00010x1002::Id; }
};
} // namespace SampleMfgSpecificAttribute0x00010x1002
namespace SampleMfgSpecificAttribute0x00010x1040 {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SampleMfgSpecificAttribute0x00010x1040::Id; }
};
} // namespace SampleMfgSpecificAttribute0x00010x1040
namespace GlobalSceneControl {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GlobalSceneControl::Id; }
};
} // namespace GlobalSceneControl
namespace OnTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTime::Id; }
};
} // namespace OnTime
namespace OffWaitTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffWaitTime::Id; }
};
} // namespace OffWaitTime
namespace StartUpOnOff {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpOnOff::Id; }
};
} // namespace StartUpOnOff
} // namespace Attributes
} // namespace OnOff
namespace OnOffSwitchConfiguration {

namespace Attributes {
namespace SwitchType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SwitchType::Id; }
};
} // namespace SwitchType
namespace SwitchActions {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SwitchActions::Id; }
};
} // namespace SwitchActions
} // namespace Attributes
} // namespace OnOffSwitchConfiguration
namespace LevelControl {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MoveMode
enum class MoveMode : uint8_t
{
    kUp   = 0x00,
    kDown = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MoveMode                             = EmberAfMoveMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for StepMode
enum class StepMode : uint8_t
{
    kUp   = 0x00,
    kDown = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using StepMode                             = EmberAfStepMode;
#endif

namespace Commands {
namespace MoveToLevel {
enum class Fields
{
    kLevel          = 0,
    kTransitionTime = 1,
    kOptionMask     = 2,
    kOptionOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevel
namespace Move {
enum class Fields
{
    kMoveMode       = 0,
    kRate           = 1,
    kOptionMask     = 2,
    kOptionOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Move::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;
    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Move::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;
    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Move
namespace Step {
enum class Fields
{
    kStepMode       = 0,
    kStepSize       = 1,
    kTransitionTime = 2,
    kOptionMask     = 3,
    kOptionOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Step::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Step::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Step
namespace Stop {
enum class Fields
{
    kOptionMask     = 0,
    kOptionOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Stop::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Stop::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace MoveToLevelWithOnOff {
enum class Fields
{
    kLevel          = 0,
    kTransitionTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevelWithOnOff
namespace MoveWithOnOff {
enum class Fields
{
    kMoveMode = 0,
    kRate     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveWithOnOff
namespace StepWithOnOff {
enum class Fields
{
    kStepMode       = 0,
    kStepSize       = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepWithOnOff
namespace StopWithOnOff {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopWithOnOff
} // namespace Commands

namespace Attributes {
namespace CurrentLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLevel::Id; }
};
} // namespace CurrentLevel
namespace RemainingTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
};
} // namespace RemainingTime
namespace Options {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Options::Id; }
};
} // namespace Options
namespace OnOffTransitionTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOffTransitionTime::Id; }
};
} // namespace OnOffTransitionTime
namespace OnLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnLevel::Id; }
};
} // namespace OnLevel
namespace OnTransitionTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTransitionTime::Id; }
};
} // namespace OnTransitionTime
namespace OffTransitionTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffTransitionTime::Id; }
};
} // namespace OffTransitionTime
namespace DefaultMoveRate {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultMoveRate::Id; }
};
} // namespace DefaultMoveRate
namespace StartUpCurrentLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpCurrentLevel::Id; }
};
} // namespace StartUpCurrentLevel
} // namespace Attributes
} // namespace LevelControl
namespace Alarms {

namespace Commands {
namespace ResetAlarm {
enum class Fields
{
    kAlarmCode = 0,
    kClusterId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetAlarm
namespace Alarm {
enum class Fields
{
    kAlarmCode = 0,
    kClusterId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Alarm::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Alarm::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Alarm
namespace ResetAllAlarms {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetAllAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetAllAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetAllAlarms
namespace GetAlarmResponse {
enum class Fields
{
    kStatus    = 0,
    kAlarmCode = 1,
    kClusterId = 2,
    kTimeStamp = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetAlarmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    uint8_t status;
    uint8_t alarmCode;
    chip::ClusterId clusterId;
    uint32_t timeStamp;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetAlarmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    uint8_t status;
    uint8_t alarmCode;
    chip::ClusterId clusterId;
    uint32_t timeStamp;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlarmResponse
namespace GetAlarm {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlarm
namespace ResetAlarmLog {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetAlarmLog::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetAlarmLog::Id; }
    static constexpr ClusterId GetClusterId() { return Alarms::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetAlarmLog
} // namespace Commands

namespace Attributes {
namespace AlarmCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Alarms::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmCount::Id; }
};
} // namespace AlarmCount
} // namespace Attributes
} // namespace Alarms
namespace Time {

namespace Attributes {
namespace Time {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Time::Id; }
};
} // namespace Time
namespace TimeStatus {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeStatus::Id; }
};
} // namespace TimeStatus
namespace TimeZone {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZone::Id; }
};
} // namespace TimeZone
namespace DstStart {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DstStart::Id; }
};
} // namespace DstStart
namespace DstEnd {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DstEnd::Id; }
};
} // namespace DstEnd
namespace DstShift {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DstShift::Id; }
};
} // namespace DstShift
namespace StandardTime {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StandardTime::Id; }
};
} // namespace StandardTime
namespace LocalTime {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTime::Id; }
};
} // namespace LocalTime
namespace LastSetTime {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastSetTime::Id; }
};
} // namespace LastSetTime
namespace ValidUntilTime {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ValidUntilTime::Id; }
};
} // namespace ValidUntilTime
} // namespace Attributes
} // namespace Time
namespace BinaryInputBasic {

namespace Attributes {
namespace ActiveText {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveText::Id; }
};
} // namespace ActiveText
namespace Description {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
};
} // namespace Description
namespace InactiveText {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InactiveText::Id; }
};
} // namespace InactiveText
namespace OutOfService {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutOfService::Id; }
};
} // namespace OutOfService
namespace Polarity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Polarity::Id; }
};
} // namespace Polarity
namespace PresentValue {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PresentValue::Id; }
};
} // namespace PresentValue
namespace Reliability {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reliability::Id; }
};
} // namespace Reliability
namespace StatusFlags {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StatusFlags::Id; }
};
} // namespace StatusFlags
namespace ApplicationType {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationType::Id; }
};
} // namespace ApplicationType
} // namespace Attributes
} // namespace BinaryInputBasic
namespace PowerProfile {

namespace Structs {
namespace PowerProfileRecord {
enum class Fields
{
    kPowerProfileId            = 0,
    kEnergyPhaseId             = 1,
    kPowerProfileRemoteControl = 2,
    kPowerProfileState         = 3,
};

struct Type
{
public:
    uint8_t powerProfileId;
    uint8_t energyPhaseId;
    bool powerProfileRemoteControl;
    uint8_t powerProfileState;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace PowerProfileRecord
namespace ScheduledPhase {
enum class Fields
{
    kEnergyPhaseId = 0,
    kScheduledTime = 1,
};

struct Type
{
public:
    uint8_t energyPhaseId;
    uint16_t scheduledTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ScheduledPhase
namespace TransferredPhase {
enum class Fields
{
    kEnergyPhaseId      = 0,
    kMacroPhaseId       = 1,
    kExpectedDuration   = 2,
    kPeakPower          = 3,
    kEnergy             = 4,
    kMaxActivationDelay = 5,
};

struct Type
{
public:
    uint8_t energyPhaseId;
    uint8_t macroPhaseId;
    uint16_t expectedDuration;
    uint16_t peakPower;
    uint16_t energy;
    uint16_t maxActivationDelay;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TransferredPhase
} // namespace Structs

namespace Commands {
namespace PowerProfileRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileRequest
namespace PowerProfileNotification {
enum class Fields
{
    kTotalProfileNum        = 0,
    kPowerProfileId         = 1,
    kNumOfTransferredPhases = 2,
    kTransferredPhases      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::List<Structs::TransferredPhase::Type> transferredPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::DecodableList<Structs::TransferredPhase::DecodableType> transferredPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileNotification
namespace PowerProfileStateRequest {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileStateRequest
namespace PowerProfileResponse {
enum class Fields
{
    kTotalProfileNum        = 0,
    kPowerProfileId         = 1,
    kNumOfTransferredPhases = 2,
    kTransferredPhases      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::List<Structs::TransferredPhase::Type> transferredPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::DecodableList<Structs::TransferredPhase::DecodableType> transferredPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileResponse
namespace GetPowerProfilePriceResponse {
enum class Fields
{
    kPowerProfileId     = 0,
    kCurrency           = 1,
    kPrice              = 2,
    kPriceTrailingDigit = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPowerProfilePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPowerProfilePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePriceResponse
namespace PowerProfileStateResponse {
enum class Fields
{
    kPowerProfileCount   = 0,
    kPowerProfileRecords = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::List<Structs::PowerProfileRecord::Type> powerProfileRecords;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::DecodableList<Structs::PowerProfileRecord::DecodableType> powerProfileRecords;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileStateResponse
namespace GetOverallSchedulePriceResponse {
enum class Fields
{
    kCurrency           = 0,
    kPrice              = 1,
    kPriceTrailingDigit = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetOverallSchedulePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetOverallSchedulePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetOverallSchedulePriceResponse
namespace GetPowerProfilePrice {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPowerProfilePrice::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPowerProfilePrice::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePrice
namespace EnergyPhasesScheduleNotification {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleNotification
namespace PowerProfilesStateNotification {
enum class Fields
{
    kPowerProfileCount   = 0,
    kPowerProfileRecords = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfilesStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::List<Structs::PowerProfileRecord::Type> powerProfileRecords;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfilesStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::DecodableList<Structs::PowerProfileRecord::DecodableType> powerProfileRecords;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfilesStateNotification
namespace EnergyPhasesScheduleResponse {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleResponse
namespace GetOverallSchedulePrice {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetOverallSchedulePrice::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetOverallSchedulePrice::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetOverallSchedulePrice
namespace PowerProfileScheduleConstraintsRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileScheduleConstraintsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileScheduleConstraintsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileScheduleConstraintsRequest
namespace EnergyPhasesScheduleRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleRequest
namespace EnergyPhasesScheduleStateRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleStateRequest
namespace EnergyPhasesScheduleStateResponse {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleStateResponse
namespace GetPowerProfilePriceExtendedResponse {
enum class Fields
{
    kPowerProfileId     = 0,
    kCurrency           = 1,
    kPrice              = 2,
    kPriceTrailingDigit = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPowerProfilePriceExtendedResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPowerProfilePriceExtendedResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePriceExtendedResponse
namespace EnergyPhasesScheduleStateNotification {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnergyPhasesScheduleStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleStateNotification
namespace PowerProfileScheduleConstraintsNotification {
enum class Fields
{
    kPowerProfileId = 0,
    kStartAfter     = 1,
    kStopBefore     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileScheduleConstraintsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileScheduleConstraintsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileScheduleConstraintsNotification
namespace PowerProfileScheduleConstraintsResponse {
enum class Fields
{
    kPowerProfileId = 0,
    kStartAfter     = 1,
    kStopBefore     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PowerProfileScheduleConstraintsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PowerProfileScheduleConstraintsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileScheduleConstraintsResponse
namespace GetPowerProfilePriceExtended {
enum class Fields
{
    kOptions               = 0,
    kPowerProfileId        = 1,
    kPowerProfileStartTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPowerProfilePriceExtended::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t options;
    uint8_t powerProfileId;
    uint16_t powerProfileStartTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPowerProfilePriceExtended::Id; }
    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }

    uint8_t options;
    uint8_t powerProfileId;
    uint16_t powerProfileStartTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePriceExtended
} // namespace Commands

namespace Attributes {
namespace TotalProfileNum {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalProfileNum::Id; }
};
} // namespace TotalProfileNum
namespace MultipleScheduling {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MultipleScheduling::Id; }
};
} // namespace MultipleScheduling
namespace EnergyFormatting {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyFormatting::Id; }
};
} // namespace EnergyFormatting
namespace EnergyRemote {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyRemote::Id; }
};
} // namespace EnergyRemote
namespace ScheduleMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleMode::Id; }
};
} // namespace ScheduleMode
} // namespace Attributes
} // namespace PowerProfile
namespace ApplianceControl {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ApplianceStatus
enum class ApplianceStatus : uint8_t
{
    kOff                      = 0x01,
    kStandBy                  = 0x02,
    kProgrammed               = 0x03,
    kProgrammedWaitingToStart = 0x04,
    kRunning                  = 0x05,
    kPause                    = 0x06,
    kEndProgrammed            = 0x07,
    kFailure                  = 0x08,
    kProgrammeInterrupted     = 0x09,
    kIdle                     = 0x0A,
    kRinseHold                = 0x0B,
    kService                  = 0x0C,
    kSuperfreezing            = 0x0D,
    kSupercooling             = 0x0E,
    kSuperheating             = 0x0F,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ApplianceStatus                      = EmberAfApplianceStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for CommandIdentification
enum class CommandIdentification : uint8_t
{
    kStart                = 0x01,
    kStop                 = 0x02,
    kPause                = 0x03,
    kStartSuperfreezing   = 0x04,
    kStopSuperfreezing    = 0x05,
    kStartSupercooling    = 0x06,
    kStopSupercooling     = 0x07,
    kDisableGas           = 0x08,
    kEnableGas            = 0x09,
    kEnableEnergyControl  = 0x0A,
    kDisableEnergyControl = 0x0B,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using CommandIdentification                = EmberAfCommandIdentification;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for WarningEvent
enum class WarningEvent : uint8_t
{
    kWarning1OverallPowerAboveAvailablePowerLevel                                      = 0x00,
    kWarning2OverallPowerAbovePowerThresholdLevel                                      = 0x01,
    kWarning3OverallPowerBackBelowTheAvailablePowerLevel                               = 0x02,
    kWarning4OverallPowerBackBelowThePowerThresholdLevel                               = 0x03,
    kWarning5OverallPowerWillBePotentiallyAboveAvailablePowerLevelIfTheApplianceStarts = 0x04,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using WarningEvent                         = EmberAfWarningEvent;
#endif

// Bitmap for RemoteEnableFlagsAndDeviceStatus2
enum class RemoteEnableFlagsAndDeviceStatus2 : uint8_t
{
    kRemoteEnableFlags      = 0,
    kDeviceStatus2Structure = 4,
};

namespace Commands {
namespace ExecutionOfACommand {
enum class Fields
{
    kCommandId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ExecutionOfACommand::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CommandIdentification commandId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ExecutionOfACommand::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CommandIdentification commandId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ExecutionOfACommand
namespace SignalStateResponse {
enum class Fields
{
    kApplianceStatus                   = 0,
    kRemoteEnableFlagsAndDeviceStatus2 = 1,
    kApplianceStatus2                  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SignalStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SignalStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignalStateResponse
namespace SignalState {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SignalState::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SignalState::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignalState
namespace SignalStateNotification {
enum class Fields
{
    kApplianceStatus                   = 0,
    kRemoteEnableFlagsAndDeviceStatus2 = 1,
    kApplianceStatus2                  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SignalStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SignalStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignalStateNotification
namespace WriteFunctions {
enum class Fields
{
    kFunctionId       = 0,
    kFunctionDataType = 1,
    kFunctionData     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return WriteFunctions::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    uint16_t functionId;
    uint8_t functionDataType;
    DataModel::List<uint8_t> functionData;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return WriteFunctions::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    uint16_t functionId;
    uint8_t functionDataType;
    DataModel::DecodableList<uint8_t> functionData;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace WriteFunctions
namespace OverloadPauseResume {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OverloadPauseResume::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OverloadPauseResume::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OverloadPauseResume
namespace OverloadPause {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OverloadPause::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OverloadPause::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OverloadPause
namespace OverloadWarning {
enum class Fields
{
    kWarningEvent = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OverloadWarning::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    WarningEvent warningEvent;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OverloadWarning::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }

    WarningEvent warningEvent;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OverloadWarning
} // namespace Commands

namespace Attributes {
namespace StartTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartTime::Id; }
};
} // namespace StartTime
namespace FinishTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FinishTime::Id; }
};
} // namespace FinishTime
namespace RemainingTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
};
} // namespace RemainingTime
} // namespace Attributes
} // namespace ApplianceControl
namespace Descriptor {

namespace Structs {
namespace DeviceType {
enum class Fields
{
    kType     = 0,
    kRevision = 1,
};

struct Type
{
public:
    chip::DeviceTypeId type;
    uint16_t revision;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace DeviceType
} // namespace Structs

namespace Attributes {
namespace DeviceList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::DeviceType::Type>;
    using DecodableType = DataModel::DecodableList<Structs::DeviceType::DecodableType>;

    static constexpr ClusterId GetClusterId() { return Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceList::Id; }
};
} // namespace DeviceList
namespace ServerList {
struct TypeInfo
{
    using Type          = DataModel::List<chip::ClusterId>;
    using DecodableType = DataModel::DecodableList<chip::ClusterId>;

    static constexpr ClusterId GetClusterId() { return Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ServerList::Id; }
};
} // namespace ServerList
namespace ClientList {
struct TypeInfo
{
    using Type          = DataModel::List<chip::ClusterId>;
    using DecodableType = DataModel::DecodableList<chip::ClusterId>;

    static constexpr ClusterId GetClusterId() { return Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClientList::Id; }
};
} // namespace ClientList
namespace PartsList {
struct TypeInfo
{
    using Type          = DataModel::List<chip::EndpointId>;
    using DecodableType = DataModel::DecodableList<chip::EndpointId>;

    static constexpr ClusterId GetClusterId() { return Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartsList::Id; }
};
} // namespace PartsList
} // namespace Attributes
} // namespace Descriptor
namespace PollControl {

namespace Commands {
namespace CheckIn {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CheckIn::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CheckIn::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CheckIn
namespace CheckInResponse {
enum class Fields
{
    kStartFastPolling = 0,
    kFastPollTimeout  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CheckInResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    bool startFastPolling;
    uint16_t fastPollTimeout;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CheckInResponse::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    bool startFastPolling;
    uint16_t fastPollTimeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CheckInResponse
namespace FastPollStop {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return FastPollStop::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return FastPollStop::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FastPollStop
namespace SetLongPollInterval {
enum class Fields
{
    kNewLongPollInterval = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetLongPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    uint32_t newLongPollInterval;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetLongPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    uint32_t newLongPollInterval;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetLongPollInterval
namespace SetShortPollInterval {
enum class Fields
{
    kNewShortPollInterval = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetShortPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    uint16_t newShortPollInterval;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetShortPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return PollControl::Id; }

    uint16_t newShortPollInterval;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetShortPollInterval
} // namespace Commands

namespace Attributes {
namespace CheckInInterval {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CheckInInterval::Id; }
};
} // namespace CheckInInterval
namespace LongPollInterval {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongPollInterval::Id; }
};
} // namespace LongPollInterval
namespace ShortPollInterval {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ShortPollInterval::Id; }
};
} // namespace ShortPollInterval
namespace FastPollTimeout {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FastPollTimeout::Id; }
};
} // namespace FastPollTimeout
namespace CheckInIntervalMin {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CheckInIntervalMin::Id; }
};
} // namespace CheckInIntervalMin
namespace LongPollIntervalMin {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongPollIntervalMin::Id; }
};
} // namespace LongPollIntervalMin
namespace FastPollTimeoutMax {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FastPollTimeoutMax::Id; }
};
} // namespace FastPollTimeoutMax
} // namespace Attributes
} // namespace PollControl
namespace Basic {

namespace Commands {
namespace StartUp {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartUp
namespace MfgSpecificPing {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MfgSpecificPing
namespace ShutDown {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShutDown
namespace Leave {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Leave
} // namespace Commands

namespace Attributes {
namespace InteractionModelVersion {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InteractionModelVersion::Id; }
};
} // namespace InteractionModelVersion
namespace VendorName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
};
} // namespace ProductName
namespace ProductID {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
};
} // namespace ProductID
namespace UserLabel {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserLabel::Id; }
};
} // namespace UserLabel
namespace Location {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Location::Id; }
};
} // namespace Location
namespace HardwareVersion {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
};
} // namespace SerialNumber
namespace LocalConfigDisabled {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalConfigDisabled::Id; }
};
} // namespace LocalConfigDisabled
namespace Reachable {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
};
} // namespace Reachable
} // namespace Attributes
} // namespace Basic
namespace OtaSoftwareUpdateProvider {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTAApplyUpdateAction
enum class OTAApplyUpdateAction : uint8_t
{
    kProceed         = 0x00,
    kAwaitNextAction = 0x01,
    kDiscontinue     = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTAApplyUpdateAction                 = EmberAfOTAApplyUpdateAction;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTADownloadProtocol
enum class OTADownloadProtocol : uint8_t
{
    kBDXSynchronous  = 0x00,
    kBDXAsynchronous = 0x01,
    kHttps           = 0x02,
    kVendorSpecific  = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTADownloadProtocol                  = EmberAfOTADownloadProtocol;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTAQueryStatus
enum class OTAQueryStatus : uint8_t
{
    kUpdateAvailable = 0x00,
    kBusy            = 0x01,
    kNotAvailable    = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTAQueryStatus                       = EmberAfOTAQueryStatus;
#endif

namespace Commands {
namespace QueryImage {
enum class Fields
{
    kVendorId            = 0,
    kProductId           = 1,
    kHardwareVersion     = 2,
    kSoftwareVersion     = 3,
    kProtocolsSupported  = 4,
    kLocation            = 5,
    kRequestorCanConsent = 6,
    kMetadataForProvider = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    uint16_t vendorId;
    uint16_t productId;
    uint16_t hardwareVersion;
    uint32_t softwareVersion;
    OTADownloadProtocol protocolsSupported;
    chip::Span<const char> location;
    bool requestorCanConsent;
    chip::ByteSpan metadataForProvider;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    uint16_t vendorId;
    uint16_t productId;
    uint16_t hardwareVersion;
    uint32_t softwareVersion;
    OTADownloadProtocol protocolsSupported;
    chip::Span<const char> location;
    bool requestorCanConsent;
    chip::ByteSpan metadataForProvider;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImage
namespace ApplyUpdateRequest {
enum class Fields
{
    kUpdateToken = 0,
    kNewVersion  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateRequest
namespace NotifyUpdateApplied {
enum class Fields
{
    kUpdateToken     = 0,
    kSoftwareVersion = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NotifyUpdateApplied
namespace QueryImageResponse {
enum class Fields
{
    kStatus                = 0,
    kDelayedActionTime     = 1,
    kImageURI              = 2,
    kSoftwareVersion       = 3,
    kSoftwareVersionString = 4,
    kUpdateToken           = 5,
    kUserConsentNeeded     = 6,
    kMetadataForRequestor  = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    OTAQueryStatus status;
    uint32_t delayedActionTime;
    chip::Span<const char> imageURI;
    uint32_t softwareVersion;
    chip::Span<const char> softwareVersionString;
    chip::ByteSpan updateToken;
    bool userConsentNeeded;
    chip::ByteSpan metadataForRequestor;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    OTAQueryStatus status;
    uint32_t delayedActionTime;
    chip::Span<const char> imageURI;
    uint32_t softwareVersion;
    chip::Span<const char> softwareVersionString;
    chip::ByteSpan updateToken;
    bool userConsentNeeded;
    chip::ByteSpan metadataForRequestor;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImageResponse
namespace ApplyUpdateRequestResponse {
enum class Fields
{
    kAction            = 0,
    kDelayedActionTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ApplyUpdateRequestResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    OTAApplyUpdateAction action;
    uint32_t delayedActionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ApplyUpdateRequestResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateProvider::Id; }

    OTAApplyUpdateAction action;
    uint32_t delayedActionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateRequestResponse
} // namespace Commands

} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTAAnnouncementReason
enum class OTAAnnouncementReason : uint8_t
{
    kSimpleAnnouncement    = 0x00,
    kUpdateAvailable       = 0x01,
    kUrgentUpdateAvailable = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTAAnnouncementReason                = EmberAfOTAAnnouncementReason;
#endif

namespace Commands {
namespace AnnounceOtaProvider {
enum class Fields
{
    kProviderLocation   = 0,
    kVendorId           = 1,
    kAnnouncementReason = 2,
    kMetadataForNode    = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AnnounceOtaProvider::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateRequestor::Id; }

    chip::ByteSpan providerLocation;
    uint16_t vendorId;
    OTAAnnouncementReason announcementReason;
    chip::ByteSpan metadataForNode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AnnounceOtaProvider::Id; }
    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateRequestor::Id; }

    chip::ByteSpan providerLocation;
    uint16_t vendorId;
    OTAAnnouncementReason announcementReason;
    chip::ByteSpan metadataForNode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AnnounceOtaProvider
} // namespace Commands

namespace Attributes {
namespace DefaultOtaProvider {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOtaProvider::Id; }
};
} // namespace DefaultOtaProvider
namespace UpdatePossible {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdatePossible::Id; }
};
} // namespace UpdatePossible
} // namespace Attributes
} // namespace OtaSoftwareUpdateRequestor
namespace PowerSource {

namespace Attributes {
namespace Status {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
};
} // namespace Status
namespace Order {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Order::Id; }
};
} // namespace Order
namespace Description {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
};
} // namespace Description
namespace WiredAssessedInputVoltage {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputVoltage::Id; }
};
} // namespace WiredAssessedInputVoltage
namespace WiredAssessedInputFrequency {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputFrequency::Id; }
};
} // namespace WiredAssessedInputFrequency
namespace WiredCurrentType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredCurrentType::Id; }
};
} // namespace WiredCurrentType
namespace WiredAssessedCurrent {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedCurrent::Id; }
};
} // namespace WiredAssessedCurrent
namespace WiredNominalVoltage {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredNominalVoltage::Id; }
};
} // namespace WiredNominalVoltage
namespace WiredMaximumCurrent {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredMaximumCurrent::Id; }
};
} // namespace WiredMaximumCurrent
namespace WiredPresent {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredPresent::Id; }
};
} // namespace WiredPresent
namespace ActiveWiredFaults {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveWiredFaults::Id; }
};
} // namespace ActiveWiredFaults
namespace BatteryVoltage {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltage::Id; }
};
} // namespace BatteryVoltage
namespace BatteryPercentRemaining {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentRemaining::Id; }
};
} // namespace BatteryPercentRemaining
namespace BatteryTimeRemaining {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryTimeRemaining::Id; }
};
} // namespace BatteryTimeRemaining
namespace BatteryChargeLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryChargeLevel::Id; }
};
} // namespace BatteryChargeLevel
namespace BatteryReplacementNeeded {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryReplacementNeeded::Id; }
};
} // namespace BatteryReplacementNeeded
namespace BatteryReplaceability {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryReplaceability::Id; }
};
} // namespace BatteryReplaceability
namespace BatteryPresent {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPresent::Id; }
};
} // namespace BatteryPresent
namespace ActiveBatteryFaults {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatteryFaults::Id; }
};
} // namespace ActiveBatteryFaults
namespace BatteryReplacementDescription {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryReplacementDescription::Id; }
};
} // namespace BatteryReplacementDescription
namespace BatteryCommonDesignation {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryCommonDesignation::Id; }
};
} // namespace BatteryCommonDesignation
namespace BatteryANSIDesignation {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryANSIDesignation::Id; }
};
} // namespace BatteryANSIDesignation
namespace BatteryIECDesignation {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryIECDesignation::Id; }
};
} // namespace BatteryIECDesignation
namespace BatteryApprovedChemistry {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryApprovedChemistry::Id; }
};
} // namespace BatteryApprovedChemistry
namespace BatteryCapacity {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryCapacity::Id; }
};
} // namespace BatteryCapacity
namespace BatteryQuantity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryQuantity::Id; }
};
} // namespace BatteryQuantity
namespace BatteryChargeState {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryChargeState::Id; }
};
} // namespace BatteryChargeState
namespace BatteryTimeToFullCharge {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryTimeToFullCharge::Id; }
};
} // namespace BatteryTimeToFullCharge
namespace BatteryFunctionalWhileCharging {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryFunctionalWhileCharging::Id; }
};
} // namespace BatteryFunctionalWhileCharging
namespace BatteryChargingCurrent {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryChargingCurrent::Id; }
};
} // namespace BatteryChargingCurrent
namespace ActiveBatteryChargeFaults {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatteryChargeFaults::Id; }
};
} // namespace ActiveBatteryChargeFaults
} // namespace Attributes
} // namespace PowerSource
namespace GeneralCommissioning {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for GeneralCommissioningError
enum class GeneralCommissioningError : uint8_t
{
    kOk                    = 0x00,
    kValueOutsideRange     = 0x01,
    kInvalidAuthentication = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using GeneralCommissioningError            = EmberAfGeneralCommissioningError;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for RegulatoryLocationType
enum class RegulatoryLocationType : uint8_t
{
    kIndoor        = 0x00,
    kOutdoor       = 0x01,
    kIndoorOutdoor = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using RegulatoryLocationType               = EmberAfRegulatoryLocationType;
#endif

namespace Structs {
namespace BasicCommissioningInfoType {
enum class Fields
{
    kFailSafeExpiryLengthMs = 0,
};

struct Type
{
public:
    uint32_t failSafeExpiryLengthMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace BasicCommissioningInfoType
} // namespace Structs

namespace Commands {
namespace ArmFailSafe {
enum class Fields
{
    kExpiryLengthSeconds = 0,
    kBreadcrumb          = 1,
    kTimeoutMs           = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafe
namespace ArmFailSafeResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafeResponse
namespace SetRegulatoryConfig {
enum class Fields
{
    kLocation    = 0,
    kCountryCode = 1,
    kBreadcrumb  = 2,
    kTimeoutMs   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    RegulatoryLocationType location;
    chip::Span<const char> countryCode;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    RegulatoryLocationType location;
    chip::Span<const char> countryCode;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfig
namespace SetRegulatoryConfigResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfigResponse
namespace CommissioningComplete {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningComplete
namespace CommissioningCompleteResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningCompleteResponse
} // namespace Commands

namespace Attributes {
namespace Breadcrumb {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Breadcrumb::Id; }
};
} // namespace Breadcrumb
namespace BasicCommissioningInfoList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::BasicCommissioningInfoType::Type>;
    using DecodableType = DataModel::DecodableList<Structs::BasicCommissioningInfoType::DecodableType>;

    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BasicCommissioningInfoList::Id; }
};
} // namespace BasicCommissioningInfoList
namespace RegulatoryConfigList {
struct TypeInfo
{
    using Type          = DataModel::List<RegulatoryLocationType>;
    using DecodableType = DataModel::DecodableList<RegulatoryLocationType>;

    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RegulatoryConfigList::Id; }
};
} // namespace RegulatoryConfigList
namespace LocationCapabilityList {
struct TypeInfo
{
    using Type          = DataModel::List<RegulatoryLocationType>;
    using DecodableType = DataModel::DecodableList<RegulatoryLocationType>;

    static constexpr ClusterId GetClusterId() { return GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocationCapabilityList::Id; }
};
} // namespace LocationCapabilityList
} // namespace Attributes
} // namespace GeneralCommissioning
namespace NetworkCommissioning {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NetworkCommissioningError
enum class NetworkCommissioningError : uint8_t
{
    kSuccess                = 0x00,
    kOutOfRange             = 0x01,
    kBoundsExceeded         = 0x02,
    kNetworkIDNotFound      = 0x03,
    kDuplicateNetworkID     = 0x04,
    kNetworkNotFound        = 0x05,
    kRegulatoryError        = 0x06,
    kAuthFailure            = 0x07,
    kUnsupportedSecurity    = 0x08,
    kOtherConnectionFailure = 0x09,
    kIPV6Failed             = 0x0A,
    kIPBindFailed           = 0x0B,
    kLabel9                 = 0x0C,
    kLabel10                = 0x0D,
    kLabel11                = 0x0E,
    kLabel12                = 0x0F,
    kLabel13                = 0x10,
    kLabel14                = 0x11,
    kLabel15                = 0x12,
    kUnknownError           = 0x13,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NetworkCommissioningError            = EmberAfNetworkCommissioningError;
#endif

namespace Structs {
namespace ThreadInterfaceScanResult {
enum class Fields
{
    kDiscoveryResponse = 0,
};

struct Type
{
public:
    chip::ByteSpan discoveryResponse;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ThreadInterfaceScanResult
namespace WiFiInterfaceScanResult {
enum class Fields
{
    kSecurity      = 0,
    kSsid          = 1,
    kBssid         = 2,
    kChannel       = 3,
    kFrequencyBand = 4,
};

struct Type
{
public:
    uint8_t security;
    chip::ByteSpan ssid;
    chip::ByteSpan bssid;
    uint8_t channel;
    uint32_t frequencyBand;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace WiFiInterfaceScanResult
} // namespace Structs

namespace Commands {
namespace ScanNetworks {
enum class Fields
{
    kSsid       = 0,
    kBreadcrumb = 1,
    kTimeoutMs  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworks
namespace ScanNetworksResponse {
enum class Fields
{
    kErrorCode         = 0,
    kDebugText         = 1,
    kWifiScanResults   = 2,
    kThreadScanResults = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    DataModel::List<Structs::WiFiInterfaceScanResult::Type> wifiScanResults;
    DataModel::List<Structs::ThreadInterfaceScanResult::Type> threadScanResults;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    DataModel::DecodableList<Structs::WiFiInterfaceScanResult::DecodableType> wifiScanResults;
    DataModel::DecodableList<Structs::ThreadInterfaceScanResult::DecodableType> threadScanResults;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworksResponse
namespace AddWiFiNetwork {
enum class Fields
{
    kSsid        = 0,
    kCredentials = 1,
    kBreadcrumb  = 2,
    kTimeoutMs   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddWiFiNetwork
namespace AddWiFiNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddWiFiNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddWiFiNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddWiFiNetworkResponse
namespace UpdateWiFiNetwork {
enum class Fields
{
    kSsid        = 0,
    kCredentials = 1,
    kBreadcrumb  = 2,
    kTimeoutMs   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateWiFiNetwork
namespace UpdateWiFiNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpdateWiFiNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpdateWiFiNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateWiFiNetworkResponse
namespace AddThreadNetwork {
enum class Fields
{
    kOperationalDataset = 0,
    kBreadcrumb         = 1,
    kTimeoutMs          = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddThreadNetwork
namespace AddThreadNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddThreadNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddThreadNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddThreadNetworkResponse
namespace UpdateThreadNetwork {
enum class Fields
{
    kOperationalDataset = 0,
    kBreadcrumb         = 1,
    kTimeoutMs          = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateThreadNetwork
namespace UpdateThreadNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpdateThreadNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpdateThreadNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateThreadNetworkResponse
namespace RemoveNetwork {
enum class Fields
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
    kTimeoutMs  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveNetwork
namespace RemoveNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveNetworkResponse
namespace EnableNetwork {
enum class Fields
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
    kTimeoutMs  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnableNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnableNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableNetwork
namespace EnableNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnableNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnableNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableNetworkResponse
namespace DisableNetwork {
enum class Fields
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
    kTimeoutMs  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return DisableNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return DisableNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableNetwork
namespace DisableNetworkResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return DisableNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return DisableNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint8_t errorCode;
    chip::Span<const char> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableNetworkResponse
namespace GetLastNetworkCommissioningResult {
enum class Fields
{
    kTimeoutMs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetLastNetworkCommissioningResult::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetLastNetworkCommissioningResult::Id; }
    static constexpr ClusterId GetClusterId() { return NetworkCommissioning::Id; }

    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLastNetworkCommissioningResult
} // namespace Commands

} // namespace NetworkCommissioning
namespace DiagnosticLogs {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for LogsIntent
enum class LogsIntent : uint8_t
{
    kEndUserSupport = 0x00,
    kNetworkDiag    = 0x01,
    kCrashLogs      = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using LogsIntent                           = EmberAfLogsIntent;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for LogsStatus
enum class LogsStatus : uint8_t
{
    kSuccess   = 0x00,
    kExhausted = 0x01,
    kNoLogs    = 0x02,
    kBusy      = 0x03,
    kDenied    = 0x04,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using LogsStatus                           = EmberAfLogsStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for LogsTransferProtocol
enum class LogsTransferProtocol : uint8_t
{
    kResponsePayload = 0x00,
    kBdx             = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using LogsTransferProtocol                 = EmberAfLogsTransferProtocol;
#endif

namespace Commands {
namespace RetrieveLogsRequest {
enum class Fields
{
    kIntent                 = 0,
    kRequestedProtocol      = 1,
    kTransferFileDesignator = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return DiagnosticLogs::Id; }

    LogsIntent intent;
    LogsTransferProtocol requestedProtocol;
    chip::ByteSpan transferFileDesignator;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return DiagnosticLogs::Id; }

    LogsIntent intent;
    LogsTransferProtocol requestedProtocol;
    chip::ByteSpan transferFileDesignator;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsRequest
namespace RetrieveLogsResponse {
enum class Fields
{
    kStatus        = 0,
    kContent       = 1,
    kTimeStamp     = 2,
    kTimeSinceBoot = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DiagnosticLogs::Id; }

    LogsStatus status;
    chip::ByteSpan content;
    uint32_t timeStamp;
    uint32_t timeSinceBoot;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DiagnosticLogs::Id; }

    LogsStatus status;
    chip::ByteSpan content;
    uint32_t timeStamp;
    uint32_t timeSinceBoot;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsResponse
} // namespace Commands

} // namespace DiagnosticLogs
namespace GeneralDiagnostics {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for BootReasonType
enum class BootReasonType : uint8_t
{
    kUnspecified             = 0x00,
    kPowerOnReboot           = 0x01,
    kBrownOutReset           = 0x02,
    kSoftwareWatchdogReset   = 0x03,
    kHardwareWatchdogReset   = 0x04,
    kSoftwareUpdateCompleted = 0x05,
    kSoftwareReset           = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using BootReasonType                       = EmberAfBootReasonType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HardwareFaultType
enum class HardwareFaultType : uint8_t
{
    kUnspecified            = 0x00,
    kRadio                  = 0x01,
    kSensor                 = 0x02,
    kResettableOverTemp     = 0x03,
    kNonResettableOverTemp  = 0x04,
    kPowerSource            = 0x05,
    kVisualDisplayFault     = 0x06,
    kAudioOutputFault       = 0x07,
    kUserInterfaceFault     = 0x08,
    kNonVolatileMemoryError = 0x09,
    kTamperDetected         = 0x0A,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HardwareFaultType                    = EmberAfHardwareFaultType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for InterfaceType
enum class InterfaceType : uint8_t
{
    kUnspecified = 0x00,
    kWiFi        = 0x01,
    kEthernet    = 0x02,
    kCellular    = 0x03,
    kThread      = 0x04,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using InterfaceType                        = EmberAfInterfaceType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NetworkFaultType
enum class NetworkFaultType : uint8_t
{
    kUnspecified      = 0x00,
    kHardwareFailure  = 0x01,
    kNetworkJammed    = 0x02,
    kConnectionFailed = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NetworkFaultType                     = EmberAfNetworkFaultType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for RadioFaultType
enum class RadioFaultType : uint8_t
{
    kUnspecified   = 0x00,
    kWiFiFault     = 0x01,
    kCellularFault = 0x02,
    kThreadFault   = 0x03,
    kNFCFault      = 0x04,
    kBLEFault      = 0x05,
    kEthernetFault = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using RadioFaultType                       = EmberAfRadioFaultType;
#endif

namespace Structs {
namespace NetworkInterfaceType {
enum class Fields
{
    kName                            = 0,
    kFabricConnected                 = 1,
    kOffPremiseServicesReachableIPv4 = 2,
    kOffPremiseServicesReachableIPv6 = 3,
    kHardwareAddress                 = 4,
    kType                            = 5,
};

struct Type
{
public:
    chip::ByteSpan name;
    bool fabricConnected;
    bool offPremiseServicesReachableIPv4;
    bool offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    InterfaceType type;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NetworkInterfaceType
} // namespace Structs

namespace Attributes {
namespace NetworkInterfaces {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::NetworkInterfaceType::Type>;
    using DecodableType = DataModel::DecodableList<Structs::NetworkInterfaceType::DecodableType>;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkInterfaces::Id; }
};
} // namespace NetworkInterfaces
namespace RebootCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RebootCount::Id; }
};
} // namespace RebootCount
namespace UpTime {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpTime::Id; }
};
} // namespace UpTime
namespace TotalOperationalHours {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalOperationalHours::Id; }
};
} // namespace TotalOperationalHours
namespace BootReasons {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BootReasons::Id; }
};
} // namespace BootReasons
namespace ActiveHardwareFaults {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveHardwareFaults::Id; }
};
} // namespace ActiveHardwareFaults
namespace ActiveRadioFaults {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveRadioFaults::Id; }
};
} // namespace ActiveRadioFaults
namespace ActiveNetworkFaults {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaults::Id; }
};
} // namespace ActiveNetworkFaults
} // namespace Attributes
} // namespace GeneralDiagnostics
namespace SoftwareDiagnostics {

namespace Structs {
namespace ThreadMetrics {
enum class Fields
{
    kId               = 0,
    kName             = 1,
    kStackFreeCurrent = 2,
    kStackFreeMinimum = 3,
    kStackSize        = 4,
};

struct Type
{
public:
    uint64_t id;
    chip::ByteSpan name;
    uint32_t stackFreeCurrent;
    uint32_t stackFreeMinimum;
    uint32_t stackSize;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ThreadMetrics
} // namespace Structs

namespace Commands {
namespace ResetWatermarks {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return SoftwareDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return SoftwareDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetWatermarks
} // namespace Commands

namespace Attributes {
namespace ThreadMetrics {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::ThreadMetrics::Type>;
    using DecodableType = DataModel::DecodableList<Structs::ThreadMetrics::DecodableType>;

    static constexpr ClusterId GetClusterId() { return SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadMetrics::Id; }
};
} // namespace ThreadMetrics
namespace CurrentHeapFree {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapFree::Id; }
};
} // namespace CurrentHeapFree
namespace CurrentHeapUsed {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapUsed::Id; }
};
} // namespace CurrentHeapUsed
namespace CurrentHeapHighWatermark {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapHighWatermark::Id; }
};
} // namespace CurrentHeapHighWatermark
} // namespace Attributes
} // namespace SoftwareDiagnostics
namespace ThreadNetworkDiagnostics {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NetworkFault
enum class NetworkFault : uint8_t
{
    kUnspecified     = 0x00,
    kLinkDown        = 0x01,
    kHardwareFailure = 0x02,
    kNetworkJammed   = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NetworkFault                         = EmberAfNetworkFault;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for RoutingRole
enum class RoutingRole : uint8_t
{
    kUnspecified     = 0x00,
    kUnassigned      = 0x01,
    kSleepyEndDevice = 0x02,
    kEndDevice       = 0x03,
    kReed            = 0x04,
    kRouter          = 0x05,
    kLeader          = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using RoutingRole                          = EmberAfRoutingRole;
#endif

namespace Structs {
namespace NeighborTable {
enum class Fields
{
    kExtAddress       = 0,
    kAge              = 1,
    kRloc16           = 2,
    kLinkFrameCounter = 3,
    kMleFrameCounter  = 4,
    kLqi              = 5,
    kAverageRssi      = 6,
    kLastRssi         = 7,
    kFrameErrorRate   = 8,
    kMessageErrorRate = 9,
    kRxOnWhenIdle     = 10,
    kFullThreadDevice = 11,
    kFullNetworkData  = 12,
    kIsChild          = 13,
};

struct Type
{
public:
    uint64_t extAddress;
    uint32_t age;
    uint16_t rloc16;
    uint32_t linkFrameCounter;
    uint32_t mleFrameCounter;
    uint8_t lqi;
    int8_t averageRssi;
    int8_t lastRssi;
    uint8_t frameErrorRate;
    uint8_t messageErrorRate;
    bool rxOnWhenIdle;
    bool fullThreadDevice;
    bool fullNetworkData;
    bool isChild;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NeighborTable
namespace OperationalDatasetComponents {
enum class Fields
{
    kActiveTimestampPresent  = 0,
    kPendingTimestampPresent = 1,
    kMasterKeyPresent        = 2,
    kNetworkNamePresent      = 3,
    kExtendedPanIdPresent    = 4,
    kMeshLocalPrefixPresent  = 5,
    kDelayPresent            = 6,
    kPanIdPresent            = 7,
    kChannelPresent          = 8,
    kPskcPresent             = 9,
    kSecurityPolicyPresent   = 10,
    kChannelMaskPresent      = 11,
};

struct Type
{
public:
    bool activeTimestampPresent;
    bool pendingTimestampPresent;
    bool masterKeyPresent;
    bool networkNamePresent;
    bool extendedPanIdPresent;
    bool meshLocalPrefixPresent;
    bool delayPresent;
    bool panIdPresent;
    bool channelPresent;
    bool pskcPresent;
    bool securityPolicyPresent;
    bool channelMaskPresent;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace OperationalDatasetComponents
namespace RouteTable {
enum class Fields
{
    kExtAddress      = 0,
    kRloc16          = 1,
    kRouterId        = 2,
    kNextHop         = 3,
    kPathCost        = 4,
    kLQIIn           = 5,
    kLQIOut          = 6,
    kAge             = 7,
    kAllocated       = 8,
    kLinkEstablished = 9,
};

struct Type
{
public:
    uint64_t extAddress;
    uint16_t rloc16;
    uint8_t routerId;
    uint8_t nextHop;
    uint8_t pathCost;
    uint8_t LQIIn;
    uint8_t LQIOut;
    uint8_t age;
    bool allocated;
    bool linkEstablished;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace RouteTable
namespace SecurityPolicy {
enum class Fields
{
    kRotationTime = 0,
    kFlags        = 1,
};

struct Type
{
public:
    uint16_t rotationTime;
    uint16_t flags;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SecurityPolicy
} // namespace Structs

namespace Commands {
namespace ResetCounts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {
namespace Channel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Channel::Id; }
};
} // namespace Channel
namespace RoutingRole {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RoutingRole::Id; }
};
} // namespace RoutingRole
namespace NetworkName {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkName::Id; }
};
} // namespace NetworkName
namespace PanId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PanId::Id; }
};
} // namespace PanId
namespace ExtendedPanId {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExtendedPanId::Id; }
};
} // namespace ExtendedPanId
namespace MeshLocalPrefix {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeshLocalPrefix::Id; }
};
} // namespace MeshLocalPrefix
namespace OverrunCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
};
} // namespace OverrunCount
namespace NeighborTableList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::NeighborTable::Type>;
    using DecodableType = DataModel::DecodableList<Structs::NeighborTable::DecodableType>;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeighborTableList::Id; }
};
} // namespace NeighborTableList
namespace RouteTableList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::RouteTable::Type>;
    using DecodableType = DataModel::DecodableList<Structs::RouteTable::DecodableType>;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouteTableList::Id; }
};
} // namespace RouteTableList
namespace PartitionId {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionId::Id; }
};
} // namespace PartitionId
namespace Weighting {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Weighting::Id; }
};
} // namespace Weighting
namespace DataVersion {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataVersion::Id; }
};
} // namespace DataVersion
namespace StableDataVersion {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StableDataVersion::Id; }
};
} // namespace StableDataVersion
namespace LeaderRouterId {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRouterId::Id; }
};
} // namespace LeaderRouterId
namespace DetachedRoleCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DetachedRoleCount::Id; }
};
} // namespace DetachedRoleCount
namespace ChildRoleCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChildRoleCount::Id; }
};
} // namespace ChildRoleCount
namespace RouterRoleCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouterRoleCount::Id; }
};
} // namespace RouterRoleCount
namespace LeaderRoleCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRoleCount::Id; }
};
} // namespace LeaderRoleCount
namespace AttachAttemptCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttachAttemptCount::Id; }
};
} // namespace AttachAttemptCount
namespace PartitionIdChangeCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionIdChangeCount::Id; }
};
} // namespace PartitionIdChangeCount
namespace BetterPartitionAttachAttemptCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BetterPartitionAttachAttemptCount::Id; }
};
} // namespace BetterPartitionAttachAttemptCount
namespace ParentChangeCount {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ParentChangeCount::Id; }
};
} // namespace ParentChangeCount
namespace TxTotalCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxTotalCount::Id; }
};
} // namespace TxTotalCount
namespace TxUnicastCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxUnicastCount::Id; }
};
} // namespace TxUnicastCount
namespace TxBroadcastCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBroadcastCount::Id; }
};
} // namespace TxBroadcastCount
namespace TxAckRequestedCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckRequestedCount::Id; }
};
} // namespace TxAckRequestedCount
namespace TxAckedCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckedCount::Id; }
};
} // namespace TxAckedCount
namespace TxNoAckRequestedCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxNoAckRequestedCount::Id; }
};
} // namespace TxNoAckRequestedCount
namespace TxDataCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataCount::Id; }
};
} // namespace TxDataCount
namespace TxDataPollCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataPollCount::Id; }
};
} // namespace TxDataPollCount
namespace TxBeaconCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconCount::Id; }
};
} // namespace TxBeaconCount
namespace TxBeaconRequestCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconRequestCount::Id; }
};
} // namespace TxBeaconRequestCount
namespace TxOtherCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxOtherCount::Id; }
};
} // namespace TxOtherCount
namespace TxRetryCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxRetryCount::Id; }
};
} // namespace TxRetryCount
namespace TxDirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDirectMaxRetryExpiryCount::Id; }
};
} // namespace TxDirectMaxRetryExpiryCount
namespace TxIndirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxIndirectMaxRetryExpiryCount::Id; }
};
} // namespace TxIndirectMaxRetryExpiryCount
namespace TxErrCcaCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCcaCount::Id; }
};
} // namespace TxErrCcaCount
namespace TxErrAbortCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrAbortCount::Id; }
};
} // namespace TxErrAbortCount
namespace TxErrBusyChannelCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrBusyChannelCount::Id; }
};
} // namespace TxErrBusyChannelCount
namespace RxTotalCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxTotalCount::Id; }
};
} // namespace RxTotalCount
namespace RxUnicastCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxUnicastCount::Id; }
};
} // namespace RxUnicastCount
namespace RxBroadcastCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBroadcastCount::Id; }
};
} // namespace RxBroadcastCount
namespace RxDataCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataCount::Id; }
};
} // namespace RxDataCount
namespace RxDataPollCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataPollCount::Id; }
};
} // namespace RxDataPollCount
namespace RxBeaconCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconCount::Id; }
};
} // namespace RxBeaconCount
namespace RxBeaconRequestCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconRequestCount::Id; }
};
} // namespace RxBeaconRequestCount
namespace RxOtherCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxOtherCount::Id; }
};
} // namespace RxOtherCount
namespace RxAddressFilteredCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxAddressFilteredCount::Id; }
};
} // namespace RxAddressFilteredCount
namespace RxDestAddrFilteredCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDestAddrFilteredCount::Id; }
};
} // namespace RxDestAddrFilteredCount
namespace RxDuplicatedCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDuplicatedCount::Id; }
};
} // namespace RxDuplicatedCount
namespace RxErrNoFrameCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrNoFrameCount::Id; }
};
} // namespace RxErrNoFrameCount
namespace RxErrUnknownNeighborCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrUnknownNeighborCount::Id; }
};
} // namespace RxErrUnknownNeighborCount
namespace RxErrInvalidSrcAddrCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrInvalidSrcAddrCount::Id; }
};
} // namespace RxErrInvalidSrcAddrCount
namespace RxErrSecCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrSecCount::Id; }
};
} // namespace RxErrSecCount
namespace RxErrFcsCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrFcsCount::Id; }
};
} // namespace RxErrFcsCount
namespace RxErrOtherCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrOtherCount::Id; }
};
} // namespace RxErrOtherCount
namespace ActiveTimestamp {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveTimestamp::Id; }
};
} // namespace ActiveTimestamp
namespace PendingTimestamp {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PendingTimestamp::Id; }
};
} // namespace PendingTimestamp
namespace Delay {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Delay::Id; }
};
} // namespace Delay
namespace SecurityPolicy {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::SecurityPolicy::Type>;
    using DecodableType = DataModel::DecodableList<Structs::SecurityPolicy::DecodableType>;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityPolicy::Id; }
};
} // namespace SecurityPolicy
namespace ChannelMask {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelMask::Id; }
};
} // namespace ChannelMask
namespace OperationalDatasetComponents {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::OperationalDatasetComponents::Type>;
    using DecodableType = DataModel::DecodableList<Structs::OperationalDatasetComponents::DecodableType>;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalDatasetComponents::Id; }
};
} // namespace OperationalDatasetComponents
namespace ActiveNetworkFaultsList {
struct TypeInfo
{
    using Type          = DataModel::List<NetworkFault>;
    using DecodableType = DataModel::DecodableList<NetworkFault>;

    static constexpr ClusterId GetClusterId() { return ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaultsList::Id; }
};
} // namespace ActiveNetworkFaultsList
} // namespace Attributes
} // namespace ThreadNetworkDiagnostics
namespace WiFiNetworkDiagnostics {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SecurityType
enum class SecurityType : uint8_t
{
    kUnspecified = 0x00,
    kNone        = 0x01,
    kWep         = 0x02,
    kWpa         = 0x03,
    kWpa2        = 0x04,
    kWpa3        = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SecurityType                         = EmberAfSecurityType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for WiFiVersionType
enum class WiFiVersionType : uint8_t
{
    k80211a  = 0x00,
    k80211b  = 0x01,
    k80211g  = 0x02,
    k80211n  = 0x03,
    k80211ac = 0x04,
    k80211ax = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using WiFiVersionType                      = EmberAfWiFiVersionType;
#endif

namespace Commands {
namespace ResetCounts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {
namespace Bssid {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bssid::Id; }
};
} // namespace Bssid
namespace SecurityType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityType::Id; }
};
} // namespace SecurityType
namespace WiFiVersion {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiFiVersion::Id; }
};
} // namespace WiFiVersion
namespace ChannelNumber {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelNumber::Id; }
};
} // namespace ChannelNumber
namespace Rssi {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Rssi::Id; }
};
} // namespace Rssi
namespace BeaconLostCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconLostCount::Id; }
};
} // namespace BeaconLostCount
namespace BeaconRxCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconRxCount::Id; }
};
} // namespace BeaconRxCount
namespace PacketMulticastRxCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastRxCount::Id; }
};
} // namespace PacketMulticastRxCount
namespace PacketMulticastTxCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastTxCount::Id; }
};
} // namespace PacketMulticastTxCount
namespace PacketUnicastRxCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastRxCount::Id; }
};
} // namespace PacketUnicastRxCount
namespace PacketUnicastTxCount {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastTxCount::Id; }
};
} // namespace PacketUnicastTxCount
namespace CurrentMaxRate {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMaxRate::Id; }
};
} // namespace CurrentMaxRate
namespace OverrunCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
};
} // namespace OverrunCount
} // namespace Attributes
} // namespace WiFiNetworkDiagnostics
namespace EthernetNetworkDiagnostics {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for PHYRateType
enum class PHYRateType : uint8_t
{
    k10m   = 0x00,
    k100m  = 0x01,
    k1000m = 0x02,
    k25g   = 0x03,
    k5g    = 0x04,
    k10g   = 0x05,
    k40g   = 0x06,
    k100g  = 0x07,
    k200g  = 0x08,
    k400g  = 0x09,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using PHYRateType                          = EmberAfPHYRateType;
#endif

namespace Commands {
namespace ResetCounts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {
namespace PHYRate {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PHYRate::Id; }
};
} // namespace PHYRate
namespace FullDuplex {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FullDuplex::Id; }
};
} // namespace FullDuplex
namespace PacketRxCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketRxCount::Id; }
};
} // namespace PacketRxCount
namespace PacketTxCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketTxCount::Id; }
};
} // namespace PacketTxCount
namespace TxErrCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCount::Id; }
};
} // namespace TxErrCount
namespace CollisionCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CollisionCount::Id; }
};
} // namespace CollisionCount
namespace OverrunCount {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
};
} // namespace OverrunCount
namespace CarrierDetect {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CarrierDetect::Id; }
};
} // namespace CarrierDetect
namespace TimeSinceReset {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeSinceReset::Id; }
};
} // namespace TimeSinceReset
} // namespace Attributes
} // namespace EthernetNetworkDiagnostics
namespace BridgedDeviceBasic {

namespace Commands {
namespace StartUp {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartUp
namespace ShutDown {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShutDown
namespace Leave {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Leave::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Leave::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Leave
namespace ReachableChanged {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReachableChanged
} // namespace Commands

namespace Attributes {
namespace VendorName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
};
} // namespace ProductName
namespace UserLabel {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserLabel::Id; }
};
} // namespace UserLabel
namespace HardwareVersion {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
};
} // namespace SerialNumber
namespace Reachable {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
};
} // namespace Reachable
} // namespace Attributes
} // namespace BridgedDeviceBasic
namespace Switch {

namespace Attributes {
namespace NumberOfPositions {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPositions::Id; }
};
} // namespace NumberOfPositions
namespace CurrentPosition {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPosition::Id; }
};
} // namespace CurrentPosition
namespace MultiPressMax {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MultiPressMax::Id; }
};
} // namespace MultiPressMax
} // namespace Attributes
} // namespace Switch
namespace AdministratorCommissioning {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for StatusCode
enum class StatusCode : uint8_t
{
    kSuccess      = 0x00,
    kBusy         = 0x01,
    kGeneralError = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using StatusCode                           = EmberAfStatusCode;
#endif

namespace Commands {
namespace OpenCommissioningWindow {
enum class Fields
{
    kCommissioningTimeout = 0,
    kPAKEVerifier         = 1,
    kDiscriminator        = 2,
    kIterations           = 3,
    kSalt                 = 4,
    kPasscodeID           = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;
    chip::ByteSpan PAKEVerifier;
    uint16_t discriminator;
    uint32_t iterations;
    chip::ByteSpan salt;
    uint16_t passcodeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;
    chip::ByteSpan PAKEVerifier;
    uint16_t discriminator;
    uint32_t iterations;
    chip::ByteSpan salt;
    uint16_t passcodeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenCommissioningWindow
namespace OpenBasicCommissioningWindow {
enum class Fields
{
    kCommissioningTimeout = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenBasicCommissioningWindow
namespace RevokeCommissioning {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return AdministratorCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return AdministratorCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RevokeCommissioning
} // namespace Commands

} // namespace AdministratorCommissioning
namespace OperationalCredentials {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NodeOperationalCertStatus
enum class NodeOperationalCertStatus : uint8_t
{
    kSuccess               = 0x00,
    kInvalidPublicKey      = 0x01,
    kInvalidNodeOpId       = 0x02,
    kInvalidNOC            = 0x03,
    kMissingCsr            = 0x04,
    kTableFull             = 0x05,
    kInsufficientPrivilege = 0x08,
    kFabricConflict        = 0x09,
    kLabelConflict         = 0x0A,
    kInvalidFabricIndex    = 0x0B,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NodeOperationalCertStatus            = EmberAfNodeOperationalCertStatus;
#endif

namespace Structs {
namespace FabricDescriptor {
enum class Fields
{
    kFabricIndex   = 0,
    kRootPublicKey = 1,
    kVendorId      = 2,
    kFabricId      = 3,
    kNodeId        = 4,
    kLabel         = 5,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan rootPublicKey;
    uint16_t vendorId;
    chip::FabricId fabricId;
    chip::NodeId nodeId;
    chip::ByteSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace FabricDescriptor
namespace NOCStruct {
enum class Fields
{
    kFabricIndex = 0,
    kNoc         = 1,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan noc;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NOCStruct
} // namespace Structs

namespace Commands {
namespace AttestationRequest {
enum class Fields
{
    kAttestationNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationRequest
namespace AttestationResponse {
enum class Fields
{
    kAttestationElements = 0,
    kSignature           = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan signature;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan signature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationResponse
namespace CertificateChainRequest {
enum class Fields
{
    kCertificateType = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    uint8_t certificateType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    uint8_t certificateType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainRequest
namespace CertificateChainResponse {
enum class Fields
{
    kCertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan certificate;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan certificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainResponse
namespace OpCSRRequest {
enum class Fields
{
    kCSRNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OpCSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OpCSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpCSRRequest
namespace OpCSRResponse {
enum class Fields
{
    kNOCSRElements        = 0,
    kAttestationSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OpCSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OpCSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpCSRResponse
namespace AddNOC {
enum class Fields
{
    kNOCValue      = 0,
    kICACValue     = 1,
    kIPKValue      = 2,
    kCaseAdminNode = 3,
    kAdminVendorId = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    chip::ByteSpan ICACValue;
    chip::ByteSpan IPKValue;
    chip::NodeId caseAdminNode;
    uint16_t adminVendorId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    chip::ByteSpan ICACValue;
    chip::ByteSpan IPKValue;
    chip::NodeId caseAdminNode;
    uint16_t adminVendorId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddNOC
namespace UpdateNOC {
enum class Fields
{
    kNOCValue  = 0,
    kICACValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    chip::ByteSpan ICACValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    chip::ByteSpan ICACValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateNOC
namespace NOCResponse {
enum class Fields
{
    kStatusCode  = 0,
    kFabricIndex = 1,
    kDebugText   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    uint8_t statusCode;
    uint8_t fabricIndex;
    chip::ByteSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    uint8_t statusCode;
    uint8_t fabricIndex;
    chip::ByteSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NOCResponse
namespace UpdateFabricLabel {
enum class Fields
{
    kLabel = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::Span<const char> label;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::Span<const char> label;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateFabricLabel
namespace RemoveFabric {
enum class Fields
{
    kFabricIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    uint8_t fabricIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    uint8_t fabricIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveFabric
namespace AddTrustedRootCertificate {
enum class Fields
{
    kRootCertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan rootCertificate;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan rootCertificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddTrustedRootCertificate
namespace RemoveTrustedRootCertificate {
enum class Fields
{
    kTrustedRootIdentifier = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RemoveTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan trustedRootIdentifier;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RemoveTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }

    chip::ByteSpan trustedRootIdentifier;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveTrustedRootCertificate
} // namespace Commands

namespace Attributes {
namespace FabricsList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::FabricDescriptor::Type>;
    using DecodableType = DataModel::DecodableList<Structs::FabricDescriptor::DecodableType>;

    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FabricsList::Id; }
};
} // namespace FabricsList
namespace SupportedFabrics {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedFabrics::Id; }
};
} // namespace SupportedFabrics
namespace CommissionedFabrics {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CommissionedFabrics::Id; }
};
} // namespace CommissionedFabrics
namespace TrustedRootCertificates {
struct TypeInfo
{
    using Type          = DataModel::List<chip::ByteSpan>;
    using DecodableType = DataModel::DecodableList<chip::ByteSpan>;

    static constexpr ClusterId GetClusterId() { return OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TrustedRootCertificates::Id; }
};
} // namespace TrustedRootCertificates
} // namespace Attributes
} // namespace OperationalCredentials
namespace FixedLabel {

namespace Structs {
namespace LabelStruct {
enum class Fields
{
    kLabel = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::ByteSpan label;
    chip::ByteSpan value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace LabelStruct
} // namespace Structs

namespace Attributes {
namespace LabelList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::LabelStruct::Type>;
    using DecodableType = DataModel::DecodableList<Structs::LabelStruct::DecodableType>;

    static constexpr ClusterId GetClusterId() { return FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
};
} // namespace LabelList
} // namespace Attributes
} // namespace FixedLabel
namespace ShadeConfiguration {

namespace Attributes {
namespace PhysicalClosedLimit {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimit::Id; }
};
} // namespace PhysicalClosedLimit
namespace MotorStepSize {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MotorStepSize::Id; }
};
} // namespace MotorStepSize
namespace Status {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
};
} // namespace Status
namespace ClosedLimit {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClosedLimit::Id; }
};
} // namespace ClosedLimit
namespace Mode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mode::Id; }
};
} // namespace Mode
} // namespace Attributes
} // namespace ShadeConfiguration
namespace DoorLock {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockOperationEventCode
enum class DoorLockOperationEventCode : uint8_t
{
    kUnknownOrMfgSpecific  = 0x00,
    kLock                  = 0x01,
    kUnlock                = 0x02,
    kLockInvalidPinOrId    = 0x03,
    kLockInvalidSchedule   = 0x04,
    kUnlockInvalidPinOrId  = 0x05,
    kUnlockInvalidSchedule = 0x06,
    kOneTouchLock          = 0x07,
    kKeyLock               = 0x08,
    kKeyUnlock             = 0x09,
    kAutoLock              = 0x0A,
    kScheduleLock          = 0x0B,
    kScheduleUnlock        = 0x0C,
    kManualLock            = 0x0D,
    kManualUnlock          = 0x0E,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockOperationEventCode           = EmberAfDoorLockOperationEventCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockProgrammingEventCode
enum class DoorLockProgrammingEventCode : uint8_t
{
    kUnknownOrMfgSpecific = 0x00,
    kMasterCodeChanged    = 0x01,
    kPinAdded             = 0x02,
    kPinDeleted           = 0x03,
    kPinChanged           = 0x04,
    kIdAdded              = 0x05,
    kIdDeleted            = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockProgrammingEventCode         = EmberAfDoorLockProgrammingEventCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockSetPinOrIdStatus
enum class DoorLockSetPinOrIdStatus : uint8_t
{
    kSuccess            = 0x00,
    kGeneralFailure     = 0x01,
    kMemoryFull         = 0x02,
    kDuplicateCodeError = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockSetPinOrIdStatus             = EmberAfDoorLockSetPinOrIdStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockUserStatus
enum class DoorLockUserStatus : uint8_t
{
    kAvailable        = 0x00,
    kOccupiedEnabled  = 0x01,
    kOccupiedDisabled = 0x03,
    kNotSupported     = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockUserStatus                   = EmberAfDoorLockUserStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockUserType
enum class DoorLockUserType : uint8_t
{
    kUnrestricted        = 0x00,
    kYearDayScheduleUser = 0x01,
    kWeekDayScheduleUser = 0x02,
    kMasterUser          = 0x03,
    kNonAccessUser       = 0x04,
    kNotSupported        = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockUserType                     = EmberAfDoorLockUserType;
#endif

// Bitmap for DoorLockDayOfWeek
enum class DoorLockDayOfWeek : uint8_t
{
    kSunday    = 0,
    kMonday    = 1,
    kTuesday   = 2,
    kWednesday = 3,
    kThursday  = 4,
    kFriday    = 5,
    kSaturday  = 6,
};

namespace Commands {
namespace LockDoor {
enum class Fields
{
    kPin = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LockDoor
namespace LockDoorResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LockDoorResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LockDoorResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LockDoorResponse
namespace UnlockDoor {
enum class Fields
{
    kPin = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockDoor
namespace UnlockDoorResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UnlockDoorResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UnlockDoorResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockDoorResponse
namespace Toggle {
enum class Fields
{
    kPin = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    chip::Span<const char> pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    chip::Span<const char> pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Toggle
namespace ToggleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ToggleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ToggleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ToggleResponse
namespace UnlockWithTimeout {
enum class Fields
{
    kTimeoutInSeconds = 0,
    kPin              = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t timeoutInSeconds;
    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t timeoutInSeconds;
    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockWithTimeout
namespace UnlockWithTimeoutResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UnlockWithTimeoutResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UnlockWithTimeoutResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockWithTimeoutResponse
namespace GetLogRecord {
enum class Fields
{
    kLogIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetLogRecord::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t logIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetLogRecord::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t logIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLogRecord
namespace GetLogRecordResponse {
enum class Fields
{
    kLogEntryId         = 0,
    kTimestamp          = 1,
    kEventType          = 2,
    kSource             = 3,
    kEventIdOrAlarmCode = 4,
    kUserId             = 5,
    kPin                = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetLogRecordResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t logEntryId;
    uint32_t timestamp;
    uint8_t eventType;
    uint8_t source;
    uint8_t eventIdOrAlarmCode;
    uint16_t userId;
    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetLogRecordResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t logEntryId;
    uint32_t timestamp;
    uint8_t eventType;
    uint8_t source;
    uint8_t eventIdOrAlarmCode;
    uint16_t userId;
    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLogRecordResponse
namespace SetPin {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kPin        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetPin::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetPin::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetPin
namespace SetPinResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetPinResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    DoorLockSetPinOrIdStatus status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetPinResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    DoorLockSetPinOrIdStatus status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetPinResponse
namespace GetPin {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPin::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPin::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPin
namespace GetPinResponse {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kPin        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPinResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPinResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPinResponse
namespace ClearPin {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearPin::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearPin::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearPin
namespace ClearPinResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearPinResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearPinResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearPinResponse
namespace ClearAllPins {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearAllPins::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearAllPins::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAllPins
namespace ClearAllPinsResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearAllPinsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearAllPinsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAllPinsResponse
namespace SetUserStatus {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    uint8_t userStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    uint8_t userStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUserStatus
namespace SetUserStatusResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetUserStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetUserStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUserStatusResponse
namespace GetUserStatus {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserStatus
namespace GetUserStatusResponse {
enum class Fields
{
    kUserId = 0,
    kStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetUserStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetUserStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserStatusResponse
namespace SetWeekdaySchedule {
enum class Fields
{
    kScheduleId  = 0,
    kUserId      = 1,
    kDaysMask    = 2,
    kStartHour   = 3,
    kStartMinute = 4,
    kEndHour     = 5,
    kEndMinute   = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetWeekdaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    BitFlags<DoorLockDayOfWeek> daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetWeekdaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    BitFlags<DoorLockDayOfWeek> daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeekdaySchedule
namespace SetWeekdayScheduleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetWeekdayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetWeekdayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeekdayScheduleResponse
namespace GetWeekdaySchedule {
enum class Fields
{
    kScheduleId = 0,
    kUserId     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetWeekdaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetWeekdaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekdaySchedule
namespace GetWeekdayScheduleResponse {
enum class Fields
{
    kScheduleId  = 0,
    kUserId      = 1,
    kStatus      = 2,
    kDaysMask    = 3,
    kStartHour   = 4,
    kStartMinute = 5,
    kEndHour     = 6,
    kEndMinute   = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetWeekdayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    uint8_t status;
    uint8_t daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetWeekdayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    uint8_t status;
    uint8_t daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekdayScheduleResponse
namespace ClearWeekdaySchedule {
enum class Fields
{
    kScheduleId = 0,
    kUserId     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearWeekdaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearWeekdaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeekdaySchedule
namespace ClearWeekdayScheduleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearWeekdayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearWeekdayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeekdayScheduleResponse
namespace SetYeardaySchedule {
enum class Fields
{
    kScheduleId     = 0,
    kUserId         = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetYeardaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    uint32_t localStartTime;
    uint32_t localEndTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetYeardaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    uint32_t localStartTime;
    uint32_t localEndTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetYeardaySchedule
namespace SetYeardayScheduleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetYeardayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetYeardayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetYeardayScheduleResponse
namespace GetYeardaySchedule {
enum class Fields
{
    kScheduleId = 0,
    kUserId     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetYeardaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetYeardaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYeardaySchedule
namespace GetYeardayScheduleResponse {
enum class Fields
{
    kScheduleId     = 0,
    kUserId         = 1,
    kStatus         = 2,
    kLocalStartTime = 3,
    kLocalEndTime   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetYeardayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    uint8_t status;
    uint32_t localStartTime;
    uint32_t localEndTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetYeardayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    uint8_t status;
    uint32_t localStartTime;
    uint32_t localEndTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYeardayScheduleResponse
namespace ClearYeardaySchedule {
enum class Fields
{
    kScheduleId = 0,
    kUserId     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearYeardaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearYeardaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearYeardaySchedule
namespace ClearYeardayScheduleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearYeardayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearYeardayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearYeardayScheduleResponse
namespace SetHolidaySchedule {
enum class Fields
{
    kScheduleId                 = 0,
    kLocalStartTime             = 1,
    kLocalEndTime               = 2,
    kOperatingModeDuringHoliday = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint32_t localStartTime;
    uint32_t localEndTime;
    uint8_t operatingModeDuringHoliday;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint32_t localStartTime;
    uint32_t localEndTime;
    uint8_t operatingModeDuringHoliday;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetHolidaySchedule
namespace SetHolidayScheduleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetHolidayScheduleResponse
namespace GetHolidaySchedule {
enum class Fields
{
    kScheduleId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidaySchedule
namespace GetHolidayScheduleResponse {
enum class Fields
{
    kScheduleId                 = 0,
    kStatus                     = 1,
    kLocalStartTime             = 2,
    kLocalEndTime               = 3,
    kOperatingModeDuringHoliday = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint8_t status;
    uint32_t localStartTime;
    uint32_t localEndTime;
    uint8_t operatingModeDuringHoliday;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    uint8_t status;
    uint32_t localStartTime;
    uint32_t localEndTime;
    uint8_t operatingModeDuringHoliday;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidayScheduleResponse
namespace ClearHolidaySchedule {
enum class Fields
{
    kScheduleId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t scheduleId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearHolidaySchedule
namespace ClearHolidayScheduleResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearHolidayScheduleResponse
namespace SetUserType {
enum class Fields
{
    kUserId   = 0,
    kUserType = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserType userType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserType userType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUserType
namespace SetUserTypeResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetUserTypeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetUserTypeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUserTypeResponse
namespace GetUserType {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserType
namespace GetUserTypeResponse {
enum class Fields
{
    kUserId   = 0,
    kUserType = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetUserTypeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserType userType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetUserTypeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserType userType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserTypeResponse
namespace SetRfid {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kId         = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetRfid::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan id;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetRfid::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan id;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRfid
namespace SetRfidResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetRfidResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    DoorLockSetPinOrIdStatus status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetRfidResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    DoorLockSetPinOrIdStatus status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRfidResponse
namespace GetRfid {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetRfid::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetRfid::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRfid
namespace GetRfidResponse {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kRfid       = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetRfidResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan rfid;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetRfidResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    DoorLockUserStatus userStatus;
    DoorLockUserType userType;
    chip::ByteSpan rfid;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRfidResponse
namespace ClearRfid {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearRfid::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearRfid::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearRfid
namespace ClearRfidResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearRfidResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearRfidResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearRfidResponse
namespace ClearAllRfids {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearAllRfids::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearAllRfids::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAllRfids
namespace ClearAllRfidsResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearAllRfidsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearAllRfidsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAllRfidsResponse
namespace OperationEventNotification {
enum class Fields
{
    kSource    = 0,
    kEventCode = 1,
    kUserId    = 2,
    kPin       = 3,
    kTimeStamp = 4,
    kData      = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return OperationEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t source;
    DoorLockOperationEventCode eventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    uint32_t timeStamp;
    chip::Span<const char> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return OperationEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t source;
    DoorLockOperationEventCode eventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    uint32_t timeStamp;
    chip::Span<const char> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationEventNotification
namespace ProgrammingEventNotification {
enum class Fields
{
    kSource     = 0,
    kEventCode  = 1,
    kUserId     = 2,
    kPin        = 3,
    kUserType   = 4,
    kUserStatus = 5,
    kTimeStamp  = 6,
    kData       = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ProgrammingEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t source;
    DoorLockProgrammingEventCode eventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    DoorLockUserType userType;
    DoorLockUserStatus userStatus;
    uint32_t timeStamp;
    chip::Span<const char> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ProgrammingEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }

    uint8_t source;
    DoorLockProgrammingEventCode eventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    DoorLockUserType userType;
    DoorLockUserStatus userStatus;
    uint32_t timeStamp;
    chip::Span<const char> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProgrammingEventNotification
} // namespace Commands

namespace Attributes {
namespace LockState {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockState::Id; }
};
} // namespace LockState
namespace LockType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockType::Id; }
};
} // namespace LockType
namespace ActuatorEnabled {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActuatorEnabled::Id; }
};
} // namespace ActuatorEnabled
namespace DoorState {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorState::Id; }
};
} // namespace DoorState
namespace DoorOpenEvents {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorOpenEvents::Id; }
};
} // namespace DoorOpenEvents
namespace DoorClosedEvents {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorClosedEvents::Id; }
};
} // namespace DoorClosedEvents
namespace OpenPeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OpenPeriod::Id; }
};
} // namespace OpenPeriod
namespace NumLockRecordsSupported {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumLockRecordsSupported::Id; }
};
} // namespace NumLockRecordsSupported
namespace NumTotalUsersSupported {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumTotalUsersSupported::Id; }
};
} // namespace NumTotalUsersSupported
namespace NumPinUsersSupported {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumPinUsersSupported::Id; }
};
} // namespace NumPinUsersSupported
namespace NumRfidUsersSupported {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumRfidUsersSupported::Id; }
};
} // namespace NumRfidUsersSupported
namespace NumWeekdaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumWeekdaySchedulesSupportedPerUser::Id; }
};
} // namespace NumWeekdaySchedulesSupportedPerUser
namespace NumYeardaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumYeardaySchedulesSupportedPerUser::Id; }
};
} // namespace NumYeardaySchedulesSupportedPerUser
namespace NumHolidaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumHolidaySchedulesSupportedPerUser::Id; }
};
} // namespace NumHolidaySchedulesSupportedPerUser
namespace MaxPinLength {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPinLength::Id; }
};
} // namespace MaxPinLength
namespace MinPinLength {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinPinLength::Id; }
};
} // namespace MinPinLength
namespace MaxRfidCodeLength {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxRfidCodeLength::Id; }
};
} // namespace MaxRfidCodeLength
namespace MinRfidCodeLength {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinRfidCodeLength::Id; }
};
} // namespace MinRfidCodeLength
namespace EnableLogging {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableLogging::Id; }
};
} // namespace EnableLogging
namespace Language {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Language::Id; }
};
} // namespace Language
namespace LedSettings {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LedSettings::Id; }
};
} // namespace LedSettings
namespace AutoRelockTime {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AutoRelockTime::Id; }
};
} // namespace AutoRelockTime
namespace SoundVolume {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoundVolume::Id; }
};
} // namespace SoundVolume
namespace OperatingMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperatingMode::Id; }
};
} // namespace OperatingMode
namespace SupportedOperatingModes {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedOperatingModes::Id; }
};
} // namespace SupportedOperatingModes
namespace DefaultConfigurationRegister {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultConfigurationRegister::Id; }
};
} // namespace DefaultConfigurationRegister
namespace EnableLocalProgramming {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableLocalProgramming::Id; }
};
} // namespace EnableLocalProgramming
namespace EnableOneTouchLocking {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableOneTouchLocking::Id; }
};
} // namespace EnableOneTouchLocking
namespace EnableInsideStatusLed {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableInsideStatusLed::Id; }
};
} // namespace EnableInsideStatusLed
namespace EnablePrivacyModeButton {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnablePrivacyModeButton::Id; }
};
} // namespace EnablePrivacyModeButton
namespace WrongCodeEntryLimit {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WrongCodeEntryLimit::Id; }
};
} // namespace WrongCodeEntryLimit
namespace UserCodeTemporaryDisableTime {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserCodeTemporaryDisableTime::Id; }
};
} // namespace UserCodeTemporaryDisableTime
namespace SendPinOverTheAir {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SendPinOverTheAir::Id; }
};
} // namespace SendPinOverTheAir
namespace RequirePinForRfOperation {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RequirePinForRfOperation::Id; }
};
} // namespace RequirePinForRfOperation
namespace ZigbeeSecurityLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZigbeeSecurityLevel::Id; }
};
} // namespace ZigbeeSecurityLevel
namespace AlarmMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmMask::Id; }
};
} // namespace AlarmMask
namespace KeypadOperationEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadOperationEventMask::Id; }
};
} // namespace KeypadOperationEventMask
namespace RfOperationEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RfOperationEventMask::Id; }
};
} // namespace RfOperationEventMask
namespace ManualOperationEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManualOperationEventMask::Id; }
};
} // namespace ManualOperationEventMask
namespace RfidOperationEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RfidOperationEventMask::Id; }
};
} // namespace RfidOperationEventMask
namespace KeypadProgrammingEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadProgrammingEventMask::Id; }
};
} // namespace KeypadProgrammingEventMask
namespace RfProgrammingEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RfProgrammingEventMask::Id; }
};
} // namespace RfProgrammingEventMask
namespace RfidProgrammingEventMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RfidProgrammingEventMask::Id; }
};
} // namespace RfidProgrammingEventMask
} // namespace Attributes
} // namespace DoorLock
namespace WindowCovering {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for WcEndProductType
enum class WcEndProductType : uint8_t
{
    kRollerShade               = 0x00,
    kRomanShade                = 0x01,
    kBalloonShade              = 0x02,
    kWovenWood                 = 0x03,
    kPleatedShade              = 0x04,
    kCellularShade             = 0x05,
    kLayeredShade              = 0x06,
    kLayeredShade2D            = 0x07,
    kSheerShade                = 0x08,
    kTiltOnlyInteriorBlind     = 0x09,
    kInteriorBlind             = 0x0A,
    kVerticalBlindStripCurtain = 0x0B,
    kInteriorVenetianBlind     = 0x0C,
    kExteriorVenetianBlind     = 0x0D,
    kLateralLeftCurtain        = 0x0E,
    kLateralRightCurtain       = 0x0F,
    kCentralCurtain            = 0x10,
    kRollerShutter             = 0x11,
    kExteriorVerticalScreen    = 0x12,
    kAwningTerracePatio        = 0x13,
    kAwningVerticalScreen      = 0x14,
    kTiltOnlyPergola           = 0x15,
    kSwingingShutter           = 0x16,
    kSlidingShutter            = 0x17,
    kUnknown                   = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using WcEndProductType                     = EmberAfWcEndProductType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for WcType
enum class WcType : uint8_t
{
    kRollershade               = 0x00,
    kRollershade2Motor         = 0x01,
    kRollershadeExterior       = 0x02,
    kRollershadeExterior2Motor = 0x03,
    kDrapery                   = 0x04,
    kAwning                    = 0x05,
    kShutter                   = 0x06,
    kTiltBlindTiltOnly         = 0x07,
    kTiltBlindLiftAndTilt      = 0x08,
    kProjectorScreen           = 0x09,
    kUnknown                   = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using WcType                               = EmberAfWcType;
#endif

// Bitmap for WcConfigStatus
enum class WcConfigStatus : uint8_t
{
    kOperational               = 0,
    kOnline                    = 1,
    kOpenAndUpCommandsReversed = 2,
    kLiftPositionAware         = 3,
    kTiltPositionAware         = 4,
    kLiftEncoderControlled     = 5,
    kTiltEncoderControlled     = 6,
};

// Bitmap for WcMode
enum class WcMode : uint8_t
{
    kMotorDirectionReversed = 0,
    kCalibrationMode        = 1,
    kMaintenanceMode        = 2,
    kLEDFeedback            = 3,
};

// Bitmap for WcOperationalStatus
enum class WcOperationalStatus : uint8_t
{
    kGlobal = 0,
    kLift   = 2,
    kTilt   = 4,
};

// Bitmap for WcSafetyStatus
enum class WcSafetyStatus : uint16_t
{
    kRemoteLockout       = 0,
    kTamperDetection     = 1,
    kFailedCommunication = 2,
    kPositionFailure     = 3,
    kThermalProtection   = 4,
    kObstacleDetected    = 5,
    kPower               = 6,
    kStopInput           = 7,
    kMotorJammed         = 8,
    kHardwareFailure     = 9,
    kManualOperation     = 10,
    kProtection          = 11,
};

namespace Commands {
namespace UpOrOpen {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpOrOpen
namespace DownOrClose {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DownOrClose
namespace StopMotion {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMotion
namespace GoToLiftValue {
enum class Fields
{
    kLiftValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint16_t liftValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint16_t liftValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftValue
namespace GoToLiftPercentage {
enum class Fields
{
    kLiftPercentageValue    = 0,
    kLiftPercent100thsValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint8_t liftPercentageValue;
    uint16_t liftPercent100thsValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint8_t liftPercentageValue;
    uint16_t liftPercent100thsValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftPercentage
namespace GoToTiltValue {
enum class Fields
{
    kTiltValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint16_t tiltValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint16_t tiltValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltValue
namespace GoToTiltPercentage {
enum class Fields
{
    kTiltPercentageValue    = 0,
    kTiltPercent100thsValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint8_t tiltPercentageValue;
    uint16_t tiltPercent100thsValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }

    uint8_t tiltPercentageValue;
    uint16_t tiltPercent100thsValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltPercentage
} // namespace Commands

namespace Attributes {
namespace Type {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Type::Id; }
};
} // namespace Type
namespace PhysicalClosedLimitLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitLift::Id; }
};
} // namespace PhysicalClosedLimitLift
namespace PhysicalClosedLimitTilt {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitTilt::Id; }
};
} // namespace PhysicalClosedLimitTilt
namespace CurrentPositionLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLift::Id; }
};
} // namespace CurrentPositionLift
namespace CurrentPositionTilt {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTilt::Id; }
};
} // namespace CurrentPositionTilt
namespace NumberOfActuationsLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsLift::Id; }
};
} // namespace NumberOfActuationsLift
namespace NumberOfActuationsTilt {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsTilt::Id; }
};
} // namespace NumberOfActuationsTilt
namespace ConfigStatus {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConfigStatus::Id; }
};
} // namespace ConfigStatus
namespace CurrentPositionLiftPercentage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercentage::Id; }
};
} // namespace CurrentPositionLiftPercentage
namespace CurrentPositionTiltPercentage {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercentage::Id; }
};
} // namespace CurrentPositionTiltPercentage
namespace OperationalStatus {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStatus::Id; }
};
} // namespace OperationalStatus
namespace TargetPositionLiftPercent100ths {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionLiftPercent100ths::Id; }
};
} // namespace TargetPositionLiftPercent100ths
namespace TargetPositionTiltPercent100ths {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionTiltPercent100ths::Id; }
};
} // namespace TargetPositionTiltPercent100ths
namespace EndProductType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndProductType::Id; }
};
} // namespace EndProductType
namespace CurrentPositionLiftPercent100ths {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercent100ths::Id; }
};
} // namespace CurrentPositionLiftPercent100ths
namespace CurrentPositionTiltPercent100ths {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercent100ths::Id; }
};
} // namespace CurrentPositionTiltPercent100ths
namespace InstalledOpenLimitLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitLift::Id; }
};
} // namespace InstalledOpenLimitLift
namespace InstalledClosedLimitLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitLift::Id; }
};
} // namespace InstalledClosedLimitLift
namespace InstalledOpenLimitTilt {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitTilt::Id; }
};
} // namespace InstalledOpenLimitTilt
namespace InstalledClosedLimitTilt {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitTilt::Id; }
};
} // namespace InstalledClosedLimitTilt
namespace VelocityLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VelocityLift::Id; }
};
} // namespace VelocityLift
namespace AccelerationTimeLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AccelerationTimeLift::Id; }
};
} // namespace AccelerationTimeLift
namespace DecelerationTimeLift {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DecelerationTimeLift::Id; }
};
} // namespace DecelerationTimeLift
namespace Mode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mode::Id; }
};
} // namespace Mode
namespace IntermediateSetpointsLift {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IntermediateSetpointsLift::Id; }
};
} // namespace IntermediateSetpointsLift
namespace IntermediateSetpointsTilt {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IntermediateSetpointsTilt::Id; }
};
} // namespace IntermediateSetpointsTilt
namespace SafetyStatus {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SafetyStatus::Id; }
};
} // namespace SafetyStatus
} // namespace Attributes
} // namespace WindowCovering
namespace BarrierControl {

namespace Commands {
namespace BarrierControlGoToPercent {
enum class Fields
{
    kPercentOpen = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return BarrierControlGoToPercent::Id; }
    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }

    uint8_t percentOpen;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return BarrierControlGoToPercent::Id; }
    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }

    uint8_t percentOpen;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BarrierControlGoToPercent
namespace BarrierControlStop {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return BarrierControlStop::Id; }
    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return BarrierControlStop::Id; }
    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BarrierControlStop
} // namespace Commands

namespace Attributes {
namespace BarrierMovingState {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierMovingState::Id; }
};
} // namespace BarrierMovingState
namespace BarrierSafetyStatus {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierSafetyStatus::Id; }
};
} // namespace BarrierSafetyStatus
namespace BarrierCapabilities {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCapabilities::Id; }
};
} // namespace BarrierCapabilities
namespace BarrierOpenEvents {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierOpenEvents::Id; }
};
} // namespace BarrierOpenEvents
namespace BarrierCloseEvents {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCloseEvents::Id; }
};
} // namespace BarrierCloseEvents
namespace BarrierCommandOpenEvents {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCommandOpenEvents::Id; }
};
} // namespace BarrierCommandOpenEvents
namespace BarrierCommandCloseEvents {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCommandCloseEvents::Id; }
};
} // namespace BarrierCommandCloseEvents
namespace BarrierOpenPeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierOpenPeriod::Id; }
};
} // namespace BarrierOpenPeriod
namespace BarrierClosePeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierClosePeriod::Id; }
};
} // namespace BarrierClosePeriod
namespace BarrierPosition {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierPosition::Id; }
};
} // namespace BarrierPosition
} // namespace Attributes
} // namespace BarrierControl
namespace PumpConfigurationAndControl {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for PumpControlMode
enum class PumpControlMode : uint8_t
{
    kConstantSpeed        = 0x00,
    kConstantPressure     = 0x01,
    kProportionalPressure = 0x02,
    kConstantFlow         = 0x03,
    kConstantTemperature  = 0x05,
    kAutomatic            = 0x07,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using PumpControlMode                      = EmberAfPumpControlMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for PumpOperationMode
enum class PumpOperationMode : uint8_t
{
    kNormal  = 0x00,
    kMinimum = 0x01,
    kMaximum = 0x02,
    kLocal   = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using PumpOperationMode                    = EmberAfPumpOperationMode;
#endif

// Bitmap for PumpStatus
enum class PumpStatus : uint16_t
{
    kDeviceFault       = 0,
    kSupplyfault       = 1,
    kSpeedLow          = 2,
    kSpeedHigh         = 3,
    kLocalOverride     = 4,
    kRunning           = 5,
    kRemotePressure    = 6,
    kRemoteFlow        = 7,
    kRemoteTemperature = 8,
};

namespace Attributes {
namespace MaxPressure {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPressure::Id; }
};
} // namespace MaxPressure
namespace MaxSpeed {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxSpeed::Id; }
};
} // namespace MaxSpeed
namespace MaxFlow {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFlow::Id; }
};
} // namespace MaxFlow
namespace MinConstPressure {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstPressure::Id; }
};
} // namespace MinConstPressure
namespace MaxConstPressure {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstPressure::Id; }
};
} // namespace MaxConstPressure
namespace MinCompPressure {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCompPressure::Id; }
};
} // namespace MinCompPressure
namespace MaxCompPressure {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCompPressure::Id; }
};
} // namespace MaxCompPressure
namespace MinConstSpeed {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstSpeed::Id; }
};
} // namespace MinConstSpeed
namespace MaxConstSpeed {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstSpeed::Id; }
};
} // namespace MaxConstSpeed
namespace MinConstFlow {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstFlow::Id; }
};
} // namespace MinConstFlow
namespace MaxConstFlow {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstFlow::Id; }
};
} // namespace MaxConstFlow
namespace MinConstTemp {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstTemp::Id; }
};
} // namespace MinConstTemp
namespace MaxConstTemp {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstTemp::Id; }
};
} // namespace MaxConstTemp
namespace PumpStatus {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PumpStatus::Id; }
};
} // namespace PumpStatus
namespace EffectiveOperationMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveOperationMode::Id; }
};
} // namespace EffectiveOperationMode
namespace EffectiveControlMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveControlMode::Id; }
};
} // namespace EffectiveControlMode
namespace Capacity {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Capacity::Id; }
};
} // namespace Capacity
namespace Speed {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Speed::Id; }
};
} // namespace Speed
namespace LifetimeRunningHours {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeRunningHours::Id; }
};
} // namespace LifetimeRunningHours
namespace Power {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Power::Id; }
};
} // namespace Power
namespace LifetimeEnergyConsumed {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeEnergyConsumed::Id; }
};
} // namespace LifetimeEnergyConsumed
namespace OperationMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationMode::Id; }
};
} // namespace OperationMode
namespace ControlMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlMode::Id; }
};
} // namespace ControlMode
namespace AlarmMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmMask::Id; }
};
} // namespace AlarmMask
} // namespace Attributes
} // namespace PumpConfigurationAndControl
namespace Thermostat {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SetpointAdjustMode
enum class SetpointAdjustMode : uint8_t
{
    kHeatSetpoint         = 0x00,
    kCoolSetpoint         = 0x01,
    kHeatAndCoolSetpoints = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SetpointAdjustMode                   = EmberAfSetpointAdjustMode;
#endif

// Bitmap for DayOfWeek
enum class DayOfWeek : uint8_t
{
    kSunday         = 0,
    kMonday         = 1,
    kTuesday        = 2,
    kWednesday      = 3,
    kThursday       = 4,
    kFriday         = 5,
    kSaturday       = 6,
    kAwayOrVacation = 7,
};

// Bitmap for ModeForSequence
enum class ModeForSequence : uint8_t
{
    kHeatSetpointFieldPresent = 0,
    kCoolSetpointFieldPresent = 1,
};

namespace Commands {
namespace SetpointRaiseLower {
enum class Fields
{
    kMode   = 0,
    kAmount = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    SetpointAdjustMode mode;
    int8_t amount;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    SetpointAdjustMode mode;
    int8_t amount;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetpointRaiseLower
namespace CurrentWeeklySchedule {
enum class Fields
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kPayload                        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CurrentWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    BitFlags<DayOfWeek> dayOfWeekForSequence;
    BitFlags<ModeForSequence> modeForSequence;
    DataModel::List<uint8_t> payload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CurrentWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    BitFlags<DayOfWeek> dayOfWeekForSequence;
    BitFlags<ModeForSequence> modeForSequence;
    DataModel::DecodableList<uint8_t> payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CurrentWeeklySchedule
namespace SetWeeklySchedule {
enum class Fields
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kPayload                        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    BitFlags<DayOfWeek> dayOfWeekForSequence;
    BitFlags<ModeForSequence> modeForSequence;
    DataModel::List<uint8_t> payload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    BitFlags<DayOfWeek> dayOfWeekForSequence;
    BitFlags<ModeForSequence> modeForSequence;
    DataModel::DecodableList<uint8_t> payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeeklySchedule
namespace RelayStatusLog {
enum class Fields
{
    kTimeOfDay            = 0,
    kRelayStatus          = 1,
    kLocalTemperature     = 2,
    kHumidityInPercentage = 3,
    kSetpoint             = 4,
    kUnreadEntries        = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RelayStatusLog::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    uint16_t timeOfDay;
    uint16_t relayStatus;
    int16_t localTemperature;
    uint8_t humidityInPercentage;
    int16_t setpoint;
    uint16_t unreadEntries;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RelayStatusLog::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    uint16_t timeOfDay;
    uint16_t relayStatus;
    int16_t localTemperature;
    uint8_t humidityInPercentage;
    int16_t setpoint;
    uint16_t unreadEntries;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RelayStatusLog
namespace GetWeeklySchedule {
enum class Fields
{
    kDaysToReturn = 0,
    kModeToReturn = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    BitFlags<DayOfWeek> daysToReturn;
    BitFlags<ModeForSequence> modeToReturn;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    BitFlags<DayOfWeek> daysToReturn;
    BitFlags<ModeForSequence> modeToReturn;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklySchedule
namespace ClearWeeklySchedule {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeeklySchedule
namespace GetRelayStatusLog {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetRelayStatusLog::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetRelayStatusLog::Id; }
    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRelayStatusLog
} // namespace Commands

namespace Attributes {
namespace LocalTemperature {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperature::Id; }
};
} // namespace LocalTemperature
namespace OutdoorTemperature {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutdoorTemperature::Id; }
};
} // namespace OutdoorTemperature
namespace Occupancy {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
};
} // namespace Occupancy
namespace AbsMinHeatSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinHeatSetpointLimit::Id; }
};
} // namespace AbsMinHeatSetpointLimit
namespace AbsMaxHeatSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxHeatSetpointLimit::Id; }
};
} // namespace AbsMaxHeatSetpointLimit
namespace AbsMinCoolSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinCoolSetpointLimit::Id; }
};
} // namespace AbsMinCoolSetpointLimit
namespace AbsMaxCoolSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxCoolSetpointLimit::Id; }
};
} // namespace AbsMaxCoolSetpointLimit
namespace PiCoolingDemand {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PiCoolingDemand::Id; }
};
} // namespace PiCoolingDemand
namespace PiHeatingDemand {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PiHeatingDemand::Id; }
};
} // namespace PiHeatingDemand
namespace HvacSystemTypeConfiguration {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HvacSystemTypeConfiguration::Id; }
};
} // namespace HvacSystemTypeConfiguration
namespace LocalTemperatureCalibration {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperatureCalibration::Id; }
};
} // namespace LocalTemperatureCalibration
namespace OccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedCoolingSetpoint::Id; }
};
} // namespace OccupiedCoolingSetpoint
namespace OccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedHeatingSetpoint::Id; }
};
} // namespace OccupiedHeatingSetpoint
namespace UnoccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedCoolingSetpoint::Id; }
};
} // namespace UnoccupiedCoolingSetpoint
namespace UnoccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedHeatingSetpoint::Id; }
};
} // namespace UnoccupiedHeatingSetpoint
namespace MinHeatSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinHeatSetpointLimit::Id; }
};
} // namespace MinHeatSetpointLimit
namespace MaxHeatSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxHeatSetpointLimit::Id; }
};
} // namespace MaxHeatSetpointLimit
namespace MinCoolSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCoolSetpointLimit::Id; }
};
} // namespace MinCoolSetpointLimit
namespace MaxCoolSetpointLimit {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCoolSetpointLimit::Id; }
};
} // namespace MaxCoolSetpointLimit
namespace MinSetpointDeadBand {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinSetpointDeadBand::Id; }
};
} // namespace MinSetpointDeadBand
namespace RemoteSensing {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemoteSensing::Id; }
};
} // namespace RemoteSensing
namespace ControlSequenceOfOperation {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlSequenceOfOperation::Id; }
};
} // namespace ControlSequenceOfOperation
namespace SystemMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SystemMode::Id; }
};
} // namespace SystemMode
namespace AlarmMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmMask::Id; }
};
} // namespace AlarmMask
namespace ThermostatRunningMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningMode::Id; }
};
} // namespace ThermostatRunningMode
namespace StartOfWeek {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartOfWeek::Id; }
};
} // namespace StartOfWeek
namespace NumberOfWeeklyTransitions {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeeklyTransitions::Id; }
};
} // namespace NumberOfWeeklyTransitions
namespace NumberOfDailyTransitions {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfDailyTransitions::Id; }
};
} // namespace NumberOfDailyTransitions
namespace TemperatureSetpointHold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHold::Id; }
};
} // namespace TemperatureSetpointHold
namespace TemperatureSetpointHoldDuration {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHoldDuration::Id; }
};
} // namespace TemperatureSetpointHoldDuration
namespace ThermostatProgrammingOperationMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatProgrammingOperationMode::Id; }
};
} // namespace ThermostatProgrammingOperationMode
namespace HvacRelayState {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HvacRelayState::Id; }
};
} // namespace HvacRelayState
namespace SetpointChangeSource {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSource::Id; }
};
} // namespace SetpointChangeSource
namespace SetpointChangeAmount {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeAmount::Id; }
};
} // namespace SetpointChangeAmount
namespace SetpointChangeSourceTimestamp {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSourceTimestamp::Id; }
};
} // namespace SetpointChangeSourceTimestamp
namespace AcType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcType::Id; }
};
} // namespace AcType
namespace AcCapacity {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCapacity::Id; }
};
} // namespace AcCapacity
namespace AcRefrigerantType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcRefrigerantType::Id; }
};
} // namespace AcRefrigerantType
namespace AcCompressor {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCompressor::Id; }
};
} // namespace AcCompressor
namespace AcErrorCode {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcErrorCode::Id; }
};
} // namespace AcErrorCode
namespace AcLouverPosition {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcLouverPosition::Id; }
};
} // namespace AcLouverPosition
namespace AcCoilTemperature {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCoilTemperature::Id; }
};
} // namespace AcCoilTemperature
namespace AcCapacityFormat {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCapacityFormat::Id; }
};
} // namespace AcCapacityFormat
} // namespace Attributes
} // namespace Thermostat
namespace FanControl {

namespace Attributes {
namespace FanMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanMode::Id; }
};
} // namespace FanMode
namespace FanModeSequence {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanModeSequence::Id; }
};
} // namespace FanModeSequence
} // namespace Attributes
} // namespace FanControl
namespace DehumidificationControl {

namespace Attributes {
namespace RelativeHumidity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RelativeHumidity::Id; }
};
} // namespace RelativeHumidity
namespace DehumidificationCooling {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationCooling::Id; }
};
} // namespace DehumidificationCooling
namespace RhDehumidificationSetpoint {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RhDehumidificationSetpoint::Id; }
};
} // namespace RhDehumidificationSetpoint
namespace RelativeHumidityMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RelativeHumidityMode::Id; }
};
} // namespace RelativeHumidityMode
namespace DehumidificationLockout {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationLockout::Id; }
};
} // namespace DehumidificationLockout
namespace DehumidificationHysteresis {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationHysteresis::Id; }
};
} // namespace DehumidificationHysteresis
namespace DehumidificationMaxCool {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationMaxCool::Id; }
};
} // namespace DehumidificationMaxCool
namespace RelativeHumidityDisplay {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RelativeHumidityDisplay::Id; }
};
} // namespace RelativeHumidityDisplay
} // namespace Attributes
} // namespace DehumidificationControl
namespace ThermostatUserInterfaceConfiguration {

namespace Attributes {
namespace TemperatureDisplayMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureDisplayMode::Id; }
};
} // namespace TemperatureDisplayMode
namespace KeypadLockout {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadLockout::Id; }
};
} // namespace KeypadLockout
namespace ScheduleProgrammingVisibility {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleProgrammingVisibility::Id; }
};
} // namespace ScheduleProgrammingVisibility
} // namespace Attributes
} // namespace ThermostatUserInterfaceConfiguration
namespace ColorControl {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ColorLoopAction
enum class ColorLoopAction : uint8_t
{
    kDeactivate                            = 0x00,
    kActivateFromColorLoopStartEnhancedHue = 0x01,
    kActivateFromEnhancedCurrentHue        = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ColorLoopAction                      = EmberAfColorLoopAction;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ColorLoopDirection
enum class ColorLoopDirection : uint8_t
{
    kDecrementHue = 0x00,
    kIncrementHue = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ColorLoopDirection                   = EmberAfColorLoopDirection;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ColorMode
enum class ColorMode : uint8_t
{
    kCurrentHueAndCurrentSaturation = 0x00,
    kCurrentXAndCurrentY            = 0x01,
    kColorTemperature               = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ColorMode                            = EmberAfColorMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HueDirection
enum class HueDirection : uint8_t
{
    kShortestDistance = 0x00,
    kLongestDistance  = 0x01,
    kUp               = 0x02,
    kDown             = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HueDirection                         = EmberAfHueDirection;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HueMoveMode
enum class HueMoveMode : uint8_t
{
    kStop = 0x00,
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HueMoveMode                          = EmberAfHueMoveMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HueStepMode
enum class HueStepMode : uint8_t
{
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HueStepMode                          = EmberAfHueStepMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SaturationMoveMode
enum class SaturationMoveMode : uint8_t
{
    kStop = 0x00,
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SaturationMoveMode                   = EmberAfSaturationMoveMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SaturationStepMode
enum class SaturationStepMode : uint8_t
{
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SaturationStepMode                   = EmberAfSaturationStepMode;
#endif

// Bitmap for ColorCapabilities
enum class ColorCapabilities : uint16_t
{
    kHueSaturationSupported    = 0,
    kEnhancedHueSupported      = 1,
    kColorLoopSupported        = 2,
    kXYAttributesSupported     = 3,
    kColorTemperatureSupported = 4,
};

// Bitmap for ColorLoopUpdateFlags
enum class ColorLoopUpdateFlags : uint8_t
{
    kUpdateAction    = 0,
    kUpdateDirection = 1,
    kUpdateTime      = 2,
    kUpdateStartHue  = 3,
};

namespace Commands {
namespace MoveToHue {
enum class Fields
{
    kHue             = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t hue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t hue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHue
namespace MoveHue {
enum class Fields
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveHue
namespace StepHue {
enum class Fields
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepHue
namespace MoveToSaturation {
enum class Fields
{
    kSaturation      = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToSaturation
namespace MoveSaturation {
enum class Fields
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    SaturationMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    SaturationMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveSaturation
namespace StepSaturation {
enum class Fields
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    SaturationStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    SaturationStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepSaturation
namespace MoveToHueAndSaturation {
enum class Fields
{
    kHue             = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t hue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t hue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHueAndSaturation
namespace MoveToColor {
enum class Fields
{
    kColorX          = 0,
    kColorY          = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t colorX;
    uint16_t colorY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t colorX;
    uint16_t colorY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColor
namespace MoveColor {
enum class Fields
{
    kRateX           = 0,
    kRateY           = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    int16_t rateX;
    int16_t rateY;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    int16_t rateX;
    int16_t rateY;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColor
namespace StepColor {
enum class Fields
{
    kStepX           = 0,
    kStepY           = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    int16_t stepX;
    int16_t stepY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    int16_t stepX;
    int16_t stepY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColor
namespace MoveToColorTemperature {
enum class Fields
{
    kColorTemperature = 0,
    kTransitionTime   = 1,
    kOptionsMask      = 2,
    kOptionsOverride  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t colorTemperature;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t colorTemperature;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColorTemperature
namespace EnhancedMoveToHue {
enum class Fields
{
    kEnhancedHue     = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t enhancedHue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t enhancedHue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHue
namespace EnhancedMoveHue {
enum class Fields
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveHue
namespace EnhancedStepHue {
enum class Fields
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedStepHue
namespace EnhancedMoveToHueAndSaturation {
enum class Fields
{
    kEnhancedHue     = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t enhancedHue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint16_t enhancedHue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHueAndSaturation
namespace ColorLoopSet {
enum class Fields
{
    kUpdateFlags     = 0,
    kAction          = 1,
    kDirection       = 2,
    kTime            = 3,
    kStartHue        = 4,
    kOptionsMask     = 5,
    kOptionsOverride = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    BitFlags<ColorLoopUpdateFlags> updateFlags;
    ColorLoopAction action;
    ColorLoopDirection direction;
    uint16_t time;
    uint16_t startHue;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    BitFlags<ColorLoopUpdateFlags> updateFlags;
    ColorLoopAction action;
    ColorLoopDirection direction;
    uint16_t time;
    uint16_t startHue;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ColorLoopSet
namespace StopMoveStep {
enum class Fields
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMoveStep
namespace MoveColorTemperature {
enum class Fields
{
    kMoveMode                = 0,
    kRate                    = 1,
    kColorTemperatureMinimum = 2,
    kColorTemperatureMaximum = 3,
    kOptionsMask             = 4,
    kOptionsOverride         = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColorTemperature
namespace StepColorTemperature {
enum class Fields
{
    kStepMode                = 0,
    kStepSize                = 1,
    kTransitionTime          = 2,
    kColorTemperatureMinimum = 3,
    kColorTemperatureMaximum = 4,
    kOptionsMask             = 5,
    kOptionsOverride         = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColorTemperature
} // namespace Commands

namespace Attributes {
namespace CurrentHue {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHue::Id; }
};
} // namespace CurrentHue
namespace CurrentSaturation {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSaturation::Id; }
};
} // namespace CurrentSaturation
namespace RemainingTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
};
} // namespace RemainingTime
namespace CurrentX {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentX::Id; }
};
} // namespace CurrentX
namespace CurrentY {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentY::Id; }
};
} // namespace CurrentY
namespace DriftCompensation {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DriftCompensation::Id; }
};
} // namespace DriftCompensation
namespace CompensationText {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompensationText::Id; }
};
} // namespace CompensationText
namespace ColorTemperature {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTemperature::Id; }
};
} // namespace ColorTemperature
namespace ColorMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorMode::Id; }
};
} // namespace ColorMode
namespace ColorControlOptions {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorControlOptions::Id; }
};
} // namespace ColorControlOptions
namespace NumberOfPrimaries {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPrimaries::Id; }
};
} // namespace NumberOfPrimaries
namespace Primary1X {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1X::Id; }
};
} // namespace Primary1X
namespace Primary1Y {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Y::Id; }
};
} // namespace Primary1Y
namespace Primary1Intensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Intensity::Id; }
};
} // namespace Primary1Intensity
namespace Primary2X {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2X::Id; }
};
} // namespace Primary2X
namespace Primary2Y {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Y::Id; }
};
} // namespace Primary2Y
namespace Primary2Intensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Intensity::Id; }
};
} // namespace Primary2Intensity
namespace Primary3X {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3X::Id; }
};
} // namespace Primary3X
namespace Primary3Y {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Y::Id; }
};
} // namespace Primary3Y
namespace Primary3Intensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Intensity::Id; }
};
} // namespace Primary3Intensity
namespace Primary4X {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4X::Id; }
};
} // namespace Primary4X
namespace Primary4Y {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Y::Id; }
};
} // namespace Primary4Y
namespace Primary4Intensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Intensity::Id; }
};
} // namespace Primary4Intensity
namespace Primary5X {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5X::Id; }
};
} // namespace Primary5X
namespace Primary5Y {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Y::Id; }
};
} // namespace Primary5Y
namespace Primary5Intensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Intensity::Id; }
};
} // namespace Primary5Intensity
namespace Primary6X {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6X::Id; }
};
} // namespace Primary6X
namespace Primary6Y {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Y::Id; }
};
} // namespace Primary6Y
namespace Primary6Intensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Intensity::Id; }
};
} // namespace Primary6Intensity
namespace WhitePointX {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointX::Id; }
};
} // namespace WhitePointX
namespace WhitePointY {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointY::Id; }
};
} // namespace WhitePointY
namespace ColorPointRX {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRX::Id; }
};
} // namespace ColorPointRX
namespace ColorPointRY {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRY::Id; }
};
} // namespace ColorPointRY
namespace ColorPointRIntensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRIntensity::Id; }
};
} // namespace ColorPointRIntensity
namespace ColorPointGX {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGX::Id; }
};
} // namespace ColorPointGX
namespace ColorPointGY {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGY::Id; }
};
} // namespace ColorPointGY
namespace ColorPointGIntensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGIntensity::Id; }
};
} // namespace ColorPointGIntensity
namespace ColorPointBX {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBX::Id; }
};
} // namespace ColorPointBX
namespace ColorPointBY {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBY::Id; }
};
} // namespace ColorPointBY
namespace ColorPointBIntensity {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBIntensity::Id; }
};
} // namespace ColorPointBIntensity
namespace EnhancedCurrentHue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedCurrentHue::Id; }
};
} // namespace EnhancedCurrentHue
namespace EnhancedColorMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedColorMode::Id; }
};
} // namespace EnhancedColorMode
namespace ColorLoopActive {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopActive::Id; }
};
} // namespace ColorLoopActive
namespace ColorLoopDirection {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopDirection::Id; }
};
} // namespace ColorLoopDirection
namespace ColorLoopTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopTime::Id; }
};
} // namespace ColorLoopTime
namespace ColorLoopStartEnhancedHue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStartEnhancedHue::Id; }
};
} // namespace ColorLoopStartEnhancedHue
namespace ColorLoopStoredEnhancedHue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStoredEnhancedHue::Id; }
};
} // namespace ColorLoopStoredEnhancedHue
namespace ColorCapabilities {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorCapabilities::Id; }
};
} // namespace ColorCapabilities
namespace ColorTempPhysicalMin {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMin::Id; }
};
} // namespace ColorTempPhysicalMin
namespace ColorTempPhysicalMax {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMax::Id; }
};
} // namespace ColorTempPhysicalMax
namespace CoupleColorTempToLevelMinMireds {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CoupleColorTempToLevelMinMireds::Id; }
};
} // namespace CoupleColorTempToLevelMinMireds
namespace StartUpColorTemperatureMireds {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpColorTemperatureMireds::Id; }
};
} // namespace StartUpColorTemperatureMireds
} // namespace Attributes
} // namespace ColorControl
namespace BallastConfiguration {

namespace Attributes {
namespace PhysicalMinLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMinLevel::Id; }
};
} // namespace PhysicalMinLevel
namespace PhysicalMaxLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMaxLevel::Id; }
};
} // namespace PhysicalMaxLevel
namespace BallastStatus {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastStatus::Id; }
};
} // namespace BallastStatus
namespace MinLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
};
} // namespace MaxLevel
namespace PowerOnLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerOnLevel::Id; }
};
} // namespace PowerOnLevel
namespace PowerOnFadeTime {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerOnFadeTime::Id; }
};
} // namespace PowerOnFadeTime
namespace IntrinsicBallastFactor {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IntrinsicBallastFactor::Id; }
};
} // namespace IntrinsicBallastFactor
namespace BallastFactorAdjustment {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastFactorAdjustment::Id; }
};
} // namespace BallastFactorAdjustment
namespace LampQuality {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampQuality::Id; }
};
} // namespace LampQuality
namespace LampType {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampType::Id; }
};
} // namespace LampType
namespace LampManufacturer {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampManufacturer::Id; }
};
} // namespace LampManufacturer
namespace LampRatedHours {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampRatedHours::Id; }
};
} // namespace LampRatedHours
namespace LampBurnHours {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHours::Id; }
};
} // namespace LampBurnHours
namespace LampAlarmMode {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampAlarmMode::Id; }
};
} // namespace LampAlarmMode
namespace LampBurnHoursTripPoint {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHoursTripPoint::Id; }
};
} // namespace LampBurnHoursTripPoint
} // namespace Attributes
} // namespace BallastConfiguration
namespace IlluminanceMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
namespace LightSensorType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LightSensorType::Id; }
};
} // namespace LightSensorType
} // namespace Attributes
} // namespace IlluminanceMeasurement
namespace IlluminanceLevelSensing {

namespace Attributes {
namespace LevelStatus {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceLevelSensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelStatus::Id; }
};
} // namespace LevelStatus
namespace LightSensorType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceLevelSensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LightSensorType::Id; }
};
} // namespace LightSensorType
namespace IlluminanceLevelTarget {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IlluminanceLevelSensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IlluminanceLevelTarget::Id; }
};
} // namespace IlluminanceLevelTarget
} // namespace Attributes
} // namespace IlluminanceLevelSensing
namespace TemperatureMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace TemperatureMeasurement
namespace PressureMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
namespace ScaledValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledValue::Id; }
};
} // namespace ScaledValue
namespace MinScaledValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinScaledValue::Id; }
};
} // namespace MinScaledValue
namespace MaxScaledValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxScaledValue::Id; }
};
} // namespace MaxScaledValue
namespace ScaledTolerance {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledTolerance::Id; }
};
} // namespace ScaledTolerance
namespace Scale {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Scale::Id; }
};
} // namespace Scale
} // namespace Attributes
} // namespace PressureMeasurement
namespace FlowMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace FlowMeasurement
namespace RelativeHumidityMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace RelativeHumidityMeasurement
namespace OccupancySensing {

namespace Attributes {
namespace Occupancy {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
};
} // namespace Occupancy
namespace OccupancySensorType {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorType::Id; }
};
} // namespace OccupancySensorType
namespace OccupancySensorTypeBitmap {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorTypeBitmap::Id; }
};
} // namespace OccupancySensorTypeBitmap
namespace PirOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PirOccupiedToUnoccupiedDelay::Id; }
};
} // namespace PirOccupiedToUnoccupiedDelay
namespace PirUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PirUnoccupiedToOccupiedDelay::Id; }
};
} // namespace PirUnoccupiedToOccupiedDelay
namespace PirUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PirUnoccupiedToOccupiedThreshold::Id; }
};
} // namespace PirUnoccupiedToOccupiedThreshold
namespace UltrasonicOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicOccupiedToUnoccupiedDelay::Id; }
};
} // namespace UltrasonicOccupiedToUnoccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedDelay::Id; }
};
} // namespace UltrasonicUnoccupiedToOccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedThreshold::Id; }
};
} // namespace UltrasonicUnoccupiedToOccupiedThreshold
namespace PhysicalContactOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactOccupiedToUnoccupiedDelay::Id; }
};
} // namespace PhysicalContactOccupiedToUnoccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedDelay::Id; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::Id; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedThreshold
} // namespace Attributes
} // namespace OccupancySensing
namespace CarbonMonoxideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace CarbonMonoxideConcentrationMeasurement
namespace CarbonDioxideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace CarbonDioxideConcentrationMeasurement
namespace EthyleneConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace EthyleneConcentrationMeasurement
namespace EthyleneOxideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace EthyleneOxideConcentrationMeasurement
namespace HydrogenConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace HydrogenConcentrationMeasurement
namespace HydrogenSulphideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace HydrogenSulphideConcentrationMeasurement
namespace NitricOxideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace NitricOxideConcentrationMeasurement
namespace NitrogenDioxideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace NitrogenDioxideConcentrationMeasurement
namespace OxygenConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace OxygenConcentrationMeasurement
namespace OzoneConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace OzoneConcentrationMeasurement
namespace SulfurDioxideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace SulfurDioxideConcentrationMeasurement
namespace DissolvedOxygenConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace DissolvedOxygenConcentrationMeasurement
namespace BromateConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace BromateConcentrationMeasurement
namespace ChloraminesConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace ChloraminesConcentrationMeasurement
namespace ChlorineConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace ChlorineConcentrationMeasurement
namespace FecalColiformAndEColiConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace FecalColiformAndEColiConcentrationMeasurement
namespace FluorideConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace FluorideConcentrationMeasurement
namespace HaloaceticAcidsConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace HaloaceticAcidsConcentrationMeasurement
namespace TotalTrihalomethanesConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace TotalTrihalomethanesConcentrationMeasurement
namespace TotalColiformBacteriaConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace TotalColiformBacteriaConcentrationMeasurement
namespace TurbidityConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace TurbidityConcentrationMeasurement
namespace CopperConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace CopperConcentrationMeasurement
namespace LeadConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace LeadConcentrationMeasurement
namespace ManganeseConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace ManganeseConcentrationMeasurement
namespace SulfateConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace SulfateConcentrationMeasurement
namespace BromodichloromethaneConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace BromodichloromethaneConcentrationMeasurement
namespace BromoformConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace BromoformConcentrationMeasurement
namespace ChlorodibromomethaneConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace ChlorodibromomethaneConcentrationMeasurement
namespace ChloroformConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace ChloroformConcentrationMeasurement
namespace SodiumConcentrationMeasurement {

namespace Attributes {
namespace MeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type          = float;
    using DecodableType = float;

    static constexpr ClusterId GetClusterId() { return SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
};
} // namespace Tolerance
} // namespace Attributes
} // namespace SodiumConcentrationMeasurement
namespace IasZone {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasEnrollResponseCode
enum class IasEnrollResponseCode : uint8_t
{
    kSuccess        = 0x00,
    kNotSupported   = 0x01,
    kNoEnrollPermit = 0x02,
    kTooManyZones   = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasEnrollResponseCode                = EmberAfIasEnrollResponseCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasZoneType
enum class IasZoneType : uint16_t
{
    kStandardCie             = 0x00,
    kMotionSensor            = 0x0D,
    kContactSwitch           = 0x15,
    kFireSensor              = 0x28,
    kWaterSensor             = 0x2A,
    kGasSensor               = 0x2B,
    kPersonalEmergencyDevice = 0x2C,
    kVibrationMovementSensor = 0x2D,
    kRemoteControl           = 0x10F,
    kKeyFob                  = 0x115,
    kKeypad                  = 0x21D,
    kStandardWarningDevice   = 0x225,
    kGlassBreakSensor        = 0x226,
    kCarbonMonoxideSensor    = 0x227,
    kSecurityRepeater        = 0x229,
    kInvalidZoneType         = 0xFFFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasZoneType                          = EmberAfIasZoneType;
#endif

// Bitmap for IasZoneStatus
enum class IasZoneStatus : uint16_t
{
    kAlarm1             = 0,
    kAlarm2             = 1,
    kTamper             = 2,
    kBattery            = 3,
    kSupervisionReports = 4,
    kRestoreReports     = 5,
    kTrouble            = 6,
    kAc                 = 7,
    kTest               = 8,
    kBatteryDefect      = 9,
};

namespace Commands {
namespace ZoneEnrollResponse {
enum class Fields
{
    kEnrollResponseCode = 0,
    kZoneId             = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ZoneEnrollResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    IasEnrollResponseCode enrollResponseCode;
    uint8_t zoneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ZoneEnrollResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    IasEnrollResponseCode enrollResponseCode;
    uint8_t zoneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneEnrollResponse
namespace ZoneStatusChangeNotification {
enum class Fields
{
    kZoneStatus     = 0,
    kExtendedStatus = 1,
    kZoneId         = 2,
    kDelay          = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ZoneStatusChangeNotification::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    BitFlags<IasZoneStatus> zoneStatus;
    uint8_t extendedStatus;
    uint8_t zoneId;
    uint16_t delay;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ZoneStatusChangeNotification::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    BitFlags<IasZoneStatus> zoneStatus;
    uint8_t extendedStatus;
    uint8_t zoneId;
    uint16_t delay;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneStatusChangeNotification
namespace InitiateNormalOperationMode {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return InitiateNormalOperationMode::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return InitiateNormalOperationMode::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateNormalOperationMode
namespace ZoneEnrollRequest {
enum class Fields
{
    kZoneType         = 0,
    kManufacturerCode = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ZoneEnrollRequest::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    IasZoneType zoneType;
    uint16_t manufacturerCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ZoneEnrollRequest::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    IasZoneType zoneType;
    uint16_t manufacturerCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneEnrollRequest
namespace InitiateTestMode {
enum class Fields
{
    kTestModeDuration            = 0,
    kCurrentZoneSensitivityLevel = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return InitiateTestMode::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    uint8_t testModeDuration;
    uint8_t currentZoneSensitivityLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return InitiateTestMode::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    uint8_t testModeDuration;
    uint8_t currentZoneSensitivityLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateTestMode
namespace InitiateNormalOperationModeResponse {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return InitiateNormalOperationModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return InitiateNormalOperationModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateNormalOperationModeResponse
namespace InitiateTestModeResponse {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return InitiateTestModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return InitiateTestModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasZone::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateTestModeResponse
} // namespace Commands

namespace Attributes {
namespace ZoneState {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneState::Id; }
};
} // namespace ZoneState
namespace ZoneType {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneType::Id; }
};
} // namespace ZoneType
namespace ZoneStatus {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneStatus::Id; }
};
} // namespace ZoneStatus
namespace IasCieAddress {
struct TypeInfo
{
    using Type          = chip::NodeId;
    using DecodableType = chip::NodeId;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IasCieAddress::Id; }
};
} // namespace IasCieAddress
namespace ZoneId {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneId::Id; }
};
} // namespace ZoneId
namespace NumberOfZoneSensitivityLevelsSupported {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfZoneSensitivityLevelsSupported::Id; }
};
} // namespace NumberOfZoneSensitivityLevelsSupported
namespace CurrentZoneSensitivityLevel {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentZoneSensitivityLevel::Id; }
};
} // namespace CurrentZoneSensitivityLevel
} // namespace Attributes
} // namespace IasZone
namespace IasAce {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasAceAlarmStatus
enum class IasAceAlarmStatus : uint8_t
{
    kNoAlarm        = 0x00,
    kBurglar        = 0x01,
    kFire           = 0x02,
    kEmergency      = 0x03,
    kPolicePanic    = 0x04,
    kFirePanic      = 0x05,
    kEmergencyPanic = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasAceAlarmStatus                    = EmberAfIasAceAlarmStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasAceArmMode
enum class IasAceArmMode : uint8_t
{
    kDisarm                 = 0x00,
    kArmDayHomeZonesOnly    = 0x01,
    kArmNightSleepZonesOnly = 0x02,
    kArmAllZones            = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasAceArmMode                        = EmberAfIasAceArmMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasAceArmNotification
enum class IasAceArmNotification : uint8_t
{
    kAllZonesDisarmed         = 0x00,
    kOnlyDayHomeZonesArmed    = 0x01,
    kOnlyNightSleepZonesArmed = 0x02,
    kAllZonesArmed            = 0x03,
    kInvalidArmDisarmCode     = 0x04,
    kNotReadyToArm            = 0x05,
    kAlreadyDisarmed          = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasAceArmNotification                = EmberAfIasAceArmNotification;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasAceAudibleNotification
enum class IasAceAudibleNotification : uint8_t
{
    kMute         = 0x00,
    kDefaultSound = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasAceAudibleNotification            = EmberAfIasAceAudibleNotification;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasAceBypassResult
enum class IasAceBypassResult : uint8_t
{
    kZoneBypassed         = 0x00,
    kZoneNotBypassed      = 0x01,
    kNotAllowed           = 0x02,
    kInvalidZoneId        = 0x03,
    kUnknownZoneId        = 0x04,
    kInvalidArmDisarmCode = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasAceBypassResult                   = EmberAfIasAceBypassResult;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasAcePanelStatus
enum class IasAcePanelStatus : uint8_t
{
    kPanelDisarmed = 0x00,
    kArmedStay     = 0x01,
    kArmedNight    = 0x02,
    kArmedAway     = 0x03,
    kExitDelay     = 0x04,
    kEntryDelay    = 0x05,
    kNotReadyToArm = 0x06,
    kInAlarm       = 0x07,
    kArmingStay    = 0x08,
    kArmingNight   = 0x09,
    kArmingAway    = 0x0A,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasAcePanelStatus                    = EmberAfIasAcePanelStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasZoneType
enum class IasZoneType : uint16_t
{
    kStandardCie             = 0x00,
    kMotionSensor            = 0x0D,
    kContactSwitch           = 0x15,
    kFireSensor              = 0x28,
    kWaterSensor             = 0x2A,
    kGasSensor               = 0x2B,
    kPersonalEmergencyDevice = 0x2C,
    kVibrationMovementSensor = 0x2D,
    kRemoteControl           = 0x10F,
    kKeyFob                  = 0x115,
    kKeypad                  = 0x21D,
    kStandardWarningDevice   = 0x225,
    kGlassBreakSensor        = 0x226,
    kCarbonMonoxideSensor    = 0x227,
    kSecurityRepeater        = 0x229,
    kInvalidZoneType         = 0xFFFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasZoneType                          = EmberAfIasZoneType;
#endif

// Bitmap for IasZoneStatus
enum class IasZoneStatus : uint16_t
{
    kAlarm1             = 0,
    kAlarm2             = 1,
    kTamper             = 2,
    kBattery            = 3,
    kSupervisionReports = 4,
    kRestoreReports     = 5,
    kTrouble            = 6,
    kAc                 = 7,
    kTest               = 8,
    kBatteryDefect      = 9,
};

namespace Structs {
namespace IasAceZoneStatusResult {
enum class Fields
{
    kZoneId     = 0,
    kZoneStatus = 1,
};

struct Type
{
public:
    uint8_t zoneId;
    BitFlags<IasZoneStatus> zoneStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace IasAceZoneStatusResult
} // namespace Structs

namespace Commands {
namespace Arm {
enum class Fields
{
    kArmMode       = 0,
    kArmDisarmCode = 1,
    kZoneId        = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Arm::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAceArmMode armMode;
    chip::Span<const char> armDisarmCode;
    uint8_t zoneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Arm::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAceArmMode armMode;
    chip::Span<const char> armDisarmCode;
    uint8_t zoneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Arm
namespace ArmResponse {
enum class Fields
{
    kArmNotification = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ArmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAceArmNotification armNotification;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ArmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAceArmNotification armNotification;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmResponse
namespace Bypass {
enum class Fields
{
    kNumberOfZones = 0,
    kZoneIds       = 1,
    kArmDisarmCode = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Bypass::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::List<uint8_t> zoneIds;
    chip::Span<const char> armDisarmCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Bypass::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::DecodableList<uint8_t> zoneIds;
    chip::Span<const char> armDisarmCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Bypass
namespace GetZoneIdMapResponse {
enum class Fields
{
    kSection0  = 0,
    kSection1  = 1,
    kSection2  = 2,
    kSection3  = 3,
    kSection4  = 4,
    kSection5  = 5,
    kSection6  = 6,
    kSection7  = 7,
    kSection8  = 8,
    kSection9  = 9,
    kSection10 = 10,
    kSection11 = 11,
    kSection12 = 12,
    kSection13 = 13,
    kSection14 = 14,
    kSection15 = 15,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetZoneIdMapResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint16_t section0;
    uint16_t section1;
    uint16_t section2;
    uint16_t section3;
    uint16_t section4;
    uint16_t section5;
    uint16_t section6;
    uint16_t section7;
    uint16_t section8;
    uint16_t section9;
    uint16_t section10;
    uint16_t section11;
    uint16_t section12;
    uint16_t section13;
    uint16_t section14;
    uint16_t section15;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetZoneIdMapResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint16_t section0;
    uint16_t section1;
    uint16_t section2;
    uint16_t section3;
    uint16_t section4;
    uint16_t section5;
    uint16_t section6;
    uint16_t section7;
    uint16_t section8;
    uint16_t section9;
    uint16_t section10;
    uint16_t section11;
    uint16_t section12;
    uint16_t section13;
    uint16_t section14;
    uint16_t section15;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneIdMapResponse
namespace Emergency {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Emergency::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Emergency::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Emergency
namespace GetZoneInformationResponse {
enum class Fields
{
    kZoneId      = 0,
    kZoneType    = 1,
    kIeeeAddress = 2,
    kZoneLabel   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetZoneInformationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t zoneId;
    IasZoneType zoneType;
    chip::NodeId ieeeAddress;
    chip::Span<const char> zoneLabel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetZoneInformationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t zoneId;
    IasZoneType zoneType;
    chip::NodeId ieeeAddress;
    chip::Span<const char> zoneLabel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneInformationResponse
namespace Fire {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Fire::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Fire::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Fire
namespace ZoneStatusChanged {
enum class Fields
{
    kZoneId              = 0,
    kZoneStatus          = 1,
    kAudibleNotification = 2,
    kZoneLabel           = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ZoneStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t zoneId;
    uint16_t zoneStatus;
    IasAceAudibleNotification audibleNotification;
    chip::Span<const char> zoneLabel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ZoneStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t zoneId;
    uint16_t zoneStatus;
    IasAceAudibleNotification audibleNotification;
    chip::Span<const char> zoneLabel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneStatusChanged
namespace Panic {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Panic::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Panic::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Panic
namespace PanelStatusChanged {
enum class Fields
{
    kPanelStatus         = 0,
    kSecondsRemaining    = 1,
    kAudibleNotification = 2,
    kAlarmStatus         = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return PanelStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return PanelStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PanelStatusChanged
namespace GetZoneIdMap {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetZoneIdMap::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetZoneIdMap::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneIdMap
namespace GetPanelStatusResponse {
enum class Fields
{
    kPanelStatus         = 0,
    kSecondsRemaining    = 1,
    kAudibleNotification = 2,
    kAlarmStatus         = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPanelStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPanelStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPanelStatusResponse
namespace GetZoneInformation {
enum class Fields
{
    kZoneId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetZoneInformation::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t zoneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetZoneInformation::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t zoneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneInformation
namespace SetBypassedZoneList {
enum class Fields
{
    kNumberOfZones = 0,
    kZoneIds       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::List<uint8_t> zoneIds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::DecodableList<uint8_t> zoneIds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetBypassedZoneList
namespace GetPanelStatus {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetPanelStatus::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetPanelStatus::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPanelStatus
namespace BypassResponse {
enum class Fields
{
    kNumberOfZones = 0,
    kBypassResult  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return BypassResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::List<IasAceBypassResult> bypassResult;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return BypassResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::DecodableList<IasAceBypassResult> bypassResult;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BypassResponse
namespace GetBypassedZoneList {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetBypassedZoneList
namespace GetZoneStatusResponse {
enum class Fields
{
    kZoneStatusComplete = 0,
    kNumberOfZones      = 1,
    kZoneStatusResult   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetZoneStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    bool zoneStatusComplete;
    uint8_t numberOfZones;
    DataModel::List<Structs::IasAceZoneStatusResult::Type> zoneStatusResult;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetZoneStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    bool zoneStatusComplete;
    uint8_t numberOfZones;
    DataModel::DecodableList<Structs::IasAceZoneStatusResult::DecodableType> zoneStatusResult;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneStatusResponse
namespace GetZoneStatus {
enum class Fields
{
    kStartingZoneId     = 0,
    kMaxNumberOfZoneIds = 1,
    kZoneStatusMaskFlag = 2,
    kZoneStatusMask     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t startingZoneId;
    uint8_t maxNumberOfZoneIds;
    bool zoneStatusMaskFlag;
    uint16_t zoneStatusMask;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return IasAce::Id; }

    uint8_t startingZoneId;
    uint8_t maxNumberOfZoneIds;
    bool zoneStatusMaskFlag;
    uint16_t zoneStatusMask;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneStatus
} // namespace Commands

} // namespace IasAce
namespace IasWd {

// Bitmap for SquawkInfo
enum class SquawkInfo : uint8_t
{
    kMode   = 4,
    kStrobe = 3,
    kLevel  = 0,
};

// Bitmap for WarningInfo
enum class WarningInfo : uint8_t
{
    kMode       = 4,
    kStrobe     = 2,
    kSirenLevel = 0,
};

namespace Commands {
namespace StartWarning {
enum class Fields
{
    kWarningInfo     = 0,
    kWarningDuration = 1,
    kStrobeDutyCycle = 2,
    kStrobeLevel     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StartWarning::Id; }
    static constexpr ClusterId GetClusterId() { return IasWd::Id; }

    BitFlags<WarningInfo> warningInfo;
    uint16_t warningDuration;
    uint8_t strobeDutyCycle;
    uint8_t strobeLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StartWarning::Id; }
    static constexpr ClusterId GetClusterId() { return IasWd::Id; }

    BitFlags<WarningInfo> warningInfo;
    uint16_t warningDuration;
    uint8_t strobeDutyCycle;
    uint8_t strobeLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartWarning
namespace Squawk {
enum class Fields
{
    kSquawkInfo = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Squawk::Id; }
    static constexpr ClusterId GetClusterId() { return IasWd::Id; }

    BitFlags<SquawkInfo> squawkInfo;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Squawk::Id; }
    static constexpr ClusterId GetClusterId() { return IasWd::Id; }

    BitFlags<SquawkInfo> squawkInfo;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Squawk
} // namespace Commands

namespace Attributes {
namespace MaxDuration {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return IasWd::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxDuration::Id; }
};
} // namespace MaxDuration
} // namespace Attributes
} // namespace IasWd
namespace WakeOnLan {

namespace Attributes {
namespace WakeOnLanMacAddress {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WakeOnLanMacAddress::Id; }
};
} // namespace WakeOnLanMacAddress
} // namespace Attributes
} // namespace WakeOnLan
namespace TvChannel {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for TvChannelErrorType
enum class TvChannelErrorType : uint8_t
{
    kMultipleMatches = 0x00,
    kNoMatches       = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using TvChannelErrorType                   = EmberAfTvChannelErrorType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for TvChannelLineupInfoType
enum class TvChannelLineupInfoType : uint8_t
{
    kMso = 0x00,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using TvChannelLineupInfoType              = EmberAfTvChannelLineupInfoType;
#endif

namespace Structs {
namespace TvChannelInfo {
enum class Fields
{
    kMajorNumber       = 0,
    kMinorNumber       = 1,
    kName              = 2,
    kCallSign          = 3,
    kAffiliateCallSign = 4,
};

struct Type
{
public:
    uint16_t majorNumber;
    uint16_t minorNumber;
    chip::ByteSpan name;
    chip::ByteSpan callSign;
    chip::ByteSpan affiliateCallSign;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TvChannelInfo
namespace TvChannelLineupInfo {
enum class Fields
{
    kOperatorName   = 0,
    kLineupName     = 1,
    kPostalCode     = 2,
    kLineupInfoType = 3,
};

struct Type
{
public:
    chip::Span<const char> operatorName;
    chip::Span<const char> lineupName;
    chip::Span<const char> postalCode;
    TvChannelLineupInfoType lineupInfoType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TvChannelLineupInfo
} // namespace Structs

namespace Commands {
namespace ChangeChannel {
enum class Fields
{
    kMatch = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    chip::Span<const char> match;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    chip::Span<const char> match;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannel
namespace ChangeChannelResponse {
enum class Fields
{
    kChannelMatch = 0,
    kErrorType    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    DataModel::List<Structs::TvChannelInfo::Type> channelMatch;
    TvChannelErrorType errorType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    DataModel::DecodableList<Structs::TvChannelInfo::DecodableType> channelMatch;
    TvChannelErrorType errorType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelResponse
namespace ChangeChannelByNumber {
enum class Fields
{
    kMajorNumber = 0,
    kMinorNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    uint16_t majorNumber;
    uint16_t minorNumber;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    uint16_t majorNumber;
    uint16_t minorNumber;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelByNumber
namespace SkipChannel {
enum class Fields
{
    kCount = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    uint16_t count;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }

    uint16_t count;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipChannel
} // namespace Commands

namespace Attributes {
namespace TvChannelList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::TvChannelInfo::Type>;
    using DecodableType = DataModel::DecodableList<Structs::TvChannelInfo::DecodableType>;

    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TvChannelList::Id; }
};
} // namespace TvChannelList
namespace TvChannelLineup {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TvChannelLineup::Id; }
};
} // namespace TvChannelLineup
namespace CurrentTvChannel {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return TvChannel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentTvChannel::Id; }
};
} // namespace CurrentTvChannel
} // namespace Attributes
} // namespace TvChannel
namespace TargetNavigator {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NavigateTargetStatus
enum class NavigateTargetStatus : uint8_t
{
    kSuccess         = 0x00,
    kAppNotAvailable = 0x01,
    kSystemBusy      = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NavigateTargetStatus                 = EmberAfNavigateTargetStatus;
#endif

namespace Structs {
namespace NavigateTargetTargetInfo {
enum class Fields
{
    kIdentifier = 0,
    kName       = 1,
};

struct Type
{
public:
    uint8_t identifier;
    chip::ByteSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NavigateTargetTargetInfo
} // namespace Structs

namespace Commands {
namespace NavigateTarget {
enum class Fields
{
    kTarget = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return TargetNavigator::Id; }

    uint8_t target;
    chip::Span<const char> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return TargetNavigator::Id; }

    uint8_t target;
    chip::Span<const char> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTarget
namespace NavigateTargetResponse {
enum class Fields
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TargetNavigator::Id; }

    NavigateTargetStatus status;
    chip::Span<const char> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TargetNavigator::Id; }

    NavigateTargetStatus status;
    chip::Span<const char> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTargetResponse
} // namespace Commands

namespace Attributes {
namespace TargetNavigatorList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::NavigateTargetTargetInfo::Type>;
    using DecodableType = DataModel::DecodableList<Structs::NavigateTargetTargetInfo::DecodableType>;

    static constexpr ClusterId GetClusterId() { return TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetNavigatorList::Id; }
};
} // namespace TargetNavigatorList
namespace CurrentNavigatorTarget {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentNavigatorTarget::Id; }
};
} // namespace CurrentNavigatorTarget
} // namespace Attributes
} // namespace TargetNavigator
namespace MediaPlayback {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MediaPlaybackState
enum class MediaPlaybackState : uint8_t
{
    kPlaying    = 0x00,
    kPaused     = 0x01,
    kNotPlaying = 0x02,
    kBuffering  = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MediaPlaybackState                   = EmberAfMediaPlaybackState;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MediaPlaybackStatus
enum class MediaPlaybackStatus : uint8_t
{
    kSuccess                = 0x00,
    kInvalidStateForCommand = 0x01,
    kNotAllowed             = 0x02,
    kNotActive              = 0x03,
    kSpeedOutOfRange        = 0x04,
    kSeekOutOfRange         = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MediaPlaybackStatus                  = EmberAfMediaPlaybackStatus;
#endif

namespace Structs {
namespace MediaPlaybackPosition {
enum class Fields
{
    kUpdatedAt = 0,
    kPosition  = 1,
};

struct Type
{
public:
    uint64_t updatedAt;
    uint64_t position;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace MediaPlaybackPosition
} // namespace Structs

namespace Commands {
namespace MediaPlay {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaPlay::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaPlay::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPlay
namespace MediaPlayResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaPlayResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaPlayResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPlayResponse
namespace MediaPause {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaPause::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaPause::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPause
namespace MediaPauseResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaPauseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaPauseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPauseResponse
namespace MediaStop {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaStop::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaStop::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStop
namespace MediaStopResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaStopResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaStopResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStopResponse
namespace MediaStartOver {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaStartOver::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaStartOver::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStartOver
namespace MediaStartOverResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaStartOverResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaStartOverResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStartOverResponse
namespace MediaPrevious {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaPrevious::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaPrevious::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPrevious
namespace MediaPreviousResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaPreviousResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaPreviousResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPreviousResponse
namespace MediaNext {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaNext::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaNext::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaNext
namespace MediaNextResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaNextResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaNextResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaNextResponse
namespace MediaRewind {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaRewind::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaRewind::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaRewind
namespace MediaRewindResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaRewindResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaRewindResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaRewindResponse
namespace MediaFastForward {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaFastForward::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaFastForward::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaFastForward
namespace MediaFastForwardResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaFastForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaFastForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaFastForwardResponse
namespace MediaSkipForward {
enum class Fields
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaSkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaSkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipForward
namespace MediaSkipForwardResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaSkipForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaSkipForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipForwardResponse
namespace MediaSkipBackward {
enum class Fields
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaSkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaSkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipBackward
namespace MediaSkipBackwardResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaSkipBackwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaSkipBackwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipBackwardResponse
namespace MediaSeek {
enum class Fields
{
    kPosition = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaSeek::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    uint64_t position;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaSeek::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    uint64_t position;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSeek
namespace MediaSeekResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MediaSeekResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MediaSeekResponse::Id; }
    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSeekResponse
} // namespace Commands

namespace Attributes {
namespace PlaybackState {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PlaybackState::Id; }
};
} // namespace PlaybackState
namespace StartTime {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartTime::Id; }
};
} // namespace StartTime
namespace Duration {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Duration::Id; }
};
} // namespace Duration
namespace PositionUpdatedAt {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PositionUpdatedAt::Id; }
};
} // namespace PositionUpdatedAt
namespace Position {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Position::Id; }
};
} // namespace Position
namespace PlaybackSpeed {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PlaybackSpeed::Id; }
};
} // namespace PlaybackSpeed
namespace SeekRangeEnd {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeEnd::Id; }
};
} // namespace SeekRangeEnd
namespace SeekRangeStart {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeStart::Id; }
};
} // namespace SeekRangeStart
} // namespace Attributes
} // namespace MediaPlayback
namespace MediaInput {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MediaInputType
enum class MediaInputType : uint8_t
{
    kInternal  = 0x00,
    kAux       = 0x01,
    kCoax      = 0x02,
    kComposite = 0x03,
    kHdmi      = 0x04,
    kInput     = 0x05,
    kLine      = 0x06,
    kOptical   = 0x07,
    kVideo     = 0x08,
    kScart     = 0x09,
    kUsb       = 0x0A,
    kOther     = 0x0B,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MediaInputType                       = EmberAfMediaInputType;
#endif

namespace Structs {
namespace MediaInputInfo {
enum class Fields
{
    kIndex       = 0,
    kInputType   = 1,
    kName        = 2,
    kDescription = 3,
};

struct Type
{
public:
    uint8_t index;
    MediaInputType inputType;
    chip::ByteSpan name;
    chip::ByteSpan description;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace MediaInputInfo
} // namespace Structs

namespace Commands {
namespace SelectInput {
enum class Fields
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    uint8_t index;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    uint8_t index;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectInput
namespace ShowInputStatus {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShowInputStatus
namespace HideInputStatus {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideInputStatus
namespace RenameInput {
enum class Fields
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    uint8_t index;
    chip::Span<const char> name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }

    uint8_t index;
    chip::Span<const char> name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameInput
} // namespace Commands

namespace Attributes {
namespace MediaInputList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::MediaInputInfo::Type>;
    using DecodableType = DataModel::DecodableList<Structs::MediaInputInfo::DecodableType>;

    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MediaInputList::Id; }
};
} // namespace MediaInputList
namespace CurrentMediaInput {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMediaInput::Id; }
};
} // namespace CurrentMediaInput
} // namespace Attributes
} // namespace MediaInput
namespace LowPower {

namespace Commands {
namespace Sleep {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return LowPower::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return LowPower::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Sleep
} // namespace Commands

} // namespace LowPower
namespace KeypadInput {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for KeypadInputCecKeyCode
enum class KeypadInputCecKeyCode : uint8_t
{
    kSelect                    = 0x00,
    kUp                        = 0x01,
    kDown                      = 0x02,
    kLeft                      = 0x03,
    kRight                     = 0x04,
    kRightUp                   = 0x05,
    kRightDown                 = 0x06,
    kLeftUp                    = 0x07,
    kLeftDown                  = 0x08,
    kRootMenu                  = 0x09,
    kSetupMenu                 = 0x0A,
    kContentsMenu              = 0x0B,
    kFavoriteMenu              = 0x0C,
    kExit                      = 0x0D,
    kMediaTopMenu              = 0x10,
    kMediaContextSensitiveMenu = 0x11,
    kNumberEntryMode           = 0x1D,
    kNumber11                  = 0x1E,
    kNumber12                  = 0x1F,
    kNumber0OrNumber10         = 0x20,
    kNumbers1                  = 0x21,
    kNumbers2                  = 0x22,
    kNumbers3                  = 0x23,
    kNumbers4                  = 0x24,
    kNumbers5                  = 0x25,
    kNumbers6                  = 0x26,
    kNumbers7                  = 0x27,
    kNumbers8                  = 0x28,
    kNumbers9                  = 0x29,
    kDot                       = 0x2A,
    kEnter                     = 0x2B,
    kClear                     = 0x2C,
    kNextFavorite              = 0x2F,
    kChannelUp                 = 0x30,
    kChannelDown               = 0x31,
    kPreviousChannel           = 0x32,
    kSoundSelect               = 0x33,
    kInputSelect               = 0x34,
    kDisplayInformation        = 0x35,
    kHelp                      = 0x36,
    kPageUp                    = 0x37,
    kPageDown                  = 0x38,
    kPower                     = 0x40,
    kVolumeUp                  = 0x41,
    kVolumeDown                = 0x42,
    kMute                      = 0x43,
    kPlay                      = 0x44,
    kStop                      = 0x45,
    kPause                     = 0x46,
    kRecord                    = 0x47,
    kRewind                    = 0x48,
    kFastForward               = 0x49,
    kEject                     = 0x4A,
    kForward                   = 0x4B,
    kBackward                  = 0x4C,
    kStopRecord                = 0x4D,
    kPauseRecord               = 0x4E,
    kReserved                  = 0x4F,
    kAngle                     = 0x50,
    kSubPicture                = 0x51,
    kVideoOnDemand             = 0x52,
    kElectronicProgramGuide    = 0x53,
    kTimerProgramming          = 0x54,
    kInitialConfiguration      = 0x55,
    kSelectBroadcastType       = 0x56,
    kSelectSoundPresentation   = 0x57,
    kPlayFunction              = 0x60,
    kPausePlayFunction         = 0x61,
    kRecordFunction            = 0x62,
    kPauseRecordFunction       = 0x63,
    kStopFunction              = 0x64,
    kMuteFunction              = 0x65,
    kRestoreVolumeFunction     = 0x66,
    kTuneFunction              = 0x67,
    kSelectMediaFunction       = 0x68,
    kSelectAvInputFunction     = 0x69,
    kSelectAudioInputFunction  = 0x6A,
    kPowerToggleFunction       = 0x6B,
    kPowerOffFunction          = 0x6C,
    kPowerOnFunction           = 0x6D,
    kF1Blue                    = 0x71,
    kF2Red                     = 0x72,
    kF3Green                   = 0x73,
    kF4Yellow                  = 0x74,
    kF5                        = 0x75,
    kData                      = 0x76,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using KeypadInputCecKeyCode                = EmberAfKeypadInputCecKeyCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for KeypadInputStatus
enum class KeypadInputStatus : uint8_t
{
    kSuccess                  = 0x00,
    kUnsupportedKey           = 0x01,
    kInvalidKeyInCurrentState = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using KeypadInputStatus                    = EmberAfKeypadInputStatus;
#endif

namespace Commands {
namespace SendKey {
enum class Fields
{
    kKeyCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return KeypadInput::Id; }

    KeypadInputCecKeyCode keyCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return KeypadInput::Id; }

    KeypadInputCecKeyCode keyCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKey
namespace SendKeyResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return KeypadInput::Id; }

    KeypadInputStatus status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return KeypadInput::Id; }

    KeypadInputStatus status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKeyResponse
} // namespace Commands

} // namespace KeypadInput
namespace ContentLauncher {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ContentLaunchMetricType
enum class ContentLaunchMetricType : uint8_t
{
    kPixels     = 0x00,
    kPercentage = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ContentLaunchMetricType              = EmberAfContentLaunchMetricType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ContentLaunchParameterEnum
enum class ContentLaunchParameterEnum : uint8_t
{
    kActor      = 0x00,
    kChannel    = 0x01,
    kCharacter  = 0x02,
    kEvent      = 0x03,
    kFranchise  = 0x04,
    kGenre      = 0x05,
    kLeague     = 0x06,
    kPopularity = 0x07,
    kSport      = 0x08,
    kSportsTeam = 0x09,
    kVideo      = 0x0A,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ContentLaunchParameterEnum           = EmberAfContentLaunchParameterEnum;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ContentLaunchStatus
enum class ContentLaunchStatus : uint8_t
{
    kSuccess         = 0x00,
    kUrlNotAvailable = 0x01,
    kAuthFailed      = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ContentLaunchStatus                  = EmberAfContentLaunchStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ContentLaunchStreamingType
enum class ContentLaunchStreamingType : uint8_t
{
    kDash = 0x00,
    kHls  = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ContentLaunchStreamingType           = EmberAfContentLaunchStreamingType;
#endif

namespace Structs {
namespace ContentLaunchAdditionalInfo {
enum class Fields
{
    kName  = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::Span<const char> name;
    chip::Span<const char> value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchAdditionalInfo
namespace ContentLaunchParamater {
enum class Fields
{
    kType           = 0,
    kValue          = 1,
    kExternalIDList = 2,
};

struct Type
{
public:
    ContentLaunchParameterEnum type;
    chip::Span<const char> value;
    DataModel::List<Structs::ContentLaunchAdditionalInfo::Type> externalIDList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    ContentLaunchParameterEnum type;
    chip::Span<const char> value;
    DataModel::DecodableList<Structs::ContentLaunchAdditionalInfo::DecodableType> externalIDList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchParamater
namespace ContentLaunchBrandingInformation {
enum class Fields
{
    kProviderName = 0,
    kBackground   = 1,
    kLogo         = 2,
    kProgressBar  = 3,
    kSplash       = 4,
    kWaterMark    = 5,
};

struct Type
{
public:
    chip::Span<const char> providerName;
    uint8_t background;
    uint8_t logo;
    uint8_t progressBar;
    uint8_t splash;
    uint8_t waterMark;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchBrandingInformation
namespace ContentLaunchDimension {
enum class Fields
{
    kWidth  = 0,
    kHeight = 1,
    kMetric = 2,
};

struct Type
{
public:
    chip::Span<const char> width;
    chip::Span<const char> height;
    ContentLaunchMetricType metric;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchDimension
namespace ContentLaunchStyleInformation {
enum class Fields
{
    kImageUrl = 0,
    kColor    = 1,
    kSize     = 2,
};

struct Type
{
public:
    chip::Span<const char> imageUrl;
    chip::Span<const char> color;
    uint8_t size;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchStyleInformation
} // namespace Structs

namespace Commands {
namespace LaunchContent {
enum class Fields
{
    kAutoPlay = 0,
    kData     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    bool autoPlay;
    chip::Span<const char> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    bool autoPlay;
    chip::Span<const char> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchContent
namespace LaunchContentResponse {
enum class Fields
{
    kData                = 0,
    kContentLaunchStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LaunchContentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    chip::Span<const char> data;
    ContentLaunchStatus contentLaunchStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LaunchContentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    chip::Span<const char> data;
    ContentLaunchStatus contentLaunchStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchContentResponse
namespace LaunchURL {
enum class Fields
{
    kContentURL    = 0,
    kDisplayString = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    chip::Span<const char> contentURL;
    chip::Span<const char> displayString;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    chip::Span<const char> contentURL;
    chip::Span<const char> displayString;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchURL
namespace LaunchURLResponse {
enum class Fields
{
    kData                = 0,
    kContentLaunchStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LaunchURLResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    chip::Span<const char> data;
    ContentLaunchStatus contentLaunchStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LaunchURLResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }

    chip::Span<const char> data;
    ContentLaunchStatus contentLaunchStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchURLResponse
} // namespace Commands

namespace Attributes {
namespace AcceptsHeaderList {
struct TypeInfo
{
    using Type          = DataModel::List<chip::ByteSpan>;
    using DecodableType = DataModel::DecodableList<chip::ByteSpan>;

    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcceptsHeaderList::Id; }
};
} // namespace AcceptsHeaderList
namespace SupportedStreamingTypes {
struct TypeInfo
{
    using Type          = DataModel::List<ContentLaunchStreamingType>;
    using DecodableType = DataModel::DecodableList<ContentLaunchStreamingType>;

    static constexpr ClusterId GetClusterId() { return ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedStreamingTypes::Id; }
};
} // namespace SupportedStreamingTypes
} // namespace Attributes
} // namespace ContentLauncher
namespace AudioOutput {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for AudioOutputType
enum class AudioOutputType : uint8_t
{
    kHdmi      = 0x00,
    kBt        = 0x01,
    kOptical   = 0x02,
    kHeadphone = 0x03,
    kInternal  = 0x04,
    kOther     = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using AudioOutputType                      = EmberAfAudioOutputType;
#endif

namespace Structs {
namespace AudioOutputInfo {
enum class Fields
{
    kIndex      = 0,
    kOutputType = 1,
    kName       = 2,
};

struct Type
{
public:
    uint8_t index;
    AudioOutputType outputType;
    chip::ByteSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace AudioOutputInfo
} // namespace Structs

namespace Commands {
namespace SelectOutput {
enum class Fields
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return AudioOutput::Id; }

    uint8_t index;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return AudioOutput::Id; }

    uint8_t index;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectOutput
namespace RenameOutput {
enum class Fields
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return AudioOutput::Id; }

    uint8_t index;
    chip::Span<const char> name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return AudioOutput::Id; }

    uint8_t index;
    chip::Span<const char> name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameOutput
} // namespace Commands

namespace Attributes {
namespace AudioOutputList {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::AudioOutputInfo::Type>;
    using DecodableType = DataModel::DecodableList<Structs::AudioOutputInfo::DecodableType>;

    static constexpr ClusterId GetClusterId() { return AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AudioOutputList::Id; }
};
} // namespace AudioOutputList
namespace CurrentAudioOutput {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentAudioOutput::Id; }
};
} // namespace CurrentAudioOutput
} // namespace Attributes
} // namespace AudioOutput
namespace ApplicationLauncher {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ApplicationLauncherStatus
enum class ApplicationLauncherStatus : uint8_t
{
    kSuccess         = 0x00,
    kAppNotAvailable = 0x01,
    kSystemBusy      = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ApplicationLauncherStatus            = EmberAfApplicationLauncherStatus;
#endif

namespace Structs {
namespace ApplicationLauncherApp {
enum class Fields
{
    kCatalogVendorId = 0,
    kApplicationId   = 1,
};

struct Type
{
public:
    uint16_t catalogVendorId;
    chip::Span<const char> applicationId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ApplicationLauncherApp
} // namespace Structs

namespace Commands {
namespace LaunchApp {
enum class Fields
{
    kData            = 0,
    kCatalogVendorId = 1,
    kApplicationId   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }

    chip::Span<const char> data;
    uint16_t catalogVendorId;
    chip::Span<const char> applicationId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }

    chip::Span<const char> data;
    uint16_t catalogVendorId;
    chip::Span<const char> applicationId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchApp
namespace LaunchAppResponse {
enum class Fields
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LaunchAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::Span<const char> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LaunchAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::Span<const char> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchAppResponse
} // namespace Commands

namespace Attributes {
namespace ApplicationLauncherList {
struct TypeInfo
{
    using Type          = DataModel::List<uint16_t>;
    using DecodableType = DataModel::DecodableList<uint16_t>;

    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationLauncherList::Id; }
};
} // namespace ApplicationLauncherList
namespace CatalogVendorId {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CatalogVendorId::Id; }
};
} // namespace CatalogVendorId
namespace ApplicationId {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationId::Id; }
};
} // namespace ApplicationId
} // namespace Attributes
} // namespace ApplicationLauncher
namespace ApplicationBasic {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ApplicationBasicStatus
enum class ApplicationBasicStatus : uint8_t
{
    kStopped               = 0x00,
    kActiveVisibleFocus    = 0x01,
    kActiveHidden          = 0x02,
    kActiveVisibleNotFocus = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ApplicationBasicStatus               = EmberAfApplicationBasicStatus;
#endif

namespace Commands {
namespace ChangeStatus {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return ChangeStatus::Id; }
    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }

    ApplicationBasicStatus status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return ChangeStatus::Id; }
    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }

    ApplicationBasicStatus status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeStatus
} // namespace Commands

namespace Attributes {
namespace VendorName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
};
} // namespace VendorName
namespace VendorId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorId::Id; }
};
} // namespace VendorId
namespace ApplicationName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationName::Id; }
};
} // namespace ApplicationName
namespace ProductId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductId::Id; }
};
} // namespace ProductId
namespace ApplicationId {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationId::Id; }
};
} // namespace ApplicationId
namespace CatalogVendorId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CatalogVendorId::Id; }
};
} // namespace CatalogVendorId
namespace ApplicationStatus {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationStatus::Id; }
};
} // namespace ApplicationStatus
} // namespace Attributes
} // namespace ApplicationBasic
namespace AccountLogin {

namespace Commands {
namespace GetSetupPIN {
enum class Fields
{
    kTempAccountIdentifier = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return AccountLogin::Id; }

    chip::Span<const char> tempAccountIdentifier;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return AccountLogin::Id; }

    chip::Span<const char> tempAccountIdentifier;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPIN
namespace GetSetupPINResponse {
enum class Fields
{
    kSetupPIN = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return AccountLogin::Id; }

    chip::Span<const char> setupPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return AccountLogin::Id; }

    chip::Span<const char> setupPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPINResponse
namespace Login {
enum class Fields
{
    kTempAccountIdentifier = 0,
    kSetupPIN              = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Login::Id; }
    static constexpr ClusterId GetClusterId() { return AccountLogin::Id; }

    chip::Span<const char> tempAccountIdentifier;
    chip::Span<const char> setupPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Login::Id; }
    static constexpr ClusterId GetClusterId() { return AccountLogin::Id; }

    chip::Span<const char> tempAccountIdentifier;
    chip::Span<const char> setupPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Login
} // namespace Commands

} // namespace AccountLogin
namespace TestCluster {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SimpleEnum
enum class SimpleEnum : uint8_t
{
    kUnspecified = 0x00,
    kValueA      = 0x01,
    kValueB      = 0x02,
    kValueC      = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SimpleEnum                           = EmberAfSimpleEnum;
#endif

// Bitmap for SimpleBitmap
enum class SimpleBitmap : uint8_t
{
    kValueA = 0,
    kValueB = 1,
    kValueC = 2,
};

namespace Structs {
namespace SimpleStruct {
enum class Fields
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
    kE = 4,
    kF = 5,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleEnum c;
    chip::ByteSpan d;
    chip::Span<const char> e;
    BitFlags<SimpleBitmap> f;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SimpleStruct
namespace NestedStruct {
enum class Fields
{
    kA = 0,
    kB = 1,
    kC = 2,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    Structs::SimpleStruct::Type c;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NestedStruct
namespace NestedStructList {
enum class Fields
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
    kE = 4,
    kF = 5,
    kG = 6,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    Structs::SimpleStruct::Type c;
    DataModel::List<Structs::SimpleStruct::Type> d;
    DataModel::List<uint32_t> e;
    DataModel::List<chip::ByteSpan> f;
    DataModel::List<uint8_t> g;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    uint8_t a;
    bool b;
    Structs::SimpleStruct::DecodableType c;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> d;
    DataModel::DecodableList<uint32_t> e;
    DataModel::DecodableList<chip::ByteSpan> f;
    DataModel::DecodableList<uint8_t> g;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NestedStructList
namespace DoubleNestedStructList {
enum class Fields
{
    kA = 0,
};

struct Type
{
public:
    DataModel::List<Structs::NestedStructList::Type> a;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<Structs::NestedStructList::DecodableType> a;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace DoubleNestedStructList
namespace TestListStructOctet {
enum class Fields
{
    kFabricIndex     = 0,
    kOperationalCert = 1,
};

struct Type
{
public:
    uint64_t fabricIndex;
    chip::ByteSpan operationalCert;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TestListStructOctet
} // namespace Structs

namespace Commands {
namespace Test {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Test::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Test::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Test
namespace TestSpecificResponse {
enum class Fields
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    uint8_t returnValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    uint8_t returnValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecificResponse
namespace TestNotHandled {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNotHandled
namespace TestAddArgumentsResponse {
enum class Fields
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    uint8_t returnValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    uint8_t returnValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArgumentsResponse
namespace TestSpecific {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecific
namespace TestSimpleArgumentResponse {
enum class Fields
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    bool returnValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    bool returnValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentResponse
namespace TestUnknownCommand {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestUnknownCommand
namespace TestStructArrayArgumentResponse {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    DataModel::List<Structs::NestedStructList::Type> arg1;
    DataModel::List<Structs::SimpleStruct::Type> arg2;
    DataModel::List<SimpleEnum> arg3;
    DataModel::List<bool> arg4;
    SimpleEnum arg5;
    bool arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5;
    bool arg6;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentResponse
namespace TestAddArguments {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    uint8_t arg1;
    uint8_t arg2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    uint8_t arg1;
    uint8_t arg2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArguments
namespace TestSimpleArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    bool arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    bool arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentRequest
namespace TestStructArrayArgumentRequest {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    DataModel::List<Structs::NestedStructList::Type> arg1;
    DataModel::List<Structs::SimpleStruct::Type> arg2;
    DataModel::List<SimpleEnum> arg3;
    DataModel::List<bool> arg4;
    SimpleEnum arg5;
    bool arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5;
    bool arg6;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentRequest
} // namespace Commands

namespace Attributes {
namespace Boolean {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Boolean::Id; }
};
} // namespace Boolean
namespace Bitmap8 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap8::Id; }
};
} // namespace Bitmap8
namespace Bitmap16 {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap16::Id; }
};
} // namespace Bitmap16
namespace Bitmap32 {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap32::Id; }
};
} // namespace Bitmap32
namespace Bitmap64 {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap64::Id; }
};
} // namespace Bitmap64
namespace Int8u {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8u::Id; }
};
} // namespace Int8u
namespace Int16u {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16u::Id; }
};
} // namespace Int16u
namespace Int32u {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32u::Id; }
};
} // namespace Int32u
namespace Int64u {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64u::Id; }
};
} // namespace Int64u
namespace Int8s {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8s::Id; }
};
} // namespace Int8s
namespace Int16s {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16s::Id; }
};
} // namespace Int16s
namespace Int32s {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32s::Id; }
};
} // namespace Int32s
namespace Int64s {
struct TypeInfo
{
    using Type          = int64_t;
    using DecodableType = int64_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64s::Id; }
};
} // namespace Int64s
namespace Enum8 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum8::Id; }
};
} // namespace Enum8
namespace Enum16 {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum16::Id; }
};
} // namespace Enum16
namespace OctetString {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OctetString::Id; }
};
} // namespace OctetString
namespace ListInt8u {
struct TypeInfo
{
    using Type          = DataModel::List<uint8_t>;
    using DecodableType = DataModel::DecodableList<uint8_t>;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListInt8u::Id; }
};
} // namespace ListInt8u
namespace ListOctetString {
struct TypeInfo
{
    using Type          = DataModel::List<chip::ByteSpan>;
    using DecodableType = DataModel::DecodableList<chip::ByteSpan>;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListOctetString::Id; }
};
} // namespace ListOctetString
namespace ListStructOctetString {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::TestListStructOctet::Type>;
    using DecodableType = DataModel::DecodableList<Structs::TestListStructOctet::DecodableType>;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListStructOctetString::Id; }
};
} // namespace ListStructOctetString
namespace LongOctetString {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongOctetString::Id; }
};
} // namespace LongOctetString
namespace CharString {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CharString::Id; }
};
} // namespace CharString
namespace LongCharString {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongCharString::Id; }
};
} // namespace LongCharString
namespace EpochUs {
struct TypeInfo
{
    using Type          = uint64_t;
    using DecodableType = uint64_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochUs::Id; }
};
} // namespace EpochUs
namespace EpochS {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochS::Id; }
};
} // namespace EpochS
namespace Unsupported {
struct TypeInfo
{
    using Type          = bool;
    using DecodableType = bool;

    static constexpr ClusterId GetClusterId() { return TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Unsupported::Id; }
};
} // namespace Unsupported
} // namespace Attributes
} // namespace TestCluster
namespace Messaging {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for EventId
enum class EventId : uint8_t
{
    kMeterCoverRemoved                  = 0x00,
    kMeterCoverClosed                   = 0x01,
    kStrongMagneticField                = 0x02,
    kNoStrongMagneticField              = 0x03,
    kBatteryFailure                     = 0x04,
    kLowBattery                         = 0x05,
    kProgramMemoryError                 = 0x06,
    kRamError                           = 0x07,
    kNvMemoryError                      = 0x08,
    kMeasurementSystemError             = 0x09,
    kWatchdogError                      = 0x0A,
    kSupplyDisconnectFailure            = 0x0B,
    kSupplyConnectFailure               = 0x0C,
    kMeasurmentSoftwareChanged          = 0x0D,
    kDstEnabled                         = 0x0E,
    kDstDisabled                        = 0x0F,
    kClockAdjBackward                   = 0x10,
    kClockAdjForward                    = 0x11,
    kClockInvalid                       = 0x12,
    kCommsErrorHan                      = 0x13,
    kCommsOkHan                         = 0x14,
    kFraudAttempt                       = 0x15,
    kPowerLoss                          = 0x16,
    kIncorrectProtocol                  = 0x17,
    kUnusualHanTraffic                  = 0x18,
    kUnexpectedClockChange              = 0x19,
    kCommsUsingUnauthenticatedComponent = 0x1A,
    kErrorRegClear                      = 0x1B,
    kAlarmRegClear                      = 0x1C,
    kUnexpectedHwReset                  = 0x1D,
    kUnexpectedProgramExecution         = 0x1E,
    kEventLogCleared                    = 0x1F,
    kManualDisconnect                   = 0x20,
    kManualConnect                      = 0x21,
    kRemoteDisconnection                = 0x22,
    kLocalDisconnection                 = 0x23,
    kLimitThresholdExceeded             = 0x24,
    kLimitThresholdOk                   = 0x25,
    kLimitThresholdChanged              = 0x26,
    kMaximumDemandExceeded              = 0x27,
    kProfileCleared                     = 0x28,
    kFirmwareReadyForActivation         = 0x29,
    kFirmwareActivated                  = 0x2A,
    kPatchFailure                       = 0x2B,
    kTouTariffActivation                = 0x2C,
    k8x8Tariffactivated                 = 0x2D,
    kSingleTariffRateActivated          = 0x2E,
    kAsynchronousBillingOccurred        = 0x2F,
    kSynchronousBillingOccurred         = 0x30,
    kIncorrectPolarity                  = 0x80,
    kCurrentNoVoltage                   = 0x81,
    kUnderVoltage                       = 0x82,
    kOverVoltage                        = 0x83,
    kNormalVoltage                      = 0x84,
    kPfBelowThreshold                   = 0x85,
    kPfAboveThreshold                   = 0x86,
    kTerminalCoverRemoved               = 0x87,
    kTerminalCoverClosed                = 0x88,
    kReverseFlow                        = 0xA0,
    kTiltTamper                         = 0xA1,
    kBatteryCoverRemoved                = 0xA2,
    kBatteryCoverClosed                 = 0xA3,
    kExcessFlow                         = 0xA4,
    kCreditOk                           = 0xC0,
    kLowCredit                          = 0xC1,
    kEmergencyCreditInUse               = 0xC0,
    kEmergencyCreditExhausted           = 0xC1,
    kZeroCreditEcNotSelected            = 0xC2,
    kSupplyOn                           = 0xC3,
    kSupplyOffAarmed                    = 0xC4,
    kSupplyOff                          = 0xC5,
    kDiscountApplied                    = 0xC6,
    kManufacturerSpecificA              = 0xE0,
    kManufacturerSpecificB              = 0xE1,
    kManufacturerSpecificC              = 0xE2,
    kManufacturerSpecificD              = 0xE3,
    kManufacturerSpecificE              = 0xE4,
    kManufacturerSpecificF              = 0xE5,
    kManufacturerSpecificG              = 0xE6,
    kManufacturerSpecificH              = 0xE7,
    kManufacturerSpecificI              = 0xE8,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using EventId                              = EmberAfEventId;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MessagingControlConfirmation
enum class MessagingControlConfirmation : uint8_t
{
    kNotRequired = 0x00,
    kRequired    = 0x80,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MessagingControlConfirmation         = EmberAfMessagingControlConfirmation;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MessagingControlEnhancedConfirmation
enum class MessagingControlEnhancedConfirmation : uint8_t
{
    kNotRequired = 0x00,
    kRequired    = 0x20,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MessagingControlEnhancedConfirmation = EmberAfMessagingControlEnhancedConfirmation;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MessagingControlImportance
enum class MessagingControlImportance : uint8_t
{
    kLow      = 0x00,
    kMedium   = 0x04,
    kHigh     = 0x08,
    kCritical = 0x0C,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MessagingControlImportance           = EmberAfMessagingControlImportance;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MessagingControlTransmission
enum class MessagingControlTransmission : uint8_t
{
    kNormal             = 0x00,
    kNormalAndAnonymous = 0x01,
    kAnonymous          = 0x02,
    kReserved           = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MessagingControlTransmission         = EmberAfMessagingControlTransmission;
#endif

// Bitmap for MessagingConfirmationControl
enum class MessagingConfirmationControl : uint8_t
{
    kNoReturned  = 0,
    kYesReturned = 1,
};

// Bitmap for MessagingControlMask
enum class MessagingControlMask : uint8_t
{
    kTransMechanism              = 0,
    kMessageUrgency              = 2,
    kEnhancedConfirmationRequest = 5,
    kMessageConfirmation         = 7,
};

// Bitmap for MessagingExtendedControlMask
enum class MessagingExtendedControlMask : uint8_t
{
    kMessageConfirmationStatus = 0,
};

namespace Commands {
namespace DisplayMessage {
enum class Fields
{
    kMessageId                      = 0,
    kMessageControl                 = 1,
    kStartTime                      = 2,
    kDurationInMinutes              = 3,
    kMessage                        = 4,
    kOptionalExtendedMessageControl = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return DisplayMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::Span<const char> message;
    BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return DisplayMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::Span<const char> message;
    BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisplayMessage
namespace GetLastMessage {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetLastMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetLastMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLastMessage
namespace CancelMessage {
enum class Fields
{
    kMessageId      = 0,
    kMessageControl = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CancelMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    BitFlags<MessagingControlMask> messageControl;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CancelMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    BitFlags<MessagingControlMask> messageControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelMessage
namespace MessageConfirmation {
enum class Fields
{
    kMessageId                  = 0,
    kConfirmationTime           = 1,
    kMessageConfirmationControl = 2,
    kMessageResponse            = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return MessageConfirmation::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    uint32_t confirmationTime;
    uint8_t messageConfirmationControl;
    chip::ByteSpan messageResponse;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return MessageConfirmation::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    uint32_t confirmationTime;
    uint8_t messageConfirmationControl;
    chip::ByteSpan messageResponse;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MessageConfirmation
namespace DisplayProtectedMessage {
enum class Fields
{
    kMessageId                      = 0,
    kMessageControl                 = 1,
    kStartTime                      = 2,
    kDurationInMinutes              = 3,
    kMessage                        = 4,
    kOptionalExtendedMessageControl = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return DisplayProtectedMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::Span<const char> message;
    BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return DisplayProtectedMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t messageId;
    BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::Span<const char> message;
    BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisplayProtectedMessage
namespace GetMessageCancellation {
enum class Fields
{
    kEarliestImplementationTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetMessageCancellation::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t earliestImplementationTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetMessageCancellation::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t earliestImplementationTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMessageCancellation
namespace CancelAllMessages {
enum class Fields
{
    kImplementationDateTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CancelAllMessages::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t implementationDateTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CancelAllMessages::Id; }
    static constexpr ClusterId GetClusterId() { return Messaging::Id; }

    uint32_t implementationDateTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelAllMessages
} // namespace Commands

} // namespace Messaging
namespace ApplianceIdentification {

namespace Attributes {
namespace BasicIdentification {
struct TypeInfo
{
    using Type          = uint8_t *;
    using DecodableType = uint8_t *;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BasicIdentification::Id; }
};
} // namespace BasicIdentification
namespace CompanyName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompanyName::Id; }
};
} // namespace CompanyName
namespace CompanyId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompanyId::Id; }
};
} // namespace CompanyId
namespace BrandName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BrandName::Id; }
};
} // namespace BrandName
namespace BrandId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BrandId::Id; }
};
} // namespace BrandId
namespace Model {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Model::Id; }
};
} // namespace Model
namespace PartNumber {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
};
} // namespace PartNumber
namespace ProductRevision {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductRevision::Id; }
};
} // namespace ProductRevision
namespace SoftwareRevision {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareRevision::Id; }
};
} // namespace SoftwareRevision
namespace ProductTypeName {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductTypeName::Id; }
};
} // namespace ProductTypeName
namespace ProductTypeId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductTypeId::Id; }
};
} // namespace ProductTypeId
namespace CecedSpecificationVersion {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CecedSpecificationVersion::Id; }
};
} // namespace CecedSpecificationVersion
} // namespace Attributes
} // namespace ApplianceIdentification
namespace MeterIdentification {

namespace Attributes {
namespace CompanyName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompanyName::Id; }
};
} // namespace CompanyName
namespace MeterTypeId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeterTypeId::Id; }
};
} // namespace MeterTypeId
namespace DataQualityId {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataQualityId::Id; }
};
} // namespace DataQualityId
namespace CustomerName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CustomerName::Id; }
};
} // namespace CustomerName
namespace Model {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Model::Id; }
};
} // namespace Model
namespace PartNumber {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
};
} // namespace PartNumber
namespace ProductRevision {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductRevision::Id; }
};
} // namespace ProductRevision
namespace SoftwareRevision {
struct TypeInfo
{
    using Type          = chip::ByteSpan;
    using DecodableType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareRevision::Id; }
};
} // namespace SoftwareRevision
namespace UtilityName {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UtilityName::Id; }
};
} // namespace UtilityName
namespace Pod {
struct TypeInfo
{
    using Type          = chip::Span<const char>;
    using DecodableType = chip::Span<const char>;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Pod::Id; }
};
} // namespace Pod
namespace AvailablePower {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailablePower::Id; }
};
} // namespace AvailablePower
namespace PowerThreshold {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerThreshold::Id; }
};
} // namespace PowerThreshold
} // namespace Attributes
} // namespace MeterIdentification
namespace ApplianceEventsAndAlert {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for EventIdentification
enum class EventIdentification : uint8_t
{
    kEndOfCycle         = 0x01,
    kTemperatureReached = 0x04,
    kEndOfCooking       = 0x05,
    kSwitchingOff       = 0x06,
    kWrongData          = 0x07,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using EventIdentification                  = EmberAfEventIdentification;
#endif

// Bitmap for AlertCount
enum class AlertCount : uint8_t
{
    kNumberOfAlerts = 0,
    kTypeOfAlert    = 4,
};

// Bitmap for AlertStructure
enum class AlertStructure : uint32_t
{
    kAlertId          = 0,
    kCategory         = 8,
    kPresenceRecovery = 12,
};

namespace Commands {
namespace GetAlerts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetAlerts::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetAlerts::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlerts
namespace GetAlertsResponse {
enum class Fields
{
    kAlertsCount     = 0,
    kAlertStructures = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetAlertsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    BitFlags<AlertCount> alertsCount;
    DataModel::List<BitFlags<AlertStructure>> alertStructures;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetAlertsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    BitFlags<AlertCount> alertsCount;
    DataModel::DecodableList<BitFlags<AlertStructure>> alertStructures;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlertsResponse
namespace AlertsNotification {
enum class Fields
{
    kAlertsCount     = 0,
    kAlertStructures = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return AlertsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    BitFlags<AlertCount> alertsCount;
    DataModel::List<BitFlags<AlertStructure>> alertStructures;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return AlertsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    BitFlags<AlertCount> alertsCount;
    DataModel::DecodableList<BitFlags<AlertStructure>> alertStructures;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AlertsNotification
namespace EventsNotification {
enum class Fields
{
    kEventHeader = 0,
    kEventId     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return EventsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    uint8_t eventHeader;
    EventIdentification eventId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return EventsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceEventsAndAlert::Id; }

    uint8_t eventHeader;
    EventIdentification eventId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EventsNotification
} // namespace Commands

} // namespace ApplianceEventsAndAlert
namespace ApplianceStatistics {

namespace Commands {
namespace LogNotification {
enum class Fields
{
    kTimeStamp  = 0,
    kLogId      = 1,
    kLogLength  = 2,
    kLogPayload = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LogNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::List<uint8_t> logPayload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LogNotification::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::DecodableList<uint8_t> logPayload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogNotification
namespace LogRequest {
enum class Fields
{
    kLogId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LogRequest::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint32_t logId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LogRequest::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint32_t logId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogRequest
namespace LogResponse {
enum class Fields
{
    kTimeStamp  = 0,
    kLogId      = 1,
    kLogLength  = 2,
    kLogPayload = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LogResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::List<uint8_t> logPayload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LogResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::DecodableList<uint8_t> logPayload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogResponse
namespace LogQueueRequest {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LogQueueRequest::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LogQueueRequest::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogQueueRequest
namespace LogQueueResponse {
enum class Fields
{
    kLogQueueSize = 0,
    kLogIds       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return LogQueueResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::List<uint32_t> logIds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return LogQueueResponse::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::DecodableList<uint32_t> logIds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogQueueResponse
namespace StatisticsAvailable {
enum class Fields
{
    kLogQueueSize = 0,
    kLogIds       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return StatisticsAvailable::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::List<uint32_t> logIds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return StatisticsAvailable::Id; }
    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::DecodableList<uint32_t> logIds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StatisticsAvailable
} // namespace Commands

namespace Attributes {
namespace LogMaxSize {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LogMaxSize::Id; }
};
} // namespace LogMaxSize
namespace LogQueueMaxSize {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LogQueueMaxSize::Id; }
};
} // namespace LogQueueMaxSize
} // namespace Attributes
} // namespace ApplianceStatistics
namespace ElectricalMeasurement {

namespace Commands {
namespace GetProfileInfoResponseCommand {
enum class Fields
{
    kProfileCount          = 0,
    kProfileIntervalPeriod = 1,
    kMaxNumberOfIntervals  = 2,
    kListOfAttributes      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetProfileInfoResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    uint8_t profileCount;
    uint8_t profileIntervalPeriod;
    uint8_t maxNumberOfIntervals;
    DataModel::List<uint16_t> listOfAttributes;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetProfileInfoResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    uint8_t profileCount;
    uint8_t profileIntervalPeriod;
    uint8_t maxNumberOfIntervals;
    DataModel::DecodableList<uint16_t> listOfAttributes;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProfileInfoResponseCommand
namespace GetProfileInfoCommand {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetProfileInfoCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetProfileInfoCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProfileInfoCommand
namespace GetMeasurementProfileResponseCommand {
enum class Fields
{
    kStartTime                  = 0,
    kStatus                     = 1,
    kProfileIntervalPeriod      = 2,
    kNumberOfIntervalsDelivered = 3,
    kAttributeId                = 4,
    kIntervals                  = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetMeasurementProfileResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    uint32_t startTime;
    uint8_t status;
    uint8_t profileIntervalPeriod;
    uint8_t numberOfIntervalsDelivered;
    uint16_t attributeId;
    DataModel::List<uint8_t> intervals;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetMeasurementProfileResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    uint32_t startTime;
    uint8_t status;
    uint8_t profileIntervalPeriod;
    uint8_t numberOfIntervalsDelivered;
    uint16_t attributeId;
    DataModel::DecodableList<uint8_t> intervals;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMeasurementProfileResponseCommand
namespace GetMeasurementProfileCommand {
enum class Fields
{
    kAttributeId       = 0,
    kStartTime         = 1,
    kNumberOfIntervals = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return GetMeasurementProfileCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    uint16_t attributeId;
    uint32_t startTime;
    uint8_t numberOfIntervals;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return GetMeasurementProfileCommand::Id; }
    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }

    uint16_t attributeId;
    uint32_t startTime;
    uint8_t numberOfIntervals;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMeasurementProfileCommand
} // namespace Commands

namespace Attributes {
namespace MeasurementType {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementType::Id; }
};
} // namespace MeasurementType
namespace DcVoltage {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltage::Id; }
};
} // namespace DcVoltage
namespace DcVoltageMin {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMin::Id; }
};
} // namespace DcVoltageMin
namespace DcVoltageMax {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMax::Id; }
};
} // namespace DcVoltageMax
namespace DcCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrent::Id; }
};
} // namespace DcCurrent
namespace DcCurrentMin {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMin::Id; }
};
} // namespace DcCurrentMin
namespace DcCurrentMax {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMax::Id; }
};
} // namespace DcCurrentMax
namespace DcPower {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPower::Id; }
};
} // namespace DcPower
namespace DcPowerMin {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMin::Id; }
};
} // namespace DcPowerMin
namespace DcPowerMax {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMax::Id; }
};
} // namespace DcPowerMax
namespace DcVoltageMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMultiplier::Id; }
};
} // namespace DcVoltageMultiplier
namespace DcVoltageDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageDivisor::Id; }
};
} // namespace DcVoltageDivisor
namespace DcCurrentMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMultiplier::Id; }
};
} // namespace DcCurrentMultiplier
namespace DcCurrentDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentDivisor::Id; }
};
} // namespace DcCurrentDivisor
namespace DcPowerMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMultiplier::Id; }
};
} // namespace DcPowerMultiplier
namespace DcPowerDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerDivisor::Id; }
};
} // namespace DcPowerDivisor
namespace AcFrequency {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequency::Id; }
};
} // namespace AcFrequency
namespace AcFrequencyMin {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMin::Id; }
};
} // namespace AcFrequencyMin
namespace AcFrequencyMax {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMax::Id; }
};
} // namespace AcFrequencyMax
namespace NeutralCurrent {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeutralCurrent::Id; }
};
} // namespace NeutralCurrent
namespace TotalActivePower {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalActivePower::Id; }
};
} // namespace TotalActivePower
namespace TotalReactivePower {
struct TypeInfo
{
    using Type          = int32_t;
    using DecodableType = int32_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalReactivePower::Id; }
};
} // namespace TotalReactivePower
namespace TotalApparentPower {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalApparentPower::Id; }
};
} // namespace TotalApparentPower
namespace Measured1stHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured1stHarmonicCurrent::Id; }
};
} // namespace Measured1stHarmonicCurrent
namespace Measured3rdHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured3rdHarmonicCurrent::Id; }
};
} // namespace Measured3rdHarmonicCurrent
namespace Measured5thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured5thHarmonicCurrent::Id; }
};
} // namespace Measured5thHarmonicCurrent
namespace Measured7thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured7thHarmonicCurrent::Id; }
};
} // namespace Measured7thHarmonicCurrent
namespace Measured9thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured9thHarmonicCurrent::Id; }
};
} // namespace Measured9thHarmonicCurrent
namespace Measured11thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured11thHarmonicCurrent::Id; }
};
} // namespace Measured11thHarmonicCurrent
namespace MeasuredPhase1stHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase1stHarmonicCurrent::Id; }
};
} // namespace MeasuredPhase1stHarmonicCurrent
namespace MeasuredPhase3rdHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase3rdHarmonicCurrent::Id; }
};
} // namespace MeasuredPhase3rdHarmonicCurrent
namespace MeasuredPhase5thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase5thHarmonicCurrent::Id; }
};
} // namespace MeasuredPhase5thHarmonicCurrent
namespace MeasuredPhase7thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase7thHarmonicCurrent::Id; }
};
} // namespace MeasuredPhase7thHarmonicCurrent
namespace MeasuredPhase9thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase9thHarmonicCurrent::Id; }
};
} // namespace MeasuredPhase9thHarmonicCurrent
namespace MeasuredPhase11thHarmonicCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase11thHarmonicCurrent::Id; }
};
} // namespace MeasuredPhase11thHarmonicCurrent
namespace AcFrequencyMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMultiplier::Id; }
};
} // namespace AcFrequencyMultiplier
namespace AcFrequencyDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyDivisor::Id; }
};
} // namespace AcFrequencyDivisor
namespace PowerMultiplier {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerMultiplier::Id; }
};
} // namespace PowerMultiplier
namespace PowerDivisor {
struct TypeInfo
{
    using Type          = uint32_t;
    using DecodableType = uint32_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerDivisor::Id; }
};
} // namespace PowerDivisor
namespace HarmonicCurrentMultiplier {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicCurrentMultiplier::Id; }
};
} // namespace HarmonicCurrentMultiplier
namespace PhaseHarmonicCurrentMultiplier {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseHarmonicCurrentMultiplier::Id; }
};
} // namespace PhaseHarmonicCurrentMultiplier
namespace InstantaneousVoltage {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousVoltage::Id; }
};
} // namespace InstantaneousVoltage
namespace InstantaneousLineCurrent {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousLineCurrent::Id; }
};
} // namespace InstantaneousLineCurrent
namespace InstantaneousActiveCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousActiveCurrent::Id; }
};
} // namespace InstantaneousActiveCurrent
namespace InstantaneousReactiveCurrent {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousReactiveCurrent::Id; }
};
} // namespace InstantaneousReactiveCurrent
namespace InstantaneousPower {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousPower::Id; }
};
} // namespace InstantaneousPower
namespace RmsVoltage {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltage::Id; }
};
} // namespace RmsVoltage
namespace RmsVoltageMin {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMin::Id; }
};
} // namespace RmsVoltageMin
namespace RmsVoltageMax {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMax::Id; }
};
} // namespace RmsVoltageMax
namespace RmsCurrent {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrent::Id; }
};
} // namespace RmsCurrent
namespace RmsCurrentMin {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMin::Id; }
};
} // namespace RmsCurrentMin
namespace RmsCurrentMax {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMax::Id; }
};
} // namespace RmsCurrentMax
namespace ActivePower {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePower::Id; }
};
} // namespace ActivePower
namespace ActivePowerMin {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMin::Id; }
};
} // namespace ActivePowerMin
namespace ActivePowerMax {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMax::Id; }
};
} // namespace ActivePowerMax
namespace ReactivePower {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePower::Id; }
};
} // namespace ReactivePower
namespace ApparentPower {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPower::Id; }
};
} // namespace ApparentPower
namespace PowerFactor {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactor::Id; }
};
} // namespace PowerFactor
namespace AverageRmsVoltageMeasurementPeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriod::Id; }
};
} // namespace AverageRmsVoltageMeasurementPeriod
namespace AverageRmsUnderVoltageCounter {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounter::Id; }
};
} // namespace AverageRmsUnderVoltageCounter
namespace RmsExtremeOverVoltagePeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriod::Id; }
};
} // namespace RmsExtremeOverVoltagePeriod
namespace RmsExtremeUnderVoltagePeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriod::Id; }
};
} // namespace RmsExtremeUnderVoltagePeriod
namespace RmsVoltageSagPeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriod::Id; }
};
} // namespace RmsVoltageSagPeriod
namespace RmsVoltageSwellPeriod {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriod::Id; }
};
} // namespace RmsVoltageSwellPeriod
namespace AcVoltageMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageMultiplier::Id; }
};
} // namespace AcVoltageMultiplier
namespace AcVoltageDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageDivisor::Id; }
};
} // namespace AcVoltageDivisor
namespace AcCurrentMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentMultiplier::Id; }
};
} // namespace AcCurrentMultiplier
namespace AcCurrentDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentDivisor::Id; }
};
} // namespace AcCurrentDivisor
namespace AcPowerMultiplier {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcPowerMultiplier::Id; }
};
} // namespace AcPowerMultiplier
namespace AcPowerDivisor {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcPowerDivisor::Id; }
};
} // namespace AcPowerDivisor
namespace OverloadAlarmsMask {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverloadAlarmsMask::Id; }
};
} // namespace OverloadAlarmsMask
namespace VoltageOverload {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VoltageOverload::Id; }
};
} // namespace VoltageOverload
namespace CurrentOverload {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentOverload::Id; }
};
} // namespace CurrentOverload
namespace AcOverloadAlarmsMask {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcOverloadAlarmsMask::Id; }
};
} // namespace AcOverloadAlarmsMask
namespace AcVoltageOverload {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageOverload::Id; }
};
} // namespace AcVoltageOverload
namespace AcCurrentOverload {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentOverload::Id; }
};
} // namespace AcCurrentOverload
namespace AcActivePowerOverload {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcActivePowerOverload::Id; }
};
} // namespace AcActivePowerOverload
namespace AcReactivePowerOverload {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcReactivePowerOverload::Id; }
};
} // namespace AcReactivePowerOverload
namespace AverageRmsOverVoltage {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltage::Id; }
};
} // namespace AverageRmsOverVoltage
namespace AverageRmsUnderVoltage {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltage::Id; }
};
} // namespace AverageRmsUnderVoltage
namespace RmsExtremeOverVoltage {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltage::Id; }
};
} // namespace RmsExtremeOverVoltage
namespace RmsExtremeUnderVoltage {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltage::Id; }
};
} // namespace RmsExtremeUnderVoltage
namespace RmsVoltageSag {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSag::Id; }
};
} // namespace RmsVoltageSag
namespace RmsVoltageSwell {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwell::Id; }
};
} // namespace RmsVoltageSwell
namespace LineCurrentPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LineCurrentPhaseB::Id; }
};
} // namespace LineCurrentPhaseB
namespace ActiveCurrentPhaseB {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrentPhaseB::Id; }
};
} // namespace ActiveCurrentPhaseB
namespace ReactiveCurrentPhaseB {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrentPhaseB::Id; }
};
} // namespace ReactiveCurrentPhaseB
namespace RmsVoltagePhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltagePhaseB::Id; }
};
} // namespace RmsVoltagePhaseB
namespace RmsVoltageMinPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMinPhaseB::Id; }
};
} // namespace RmsVoltageMinPhaseB
namespace RmsVoltageMaxPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMaxPhaseB::Id; }
};
} // namespace RmsVoltageMaxPhaseB
namespace RmsCurrentPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentPhaseB::Id; }
};
} // namespace RmsCurrentPhaseB
namespace RmsCurrentMinPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMinPhaseB::Id; }
};
} // namespace RmsCurrentMinPhaseB
namespace RmsCurrentMaxPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMaxPhaseB::Id; }
};
} // namespace RmsCurrentMaxPhaseB
namespace ActivePowerPhaseB {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerPhaseB::Id; }
};
} // namespace ActivePowerPhaseB
namespace ActivePowerMinPhaseB {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMinPhaseB::Id; }
};
} // namespace ActivePowerMinPhaseB
namespace ActivePowerMaxPhaseB {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMaxPhaseB::Id; }
};
} // namespace ActivePowerMaxPhaseB
namespace ReactivePowerPhaseB {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePowerPhaseB::Id; }
};
} // namespace ReactivePowerPhaseB
namespace ApparentPowerPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPowerPhaseB::Id; }
};
} // namespace ApparentPowerPhaseB
namespace PowerFactorPhaseB {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactorPhaseB::Id; }
};
} // namespace PowerFactorPhaseB
namespace AverageRmsVoltageMeasurementPeriodPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::Id; }
};
} // namespace AverageRmsVoltageMeasurementPeriodPhaseB
namespace AverageRmsOverVoltageCounterPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltageCounterPhaseB::Id; }
};
} // namespace AverageRmsOverVoltageCounterPhaseB
namespace AverageRmsUnderVoltageCounterPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounterPhaseB::Id; }
};
} // namespace AverageRmsUnderVoltageCounterPhaseB
namespace RmsExtremeOverVoltagePeriodPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriodPhaseB::Id; }
};
} // namespace RmsExtremeOverVoltagePeriodPhaseB
namespace RmsExtremeUnderVoltagePeriodPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriodPhaseB::Id; }
};
} // namespace RmsExtremeUnderVoltagePeriodPhaseB
namespace RmsVoltageSagPeriodPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriodPhaseB::Id; }
};
} // namespace RmsVoltageSagPeriodPhaseB
namespace RmsVoltageSwellPeriodPhaseB {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriodPhaseB::Id; }
};
} // namespace RmsVoltageSwellPeriodPhaseB
namespace LineCurrentPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LineCurrentPhaseC::Id; }
};
} // namespace LineCurrentPhaseC
namespace ActiveCurrentPhaseC {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrentPhaseC::Id; }
};
} // namespace ActiveCurrentPhaseC
namespace ReactiveCurrentPhaseC {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrentPhaseC::Id; }
};
} // namespace ReactiveCurrentPhaseC
namespace RmsVoltagePhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltagePhaseC::Id; }
};
} // namespace RmsVoltagePhaseC
namespace RmsVoltageMinPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMinPhaseC::Id; }
};
} // namespace RmsVoltageMinPhaseC
namespace RmsVoltageMaxPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMaxPhaseC::Id; }
};
} // namespace RmsVoltageMaxPhaseC
namespace RmsCurrentPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentPhaseC::Id; }
};
} // namespace RmsCurrentPhaseC
namespace RmsCurrentMinPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMinPhaseC::Id; }
};
} // namespace RmsCurrentMinPhaseC
namespace RmsCurrentMaxPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMaxPhaseC::Id; }
};
} // namespace RmsCurrentMaxPhaseC
namespace ActivePowerPhaseC {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerPhaseC::Id; }
};
} // namespace ActivePowerPhaseC
namespace ActivePowerMinPhaseC {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMinPhaseC::Id; }
};
} // namespace ActivePowerMinPhaseC
namespace ActivePowerMaxPhaseC {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMaxPhaseC::Id; }
};
} // namespace ActivePowerMaxPhaseC
namespace ReactivePowerPhaseC {
struct TypeInfo
{
    using Type          = int16_t;
    using DecodableType = int16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePowerPhaseC::Id; }
};
} // namespace ReactivePowerPhaseC
namespace ApparentPowerPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPowerPhaseC::Id; }
};
} // namespace ApparentPowerPhaseC
namespace PowerFactorPhaseC {
struct TypeInfo
{
    using Type          = int8_t;
    using DecodableType = int8_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactorPhaseC::Id; }
};
} // namespace PowerFactorPhaseC
namespace AverageRmsVoltageMeasurementPeriodPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::Id; }
};
} // namespace AverageRmsVoltageMeasurementPeriodPhaseC
namespace AverageRmsOverVoltageCounterPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltageCounterPhaseC::Id; }
};
} // namespace AverageRmsOverVoltageCounterPhaseC
namespace AverageRmsUnderVoltageCounterPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounterPhaseC::Id; }
};
} // namespace AverageRmsUnderVoltageCounterPhaseC
namespace RmsExtremeOverVoltagePeriodPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriodPhaseC::Id; }
};
} // namespace RmsExtremeOverVoltagePeriodPhaseC
namespace RmsExtremeUnderVoltagePeriodPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriodPhaseC::Id; }
};
} // namespace RmsExtremeUnderVoltagePeriodPhaseC
namespace RmsVoltageSagPeriodPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriodPhaseC::Id; }
};
} // namespace RmsVoltageSagPeriodPhaseC
namespace RmsVoltageSwellPeriodPhaseC {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriodPhaseC::Id; }
};
} // namespace RmsVoltageSwellPeriodPhaseC
} // namespace Attributes
} // namespace ElectricalMeasurement
namespace Binding {

namespace Commands {
namespace Bind {
enum class Fields
{
    kNodeId     = 0,
    kGroupId    = 1,
    kEndpointId = 2,
    kClusterId  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Bind::Id; }
    static constexpr ClusterId GetClusterId() { return Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Bind::Id; }
    static constexpr ClusterId GetClusterId() { return Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Bind
namespace Unbind {
enum class Fields
{
    kNodeId     = 0,
    kGroupId    = 1,
    kEndpointId = 2,
    kClusterId  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Unbind::Id; }
    static constexpr ClusterId GetClusterId() { return Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Unbind::Id; }
    static constexpr ClusterId GetClusterId() { return Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Unbind
} // namespace Commands

} // namespace Binding
namespace GroupKeyManagement {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for GroupKeySecurityPolicy
enum class GroupKeySecurityPolicy : uint8_t
{
    kStandard   = 0x00,
    kLowLatency = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using GroupKeySecurityPolicy               = EmberAfGroupKeySecurityPolicy;
#endif

namespace Structs {
namespace GroupKey {
enum class Fields
{
    kVendorId               = 0,
    kGroupKeyIndex          = 1,
    kGroupKeyRoot           = 2,
    kGroupKeyEpochStartTime = 3,
    kGroupKeySecurityPolicy = 4,
};

struct Type
{
public:
    uint16_t vendorId;
    uint16_t groupKeyIndex;
    chip::ByteSpan groupKeyRoot;
    uint64_t groupKeyEpochStartTime;
    GroupKeySecurityPolicy groupKeySecurityPolicy;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace GroupKey
namespace GroupState {
enum class Fields
{
    kVendorId         = 0,
    kVendorGroupId    = 1,
    kGroupKeySetIndex = 2,
};

struct Type
{
public:
    uint16_t vendorId;
    uint16_t vendorGroupId;
    uint16_t groupKeySetIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace GroupState
} // namespace Structs

namespace Attributes {
namespace Groups {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::GroupState::Type>;
    using DecodableType = DataModel::DecodableList<Structs::GroupState::DecodableType>;

    static constexpr ClusterId GetClusterId() { return GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Groups::Id; }
};
} // namespace Groups
namespace GroupKeys {
struct TypeInfo
{
    using Type          = DataModel::List<Structs::GroupKey::Type>;
    using DecodableType = DataModel::DecodableList<Structs::GroupKey::DecodableType>;

    static constexpr ClusterId GetClusterId() { return GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupKeys::Id; }
};
} // namespace GroupKeys
} // namespace Attributes
} // namespace GroupKeyManagement
namespace SampleMfgSpecificCluster {

namespace Commands {
namespace CommandOne {
enum class Fields
{
    kArgOne = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CommandOne::Id; }
    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster::Id; }

    uint8_t argOne;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CommandOne::Id; }
    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster::Id; }

    uint8_t argOne;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommandOne
} // namespace Commands

namespace Attributes {
namespace EmberSampleAttribute {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EmberSampleAttribute::Id; }
};
} // namespace EmberSampleAttribute
namespace EmberSampleAttribute2 {
struct TypeInfo
{
    using Type          = uint8_t;
    using DecodableType = uint8_t;

    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EmberSampleAttribute2::Id; }
};
} // namespace EmberSampleAttribute2
} // namespace Attributes
} // namespace SampleMfgSpecificCluster
namespace SampleMfgSpecificCluster2 {

namespace Commands {
namespace CommandTwo {
enum class Fields
{
    kArgOne = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return CommandTwo::Id; }
    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster2::Id; }

    uint8_t argOne;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return CommandTwo::Id; }
    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster2::Id; }

    uint8_t argOne;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommandTwo
} // namespace Commands

namespace Attributes {
namespace EmberSampleAttribute3 {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster2::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EmberSampleAttribute3::Id; }
};
} // namespace EmberSampleAttribute3
namespace EmberSampleAttribute4 {
struct TypeInfo
{
    using Type          = uint16_t;
    using DecodableType = uint16_t;

    static constexpr ClusterId GetClusterId() { return SampleMfgSpecificCluster2::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EmberSampleAttribute4::Id; }
};
} // namespace EmberSampleAttribute4
} // namespace Attributes
} // namespace SampleMfgSpecificCluster2

} // namespace Clusters
} // namespace app
} // namespace chip
