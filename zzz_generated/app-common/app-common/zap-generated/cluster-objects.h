/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app-common/zap-generated/ids/Attributes.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app-common/zap-generated/ids/Events.h>
#include <app/ConcreteAttributePath.h>
#include <app/EventLoggingTypes.h>
#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/util/basic-types.h>
#include <lib/core/ClusterEnums.h>
#include <lib/support/BitMask.h>
#include <protocols/interaction_model/Constants.h>

namespace chip {
namespace app {
namespace Clusters {

namespace detail {
// Structs shared across multiple clusters.
namespace Structs {

namespace ModeTagStruct {
enum class Fields : uint8_t
{
    kMfgCode = 0,
    kValue   = 1,
};

struct Type
{
public:
    Optional<chip::VendorId> mfgCode;
    uint16_t value = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ModeTagStruct
namespace ModeOptionStruct {
enum class Fields : uint8_t
{
    kLabel    = 0,
    kMode     = 1,
    kModeTags = 2,
};

struct Type
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::List<const Structs::ModeTagStruct::Type> modeTags;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::DecodableList<Structs::ModeTagStruct::DecodableType> modeTags;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ModeOptionStruct
namespace MeasurementAccuracyRangeStruct {
enum class Fields : uint8_t
{
    kRangeMin       = 0,
    kRangeMax       = 1,
    kPercentMax     = 2,
    kPercentMin     = 3,
    kPercentTypical = 4,
    kFixedMax       = 5,
    kFixedMin       = 6,
    kFixedTypical   = 7,
};

struct Type
{
public:
    int64_t rangeMin = static_cast<int64_t>(0);
    int64_t rangeMax = static_cast<int64_t>(0);
    Optional<chip::Percent100ths> percentMax;
    Optional<chip::Percent100ths> percentMin;
    Optional<chip::Percent100ths> percentTypical;
    Optional<uint64_t> fixedMax;
    Optional<uint64_t> fixedMin;
    Optional<uint64_t> fixedTypical;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MeasurementAccuracyRangeStruct
namespace MeasurementAccuracyStruct {
enum class Fields : uint8_t
{
    kMeasurementType  = 0,
    kMeasured         = 1,
    kMinMeasuredValue = 2,
    kMaxMeasuredValue = 3,
    kAccuracyRanges   = 4,
};

struct Type
{
public:
    MeasurementTypeEnum measurementType = static_cast<MeasurementTypeEnum>(0);
    bool measured                       = static_cast<bool>(0);
    int64_t minMeasuredValue            = static_cast<int64_t>(0);
    int64_t maxMeasuredValue            = static_cast<int64_t>(0);
    DataModel::List<const Structs::MeasurementAccuracyRangeStruct::Type> accuracyRanges;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    MeasurementTypeEnum measurementType = static_cast<MeasurementTypeEnum>(0);
    bool measured                       = static_cast<bool>(0);
    int64_t minMeasuredValue            = static_cast<int64_t>(0);
    int64_t maxMeasuredValue            = static_cast<int64_t>(0);
    DataModel::DecodableList<Structs::MeasurementAccuracyRangeStruct::DecodableType> accuracyRanges;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace MeasurementAccuracyStruct
namespace DeviceTypeStruct {
enum class Fields : uint8_t
{
    kDeviceType = 0,
    kRevision   = 1,
};

struct Type
{
public:
    chip::DeviceTypeId deviceType = static_cast<chip::DeviceTypeId>(0);
    uint16_t revision             = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DeviceTypeStruct
namespace ApplicationStruct {
enum class Fields : uint8_t
{
    kCatalogVendorID = 0,
    kApplicationID   = 1,
};

struct Type
{
public:
    uint16_t catalogVendorID = static_cast<uint16_t>(0);
    chip::CharSpan applicationID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ApplicationStruct
namespace ErrorStateStruct {
enum class Fields : uint8_t
{
    kErrorStateID      = 0,
    kErrorStateLabel   = 1,
    kErrorStateDetails = 2,
};

struct Type
{
public:
    uint8_t errorStateID = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> errorStateLabel;
    Optional<chip::CharSpan> errorStateDetails;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ErrorStateStruct
namespace ICEServerStruct {
enum class Fields : uint8_t
{
    kUrls       = 1,
    kUsername   = 2,
    kCredential = 3,
    kCaid       = 4,
};

struct Type
{
public:
    DataModel::List<const chip::CharSpan> urls;
    Optional<chip::CharSpan> username;
    Optional<chip::CharSpan> credential;
    Optional<uint16_t> caid;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<chip::CharSpan> urls;
    Optional<chip::CharSpan> username;
    Optional<chip::CharSpan> credential;
    Optional<uint16_t> caid;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ICEServerStruct
namespace LabelStruct {
enum class Fields : uint8_t
{
    kLabel = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::CharSpan label;
    chip::CharSpan value;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LabelStruct
namespace OperationalStateStruct {
enum class Fields : uint8_t
{
    kOperationalStateID    = 0,
    kOperationalStateLabel = 1,
};

struct Type
{
public:
    uint8_t operationalStateID = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> operationalStateLabel;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OperationalStateStruct
namespace ViewportStruct {
enum class Fields : uint8_t
{
    kX1 = 0,
    kY1 = 1,
    kX2 = 2,
    kY2 = 3,
};

struct Type
{
public:
    uint16_t x1 = static_cast<uint16_t>(0);
    uint16_t y1 = static_cast<uint16_t>(0);
    uint16_t x2 = static_cast<uint16_t>(0);
    uint16_t y2 = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ViewportStruct
namespace WebRTCSessionStruct {
enum class Fields : uint8_t
{
    kId              = 1,
    kPeerNodeID      = 2,
    kStreamUsage     = 3,
    kVideoStreamID   = 4,
    kAudioStreamID   = 5,
    kMetadataOptions = 6,
    kFabricIndex     = 254,
};

struct Type
{
public:
    uint16_t id                 = static_cast<uint16_t>(0);
    chip::NodeId peerNodeID     = static_cast<chip::NodeId>(0);
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    DataModel::Nullable<uint16_t> videoStreamID;
    DataModel::Nullable<uint16_t> audioStreamID;
    chip::BitMask<WebRTCMetadataOptionsBitmap> metadataOptions = static_cast<chip::BitMask<WebRTCMetadataOptionsBitmap>>(0);
    chip::FabricIndex fabricIndex                              = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace WebRTCSessionStruct
} // namespace Structs
} // namespace detail

namespace Globals {

// Global structs.
namespace Structs {

namespace TestGlobalStruct {
enum class Fields : uint8_t
{
    kName     = 0,
    kMyBitmap = 1,
    kMyEnum   = 2,
};

struct Type
{
public:
    chip::CharSpan name;
    DataModel::Nullable<chip::BitMask<Globals::TestGlobalBitmap>> myBitmap;
    Optional<DataModel::Nullable<Globals::TestGlobalEnum>> myEnum;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TestGlobalStruct

namespace LocationDescriptorStruct {
enum class Fields : uint8_t
{
    kLocationName = 0,
    kFloorNumber  = 1,
    kAreaType     = 2,
};

struct Type
{
public:
    chip::CharSpan locationName;
    DataModel::Nullable<int16_t> floorNumber;
    DataModel::Nullable<Globals::AreaTypeTag> areaType;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LocationDescriptorStruct

namespace AtomicAttributeStatusStruct {
enum class Fields : uint8_t
{
    kAttributeID = 0,
    kStatusCode  = 1,
};

struct Type
{
public:
    chip::AttributeId attributeID = static_cast<chip::AttributeId>(0);
    uint8_t statusCode            = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AtomicAttributeStatusStruct

} // namespace Structs

namespace Attributes {
namespace GeneratedCommandList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::CommandId>;
    using DecodableType    = DataModel::DecodableList<chip::CommandId>;
    using DecodableArgType = const DataModel::DecodableList<chip::CommandId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::GeneratedCommandList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GeneratedCommandList

namespace AcceptedCommandList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::CommandId>;
    using DecodableType    = DataModel::DecodableList<chip::CommandId>;
    using DecodableArgType = const DataModel::DecodableList<chip::CommandId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::AcceptedCommandList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcceptedCommandList

namespace AttributeList {
struct TypeInfo
{
    using Type             = DataModel::List<const chip::AttributeId>;
    using DecodableType    = DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const DataModel::DecodableList<chip::AttributeId> &;

    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList

namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap

namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

} // namespace Attributes
} // namespace Globals

namespace Identify {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Identify {
struct Type;
struct DecodableType;
} // namespace Identify

namespace TriggerEffect {
struct Type;
struct DecodableType;
} // namespace TriggerEffect

} // namespace Commands

namespace Commands {
namespace Identify {
enum class Fields : uint8_t
{
    kIdentifyTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t identifyTime = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t identifyTime = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Identify
namespace TriggerEffect {
enum class Fields : uint8_t
{
    kEffectIdentifier = 0,
    kEffectVariant    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    EffectVariantEnum effectVariant       = static_cast<EffectVariantEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    EffectVariantEnum effectVariant       = static_cast<EffectVariantEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TriggerEffect
} // namespace Commands

namespace Attributes {

namespace IdentifyTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdentifyTime
namespace IdentifyType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Identify::IdentifyTypeEnum;
    using DecodableType    = chip::app::Clusters::Identify::IdentifyTypeEnum;
    using DecodableArgType = chip::app::Clusters::Identify::IdentifyTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdentifyType
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::IdentifyTime::TypeInfo::DecodableType identifyTime = static_cast<uint16_t>(0);
        Attributes::IdentifyType::TypeInfo::DecodableType identifyType =
            static_cast<chip::app::Clusters::Identify::IdentifyTypeEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Identify
namespace Groups {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddGroup {
struct Type;
struct DecodableType;
} // namespace AddGroup

namespace AddGroupResponse {
struct Type;
struct DecodableType;
} // namespace AddGroupResponse

namespace ViewGroup {
struct Type;
struct DecodableType;
} // namespace ViewGroup

namespace ViewGroupResponse {
struct Type;
struct DecodableType;
} // namespace ViewGroupResponse

namespace GetGroupMembership {
struct Type;
struct DecodableType;
} // namespace GetGroupMembership

namespace GetGroupMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetGroupMembershipResponse

namespace RemoveGroup {
struct Type;
struct DecodableType;
} // namespace RemoveGroup

namespace RemoveGroupResponse {
struct Type;
struct DecodableType;
} // namespace RemoveGroupResponse

namespace RemoveAllGroups {
struct Type;
struct DecodableType;
} // namespace RemoveAllGroups

namespace AddGroupIfIdentifying {
struct Type;
struct DecodableType;
} // namespace AddGroupIfIdentifying

} // namespace Commands

namespace Commands {
namespace AddGroup {
enum class Fields : uint8_t
{
    kGroupID   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::AddGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroup
namespace AddGroupResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupResponse
namespace ViewGroup {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::ViewGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroup
namespace ViewGroupResponse {
enum class Fields : uint8_t
{
    kStatus    = 0,
    kGroupID   = 1,
    kGroupName = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroupResponse
namespace GetGroupMembership {
enum class Fields : uint8_t
{
    kGroupList = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::List<const chip::GroupId> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::DecodableList<chip::GroupId> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembership
namespace GetGroupMembershipResponse {
enum class Fields : uint8_t
{
    kCapacity  = 0,
    kGroupList = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::Nullable<uint8_t> capacity;
    DataModel::List<const chip::GroupId> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::Nullable<uint8_t> capacity;
    DataModel::DecodableList<chip::GroupId> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembershipResponse
namespace RemoveGroup {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Groups::Commands::RemoveGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroup
namespace RemoveGroupResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroupResponse
namespace RemoveAllGroups {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllGroups
namespace AddGroupIfIdentifying {
enum class Fields : uint8_t
{
    kGroupID   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupIfIdentifying
} // namespace Commands

namespace Attributes {

namespace NameSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NameSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NameSupport
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NameSupport::TypeInfo::DecodableType nameSupport =
            static_cast<chip::BitMask<chip::app::Clusters::Groups::NameSupportBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Groups
namespace OnOff {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Off {
struct Type;
struct DecodableType;
} // namespace Off

namespace On {
struct Type;
struct DecodableType;
} // namespace On

namespace Toggle {
struct Type;
struct DecodableType;
} // namespace Toggle

namespace OffWithEffect {
struct Type;
struct DecodableType;
} // namespace OffWithEffect

namespace OnWithRecallGlobalScene {
struct Type;
struct DecodableType;
} // namespace OnWithRecallGlobalScene

namespace OnWithTimedOff {
struct Type;
struct DecodableType;
} // namespace OnWithTimedOff

} // namespace Commands

namespace Commands {
namespace Off {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Off::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Off::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Off
namespace On {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::On::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::On::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace On
namespace Toggle {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Toggle
namespace OffWithEffect {
enum class Fields : uint8_t
{
    kEffectIdentifier = 0,
    kEffectVariant    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    uint8_t effectVariant                 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    EffectIdentifierEnum effectIdentifier = static_cast<EffectIdentifierEnum>(0);
    uint8_t effectVariant                 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OffWithEffect
namespace OnWithRecallGlobalScene {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithRecallGlobalScene
namespace OnWithTimedOff {
enum class Fields : uint8_t
{
    kOnOffControl = 0,
    kOnTime       = 1,
    kOffWaitTime  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    chip::BitMask<OnOffControlBitmap> onOffControl = static_cast<chip::BitMask<OnOffControlBitmap>>(0);
    uint16_t onTime                                = static_cast<uint16_t>(0);
    uint16_t offWaitTime                           = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    chip::BitMask<OnOffControlBitmap> onOffControl = static_cast<chip::BitMask<OnOffControlBitmap>>(0);
    uint16_t onTime                                = static_cast<uint16_t>(0);
    uint16_t offWaitTime                           = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithTimedOff
} // namespace Commands

namespace Attributes {

namespace OnOff {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnOff
namespace GlobalSceneControl {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GlobalSceneControl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GlobalSceneControl
namespace OnTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnTime
namespace OffWaitTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffWaitTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OffWaitTime
namespace StartUpOnOff {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::StartUpOnOffEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::StartUpOnOffEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::OnOff::StartUpOnOffEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpOnOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpOnOff
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OnOff::TypeInfo::DecodableType onOff                           = static_cast<bool>(0);
        Attributes::GlobalSceneControl::TypeInfo::DecodableType globalSceneControl = static_cast<bool>(0);
        Attributes::OnTime::TypeInfo::DecodableType onTime                         = static_cast<uint16_t>(0);
        Attributes::OffWaitTime::TypeInfo::DecodableType offWaitTime               = static_cast<uint16_t>(0);
        Attributes::StartUpOnOff::TypeInfo::DecodableType startUpOnOff;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OnOff
namespace LevelControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToLevel {
struct Type;
struct DecodableType;
} // namespace MoveToLevel

namespace Move {
struct Type;
struct DecodableType;
} // namespace Move

namespace Step {
struct Type;
struct DecodableType;
} // namespace Step

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace MoveToLevelWithOnOff {
struct Type;
struct DecodableType;
} // namespace MoveToLevelWithOnOff

namespace MoveWithOnOff {
struct Type;
struct DecodableType;
} // namespace MoveWithOnOff

namespace StepWithOnOff {
struct Type;
struct DecodableType;
} // namespace StepWithOnOff

namespace StopWithOnOff {
struct Type;
struct DecodableType;
} // namespace StopWithOnOff

namespace MoveToClosestFrequency {
struct Type;
struct DecodableType;
} // namespace MoveToClosestFrequency

} // namespace Commands

namespace Commands {
namespace MoveToLevel {
enum class Fields : uint8_t
{
    kLevel           = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevel
namespace Move {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Move::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Move::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Move
namespace Step {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Step
namespace Stop {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace MoveToLevelWithOnOff {
enum class Fields : uint8_t
{
    kLevel           = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevelWithOnOff
namespace MoveWithOnOff {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveModeEnum moveMode = static_cast<MoveModeEnum>(0);
    DataModel::Nullable<uint8_t> rate;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveWithOnOff
namespace StepWithOnOff {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepModeEnum stepMode = static_cast<StepModeEnum>(0);
    uint8_t stepSize      = static_cast<uint8_t>(0);
    DataModel::Nullable<uint16_t> transitionTime;
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepWithOnOff
namespace StopWithOnOff {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopWithOnOff
namespace MoveToClosestFrequency {
enum class Fields : uint8_t
{
    kFrequency = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToClosestFrequency::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint16_t frequency = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToClosestFrequency::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint16_t frequency = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToClosestFrequency
} // namespace Commands

namespace Attributes {

namespace CurrentLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLevel
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace MinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxLevel
namespace CurrentFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFrequency
namespace MinFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinFrequency
namespace MaxFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxFrequency
namespace Options {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Options::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Options
namespace OnOffTransitionTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOffTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnOffTransitionTime
namespace OnLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnLevel
namespace OnTransitionTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnTransitionTime
namespace OffTransitionTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OffTransitionTime
namespace DefaultMoveRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultMoveRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultMoveRate
namespace StartUpCurrentLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpCurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpCurrentLevel
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentLevel::TypeInfo::DecodableType currentLevel;
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime       = static_cast<uint16_t>(0);
        Attributes::MinLevel::TypeInfo::DecodableType minLevel                 = static_cast<uint8_t>(0);
        Attributes::MaxLevel::TypeInfo::DecodableType maxLevel                 = static_cast<uint8_t>(0);
        Attributes::CurrentFrequency::TypeInfo::DecodableType currentFrequency = static_cast<uint16_t>(0);
        Attributes::MinFrequency::TypeInfo::DecodableType minFrequency         = static_cast<uint16_t>(0);
        Attributes::MaxFrequency::TypeInfo::DecodableType maxFrequency         = static_cast<uint16_t>(0);
        Attributes::Options::TypeInfo::DecodableType options =
            static_cast<chip::BitMask<chip::app::Clusters::LevelControl::OptionsBitmap>>(0);
        Attributes::OnOffTransitionTime::TypeInfo::DecodableType onOffTransitionTime = static_cast<uint16_t>(0);
        Attributes::OnLevel::TypeInfo::DecodableType onLevel;
        Attributes::OnTransitionTime::TypeInfo::DecodableType onTransitionTime;
        Attributes::OffTransitionTime::TypeInfo::DecodableType offTransitionTime;
        Attributes::DefaultMoveRate::TypeInfo::DecodableType defaultMoveRate;
        Attributes::StartUpCurrentLevel::TypeInfo::DecodableType startUpCurrentLevel;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LevelControl
namespace PulseWidthModulation {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PulseWidthModulation
namespace Descriptor {
namespace Structs {
namespace DeviceTypeStruct = Clusters::detail::Structs::DeviceTypeStruct;
namespace SemanticTagStruct {
enum class Fields : uint8_t
{
    kMfgCode     = 0,
    kNamespaceID = 1,
    kTag         = 2,
    kLabel       = 3,
};

struct Type
{
public:
    DataModel::Nullable<chip::VendorId> mfgCode;
    uint8_t namespaceID = static_cast<uint8_t>(0);
    uint8_t tag         = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<chip::CharSpan>> label;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SemanticTagStruct
} // namespace Structs

namespace Attributes {

namespace DeviceTypeList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Descriptor::Structs::DeviceTypeStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceTypeStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceTypeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceTypeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceTypeList
namespace ServerList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ClusterId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ClusterId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ClusterId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ServerList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ServerList
namespace ClientList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ClusterId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ClusterId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ClusterId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClientList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClientList
namespace PartsList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartsList
namespace TagList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Descriptor::Structs::SemanticTagStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::SemanticTagStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::SemanticTagStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TagList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TagList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DeviceTypeList::TypeInfo::DecodableType deviceTypeList;
        Attributes::ServerList::TypeInfo::DecodableType serverList;
        Attributes::ClientList::TypeInfo::DecodableType clientList;
        Attributes::PartsList::TypeInfo::DecodableType partsList;
        Attributes::TagList::TypeInfo::DecodableType tagList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Descriptor
namespace Binding {
namespace Structs {
namespace TargetStruct {
enum class Fields : uint8_t
{
    kNode        = 1,
    kGroup       = 2,
    kEndpoint    = 3,
    kCluster     = 4,
    kFabricIndex = 254,
};

struct Type
{
public:
    Optional<chip::NodeId> node;
    Optional<chip::GroupId> group;
    Optional<chip::EndpointId> endpoint;
    Optional<chip::ClusterId> cluster;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace TargetStruct
} // namespace Structs

namespace Attributes {

namespace Binding {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Binding::Structs::TargetStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Binding::Structs::TargetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Binding::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Binding
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Binding::TypeInfo::DecodableType binding;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Binding
namespace AccessControl {
namespace Structs {
namespace AccessRestrictionStruct {
enum class Fields : uint8_t
{
    kType = 0,
    kId   = 1,
};

struct Type
{
public:
    AccessRestrictionTypeEnum type = static_cast<AccessRestrictionTypeEnum>(0);
    DataModel::Nullable<uint32_t> id;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AccessRestrictionStruct
namespace CommissioningAccessRestrictionEntryStruct {
enum class Fields : uint8_t
{
    kEndpoint     = 0,
    kCluster      = 1,
    kRestrictions = 2,
};

struct Type
{
public:
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);
    chip::ClusterId cluster   = static_cast<chip::ClusterId>(0);
    DataModel::List<const Structs::AccessRestrictionStruct::Type> restrictions;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);
    chip::ClusterId cluster   = static_cast<chip::ClusterId>(0);
    DataModel::DecodableList<Structs::AccessRestrictionStruct::DecodableType> restrictions;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace CommissioningAccessRestrictionEntryStruct
namespace AccessRestrictionEntryStruct {
enum class Fields : uint8_t
{
    kEndpoint     = 0,
    kCluster      = 1,
    kRestrictions = 2,
    kFabricIndex  = 254,
};

struct Type
{
public:
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);
    chip::ClusterId cluster   = static_cast<chip::ClusterId>(0);
    DataModel::List<const Structs::AccessRestrictionStruct::Type> restrictions;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);
    chip::ClusterId cluster   = static_cast<chip::ClusterId>(0);
    DataModel::DecodableList<Structs::AccessRestrictionStruct::DecodableType> restrictions;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace AccessRestrictionEntryStruct
namespace AccessControlTargetStruct {
enum class Fields : uint8_t
{
    kCluster    = 0,
    kEndpoint   = 1,
    kDeviceType = 2,
};

struct Type
{
public:
    DataModel::Nullable<chip::ClusterId> cluster;
    DataModel::Nullable<chip::EndpointId> endpoint;
    DataModel::Nullable<chip::DeviceTypeId> deviceType;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AccessControlTargetStruct
namespace AccessControlEntryStruct {
enum class Fields : uint8_t
{
    kPrivilege   = 1,
    kAuthMode    = 2,
    kSubjects    = 3,
    kTargets     = 4,
    kFabricIndex = 254,
};

struct Type
{
public:
    AccessControlEntryPrivilegeEnum privilege = static_cast<AccessControlEntryPrivilegeEnum>(0);
    AccessControlEntryAuthModeEnum authMode   = static_cast<AccessControlEntryAuthModeEnum>(0);
    DataModel::Nullable<DataModel::List<const uint64_t>> subjects;
    DataModel::Nullable<DataModel::List<const Structs::AccessControlTargetStruct::Type>> targets;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    AccessControlEntryPrivilegeEnum privilege = static_cast<AccessControlEntryPrivilegeEnum>(0);
    AccessControlEntryAuthModeEnum authMode   = static_cast<AccessControlEntryAuthModeEnum>(0);
    DataModel::Nullable<DataModel::DecodableList<uint64_t>> subjects;
    DataModel::Nullable<DataModel::DecodableList<Structs::AccessControlTargetStruct::DecodableType>> targets;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace AccessControlEntryStruct
namespace AccessControlExtensionStruct {
enum class Fields : uint8_t
{
    kData        = 1,
    kFabricIndex = 254,
};

struct Type
{
public:
    chip::ByteSpan data;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace AccessControlExtensionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ReviewFabricRestrictions {
struct Type;
struct DecodableType;
} // namespace ReviewFabricRestrictions

namespace ReviewFabricRestrictionsResponse {
struct Type;
struct DecodableType;
} // namespace ReviewFabricRestrictionsResponse

} // namespace Commands

namespace Commands {
namespace ReviewFabricRestrictions {
enum class Fields : uint8_t
{
    kArl = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReviewFabricRestrictions::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    DataModel::List<const Structs::CommissioningAccessRestrictionEntryStruct::Type> arl;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::AccessControl::Commands::ReviewFabricRestrictionsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReviewFabricRestrictions::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    DataModel::DecodableList<Structs::CommissioningAccessRestrictionEntryStruct::DecodableType> arl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReviewFabricRestrictions
namespace ReviewFabricRestrictionsResponse {
enum class Fields : uint8_t
{
    kToken = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReviewFabricRestrictionsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    uint64_t token = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReviewFabricRestrictionsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    uint64_t token = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReviewFabricRestrictionsResponse
} // namespace Commands

namespace Attributes {

namespace Acl {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntryStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntryStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessControlEntryStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Acl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Acl
namespace Extension {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlExtensionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessControlExtensionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessControlExtensionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Extension::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Extension
namespace SubjectsPerAccessControlEntry {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SubjectsPerAccessControlEntry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SubjectsPerAccessControlEntry
namespace TargetsPerAccessControlEntry {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetsPerAccessControlEntry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetsPerAccessControlEntry
namespace AccessControlEntriesPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AccessControlEntriesPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AccessControlEntriesPerFabric
namespace CommissioningARL {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::AccessControl::Structs::CommissioningAccessRestrictionEntryStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::CommissioningAccessRestrictionEntryStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::CommissioningAccessRestrictionEntryStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CommissioningARL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CommissioningARL
namespace Arl {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessRestrictionEntryStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessRestrictionEntryStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::AccessControl::Structs::AccessRestrictionEntryStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Arl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Arl
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Acl::TypeInfo::DecodableType acl;
        Attributes::Extension::TypeInfo::DecodableType extension;
        Attributes::SubjectsPerAccessControlEntry::TypeInfo::DecodableType subjectsPerAccessControlEntry = static_cast<uint16_t>(0);
        Attributes::TargetsPerAccessControlEntry::TypeInfo::DecodableType targetsPerAccessControlEntry   = static_cast<uint16_t>(0);
        Attributes::AccessControlEntriesPerFabric::TypeInfo::DecodableType accessControlEntriesPerFabric = static_cast<uint16_t>(0);
        Attributes::CommissioningARL::TypeInfo::DecodableType commissioningARL;
        Attributes::Arl::TypeInfo::DecodableType arl;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace AccessControlEntryChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAdminNodeID     = 1,
    kAdminPasscodeID = 2,
    kChangeType      = 3,
    kLatestValue     = 4,
    kFabricIndex     = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlEntryChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr bool kIsFabricScoped = true;

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlEntryStruct::Type> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlEntryChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlEntryStruct::DecodableType> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AccessControlEntryChanged
namespace AccessControlExtensionChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAdminNodeID     = 1,
    kAdminPasscodeID = 2,
    kChangeType      = 3,
    kLatestValue     = 4,
    kFabricIndex     = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlExtensionChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr bool kIsFabricScoped = true;

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlExtensionStruct::Type> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AccessControlExtensionChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    DataModel::Nullable<chip::NodeId> adminNodeID;
    DataModel::Nullable<uint16_t> adminPasscodeID;
    ChangeTypeEnum changeType = static_cast<ChangeTypeEnum>(0);
    DataModel::Nullable<Structs::AccessControlExtensionStruct::DecodableType> latestValue;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AccessControlExtensionChanged
namespace FabricRestrictionReviewUpdate {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kToken             = 0,
    kInstruction       = 1,
    kARLRequestFlowUrl = 2,
    kFabricIndex       = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::FabricRestrictionReviewUpdate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr bool kIsFabricScoped = true;

    uint64_t token = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> instruction;
    Optional<chip::CharSpan> ARLRequestFlowUrl;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::FabricRestrictionReviewUpdate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

    uint64_t token = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> instruction;
    Optional<chip::CharSpan> ARLRequestFlowUrl;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace FabricRestrictionReviewUpdate
} // namespace Events
} // namespace AccessControl
namespace Actions {
namespace Structs {
namespace ActionStruct {
enum class Fields : uint8_t
{
    kActionID          = 0,
    kName              = 1,
    kType              = 2,
    kEndpointListID    = 3,
    kSupportedCommands = 4,
    kState             = 5,
};

struct Type
{
public:
    uint16_t actionID = static_cast<uint16_t>(0);
    chip::CharSpan name;
    ActionTypeEnum type                          = static_cast<ActionTypeEnum>(0);
    uint16_t endpointListID                      = static_cast<uint16_t>(0);
    chip::BitMask<CommandBits> supportedCommands = static_cast<chip::BitMask<CommandBits>>(0);
    ActionStateEnum state                        = static_cast<ActionStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ActionStruct
namespace EndpointListStruct {
enum class Fields : uint8_t
{
    kEndpointListID = 0,
    kName           = 1,
    kType           = 2,
    kEndpoints      = 3,
};

struct Type
{
public:
    uint16_t endpointListID = static_cast<uint16_t>(0);
    chip::CharSpan name;
    EndpointListTypeEnum type = static_cast<EndpointListTypeEnum>(0);
    DataModel::List<const chip::EndpointId> endpoints;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint16_t endpointListID = static_cast<uint16_t>(0);
    chip::CharSpan name;
    EndpointListTypeEnum type = static_cast<EndpointListTypeEnum>(0);
    DataModel::DecodableList<chip::EndpointId> endpoints;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace EndpointListStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace InstantAction {
struct Type;
struct DecodableType;
} // namespace InstantAction

namespace InstantActionWithTransition {
struct Type;
struct DecodableType;
} // namespace InstantActionWithTransition

namespace StartAction {
struct Type;
struct DecodableType;
} // namespace StartAction

namespace StartActionWithDuration {
struct Type;
struct DecodableType;
} // namespace StartActionWithDuration

namespace StopAction {
struct Type;
struct DecodableType;
} // namespace StopAction

namespace PauseAction {
struct Type;
struct DecodableType;
} // namespace PauseAction

namespace PauseActionWithDuration {
struct Type;
struct DecodableType;
} // namespace PauseActionWithDuration

namespace ResumeAction {
struct Type;
struct DecodableType;
} // namespace ResumeAction

namespace EnableAction {
struct Type;
struct DecodableType;
} // namespace EnableAction

namespace EnableActionWithDuration {
struct Type;
struct DecodableType;
} // namespace EnableActionWithDuration

namespace DisableAction {
struct Type;
struct DecodableType;
} // namespace DisableAction

namespace DisableActionWithDuration {
struct Type;
struct DecodableType;
} // namespace DisableActionWithDuration

} // namespace Commands

namespace Commands {
namespace InstantAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InstantAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InstantAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InstantAction
namespace InstantActionWithTransition {
enum class Fields : uint8_t
{
    kActionID       = 0,
    kInvokeID       = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InstantActionWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint16_t transitionTime = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InstantActionWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint16_t transitionTime = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InstantActionWithTransition
namespace StartAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartAction
namespace StartActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartActionWithDuration
namespace StopAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopAction
namespace PauseAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseAction
namespace PauseActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseActionWithDuration
namespace ResumeAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResumeAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResumeAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResumeAction
namespace EnableAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableAction
namespace EnableActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableActionWithDuration
namespace DisableAction {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableAction
namespace DisableActionWithDuration {
enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID = static_cast<uint16_t>(0);
    Optional<uint32_t> invokeID;
    uint32_t duration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableActionWithDuration
} // namespace Commands

namespace Attributes {

namespace ActionList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Actions::Structs::ActionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::ActionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::ActionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActionList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActionList
namespace EndpointLists {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Actions::Structs::EndpointListStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::EndpointListStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Actions::Structs::EndpointListStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndpointLists::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndpointLists
namespace SetupURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetupURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 512; }
};
} // namespace SetupURL
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActionList::TypeInfo::DecodableType actionList;
        Attributes::EndpointLists::TypeInfo::DecodableType endpointLists;
        Attributes::SetupURL::TypeInfo::DecodableType setupURL;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kNewState = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChanged
namespace ActionFailed {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActionID = 0,
    kInvokeID = 1,
    kNewState = 2,
    kError    = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ActionFailed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);
    ActionErrorEnum error    = static_cast<ActionErrorEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ActionFailed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Actions::Id; }

    uint16_t actionID        = static_cast<uint16_t>(0);
    uint32_t invokeID        = static_cast<uint32_t>(0);
    ActionStateEnum newState = static_cast<ActionStateEnum>(0);
    ActionErrorEnum error    = static_cast<ActionErrorEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ActionFailed
} // namespace Events
} // namespace Actions
namespace BasicInformation {
namespace Structs {
namespace CapabilityMinimaStruct {
enum class Fields : uint8_t
{
    kCaseSessionsPerFabric  = 0,
    kSubscriptionsPerFabric = 1,
};

struct Type
{
public:
    uint16_t caseSessionsPerFabric  = static_cast<uint16_t>(0);
    uint16_t subscriptionsPerFabric = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CapabilityMinimaStruct
namespace ProductAppearanceStruct {
enum class Fields : uint8_t
{
    kFinish       = 0,
    kPrimaryColor = 1,
};

struct Type
{
public:
    ProductFinishEnum finish = static_cast<ProductFinishEnum>(0);
    DataModel::Nullable<ColorEnum> primaryColor;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProductAppearanceStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MfgSpecificPing {
struct Type;
struct DecodableType;
} // namespace MfgSpecificPing

} // namespace Commands

namespace Commands {
namespace MfgSpecificPing {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MfgSpecificPing
} // namespace Commands

namespace Attributes {

namespace DataModelRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataModelRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DataModelRevision
namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace ProductName
namespace ProductID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductID
namespace NodeLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NodeLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace NodeLabel
namespace Location {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Location::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 2; }
};
} // namespace Location
namespace HardwareVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 256; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace SerialNumber
namespace LocalConfigDisabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalConfigDisabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalConfigDisabled
namespace Reachable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reachable
namespace UniqueID {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UniqueID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace UniqueID
namespace CapabilityMinima {
struct TypeInfo
{
    using Type             = chip::app::Clusters::BasicInformation::Structs::CapabilityMinimaStruct::Type;
    using DecodableType    = chip::app::Clusters::BasicInformation::Structs::CapabilityMinimaStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::BasicInformation::Structs::CapabilityMinimaStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CapabilityMinima::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CapabilityMinima
namespace ProductAppearance {
struct TypeInfo
{
    using Type             = chip::app::Clusters::BasicInformation::Structs::ProductAppearanceStruct::Type;
    using DecodableType    = chip::app::Clusters::BasicInformation::Structs::ProductAppearanceStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::BasicInformation::Structs::ProductAppearanceStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductAppearance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductAppearance
namespace SpecificationVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpecificationVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpecificationVersion
namespace MaxPathsPerInvoke {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPathsPerInvoke::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPathsPerInvoke
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DataModelRevision::TypeInfo::DecodableType dataModelRevision = static_cast<uint16_t>(0);
        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID = static_cast<chip::VendorId>(0);
        Attributes::ProductName::TypeInfo::DecodableType productName;
        Attributes::ProductID::TypeInfo::DecodableType productID = static_cast<uint16_t>(0);
        Attributes::NodeLabel::TypeInfo::DecodableType nodeLabel;
        Attributes::Location::TypeInfo::DecodableType location;
        Attributes::HardwareVersion::TypeInfo::DecodableType hardwareVersion = static_cast<uint16_t>(0);
        Attributes::HardwareVersionString::TypeInfo::DecodableType hardwareVersionString;
        Attributes::SoftwareVersion::TypeInfo::DecodableType softwareVersion = static_cast<uint32_t>(0);
        Attributes::SoftwareVersionString::TypeInfo::DecodableType softwareVersionString;
        Attributes::ManufacturingDate::TypeInfo::DecodableType manufacturingDate;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductURL::TypeInfo::DecodableType productURL;
        Attributes::ProductLabel::TypeInfo::DecodableType productLabel;
        Attributes::SerialNumber::TypeInfo::DecodableType serialNumber;
        Attributes::LocalConfigDisabled::TypeInfo::DecodableType localConfigDisabled = static_cast<bool>(0);
        Attributes::Reachable::TypeInfo::DecodableType reachable                     = static_cast<bool>(0);
        Attributes::UniqueID::TypeInfo::DecodableType uniqueID;
        Attributes::CapabilityMinima::TypeInfo::DecodableType capabilityMinima;
        Attributes::ProductAppearance::TypeInfo::DecodableType productAppearance;
        Attributes::SpecificationVersion::TypeInfo::DecodableType specificationVersion = static_cast<uint32_t>(0);
        Attributes::MaxPathsPerInvoke::TypeInfo::DecodableType maxPathsPerInvoke       = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StartUp {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StartUp
namespace ShutDown {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShutDown
namespace Leave {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kFabricIndex = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leave
namespace ReachableChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kReachableNewValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BasicInformation::Id; }

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ReachableChanged
} // namespace Events
} // namespace BasicInformation
namespace OtaSoftwareUpdateProvider {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace QueryImage {
struct Type;
struct DecodableType;
} // namespace QueryImage

namespace QueryImageResponse {
struct Type;
struct DecodableType;
} // namespace QueryImageResponse

namespace ApplyUpdateRequest {
struct Type;
struct DecodableType;
} // namespace ApplyUpdateRequest

namespace ApplyUpdateResponse {
struct Type;
struct DecodableType;
} // namespace ApplyUpdateResponse

namespace NotifyUpdateApplied {
struct Type;
struct DecodableType;
} // namespace NotifyUpdateApplied

} // namespace Commands

namespace Commands {
namespace QueryImage {
enum class Fields : uint8_t
{
    kVendorID            = 0,
    kProductID           = 1,
    kSoftwareVersion     = 2,
    kProtocolsSupported  = 3,
    kHardwareVersion     = 4,
    kLocation            = 5,
    kRequestorCanConsent = 6,
    kMetadataForProvider = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::VendorId vendorID  = static_cast<chip::VendorId>(0);
    uint16_t productID       = static_cast<uint16_t>(0);
    uint32_t softwareVersion = static_cast<uint32_t>(0);
    DataModel::List<const DownloadProtocolEnum> protocolsSupported;
    Optional<uint16_t> hardwareVersion;
    Optional<chip::CharSpan> location;
    Optional<bool> requestorCanConsent;
    Optional<chip::ByteSpan> metadataForProvider;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OtaSoftwareUpdateProvider::Commands::QueryImageResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::VendorId vendorID  = static_cast<chip::VendorId>(0);
    uint16_t productID       = static_cast<uint16_t>(0);
    uint32_t softwareVersion = static_cast<uint32_t>(0);
    DataModel::DecodableList<DownloadProtocolEnum> protocolsSupported;
    Optional<uint16_t> hardwareVersion;
    Optional<chip::CharSpan> location;
    Optional<bool> requestorCanConsent;
    Optional<chip::ByteSpan> metadataForProvider;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImage
namespace QueryImageResponse {
enum class Fields : uint8_t
{
    kStatus                = 0,
    kDelayedActionTime     = 1,
    kImageURI              = 2,
    kSoftwareVersion       = 3,
    kSoftwareVersionString = 4,
    kUpdateToken           = 5,
    kUserConsentNeeded     = 6,
    kMetadataForRequestor  = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<uint32_t> delayedActionTime;
    Optional<chip::CharSpan> imageURI;
    Optional<uint32_t> softwareVersion;
    Optional<chip::CharSpan> softwareVersionString;
    Optional<chip::ByteSpan> updateToken;
    Optional<bool> userConsentNeeded;
    Optional<chip::ByteSpan> metadataForRequestor;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<uint32_t> delayedActionTime;
    Optional<chip::CharSpan> imageURI;
    Optional<uint32_t> softwareVersion;
    Optional<chip::CharSpan> softwareVersionString;
    Optional<chip::ByteSpan> updateToken;
    Optional<bool> userConsentNeeded;
    Optional<chip::ByteSpan> metadataForRequestor;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImageResponse
namespace ApplyUpdateRequest {
enum class Fields : uint8_t
{
    kUpdateToken = 0,
    kNewVersion  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateRequest
namespace ApplyUpdateResponse {
enum class Fields : uint8_t
{
    kAction            = 0,
    kDelayedActionTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    ApplyUpdateActionEnum action = static_cast<ApplyUpdateActionEnum>(0);
    uint32_t delayedActionTime   = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    ApplyUpdateActionEnum action = static_cast<ApplyUpdateActionEnum>(0);
    uint32_t delayedActionTime   = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateResponse
namespace NotifyUpdateApplied {
enum class Fields : uint8_t
{
    kUpdateToken     = 0,
    kSoftwareVersion = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NotifyUpdateApplied
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
namespace Structs {
namespace ProviderLocation {
enum class Fields : uint8_t
{
    kProviderNodeID = 1,
    kEndpoint       = 2,
    kFabricIndex    = 254,
};

struct Type
{
public:
    chip::NodeId providerNodeID   = static_cast<chip::NodeId>(0);
    chip::EndpointId endpoint     = static_cast<chip::EndpointId>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace ProviderLocation
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AnnounceOTAProvider {
struct Type;
struct DecodableType;
} // namespace AnnounceOTAProvider

} // namespace Commands

namespace Commands {
namespace AnnounceOTAProvider {
enum class Fields : uint8_t
{
    kProviderNodeID     = 0,
    kVendorID           = 1,
    kAnnouncementReason = 2,
    kMetadataForNode    = 3,
    kEndpoint           = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AnnounceOTAProvider::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    chip::NodeId providerNodeID               = static_cast<chip::NodeId>(0);
    chip::VendorId vendorID                   = static_cast<chip::VendorId>(0);
    AnnouncementReasonEnum announcementReason = static_cast<AnnouncementReasonEnum>(0);
    Optional<chip::ByteSpan> metadataForNode;
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AnnounceOTAProvider::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    chip::NodeId providerNodeID               = static_cast<chip::NodeId>(0);
    chip::VendorId vendorID                   = static_cast<chip::VendorId>(0);
    AnnouncementReasonEnum announcementReason = static_cast<AnnouncementReasonEnum>(0);
    Optional<chip::ByteSpan> metadataForNode;
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AnnounceOTAProvider
} // namespace Commands

namespace Attributes {

namespace DefaultOTAProviders {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOTAProviders::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOTAProviders
namespace UpdatePossible {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdatePossible::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdatePossible
namespace UpdateState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;
    using DecodableType    = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;
    using DecodableArgType = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdateState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdateState
namespace UpdateStateProgress {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdateStateProgress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdateStateProgress
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DefaultOTAProviders::TypeInfo::DecodableType defaultOTAProviders;
        Attributes::UpdatePossible::TypeInfo::DecodableType updatePossible = static_cast<bool>(0);
        Attributes::UpdateState::TypeInfo::DecodableType updateState =
            static_cast<chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum>(0);
        Attributes::UpdateStateProgress::TypeInfo::DecodableType updateStateProgress;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateTransition {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousState         = 0,
    kNewState              = 1,
    kReason                = 2,
    kTargetSoftwareVersion = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr bool kIsFabricScoped = false;

    UpdateStateEnum previousState = static_cast<UpdateStateEnum>(0);
    UpdateStateEnum newState      = static_cast<UpdateStateEnum>(0);
    ChangeReasonEnum reason       = static_cast<ChangeReasonEnum>(0);
    DataModel::Nullable<uint32_t> targetSoftwareVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    UpdateStateEnum previousState = static_cast<UpdateStateEnum>(0);
    UpdateStateEnum newState      = static_cast<UpdateStateEnum>(0);
    ChangeReasonEnum reason       = static_cast<ChangeReasonEnum>(0);
    DataModel::Nullable<uint32_t> targetSoftwareVersion;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateTransition
namespace VersionApplied {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
    kProductID       = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::VersionApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint16_t productID       = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::VersionApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint16_t productID       = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace VersionApplied
namespace DownloadError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
    kBytesDownloaded = 1,
    kProgressPercent = 2,
    kPlatformCode    = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DownloadError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint64_t bytesDownloaded = static_cast<uint64_t>(0);
    DataModel::Nullable<uint8_t> progressPercent;
    DataModel::Nullable<int64_t> platformCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DownloadError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);
    uint64_t bytesDownloaded = static_cast<uint64_t>(0);
    DataModel::Nullable<uint8_t> progressPercent;
    DataModel::Nullable<int64_t> platformCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DownloadError
} // namespace Events
} // namespace OtaSoftwareUpdateRequestor
namespace LocalizationConfiguration {

namespace Attributes {

namespace ActiveLocale {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveLocale::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 35; }
};
} // namespace ActiveLocale
namespace SupportedLocales {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedLocales::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedLocales
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActiveLocale::TypeInfo::DecodableType activeLocale;
        Attributes::SupportedLocales::TypeInfo::DecodableType supportedLocales;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LocalizationConfiguration
namespace TimeFormatLocalization {

namespace Attributes {

namespace HourFormat {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeFormatLocalization::HourFormatEnum;
    using DecodableType    = chip::app::Clusters::TimeFormatLocalization::HourFormatEnum;
    using DecodableArgType = chip::app::Clusters::TimeFormatLocalization::HourFormatEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HourFormat::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HourFormat
namespace ActiveCalendarType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum;
    using DecodableType    = chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum;
    using DecodableArgType = chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCalendarType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCalendarType
namespace SupportedCalendarTypes {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedCalendarTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedCalendarTypes
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TimeFormatLocalization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::HourFormat::TypeInfo::DecodableType hourFormat =
            static_cast<chip::app::Clusters::TimeFormatLocalization::HourFormatEnum>(0);
        Attributes::ActiveCalendarType::TypeInfo::DecodableType activeCalendarType =
            static_cast<chip::app::Clusters::TimeFormatLocalization::CalendarTypeEnum>(0);
        Attributes::SupportedCalendarTypes::TypeInfo::DecodableType supportedCalendarTypes;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TimeFormatLocalization
namespace UnitLocalization {

namespace Attributes {

namespace TemperatureUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::UnitLocalization::TempUnitEnum;
    using DecodableType    = chip::app::Clusters::UnitLocalization::TempUnitEnum;
    using DecodableArgType = chip::app::Clusters::UnitLocalization::TempUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureUnit
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UnitLocalization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureUnit::TypeInfo::DecodableType temperatureUnit =
            static_cast<chip::app::Clusters::UnitLocalization::TempUnitEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace UnitLocalization
namespace PowerSourceConfiguration {

namespace Attributes {

namespace Sources {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Sources::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Sources
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Sources::TypeInfo::DecodableType sources;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PowerSourceConfiguration
namespace PowerSource {
namespace Structs {
namespace BatChargeFaultChangeType {
enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    DataModel::List<const BatChargeFaultEnum> current;
    DataModel::List<const BatChargeFaultEnum> previous;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<BatChargeFaultEnum> current;
    DataModel::DecodableList<BatChargeFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace BatChargeFaultChangeType
namespace BatFaultChangeType {
enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    DataModel::List<const BatFaultEnum> current;
    DataModel::List<const BatFaultEnum> previous;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<BatFaultEnum> current;
    DataModel::DecodableList<BatFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace BatFaultChangeType
namespace WiredFaultChangeType {
enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    DataModel::List<const WiredFaultEnum> current;
    DataModel::List<const WiredFaultEnum> previous;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<WiredFaultEnum> current;
    DataModel::DecodableList<WiredFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace WiredFaultChangeType
} // namespace Structs

namespace Attributes {

namespace Status {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::PowerSourceStatusEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::PowerSourceStatusEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::PowerSourceStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Status
namespace Order {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Order::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Order
namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 60; }
};
} // namespace Description
namespace WiredAssessedInputVoltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedInputVoltage
namespace WiredAssessedInputFrequency {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedInputFrequency
namespace WiredCurrentType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::WiredCurrentTypeEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::WiredCurrentTypeEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::WiredCurrentTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredCurrentType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredCurrentType
namespace WiredAssessedCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedCurrent
namespace WiredNominalVoltage {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredNominalVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredNominalVoltage
namespace WiredMaximumCurrent {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredMaximumCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredMaximumCurrent
namespace WiredPresent {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredPresent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredPresent
namespace ActiveWiredFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::PowerSource::WiredFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::WiredFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::WiredFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveWiredFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveWiredFaults
namespace BatVoltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatVoltage
namespace BatPercentRemaining {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatPercentRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatPercentRemaining
namespace BatTimeRemaining {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatTimeRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatTimeRemaining
namespace BatChargeLevel {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatChargeLevelEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatChargeLevelEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatChargeLevelEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatChargeLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatChargeLevel
namespace BatReplacementNeeded {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatReplacementNeeded::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatReplacementNeeded
namespace BatReplaceability {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatReplaceabilityEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatReplaceabilityEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatReplaceabilityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatReplaceability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatReplaceability
namespace BatPresent {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatPresent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatPresent
namespace ActiveBatFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::PowerSource::BatFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveBatFaults
namespace BatReplacementDescription {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatReplacementDescription::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 60; }
};
} // namespace BatReplacementDescription
namespace BatCommonDesignation {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatCommonDesignationEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatCommonDesignationEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatCommonDesignationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatCommonDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatCommonDesignation
namespace BatANSIDesignation {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatANSIDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 20; }
};
} // namespace BatANSIDesignation
namespace BatIECDesignation {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatIECDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 20; }
};
} // namespace BatIECDesignation
namespace BatApprovedChemistry {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatApprovedChemistryEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatApprovedChemistryEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatApprovedChemistryEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatApprovedChemistry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatApprovedChemistry
namespace BatCapacity {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatCapacity
namespace BatQuantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatQuantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatQuantity
namespace BatChargeState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PowerSource::BatChargeStateEnum;
    using DecodableType    = chip::app::Clusters::PowerSource::BatChargeStateEnum;
    using DecodableArgType = chip::app::Clusters::PowerSource::BatChargeStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatChargeState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatChargeState
namespace BatTimeToFullCharge {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatTimeToFullCharge::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatTimeToFullCharge
namespace BatFunctionalWhileCharging {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatFunctionalWhileCharging::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatFunctionalWhileCharging
namespace BatChargingCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatChargingCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatChargingCurrent
namespace ActiveBatChargeFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::PowerSource::BatChargeFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatChargeFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::PowerSource::BatChargeFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatChargeFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveBatChargeFaults
namespace EndpointList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndpointList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndpointList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Status::TypeInfo::DecodableType status =
            static_cast<chip::app::Clusters::PowerSource::PowerSourceStatusEnum>(0);
        Attributes::Order::TypeInfo::DecodableType order = static_cast<uint8_t>(0);
        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::WiredAssessedInputVoltage::TypeInfo::DecodableType wiredAssessedInputVoltage;
        Attributes::WiredAssessedInputFrequency::TypeInfo::DecodableType wiredAssessedInputFrequency;
        Attributes::WiredCurrentType::TypeInfo::DecodableType wiredCurrentType =
            static_cast<chip::app::Clusters::PowerSource::WiredCurrentTypeEnum>(0);
        Attributes::WiredAssessedCurrent::TypeInfo::DecodableType wiredAssessedCurrent;
        Attributes::WiredNominalVoltage::TypeInfo::DecodableType wiredNominalVoltage = static_cast<uint32_t>(0);
        Attributes::WiredMaximumCurrent::TypeInfo::DecodableType wiredMaximumCurrent = static_cast<uint32_t>(0);
        Attributes::WiredPresent::TypeInfo::DecodableType wiredPresent               = static_cast<bool>(0);
        Attributes::ActiveWiredFaults::TypeInfo::DecodableType activeWiredFaults;
        Attributes::BatVoltage::TypeInfo::DecodableType batVoltage;
        Attributes::BatPercentRemaining::TypeInfo::DecodableType batPercentRemaining;
        Attributes::BatTimeRemaining::TypeInfo::DecodableType batTimeRemaining;
        Attributes::BatChargeLevel::TypeInfo::DecodableType batChargeLevel =
            static_cast<chip::app::Clusters::PowerSource::BatChargeLevelEnum>(0);
        Attributes::BatReplacementNeeded::TypeInfo::DecodableType batReplacementNeeded = static_cast<bool>(0);
        Attributes::BatReplaceability::TypeInfo::DecodableType batReplaceability =
            static_cast<chip::app::Clusters::PowerSource::BatReplaceabilityEnum>(0);
        Attributes::BatPresent::TypeInfo::DecodableType batPresent = static_cast<bool>(0);
        Attributes::ActiveBatFaults::TypeInfo::DecodableType activeBatFaults;
        Attributes::BatReplacementDescription::TypeInfo::DecodableType batReplacementDescription;
        Attributes::BatCommonDesignation::TypeInfo::DecodableType batCommonDesignation =
            static_cast<chip::app::Clusters::PowerSource::BatCommonDesignationEnum>(0);
        Attributes::BatANSIDesignation::TypeInfo::DecodableType batANSIDesignation;
        Attributes::BatIECDesignation::TypeInfo::DecodableType batIECDesignation;
        Attributes::BatApprovedChemistry::TypeInfo::DecodableType batApprovedChemistry =
            static_cast<chip::app::Clusters::PowerSource::BatApprovedChemistryEnum>(0);
        Attributes::BatCapacity::TypeInfo::DecodableType batCapacity = static_cast<uint32_t>(0);
        Attributes::BatQuantity::TypeInfo::DecodableType batQuantity = static_cast<uint8_t>(0);
        Attributes::BatChargeState::TypeInfo::DecodableType batChargeState =
            static_cast<chip::app::Clusters::PowerSource::BatChargeStateEnum>(0);
        Attributes::BatTimeToFullCharge::TypeInfo::DecodableType batTimeToFullCharge;
        Attributes::BatFunctionalWhileCharging::TypeInfo::DecodableType batFunctionalWhileCharging = static_cast<bool>(0);
        Attributes::BatChargingCurrent::TypeInfo::DecodableType batChargingCurrent;
        Attributes::ActiveBatChargeFaults::TypeInfo::DecodableType activeBatChargeFaults;
        Attributes::EndpointList::TypeInfo::DecodableType endpointList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace WiredFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::WiredFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const WiredFaultEnum> current;
    DataModel::List<const WiredFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::WiredFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

    DataModel::DecodableList<WiredFaultEnum> current;
    DataModel::DecodableList<WiredFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace WiredFaultChange
namespace BatFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const BatFaultEnum> current;
    DataModel::List<const BatFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

    DataModel::DecodableList<BatFaultEnum> current;
    DataModel::DecodableList<BatFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BatFaultChange
namespace BatChargeFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatChargeFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const BatChargeFaultEnum> current;
    DataModel::List<const BatChargeFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BatChargeFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

    DataModel::DecodableList<BatChargeFaultEnum> current;
    DataModel::DecodableList<BatChargeFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BatChargeFaultChange
} // namespace Events
} // namespace PowerSource
namespace GeneralCommissioning {
namespace Structs {
namespace BasicCommissioningInfo {
enum class Fields : uint8_t
{
    kFailSafeExpiryLengthSeconds  = 0,
    kMaxCumulativeFailsafeSeconds = 1,
};

struct Type
{
public:
    uint16_t failSafeExpiryLengthSeconds  = static_cast<uint16_t>(0);
    uint16_t maxCumulativeFailsafeSeconds = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace BasicCommissioningInfo
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ArmFailSafe {
struct Type;
struct DecodableType;
} // namespace ArmFailSafe

namespace ArmFailSafeResponse {
struct Type;
struct DecodableType;
} // namespace ArmFailSafeResponse

namespace SetRegulatoryConfig {
struct Type;
struct DecodableType;
} // namespace SetRegulatoryConfig

namespace SetRegulatoryConfigResponse {
struct Type;
struct DecodableType;
} // namespace SetRegulatoryConfigResponse

namespace CommissioningComplete {
struct Type;
struct DecodableType;
} // namespace CommissioningComplete

namespace CommissioningCompleteResponse {
struct Type;
struct DecodableType;
} // namespace CommissioningCompleteResponse

namespace SetTCAcknowledgements {
struct Type;
struct DecodableType;
} // namespace SetTCAcknowledgements

namespace SetTCAcknowledgementsResponse {
struct Type;
struct DecodableType;
} // namespace SetTCAcknowledgementsResponse

} // namespace Commands

namespace Commands {
namespace ArmFailSafe {
enum class Fields : uint8_t
{
    kExpiryLengthSeconds = 0,
    kBreadcrumb          = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds = static_cast<uint16_t>(0);
    uint64_t breadcrumb          = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds = static_cast<uint16_t>(0);
    uint64_t breadcrumb          = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafe
namespace ArmFailSafeResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafeResponse
namespace SetRegulatoryConfig {
enum class Fields : uint8_t
{
    kNewRegulatoryConfig = 0,
    kCountryCode         = 1,
    kBreadcrumb          = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    RegulatoryLocationTypeEnum newRegulatoryConfig = static_cast<RegulatoryLocationTypeEnum>(0);
    chip::CharSpan countryCode;
    uint64_t breadcrumb = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::SetRegulatoryConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    RegulatoryLocationTypeEnum newRegulatoryConfig = static_cast<RegulatoryLocationTypeEnum>(0);
    chip::CharSpan countryCode;
    uint64_t breadcrumb = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfig
namespace SetRegulatoryConfigResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfigResponse
namespace CommissioningComplete {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningComplete
namespace CommissioningCompleteResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningCompleteResponse
namespace SetTCAcknowledgements {
enum class Fields : uint8_t
{
    kTCVersion      = 0,
    kTCUserResponse = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTCAcknowledgements::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t TCVersion      = static_cast<uint16_t>(0);
    uint16_t TCUserResponse = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::SetTCAcknowledgementsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTCAcknowledgements::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t TCVersion      = static_cast<uint16_t>(0);
    uint16_t TCUserResponse = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTCAcknowledgements
namespace SetTCAcknowledgementsResponse {
enum class Fields : uint8_t
{
    kErrorCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTCAcknowledgementsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTCAcknowledgementsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CommissioningErrorEnum errorCode = static_cast<CommissioningErrorEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTCAcknowledgementsResponse
} // namespace Commands

namespace Attributes {

namespace Breadcrumb {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Breadcrumb::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Breadcrumb
namespace BasicCommissioningInfo {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::Type;
    using DecodableType    = chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::DecodableType;
    using DecodableArgType = const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfo::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BasicCommissioningInfo::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BasicCommissioningInfo
namespace RegulatoryConfig {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableType    = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableArgType = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RegulatoryConfig::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RegulatoryConfig
namespace LocationCapability {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableType    = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;
    using DecodableArgType = chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocationCapability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocationCapability
namespace SupportsConcurrentConnection {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportsConcurrentConnection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportsConcurrentConnection
namespace TCAcceptedVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TCAcceptedVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TCAcceptedVersion
namespace TCMinRequiredVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TCMinRequiredVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TCMinRequiredVersion
namespace TCAcknowledgements {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TCAcknowledgements::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TCAcknowledgements
namespace TCAcknowledgementsRequired {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TCAcknowledgementsRequired::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TCAcknowledgementsRequired
namespace TCUpdateDeadline {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TCUpdateDeadline::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TCUpdateDeadline
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Breadcrumb::TypeInfo::DecodableType breadcrumb = static_cast<uint64_t>(0);
        Attributes::BasicCommissioningInfo::TypeInfo::DecodableType basicCommissioningInfo;
        Attributes::RegulatoryConfig::TypeInfo::DecodableType regulatoryConfig =
            static_cast<chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum>(0);
        Attributes::LocationCapability::TypeInfo::DecodableType locationCapability =
            static_cast<chip::app::Clusters::GeneralCommissioning::RegulatoryLocationTypeEnum>(0);
        Attributes::SupportsConcurrentConnection::TypeInfo::DecodableType supportsConcurrentConnection = static_cast<bool>(0);
        Attributes::TCAcceptedVersion::TypeInfo::DecodableType TCAcceptedVersion                       = static_cast<uint16_t>(0);
        Attributes::TCMinRequiredVersion::TypeInfo::DecodableType TCMinRequiredVersion                 = static_cast<uint16_t>(0);
        Attributes::TCAcknowledgements::TypeInfo::DecodableType TCAcknowledgements                     = static_cast<uint16_t>(0);
        Attributes::TCAcknowledgementsRequired::TypeInfo::DecodableType TCAcknowledgementsRequired     = static_cast<bool>(0);
        Attributes::TCUpdateDeadline::TypeInfo::DecodableType TCUpdateDeadline;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace GeneralCommissioning
namespace NetworkCommissioning {
namespace Structs {
namespace NetworkInfoStruct {
enum class Fields : uint8_t
{
    kNetworkID         = 0,
    kConnected         = 1,
    kNetworkIdentifier = 2,
    kClientIdentifier  = 3,
};

struct Type
{
public:
    chip::ByteSpan networkID;
    bool connected = static_cast<bool>(0);
    Optional<DataModel::Nullable<chip::ByteSpan>> networkIdentifier;
    Optional<DataModel::Nullable<chip::ByteSpan>> clientIdentifier;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace NetworkInfoStruct
namespace ThreadInterfaceScanResultStruct {
enum class Fields : uint8_t
{
    kPanId           = 0,
    kExtendedPanId   = 1,
    kNetworkName     = 2,
    kChannel         = 3,
    kVersion         = 4,
    kExtendedAddress = 5,
    kRssi            = 6,
    kLqi             = 7,
};

struct Type
{
public:
    uint16_t panId         = static_cast<uint16_t>(0);
    uint64_t extendedPanId = static_cast<uint64_t>(0);
    chip::CharSpan networkName;
    uint16_t channel = static_cast<uint16_t>(0);
    uint8_t version  = static_cast<uint8_t>(0);
    chip::ByteSpan extendedAddress;
    int8_t rssi = static_cast<int8_t>(0);
    uint8_t lqi = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ThreadInterfaceScanResultStruct
namespace WiFiInterfaceScanResultStruct {
enum class Fields : uint8_t
{
    kSecurity = 0,
    kSsid     = 1,
    kBssid    = 2,
    kChannel  = 3,
    kWiFiBand = 4,
    kRssi     = 5,
};

struct Type
{
public:
    chip::BitMask<WiFiSecurityBitmap> security = static_cast<chip::BitMask<WiFiSecurityBitmap>>(0);
    chip::ByteSpan ssid;
    chip::ByteSpan bssid;
    uint16_t channel      = static_cast<uint16_t>(0);
    WiFiBandEnum wiFiBand = static_cast<WiFiBandEnum>(0);
    int8_t rssi           = static_cast<int8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace WiFiInterfaceScanResultStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ScanNetworks {
struct Type;
struct DecodableType;
} // namespace ScanNetworks

namespace ScanNetworksResponse {
struct Type;
struct DecodableType;
} // namespace ScanNetworksResponse

namespace AddOrUpdateWiFiNetwork {
struct Type;
struct DecodableType;
} // namespace AddOrUpdateWiFiNetwork

namespace AddOrUpdateThreadNetwork {
struct Type;
struct DecodableType;
} // namespace AddOrUpdateThreadNetwork

namespace RemoveNetwork {
struct Type;
struct DecodableType;
} // namespace RemoveNetwork

namespace NetworkConfigResponse {
struct Type;
struct DecodableType;
} // namespace NetworkConfigResponse

namespace ConnectNetwork {
struct Type;
struct DecodableType;
} // namespace ConnectNetwork

namespace ConnectNetworkResponse {
struct Type;
struct DecodableType;
} // namespace ConnectNetworkResponse

namespace ReorderNetwork {
struct Type;
struct DecodableType;
} // namespace ReorderNetwork

namespace QueryIdentity {
struct Type;
struct DecodableType;
} // namespace QueryIdentity

namespace QueryIdentityResponse {
struct Type;
struct DecodableType;
} // namespace QueryIdentityResponse

} // namespace Commands

namespace Commands {
namespace ScanNetworks {
enum class Fields : uint8_t
{
    kSsid       = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    Optional<DataModel::Nullable<chip::ByteSpan>> ssid;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::ScanNetworksResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    Optional<DataModel::Nullable<chip::ByteSpan>> ssid;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworks
namespace ScanNetworksResponse {
enum class Fields : uint8_t
{
    kNetworkingStatus  = 0,
    kDebugText         = 1,
    kWiFiScanResults   = 2,
    kThreadScanResults = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<DataModel::List<const Structs::WiFiInterfaceScanResultStruct::Type>> wiFiScanResults;
    Optional<DataModel::List<const Structs::ThreadInterfaceScanResultStruct::Type>> threadScanResults;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<DataModel::DecodableList<Structs::WiFiInterfaceScanResultStruct::DecodableType>> wiFiScanResults;
    Optional<DataModel::DecodableList<Structs::ThreadInterfaceScanResultStruct::DecodableType>> threadScanResults;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworksResponse
namespace AddOrUpdateWiFiNetwork {
enum class Fields : uint8_t
{
    kSsid             = 0,
    kCredentials      = 1,
    kBreadcrumb       = 2,
    kNetworkIdentity  = 3,
    kClientIdentifier = 4,
    kPossessionNonce  = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    Optional<uint64_t> breadcrumb;
    Optional<chip::ByteSpan> networkIdentity;
    Optional<chip::ByteSpan> clientIdentifier;
    Optional<chip::ByteSpan> possessionNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    Optional<uint64_t> breadcrumb;
    Optional<chip::ByteSpan> networkIdentity;
    Optional<chip::ByteSpan> clientIdentifier;
    Optional<chip::ByteSpan> possessionNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddOrUpdateWiFiNetwork
namespace AddOrUpdateThreadNetwork {
enum class Fields : uint8_t
{
    kOperationalDataset = 0,
    kBreadcrumb         = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddOrUpdateThreadNetwork
namespace RemoveNetwork {
enum class Fields : uint8_t
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveNetwork
namespace NetworkConfigResponse {
enum class Fields : uint8_t
{
    kNetworkingStatus    = 0,
    kDebugText           = 1,
    kNetworkIndex        = 2,
    kClientIdentity      = 3,
    kPossessionSignature = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<uint8_t> networkIndex;
    Optional<chip::ByteSpan> clientIdentity;
    Optional<chip::ByteSpan> possessionSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    Optional<uint8_t> networkIndex;
    Optional<chip::ByteSpan> clientIdentity;
    Optional<chip::ByteSpan> possessionSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkConfigResponse
namespace ConnectNetwork {
enum class Fields : uint8_t
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::ConnectNetworkResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConnectNetwork
namespace ConnectNetworkResponse {
enum class Fields : uint8_t
{
    kNetworkingStatus = 0,
    kDebugText        = 1,
    kErrorValue       = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    DataModel::Nullable<int32_t> errorValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatusEnum networkingStatus = static_cast<NetworkCommissioningStatusEnum>(0);
    Optional<chip::CharSpan> debugText;
    DataModel::Nullable<int32_t> errorValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConnectNetworkResponse
namespace ReorderNetwork {
enum class Fields : uint8_t
{
    kNetworkID    = 0,
    kNetworkIndex = 1,
    kBreadcrumb   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReorderNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint8_t networkIndex = static_cast<uint8_t>(0);
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReorderNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint8_t networkIndex = static_cast<uint8_t>(0);
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReorderNetwork
namespace QueryIdentity {
enum class Fields : uint8_t
{
    kKeyIdentifier   = 0,
    kPossessionNonce = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentity::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan keyIdentifier;
    Optional<chip::ByteSpan> possessionNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::QueryIdentityResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentity::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan keyIdentifier;
    Optional<chip::ByteSpan> possessionNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryIdentity
namespace QueryIdentityResponse {
enum class Fields : uint8_t
{
    kIdentity            = 0,
    kPossessionSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentityResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan identity;
    Optional<chip::ByteSpan> possessionSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryIdentityResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan identity;
    Optional<chip::ByteSpan> possessionSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryIdentityResponse
} // namespace Commands

namespace Attributes {

namespace MaxNetworks {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxNetworks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxNetworks
namespace Networks {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfoStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Networks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Networks
namespace ScanMaxTimeSeconds {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScanMaxTimeSeconds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScanMaxTimeSeconds
namespace ConnectMaxTimeSeconds {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConnectMaxTimeSeconds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ConnectMaxTimeSeconds
namespace InterfaceEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterfaceEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterfaceEnabled
namespace LastNetworkingStatus {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatusEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatusEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatusEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastNetworkingStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastNetworkingStatus
namespace LastNetworkID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastNetworkID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace LastNetworkID
namespace LastConnectErrorValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConnectErrorValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastConnectErrorValue
namespace SupportedWiFiBands {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::NetworkCommissioning::WiFiBandEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::WiFiBandEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::WiFiBandEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedWiFiBands::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedWiFiBands
namespace SupportedThreadFeatures {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedThreadFeatures::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedThreadFeatures
namespace ThreadVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadVersion
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxNetworks::TypeInfo::DecodableType maxNetworks = static_cast<uint8_t>(0);
        Attributes::Networks::TypeInfo::DecodableType networks;
        Attributes::ScanMaxTimeSeconds::TypeInfo::DecodableType scanMaxTimeSeconds       = static_cast<uint8_t>(0);
        Attributes::ConnectMaxTimeSeconds::TypeInfo::DecodableType connectMaxTimeSeconds = static_cast<uint8_t>(0);
        Attributes::InterfaceEnabled::TypeInfo::DecodableType interfaceEnabled           = static_cast<bool>(0);
        Attributes::LastNetworkingStatus::TypeInfo::DecodableType lastNetworkingStatus;
        Attributes::LastNetworkID::TypeInfo::DecodableType lastNetworkID;
        Attributes::LastConnectErrorValue::TypeInfo::DecodableType lastConnectErrorValue;
        Attributes::SupportedWiFiBands::TypeInfo::DecodableType supportedWiFiBands;
        Attributes::SupportedThreadFeatures::TypeInfo::DecodableType supportedThreadFeatures =
            static_cast<chip::BitMask<chip::app::Clusters::NetworkCommissioning::ThreadCapabilitiesBitmap>>(0);
        Attributes::ThreadVersion::TypeInfo::DecodableType threadVersion = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace NetworkCommissioning
namespace DiagnosticLogs {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RetrieveLogsRequest {
struct Type;
struct DecodableType;
} // namespace RetrieveLogsRequest

namespace RetrieveLogsResponse {
struct Type;
struct DecodableType;
} // namespace RetrieveLogsResponse

} // namespace Commands

namespace Commands {
namespace RetrieveLogsRequest {
enum class Fields : uint8_t
{
    kIntent                 = 0,
    kRequestedProtocol      = 1,
    kTransferFileDesignator = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    IntentEnum intent                      = static_cast<IntentEnum>(0);
    TransferProtocolEnum requestedProtocol = static_cast<TransferProtocolEnum>(0);
    Optional<chip::CharSpan> transferFileDesignator;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DiagnosticLogs::Commands::RetrieveLogsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    IntentEnum intent                      = static_cast<IntentEnum>(0);
    TransferProtocolEnum requestedProtocol = static_cast<TransferProtocolEnum>(0);
    Optional<chip::CharSpan> transferFileDesignator;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsRequest
namespace RetrieveLogsResponse {
enum class Fields : uint8_t
{
    kStatus        = 0,
    kLogContent    = 1,
    kUTCTimeStamp  = 2,
    kTimeSinceBoot = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    chip::ByteSpan logContent;
    Optional<uint64_t> UTCTimeStamp;
    Optional<uint64_t> timeSinceBoot;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    chip::ByteSpan logContent;
    Optional<uint64_t> UTCTimeStamp;
    Optional<uint64_t> timeSinceBoot;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsResponse
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace DiagnosticLogs
namespace GeneralDiagnostics {
namespace Structs {
namespace NetworkInterface {
enum class Fields : uint8_t
{
    kName                            = 0,
    kIsOperational                   = 1,
    kOffPremiseServicesReachableIPv4 = 2,
    kOffPremiseServicesReachableIPv6 = 3,
    kHardwareAddress                 = 4,
    kIPv4Addresses                   = 5,
    kIPv6Addresses                   = 6,
    kType                            = 7,
};

struct Type
{
public:
    chip::CharSpan name;
    bool isOperational = static_cast<bool>(0);
    DataModel::Nullable<bool> offPremiseServicesReachableIPv4;
    DataModel::Nullable<bool> offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    DataModel::List<const chip::ByteSpan> IPv4Addresses;
    DataModel::List<const chip::ByteSpan> IPv6Addresses;
    InterfaceTypeEnum type = static_cast<InterfaceTypeEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan name;
    bool isOperational = static_cast<bool>(0);
    DataModel::Nullable<bool> offPremiseServicesReachableIPv4;
    DataModel::Nullable<bool> offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    DataModel::DecodableList<chip::ByteSpan> IPv4Addresses;
    DataModel::DecodableList<chip::ByteSpan> IPv6Addresses;
    InterfaceTypeEnum type = static_cast<InterfaceTypeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace NetworkInterface
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace TestEventTrigger {
struct Type;
struct DecodableType;
} // namespace TestEventTrigger

namespace TimeSnapshot {
struct Type;
struct DecodableType;
} // namespace TimeSnapshot

namespace TimeSnapshotResponse {
struct Type;
struct DecodableType;
} // namespace TimeSnapshotResponse

namespace PayloadTestRequest {
struct Type;
struct DecodableType;
} // namespace PayloadTestRequest

namespace PayloadTestResponse {
struct Type;
struct DecodableType;
} // namespace PayloadTestResponse

} // namespace Commands

namespace Commands {
namespace TestEventTrigger {
enum class Fields : uint8_t
{
    kEnableKey    = 0,
    kEventTrigger = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEventTrigger::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint64_t eventTrigger = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEventTrigger::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint64_t eventTrigger = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEventTrigger
namespace TimeSnapshot {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshot::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralDiagnostics::Commands::TimeSnapshotResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshot::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimeSnapshot
namespace TimeSnapshotResponse {
enum class Fields : uint8_t
{
    kSystemTimeMs = 0,
    kPosixTimeMs  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshotResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    uint64_t systemTimeMs = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> posixTimeMs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimeSnapshotResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    uint64_t systemTimeMs = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> posixTimeMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimeSnapshotResponse
namespace PayloadTestRequest {
enum class Fields : uint8_t
{
    kEnableKey = 0,
    kValue     = 1,
    kCount     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint8_t value  = static_cast<uint8_t>(0);
    uint16_t count = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GeneralDiagnostics::Commands::PayloadTestResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan enableKey;
    uint8_t value  = static_cast<uint8_t>(0);
    uint16_t count = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PayloadTestRequest
namespace PayloadTestResponse {
enum class Fields : uint8_t
{
    kPayload = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PayloadTestResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    chip::ByteSpan payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PayloadTestResponse
} // namespace Commands

namespace Attributes {

namespace NetworkInterfaces {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterface::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterface::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterface::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkInterfaces::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NetworkInterfaces
namespace RebootCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RebootCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RebootCount
namespace UpTime {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpTime
namespace TotalOperationalHours {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalOperationalHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalOperationalHours
namespace BootReason {
struct TypeInfo
{
    using Type             = chip::app::Clusters::GeneralDiagnostics::BootReasonEnum;
    using DecodableType    = chip::app::Clusters::GeneralDiagnostics::BootReasonEnum;
    using DecodableArgType = chip::app::Clusters::GeneralDiagnostics::BootReasonEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BootReason::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BootReason
namespace ActiveHardwareFaults {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::HardwareFaultEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::HardwareFaultEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::HardwareFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveHardwareFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveHardwareFaults
namespace ActiveRadioFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::RadioFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::RadioFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::RadioFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveRadioFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveRadioFaults
namespace ActiveNetworkFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::NetworkFaultEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::NetworkFaultEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::NetworkFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveNetworkFaults
namespace TestEventTriggersEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TestEventTriggersEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TestEventTriggersEnabled
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NetworkInterfaces::TypeInfo::DecodableType networkInterfaces;
        Attributes::RebootCount::TypeInfo::DecodableType rebootCount                     = static_cast<uint16_t>(0);
        Attributes::UpTime::TypeInfo::DecodableType upTime                               = static_cast<uint64_t>(0);
        Attributes::TotalOperationalHours::TypeInfo::DecodableType totalOperationalHours = static_cast<uint32_t>(0);
        Attributes::BootReason::TypeInfo::DecodableType bootReason =
            static_cast<chip::app::Clusters::GeneralDiagnostics::BootReasonEnum>(0);
        Attributes::ActiveHardwareFaults::TypeInfo::DecodableType activeHardwareFaults;
        Attributes::ActiveRadioFaults::TypeInfo::DecodableType activeRadioFaults;
        Attributes::ActiveNetworkFaults::TypeInfo::DecodableType activeNetworkFaults;
        Attributes::TestEventTriggersEnabled::TypeInfo::DecodableType testEventTriggersEnabled = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace HardwareFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const HardwareFaultEnum> current;
    DataModel::List<const HardwareFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<HardwareFaultEnum> current;
    DataModel::DecodableList<HardwareFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace HardwareFaultChange
namespace RadioFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RadioFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const RadioFaultEnum> current;
    DataModel::List<const RadioFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RadioFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<RadioFaultEnum> current;
    DataModel::DecodableList<RadioFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace RadioFaultChange
namespace NetworkFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const NetworkFaultEnum> current;
    DataModel::List<const NetworkFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<NetworkFaultEnum> current;
    DataModel::DecodableList<NetworkFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace NetworkFaultChange
namespace BootReason {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kBootReason = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BootReason::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    BootReasonEnum bootReason = static_cast<BootReasonEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BootReason::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    BootReasonEnum bootReason = static_cast<BootReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BootReason
} // namespace Events
} // namespace GeneralDiagnostics
namespace SoftwareDiagnostics {
namespace Structs {
namespace ThreadMetricsStruct {
enum class Fields : uint8_t
{
    kId               = 0,
    kName             = 1,
    kStackFreeCurrent = 2,
    kStackFreeMinimum = 3,
    kStackSize        = 4,
};

struct Type
{
public:
    uint64_t id = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;
    Optional<uint32_t> stackFreeCurrent;
    Optional<uint32_t> stackFreeMinimum;
    Optional<uint32_t> stackSize;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ThreadMetricsStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetWatermarks {
struct Type;
struct DecodableType;
} // namespace ResetWatermarks

} // namespace Commands

namespace Commands {
namespace ResetWatermarks {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetWatermarks
} // namespace Commands

namespace Attributes {

namespace ThreadMetrics {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetricsStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetricsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetricsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadMetrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadMetrics
namespace CurrentHeapFree {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapFree::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapFree
namespace CurrentHeapUsed {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapUsed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapUsed
namespace CurrentHeapHighWatermark {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapHighWatermark::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapHighWatermark
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ThreadMetrics::TypeInfo::DecodableType threadMetrics;
        Attributes::CurrentHeapFree::TypeInfo::DecodableType currentHeapFree                   = static_cast<uint64_t>(0);
        Attributes::CurrentHeapUsed::TypeInfo::DecodableType currentHeapUsed                   = static_cast<uint64_t>(0);
        Attributes::CurrentHeapHighWatermark::TypeInfo::DecodableType currentHeapHighWatermark = static_cast<uint64_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SoftwareFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kId             = 0,
    kName           = 1,
    kFaultRecording = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SoftwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint64_t id = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> faultRecording;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SoftwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    uint64_t id = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> faultRecording;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SoftwareFault
} // namespace Events
} // namespace SoftwareDiagnostics
namespace ThreadNetworkDiagnostics {
namespace Structs {
namespace NeighborTableStruct {
enum class Fields : uint8_t
{
    kExtAddress       = 0,
    kAge              = 1,
    kRloc16           = 2,
    kLinkFrameCounter = 3,
    kMleFrameCounter  = 4,
    kLqi              = 5,
    kAverageRssi      = 6,
    kLastRssi         = 7,
    kFrameErrorRate   = 8,
    kMessageErrorRate = 9,
    kRxOnWhenIdle     = 10,
    kFullThreadDevice = 11,
    kFullNetworkData  = 12,
    kIsChild          = 13,
};

struct Type
{
public:
    uint64_t extAddress       = static_cast<uint64_t>(0);
    uint32_t age              = static_cast<uint32_t>(0);
    uint16_t rloc16           = static_cast<uint16_t>(0);
    uint32_t linkFrameCounter = static_cast<uint32_t>(0);
    uint32_t mleFrameCounter  = static_cast<uint32_t>(0);
    uint8_t lqi               = static_cast<uint8_t>(0);
    DataModel::Nullable<int8_t> averageRssi;
    DataModel::Nullable<int8_t> lastRssi;
    uint8_t frameErrorRate   = static_cast<uint8_t>(0);
    uint8_t messageErrorRate = static_cast<uint8_t>(0);
    bool rxOnWhenIdle        = static_cast<bool>(0);
    bool fullThreadDevice    = static_cast<bool>(0);
    bool fullNetworkData     = static_cast<bool>(0);
    bool isChild             = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace NeighborTableStruct
namespace OperationalDatasetComponents {
enum class Fields : uint8_t
{
    kActiveTimestampPresent  = 0,
    kPendingTimestampPresent = 1,
    kMasterKeyPresent        = 2,
    kNetworkNamePresent      = 3,
    kExtendedPanIdPresent    = 4,
    kMeshLocalPrefixPresent  = 5,
    kDelayPresent            = 6,
    kPanIdPresent            = 7,
    kChannelPresent          = 8,
    kPskcPresent             = 9,
    kSecurityPolicyPresent   = 10,
    kChannelMaskPresent      = 11,
};

struct Type
{
public:
    bool activeTimestampPresent  = static_cast<bool>(0);
    bool pendingTimestampPresent = static_cast<bool>(0);
    bool masterKeyPresent        = static_cast<bool>(0);
    bool networkNamePresent      = static_cast<bool>(0);
    bool extendedPanIdPresent    = static_cast<bool>(0);
    bool meshLocalPrefixPresent  = static_cast<bool>(0);
    bool delayPresent            = static_cast<bool>(0);
    bool panIdPresent            = static_cast<bool>(0);
    bool channelPresent          = static_cast<bool>(0);
    bool pskcPresent             = static_cast<bool>(0);
    bool securityPolicyPresent   = static_cast<bool>(0);
    bool channelMaskPresent      = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OperationalDatasetComponents
namespace RouteTableStruct {
enum class Fields : uint8_t
{
    kExtAddress      = 0,
    kRloc16          = 1,
    kRouterId        = 2,
    kNextHop         = 3,
    kPathCost        = 4,
    kLQIIn           = 5,
    kLQIOut          = 6,
    kAge             = 7,
    kAllocated       = 8,
    kLinkEstablished = 9,
};

struct Type
{
public:
    uint64_t extAddress  = static_cast<uint64_t>(0);
    uint16_t rloc16      = static_cast<uint16_t>(0);
    uint8_t routerId     = static_cast<uint8_t>(0);
    uint8_t nextHop      = static_cast<uint8_t>(0);
    uint8_t pathCost     = static_cast<uint8_t>(0);
    uint8_t LQIIn        = static_cast<uint8_t>(0);
    uint8_t LQIOut       = static_cast<uint8_t>(0);
    uint8_t age          = static_cast<uint8_t>(0);
    bool allocated       = static_cast<bool>(0);
    bool linkEstablished = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace RouteTableStruct
namespace SecurityPolicy {
enum class Fields : uint8_t
{
    kRotationTime = 0,
    kFlags        = 1,
};

struct Type
{
public:
    uint16_t rotationTime = static_cast<uint16_t>(0);
    uint16_t flags        = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SecurityPolicy
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace Channel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Channel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Channel
namespace RoutingRole {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRoleEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRoleEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::RoutingRoleEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RoutingRole::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RoutingRole
namespace NetworkName {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace NetworkName
namespace PanId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PanId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PanId
namespace ExtendedPanId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExtendedPanId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExtendedPanId
namespace MeshLocalPrefix {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeshLocalPrefix::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 17; }
};
} // namespace MeshLocalPrefix
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace NeighborTable {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTableStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTableStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTableStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeighborTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeighborTable
namespace RouteTable {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTableStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTableStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTableStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouteTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RouteTable
namespace PartitionId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartitionId
namespace Weighting {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Weighting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Weighting
namespace DataVersion {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DataVersion
namespace StableDataVersion {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StableDataVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StableDataVersion
namespace LeaderRouterId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRouterId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LeaderRouterId
namespace DetachedRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DetachedRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DetachedRoleCount
namespace ChildRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChildRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChildRoleCount
namespace RouterRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouterRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RouterRoleCount
namespace LeaderRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LeaderRoleCount
namespace AttachAttemptCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttachAttemptCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttachAttemptCount
namespace PartitionIdChangeCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionIdChangeCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartitionIdChangeCount
namespace BetterPartitionAttachAttemptCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BetterPartitionAttachAttemptCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BetterPartitionAttachAttemptCount
namespace ParentChangeCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ParentChangeCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ParentChangeCount
namespace TxTotalCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxTotalCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxTotalCount
namespace TxUnicastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxUnicastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxUnicastCount
namespace TxBroadcastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBroadcastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBroadcastCount
namespace TxAckRequestedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckRequestedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxAckRequestedCount
namespace TxAckedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxAckedCount
namespace TxNoAckRequestedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxNoAckRequestedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxNoAckRequestedCount
namespace TxDataCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDataCount
namespace TxDataPollCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataPollCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDataPollCount
namespace TxBeaconCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBeaconCount
namespace TxBeaconRequestCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconRequestCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBeaconRequestCount
namespace TxOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxOtherCount
namespace TxRetryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxRetryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxRetryCount
namespace TxDirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDirectMaxRetryExpiryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDirectMaxRetryExpiryCount
namespace TxIndirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxIndirectMaxRetryExpiryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxIndirectMaxRetryExpiryCount
namespace TxErrCcaCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCcaCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrCcaCount
namespace TxErrAbortCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrAbortCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrAbortCount
namespace TxErrBusyChannelCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrBusyChannelCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrBusyChannelCount
namespace RxTotalCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxTotalCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxTotalCount
namespace RxUnicastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxUnicastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxUnicastCount
namespace RxBroadcastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBroadcastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBroadcastCount
namespace RxDataCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDataCount
namespace RxDataPollCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataPollCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDataPollCount
namespace RxBeaconCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBeaconCount
namespace RxBeaconRequestCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconRequestCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBeaconRequestCount
namespace RxOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxOtherCount
namespace RxAddressFilteredCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxAddressFilteredCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxAddressFilteredCount
namespace RxDestAddrFilteredCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDestAddrFilteredCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDestAddrFilteredCount
namespace RxDuplicatedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDuplicatedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDuplicatedCount
namespace RxErrNoFrameCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrNoFrameCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrNoFrameCount
namespace RxErrUnknownNeighborCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrUnknownNeighborCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrUnknownNeighborCount
namespace RxErrInvalidSrcAddrCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrInvalidSrcAddrCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrInvalidSrcAddrCount
namespace RxErrSecCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrSecCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrSecCount
namespace RxErrFcsCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrFcsCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrFcsCount
namespace RxErrOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrOtherCount
namespace ActiveTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveTimestamp
namespace PendingTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PendingTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PendingTimestamp
namespace Delay {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Delay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Delay
namespace SecurityPolicy {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityPolicy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SecurityPolicy
namespace ChannelPage0Mask {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelPage0Mask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 4; }
};
} // namespace ChannelPage0Mask
namespace OperationalDatasetComponents {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalDatasetComponents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalDatasetComponents
namespace ActiveNetworkFaultsList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFaultEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFaultEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFaultEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaultsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveNetworkFaultsList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Channel::TypeInfo::DecodableType channel;
        Attributes::RoutingRole::TypeInfo::DecodableType routingRole;
        Attributes::NetworkName::TypeInfo::DecodableType networkName;
        Attributes::PanId::TypeInfo::DecodableType panId;
        Attributes::ExtendedPanId::TypeInfo::DecodableType extendedPanId;
        Attributes::MeshLocalPrefix::TypeInfo::DecodableType meshLocalPrefix;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount = static_cast<uint64_t>(0);
        Attributes::NeighborTable::TypeInfo::DecodableType neighborTable;
        Attributes::RouteTable::TypeInfo::DecodableType routeTable;
        Attributes::PartitionId::TypeInfo::DecodableType partitionId;
        Attributes::Weighting::TypeInfo::DecodableType weighting;
        Attributes::DataVersion::TypeInfo::DecodableType dataVersion;
        Attributes::StableDataVersion::TypeInfo::DecodableType stableDataVersion;
        Attributes::LeaderRouterId::TypeInfo::DecodableType leaderRouterId;
        Attributes::DetachedRoleCount::TypeInfo::DecodableType detachedRoleCount           = static_cast<uint16_t>(0);
        Attributes::ChildRoleCount::TypeInfo::DecodableType childRoleCount                 = static_cast<uint16_t>(0);
        Attributes::RouterRoleCount::TypeInfo::DecodableType routerRoleCount               = static_cast<uint16_t>(0);
        Attributes::LeaderRoleCount::TypeInfo::DecodableType leaderRoleCount               = static_cast<uint16_t>(0);
        Attributes::AttachAttemptCount::TypeInfo::DecodableType attachAttemptCount         = static_cast<uint16_t>(0);
        Attributes::PartitionIdChangeCount::TypeInfo::DecodableType partitionIdChangeCount = static_cast<uint16_t>(0);
        Attributes::BetterPartitionAttachAttemptCount::TypeInfo::DecodableType betterPartitionAttachAttemptCount =
            static_cast<uint16_t>(0);
        Attributes::ParentChangeCount::TypeInfo::DecodableType parentChangeCount                         = static_cast<uint16_t>(0);
        Attributes::TxTotalCount::TypeInfo::DecodableType txTotalCount                                   = static_cast<uint32_t>(0);
        Attributes::TxUnicastCount::TypeInfo::DecodableType txUnicastCount                               = static_cast<uint32_t>(0);
        Attributes::TxBroadcastCount::TypeInfo::DecodableType txBroadcastCount                           = static_cast<uint32_t>(0);
        Attributes::TxAckRequestedCount::TypeInfo::DecodableType txAckRequestedCount                     = static_cast<uint32_t>(0);
        Attributes::TxAckedCount::TypeInfo::DecodableType txAckedCount                                   = static_cast<uint32_t>(0);
        Attributes::TxNoAckRequestedCount::TypeInfo::DecodableType txNoAckRequestedCount                 = static_cast<uint32_t>(0);
        Attributes::TxDataCount::TypeInfo::DecodableType txDataCount                                     = static_cast<uint32_t>(0);
        Attributes::TxDataPollCount::TypeInfo::DecodableType txDataPollCount                             = static_cast<uint32_t>(0);
        Attributes::TxBeaconCount::TypeInfo::DecodableType txBeaconCount                                 = static_cast<uint32_t>(0);
        Attributes::TxBeaconRequestCount::TypeInfo::DecodableType txBeaconRequestCount                   = static_cast<uint32_t>(0);
        Attributes::TxOtherCount::TypeInfo::DecodableType txOtherCount                                   = static_cast<uint32_t>(0);
        Attributes::TxRetryCount::TypeInfo::DecodableType txRetryCount                                   = static_cast<uint32_t>(0);
        Attributes::TxDirectMaxRetryExpiryCount::TypeInfo::DecodableType txDirectMaxRetryExpiryCount     = static_cast<uint32_t>(0);
        Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo::DecodableType txIndirectMaxRetryExpiryCount = static_cast<uint32_t>(0);
        Attributes::TxErrCcaCount::TypeInfo::DecodableType txErrCcaCount                                 = static_cast<uint32_t>(0);
        Attributes::TxErrAbortCount::TypeInfo::DecodableType txErrAbortCount                             = static_cast<uint32_t>(0);
        Attributes::TxErrBusyChannelCount::TypeInfo::DecodableType txErrBusyChannelCount                 = static_cast<uint32_t>(0);
        Attributes::RxTotalCount::TypeInfo::DecodableType rxTotalCount                                   = static_cast<uint32_t>(0);
        Attributes::RxUnicastCount::TypeInfo::DecodableType rxUnicastCount                               = static_cast<uint32_t>(0);
        Attributes::RxBroadcastCount::TypeInfo::DecodableType rxBroadcastCount                           = static_cast<uint32_t>(0);
        Attributes::RxDataCount::TypeInfo::DecodableType rxDataCount                                     = static_cast<uint32_t>(0);
        Attributes::RxDataPollCount::TypeInfo::DecodableType rxDataPollCount                             = static_cast<uint32_t>(0);
        Attributes::RxBeaconCount::TypeInfo::DecodableType rxBeaconCount                                 = static_cast<uint32_t>(0);
        Attributes::RxBeaconRequestCount::TypeInfo::DecodableType rxBeaconRequestCount                   = static_cast<uint32_t>(0);
        Attributes::RxOtherCount::TypeInfo::DecodableType rxOtherCount                                   = static_cast<uint32_t>(0);
        Attributes::RxAddressFilteredCount::TypeInfo::DecodableType rxAddressFilteredCount               = static_cast<uint32_t>(0);
        Attributes::RxDestAddrFilteredCount::TypeInfo::DecodableType rxDestAddrFilteredCount             = static_cast<uint32_t>(0);
        Attributes::RxDuplicatedCount::TypeInfo::DecodableType rxDuplicatedCount                         = static_cast<uint32_t>(0);
        Attributes::RxErrNoFrameCount::TypeInfo::DecodableType rxErrNoFrameCount                         = static_cast<uint32_t>(0);
        Attributes::RxErrUnknownNeighborCount::TypeInfo::DecodableType rxErrUnknownNeighborCount         = static_cast<uint32_t>(0);
        Attributes::RxErrInvalidSrcAddrCount::TypeInfo::DecodableType rxErrInvalidSrcAddrCount           = static_cast<uint32_t>(0);
        Attributes::RxErrSecCount::TypeInfo::DecodableType rxErrSecCount                                 = static_cast<uint32_t>(0);
        Attributes::RxErrFcsCount::TypeInfo::DecodableType rxErrFcsCount                                 = static_cast<uint32_t>(0);
        Attributes::RxErrOtherCount::TypeInfo::DecodableType rxErrOtherCount                             = static_cast<uint32_t>(0);
        Attributes::ActiveTimestamp::TypeInfo::DecodableType activeTimestamp;
        Attributes::PendingTimestamp::TypeInfo::DecodableType pendingTimestamp;
        Attributes::Delay::TypeInfo::DecodableType delay;
        Attributes::SecurityPolicy::TypeInfo::DecodableType securityPolicy;
        Attributes::ChannelPage0Mask::TypeInfo::DecodableType channelPage0Mask;
        Attributes::OperationalDatasetComponents::TypeInfo::DecodableType operationalDatasetComponents;
        Attributes::ActiveNetworkFaultsList::TypeInfo::DecodableType activeNetworkFaultsList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace ConnectionStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kConnectionStatus = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ConnectionStatus
namespace NetworkFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const NetworkFaultEnum> current;
    DataModel::List<const NetworkFaultEnum> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::NetworkFaultChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    DataModel::DecodableList<NetworkFaultEnum> current;
    DataModel::DecodableList<NetworkFaultEnum> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace NetworkFaultChange
} // namespace Events
} // namespace ThreadNetworkDiagnostics
namespace WiFiNetworkDiagnostics {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace Bssid {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bssid::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 6; }
};
} // namespace Bssid
namespace SecurityType {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::SecurityTypeEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SecurityType
namespace WiFiVersion {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::WiFiNetworkDiagnostics::WiFiVersionEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiFiVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiFiVersion
namespace ChannelNumber {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelNumber
namespace Rssi {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Rssi::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Rssi
namespace BeaconLostCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconLostCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BeaconLostCount
namespace BeaconRxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BeaconRxCount
namespace PacketMulticastRxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketMulticastRxCount
namespace PacketMulticastTxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketMulticastTxCount
namespace PacketUnicastRxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketUnicastRxCount
namespace PacketUnicastTxCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketUnicastTxCount
namespace CurrentMaxRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMaxRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMaxRate
namespace OverrunCount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Bssid::TypeInfo::DecodableType bssid;
        Attributes::SecurityType::TypeInfo::DecodableType securityType;
        Attributes::WiFiVersion::TypeInfo::DecodableType wiFiVersion;
        Attributes::ChannelNumber::TypeInfo::DecodableType channelNumber;
        Attributes::Rssi::TypeInfo::DecodableType rssi;
        Attributes::BeaconLostCount::TypeInfo::DecodableType beaconLostCount;
        Attributes::BeaconRxCount::TypeInfo::DecodableType beaconRxCount;
        Attributes::PacketMulticastRxCount::TypeInfo::DecodableType packetMulticastRxCount;
        Attributes::PacketMulticastTxCount::TypeInfo::DecodableType packetMulticastTxCount;
        Attributes::PacketUnicastRxCount::TypeInfo::DecodableType packetUnicastRxCount;
        Attributes::PacketUnicastTxCount::TypeInfo::DecodableType packetUnicastTxCount;
        Attributes::CurrentMaxRate::TypeInfo::DecodableType currentMaxRate;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace Disconnection {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kReasonCode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Disconnection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t reasonCode = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Disconnection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    uint16_t reasonCode = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Disconnection
namespace AssociationFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAssociationFailureCause = 0,
    kStatus                  = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AssociationFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    AssociationFailureCauseEnum associationFailureCause = static_cast<AssociationFailureCauseEnum>(0);
    uint16_t status                                     = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AssociationFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    AssociationFailureCauseEnum associationFailureCause = static_cast<AssociationFailureCauseEnum>(0);
    uint16_t status                                     = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AssociationFailure
namespace ConnectionStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kConnectionStatus = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr bool kIsFabricScoped = false;

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ConnectionStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    ConnectionStatusEnum connectionStatus = static_cast<ConnectionStatusEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ConnectionStatus
} // namespace Events
} // namespace WiFiNetworkDiagnostics
namespace EthernetNetworkDiagnostics {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace PHYRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::EthernetNetworkDiagnostics::PHYRateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PHYRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PHYRate
namespace FullDuplex {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FullDuplex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FullDuplex
namespace PacketRxCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketRxCount
namespace PacketTxCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketTxCount
namespace TxErrCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrCount
namespace CollisionCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CollisionCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CollisionCount
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace CarrierDetect {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CarrierDetect::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CarrierDetect
namespace TimeSinceReset {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeSinceReset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeSinceReset
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PHYRate::TypeInfo::DecodableType PHYRate;
        Attributes::FullDuplex::TypeInfo::DecodableType fullDuplex;
        Attributes::PacketRxCount::TypeInfo::DecodableType packetRxCount   = static_cast<uint64_t>(0);
        Attributes::PacketTxCount::TypeInfo::DecodableType packetTxCount   = static_cast<uint64_t>(0);
        Attributes::TxErrCount::TypeInfo::DecodableType txErrCount         = static_cast<uint64_t>(0);
        Attributes::CollisionCount::TypeInfo::DecodableType collisionCount = static_cast<uint64_t>(0);
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount     = static_cast<uint64_t>(0);
        Attributes::CarrierDetect::TypeInfo::DecodableType carrierDetect;
        Attributes::TimeSinceReset::TypeInfo::DecodableType timeSinceReset = static_cast<uint64_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EthernetNetworkDiagnostics
namespace TimeSynchronization {
namespace Structs {
namespace DSTOffsetStruct {
enum class Fields : uint8_t
{
    kOffset        = 0,
    kValidStarting = 1,
    kValidUntil    = 2,
};

struct Type
{
public:
    int32_t offset         = static_cast<int32_t>(0);
    uint64_t validStarting = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> validUntil;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DSTOffsetStruct
namespace FabricScopedTrustedTimeSourceStruct {
enum class Fields : uint8_t
{
    kNodeID   = 0,
    kEndpoint = 1,
};

struct Type
{
public:
    chip::NodeId nodeID       = static_cast<chip::NodeId>(0);
    chip::EndpointId endpoint = static_cast<chip::EndpointId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace FabricScopedTrustedTimeSourceStruct
namespace TimeZoneStruct {
enum class Fields : uint8_t
{
    kOffset  = 0,
    kValidAt = 1,
    kName    = 2,
};

struct Type
{
public:
    int32_t offset   = static_cast<int32_t>(0);
    uint64_t validAt = static_cast<uint64_t>(0);
    Optional<chip::CharSpan> name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TimeZoneStruct
namespace TrustedTimeSourceStruct {
enum class Fields : uint8_t
{
    kFabricIndex = 0,
    kNodeID      = 1,
    kEndpoint    = 2,
};

struct Type
{
public:
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    chip::NodeId nodeID           = static_cast<chip::NodeId>(0);
    chip::EndpointId endpoint     = static_cast<chip::EndpointId>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TrustedTimeSourceStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetUTCTime {
struct Type;
struct DecodableType;
} // namespace SetUTCTime

namespace SetTrustedTimeSource {
struct Type;
struct DecodableType;
} // namespace SetTrustedTimeSource

namespace SetTimeZone {
struct Type;
struct DecodableType;
} // namespace SetTimeZone

namespace SetTimeZoneResponse {
struct Type;
struct DecodableType;
} // namespace SetTimeZoneResponse

namespace SetDSTOffset {
struct Type;
struct DecodableType;
} // namespace SetDSTOffset

namespace SetDefaultNTP {
struct Type;
struct DecodableType;
} // namespace SetDefaultNTP

} // namespace Commands

namespace Commands {
namespace SetUTCTime {
enum class Fields : uint8_t
{
    kUTCTime     = 0,
    kGranularity = 1,
    kTimeSource  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUTCTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    uint64_t UTCTime            = static_cast<uint64_t>(0);
    GranularityEnum granularity = static_cast<GranularityEnum>(0);
    Optional<TimeSourceEnum> timeSource;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUTCTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    uint64_t UTCTime            = static_cast<uint64_t>(0);
    GranularityEnum granularity = static_cast<GranularityEnum>(0);
    Optional<TimeSourceEnum> timeSource;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUTCTime
namespace SetTrustedTimeSource {
enum class Fields : uint8_t
{
    kTrustedTimeSource = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<Structs::FabricScopedTrustedTimeSourceStruct::Type> trustedTimeSource;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<Structs::FabricScopedTrustedTimeSourceStruct::DecodableType> trustedTimeSource;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTrustedTimeSource
namespace SetTimeZone {
enum class Fields : uint8_t
{
    kTimeZone = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::List<const Structs::TimeZoneStruct::Type> timeZone;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TimeSynchronization::Commands::SetTimeZoneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::DecodableList<Structs::TimeZoneStruct::DecodableType> timeZone;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTimeZone
namespace SetTimeZoneResponse {
enum class Fields : uint8_t
{
    kDSTOffsetRequired = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    bool DSTOffsetRequired = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTimeZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    bool DSTOffsetRequired = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTimeZoneResponse
namespace SetDSTOffset {
enum class Fields : uint8_t
{
    kDSTOffset = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetDSTOffset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::List<const Structs::DSTOffsetStruct::Type> DSTOffset;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetDSTOffset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::DecodableList<Structs::DSTOffsetStruct::DecodableType> DSTOffset;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetDSTOffset
namespace SetDefaultNTP {
enum class Fields : uint8_t
{
    kDefaultNTP = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetDefaultNTP::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<chip::CharSpan> defaultNTP;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetDefaultNTP::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    DataModel::Nullable<chip::CharSpan> defaultNTP;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetDefaultNTP
} // namespace Commands

namespace Attributes {

namespace UTCTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UTCTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UTCTime
namespace Granularity {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeSynchronization::GranularityEnum;
    using DecodableType    = chip::app::Clusters::TimeSynchronization::GranularityEnum;
    using DecodableArgType = chip::app::Clusters::TimeSynchronization::GranularityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Granularity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Granularity
namespace TimeSource {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeSynchronization::TimeSourceEnum;
    using DecodableType    = chip::app::Clusters::TimeSynchronization::TimeSourceEnum;
    using DecodableArgType = chip::app::Clusters::TimeSynchronization::TimeSourceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeSource
namespace TrustedTimeSource {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::TimeSynchronization::Structs::TrustedTimeSourceStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::TimeSynchronization::Structs::TrustedTimeSourceStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::TimeSynchronization::Structs::TrustedTimeSourceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TrustedTimeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TrustedTimeSource
namespace DefaultNTP {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultNTP::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 128; }
};
} // namespace DefaultNTP
namespace TimeZone {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TimeSynchronization::Structs::TimeZoneStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TimeSynchronization::Structs::TimeZoneStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TimeSynchronization::Structs::TimeZoneStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZone::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZone
namespace DSTOffset {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TimeSynchronization::Structs::DSTOffsetStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TimeSynchronization::Structs::DSTOffsetStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TimeSynchronization::Structs::DSTOffsetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DSTOffset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DSTOffset
namespace LocalTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTime
namespace TimeZoneDatabase {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum;
    using DecodableType    = chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum;
    using DecodableArgType = chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZoneDatabase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZoneDatabase
namespace NTPServerAvailable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NTPServerAvailable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NTPServerAvailable
namespace TimeZoneListMaxSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZoneListMaxSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZoneListMaxSize
namespace DSTOffsetListMaxSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DSTOffsetListMaxSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DSTOffsetListMaxSize
namespace SupportsDNSResolve {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportsDNSResolve::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportsDNSResolve
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::UTCTime::TypeInfo::DecodableType UTCTime;
        Attributes::Granularity::TypeInfo::DecodableType granularity =
            static_cast<chip::app::Clusters::TimeSynchronization::GranularityEnum>(0);
        Attributes::TimeSource::TypeInfo::DecodableType timeSource =
            static_cast<chip::app::Clusters::TimeSynchronization::TimeSourceEnum>(0);
        Attributes::TrustedTimeSource::TypeInfo::DecodableType trustedTimeSource;
        Attributes::DefaultNTP::TypeInfo::DecodableType defaultNTP;
        Attributes::TimeZone::TypeInfo::DecodableType timeZone;
        Attributes::DSTOffset::TypeInfo::DecodableType DSTOffset;
        Attributes::LocalTime::TypeInfo::DecodableType localTime;
        Attributes::TimeZoneDatabase::TypeInfo::DecodableType timeZoneDatabase =
            static_cast<chip::app::Clusters::TimeSynchronization::TimeZoneDatabaseEnum>(0);
        Attributes::NTPServerAvailable::TypeInfo::DecodableType NTPServerAvailable     = static_cast<bool>(0);
        Attributes::TimeZoneListMaxSize::TypeInfo::DecodableType timeZoneListMaxSize   = static_cast<uint8_t>(0);
        Attributes::DSTOffsetListMaxSize::TypeInfo::DecodableType DSTOffsetListMaxSize = static_cast<uint8_t>(0);
        Attributes::SupportsDNSResolve::TypeInfo::DecodableType supportsDNSResolve     = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace DSTTableEmpty {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTTableEmpty::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTTableEmpty::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DSTTableEmpty
namespace DSTStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kDSTOffsetActive = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool DSTOffsetActive = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DSTStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    bool DSTOffsetActive = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DSTStatus
namespace TimeZoneStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kOffset = 0,
    kName   = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    int32_t offset = static_cast<int32_t>(0);
    Optional<chip::CharSpan> name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    int32_t offset = static_cast<int32_t>(0);
    Optional<chip::CharSpan> name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TimeZoneStatus
namespace TimeFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TimeFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TimeFailure
namespace MissingTrustedTimeSource {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MissingTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MissingTrustedTimeSource::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MissingTrustedTimeSource
} // namespace Events
} // namespace TimeSynchronization
namespace BridgedDeviceBasicInformation {
namespace Structs {
namespace ProductAppearanceStruct {
enum class Fields : uint8_t
{
    kFinish       = 0,
    kPrimaryColor = 1,
};

struct Type
{
public:
    ProductFinishEnum finish = static_cast<ProductFinishEnum>(0);
    DataModel::Nullable<ColorEnum> primaryColor;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProductAppearanceStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace KeepActive {
struct Type;
struct DecodableType;
} // namespace KeepActive

} // namespace Commands

namespace Commands {
namespace KeepActive {
enum class Fields : uint8_t
{
    kStayActiveDuration = 0,
    kTimeoutMs          = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeepActive::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    uint32_t stayActiveDuration = static_cast<uint32_t>(0);
    uint32_t timeoutMs          = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeepActive::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    uint32_t stayActiveDuration = static_cast<uint32_t>(0);
    uint32_t timeoutMs          = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeepActive
} // namespace Commands

namespace Attributes {

namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace ProductName
namespace ProductID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductID
namespace NodeLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NodeLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace NodeLabel
namespace HardwareVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 256; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace SerialNumber
namespace Reachable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reachable
namespace UniqueID {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UniqueID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace UniqueID
namespace ProductAppearance {
struct TypeInfo
{
    using Type          = chip::app::Clusters::BridgedDeviceBasicInformation::Structs::ProductAppearanceStruct::Type;
    using DecodableType = chip::app::Clusters::BridgedDeviceBasicInformation::Structs::ProductAppearanceStruct::DecodableType;
    using DecodableArgType =
        const chip::app::Clusters::BridgedDeviceBasicInformation::Structs::ProductAppearanceStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductAppearance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductAppearance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID = static_cast<chip::VendorId>(0);
        Attributes::ProductName::TypeInfo::DecodableType productName;
        Attributes::ProductID::TypeInfo::DecodableType productID = static_cast<uint16_t>(0);
        Attributes::NodeLabel::TypeInfo::DecodableType nodeLabel;
        Attributes::HardwareVersion::TypeInfo::DecodableType hardwareVersion = static_cast<uint16_t>(0);
        Attributes::HardwareVersionString::TypeInfo::DecodableType hardwareVersionString;
        Attributes::SoftwareVersion::TypeInfo::DecodableType softwareVersion = static_cast<uint32_t>(0);
        Attributes::SoftwareVersionString::TypeInfo::DecodableType softwareVersionString;
        Attributes::ManufacturingDate::TypeInfo::DecodableType manufacturingDate;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductURL::TypeInfo::DecodableType productURL;
        Attributes::ProductLabel::TypeInfo::DecodableType productLabel;
        Attributes::SerialNumber::TypeInfo::DecodableType serialNumber;
        Attributes::Reachable::TypeInfo::DecodableType reachable = static_cast<bool>(0);
        Attributes::UniqueID::TypeInfo::DecodableType uniqueID;
        Attributes::ProductAppearance::TypeInfo::DecodableType productAppearance;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StartUp {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSoftwareVersion = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    uint32_t softwareVersion = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StartUp
namespace ShutDown {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShutDown
namespace Leave {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leave
namespace ReachableChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kReachableNewValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    bool reachableNewValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ReachableChanged
namespace ActiveChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPromisedActiveDuration = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ActiveChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t promisedActiveDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ActiveChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasicInformation::Id; }

    uint32_t promisedActiveDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ActiveChanged
} // namespace Events
} // namespace BridgedDeviceBasicInformation
namespace Switch {

namespace Attributes {

namespace NumberOfPositions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPositions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPositions
namespace CurrentPosition {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPosition
namespace MultiPressMax {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MultiPressMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MultiPressMax
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NumberOfPositions::TypeInfo::DecodableType numberOfPositions = static_cast<uint8_t>(0);
        Attributes::CurrentPosition::TypeInfo::DecodableType currentPosition     = static_cast<uint8_t>(0);
        Attributes::MultiPressMax::TypeInfo::DecodableType multiPressMax         = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SwitchLatched {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SwitchLatched::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SwitchLatched::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SwitchLatched
namespace InitialPress {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InitialPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InitialPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InitialPress
namespace LongPress {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongPress::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LongPress
namespace ShortRelease {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShortRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ShortRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShortRelease
namespace LongRelease {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LongRelease::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LongRelease
namespace MultiPressOngoing {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kNewPosition                   = 0,
    kCurrentNumberOfPressesCounted = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressOngoing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t newPosition                   = static_cast<uint8_t>(0);
    uint8_t currentNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressOngoing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition                   = static_cast<uint8_t>(0);
    uint8_t currentNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MultiPressOngoing
namespace MultiPressComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kPreviousPosition            = 0,
    kTotalNumberOfPressesCounted = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t previousPosition            = static_cast<uint8_t>(0);
    uint8_t totalNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MultiPressComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition            = static_cast<uint8_t>(0);
    uint8_t totalNumberOfPressesCounted = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MultiPressComplete
} // namespace Events
} // namespace Switch
namespace AdministratorCommissioning {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace OpenCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace OpenCommissioningWindow

namespace OpenBasicCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace OpenBasicCommissioningWindow

namespace RevokeCommissioning {
struct Type;
struct DecodableType;
} // namespace RevokeCommissioning

} // namespace Commands

namespace Commands {
namespace OpenCommissioningWindow {
enum class Fields : uint8_t
{
    kCommissioningTimeout = 0,
    kPAKEPasscodeVerifier = 1,
    kDiscriminator        = 2,
    kIterations           = 3,
    kSalt                 = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    chip::ByteSpan PAKEPasscodeVerifier;
    uint16_t discriminator = static_cast<uint16_t>(0);
    uint32_t iterations    = static_cast<uint32_t>(0);
    chip::ByteSpan salt;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    chip::ByteSpan PAKEPasscodeVerifier;
    uint16_t discriminator = static_cast<uint16_t>(0);
    uint32_t iterations    = static_cast<uint32_t>(0);
    chip::ByteSpan salt;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenCommissioningWindow
namespace OpenBasicCommissioningWindow {
enum class Fields : uint8_t
{
    kCommissioningTimeout = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenBasicCommissioningWindow
namespace RevokeCommissioning {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RevokeCommissioning
} // namespace Commands

namespace Attributes {

namespace WindowStatus {
struct TypeInfo
{
    using Type             = chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum;
    using DecodableType    = chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum;
    using DecodableArgType = chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindowStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindowStatus
namespace AdminFabricIndex {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::FabricIndex>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::FabricIndex>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::FabricIndex> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AdminFabricIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AdminFabricIndex
namespace AdminVendorId {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::VendorId>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::VendorId>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::VendorId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AdminVendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AdminVendorId
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::WindowStatus::TypeInfo::DecodableType windowStatus =
            static_cast<chip::app::Clusters::AdministratorCommissioning::CommissioningWindowStatusEnum>(0);
        Attributes::AdminFabricIndex::TypeInfo::DecodableType adminFabricIndex;
        Attributes::AdminVendorId::TypeInfo::DecodableType adminVendorId;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace AdministratorCommissioning
namespace OperationalCredentials {
namespace Structs {
namespace FabricDescriptorStruct {
enum class Fields : uint8_t
{
    kRootPublicKey            = 1,
    kVendorID                 = 2,
    kFabricID                 = 3,
    kNodeID                   = 4,
    kLabel                    = 5,
    kVidVerificationStatement = 6,
    kFabricIndex              = 254,
};

struct Type
{
public:
    chip::ByteSpan rootPublicKey;
    chip::VendorId vendorID = static_cast<chip::VendorId>(0);
    chip::FabricId fabricID = static_cast<chip::FabricId>(0);
    chip::NodeId nodeID     = static_cast<chip::NodeId>(0);
    chip::CharSpan label;
    Optional<chip::ByteSpan> vidVerificationStatement;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace FabricDescriptorStruct
namespace NOCStruct {
enum class Fields : uint8_t
{
    kNoc         = 1,
    kIcac        = 2,
    kVvsc        = 3,
    kFabricIndex = 254,
};

struct Type
{
public:
    chip::ByteSpan noc;
    DataModel::Nullable<chip::ByteSpan> icac;
    Optional<chip::ByteSpan> vvsc;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace NOCStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AttestationRequest {
struct Type;
struct DecodableType;
} // namespace AttestationRequest

namespace AttestationResponse {
struct Type;
struct DecodableType;
} // namespace AttestationResponse

namespace CertificateChainRequest {
struct Type;
struct DecodableType;
} // namespace CertificateChainRequest

namespace CertificateChainResponse {
struct Type;
struct DecodableType;
} // namespace CertificateChainResponse

namespace CSRRequest {
struct Type;
struct DecodableType;
} // namespace CSRRequest

namespace CSRResponse {
struct Type;
struct DecodableType;
} // namespace CSRResponse

namespace AddNOC {
struct Type;
struct DecodableType;
} // namespace AddNOC

namespace UpdateNOC {
struct Type;
struct DecodableType;
} // namespace UpdateNOC

namespace NOCResponse {
struct Type;
struct DecodableType;
} // namespace NOCResponse

namespace UpdateFabricLabel {
struct Type;
struct DecodableType;
} // namespace UpdateFabricLabel

namespace RemoveFabric {
struct Type;
struct DecodableType;
} // namespace RemoveFabric

namespace AddTrustedRootCertificate {
struct Type;
struct DecodableType;
} // namespace AddTrustedRootCertificate

namespace SetVidVerificationStatement {
struct Type;
struct DecodableType;
} // namespace SetVidVerificationStatement

namespace SignVidVerificationRequest {
struct Type;
struct DecodableType;
} // namespace SignVidVerificationRequest

namespace SignVidVerificationResponse {
struct Type;
struct DecodableType;
} // namespace SignVidVerificationResponse

} // namespace Commands

namespace Commands {
namespace AttestationRequest {
enum class Fields : uint8_t
{
    kAttestationNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::AttestationResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationRequest
namespace AttestationResponse {
enum class Fields : uint8_t
{
    kAttestationElements  = 0,
    kAttestationSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan attestationSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan attestationSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationResponse
namespace CertificateChainRequest {
enum class Fields : uint8_t
{
    kCertificateType = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    CertificateChainTypeEnum certificateType = static_cast<CertificateChainTypeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::CertificateChainResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    CertificateChainTypeEnum certificateType = static_cast<CertificateChainTypeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainRequest
namespace CertificateChainResponse {
enum class Fields : uint8_t
{
    kCertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan certificate;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan certificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainResponse
namespace CSRRequest {
enum class Fields : uint8_t
{
    kCSRNonce       = 0,
    kIsForUpdateNOC = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;
    Optional<bool> isForUpdateNOC;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::CSRResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;
    Optional<bool> isForUpdateNOC;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CSRRequest
namespace CSRResponse {
enum class Fields : uint8_t
{
    kNOCSRElements        = 0,
    kAttestationSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CSRResponse
namespace AddNOC {
enum class Fields : uint8_t
{
    kNOCValue         = 0,
    kICACValue        = 1,
    kIPKValue         = 2,
    kCaseAdminSubject = 3,
    kAdminVendorId    = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    chip::ByteSpan IPKValue;
    uint64_t caseAdminSubject    = static_cast<uint64_t>(0);
    chip::VendorId adminVendorId = static_cast<chip::VendorId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    chip::ByteSpan IPKValue;
    uint64_t caseAdminSubject    = static_cast<uint64_t>(0);
    chip::VendorId adminVendorId = static_cast<chip::VendorId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddNOC
namespace UpdateNOC {
enum class Fields : uint8_t
{
    kNOCValue  = 0,
    kICACValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateNOC
namespace NOCResponse {
enum class Fields : uint8_t
{
    kStatusCode  = 0,
    kFabricIndex = 1,
    kDebugText   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    NodeOperationalCertStatusEnum statusCode = static_cast<NodeOperationalCertStatusEnum>(0);
    Optional<chip::FabricIndex> fabricIndex;
    Optional<chip::CharSpan> debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    NodeOperationalCertStatusEnum statusCode = static_cast<NodeOperationalCertStatusEnum>(0);
    Optional<chip::FabricIndex> fabricIndex;
    Optional<chip::CharSpan> debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NOCResponse
namespace UpdateFabricLabel {
enum class Fields : uint8_t
{
    kLabel = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::CharSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::CharSpan label;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateFabricLabel
namespace RemoveFabric {
enum class Fields : uint8_t
{
    kFabricIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveFabric
namespace AddTrustedRootCertificate {
enum class Fields : uint8_t
{
    kRootCACertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan rootCACertificate;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan rootCACertificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddTrustedRootCertificate
namespace SetVidVerificationStatement {
enum class Fields : uint8_t
{
    kVendorID                 = 0,
    kVidVerificationStatement = 1,
    kVvsc                     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetVidVerificationStatement::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    Optional<chip::VendorId> vendorID;
    Optional<chip::ByteSpan> vidVerificationStatement;
    Optional<chip::ByteSpan> vvsc;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetVidVerificationStatement::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    Optional<chip::VendorId> vendorID;
    Optional<chip::ByteSpan> vidVerificationStatement;
    Optional<chip::ByteSpan> vvsc;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetVidVerificationStatement
namespace SignVidVerificationRequest {
enum class Fields : uint8_t
{
    kFabricIndex     = 0,
    kClientChallenge = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SignVidVerificationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    chip::ByteSpan clientChallenge;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::SignVidVerificationResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SignVidVerificationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    chip::ByteSpan clientChallenge;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignVidVerificationRequest
namespace SignVidVerificationResponse {
enum class Fields : uint8_t
{
    kFabricIndex          = 0,
    kFabricBindingVersion = 1,
    kSignature            = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SignVidVerificationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    uint8_t fabricBindingVersion  = static_cast<uint8_t>(0);
    chip::ByteSpan signature;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SignVidVerificationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);
    uint8_t fabricBindingVersion  = static_cast<uint8_t>(0);
    chip::ByteSpan signature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignVidVerificationResponse
} // namespace Commands

namespace Attributes {

namespace NOCs {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::NOCStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NOCs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NOCs
namespace Fabrics {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptorStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptorStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptorStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Fabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Fabrics
namespace SupportedFabrics {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedFabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedFabrics
namespace CommissionedFabrics {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CommissionedFabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CommissionedFabrics
namespace TrustedRootCertificates {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TrustedRootCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TrustedRootCertificates
namespace CurrentFabricIndex {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFabricIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFabricIndex
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NOCs::TypeInfo::DecodableType NOCs;
        Attributes::Fabrics::TypeInfo::DecodableType fabrics;
        Attributes::SupportedFabrics::TypeInfo::DecodableType supportedFabrics       = static_cast<uint8_t>(0);
        Attributes::CommissionedFabrics::TypeInfo::DecodableType commissionedFabrics = static_cast<uint8_t>(0);
        Attributes::TrustedRootCertificates::TypeInfo::DecodableType trustedRootCertificates;
        Attributes::CurrentFabricIndex::TypeInfo::DecodableType currentFabricIndex = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OperationalCredentials
namespace GroupKeyManagement {
namespace Structs {
namespace GroupInfoMapStruct {
enum class Fields : uint8_t
{
    kGroupId     = 1,
    kEndpoints   = 2,
    kGroupName   = 3,
    kFabricIndex = 254,
};

struct Type
{
public:
    chip::GroupId groupId = static_cast<chip::GroupId>(0);
    DataModel::List<const chip::EndpointId> endpoints;
    Optional<chip::CharSpan> groupName;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    chip::GroupId groupId = static_cast<chip::GroupId>(0);
    DataModel::DecodableList<chip::EndpointId> endpoints;
    Optional<chip::CharSpan> groupName;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace GroupInfoMapStruct
namespace GroupKeyMapStruct {
enum class Fields : uint8_t
{
    kGroupId       = 1,
    kGroupKeySetID = 2,
    kFabricIndex   = 254,
};

struct Type
{
public:
    chip::GroupId groupId         = static_cast<chip::GroupId>(0);
    uint16_t groupKeySetID        = static_cast<uint16_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace GroupKeyMapStruct
namespace GroupKeySetStruct {
enum class Fields : uint8_t
{
    kGroupKeySetID          = 0,
    kGroupKeySecurityPolicy = 1,
    kEpochKey0              = 2,
    kEpochStartTime0        = 3,
    kEpochKey1              = 4,
    kEpochStartTime1        = 5,
    kEpochKey2              = 6,
    kEpochStartTime2        = 7,
};

struct Type
{
public:
    uint16_t groupKeySetID                            = static_cast<uint16_t>(0);
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = static_cast<GroupKeySecurityPolicyEnum>(0);
    DataModel::Nullable<chip::ByteSpan> epochKey0;
    DataModel::Nullable<uint64_t> epochStartTime0;
    DataModel::Nullable<chip::ByteSpan> epochKey1;
    DataModel::Nullable<uint64_t> epochStartTime1;
    DataModel::Nullable<chip::ByteSpan> epochKey2;
    DataModel::Nullable<uint64_t> epochStartTime2;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace GroupKeySetStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace KeySetWrite {
struct Type;
struct DecodableType;
} // namespace KeySetWrite

namespace KeySetRead {
struct Type;
struct DecodableType;
} // namespace KeySetRead

namespace KeySetReadResponse {
struct Type;
struct DecodableType;
} // namespace KeySetReadResponse

namespace KeySetRemove {
struct Type;
struct DecodableType;
} // namespace KeySetRemove

namespace KeySetReadAllIndices {
struct Type;
struct DecodableType;
} // namespace KeySetReadAllIndices

namespace KeySetReadAllIndicesResponse {
struct Type;
struct DecodableType;
} // namespace KeySetReadAllIndicesResponse

} // namespace Commands

namespace Commands {
namespace KeySetWrite {
enum class Fields : uint8_t
{
    kGroupKeySet = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetWrite::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::Type groupKeySet;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetWrite::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::DecodableType groupKeySet;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetWrite
namespace KeySetRead {
enum class Fields : uint8_t
{
    kGroupKeySetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetRead::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetRead::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetRead
namespace KeySetReadResponse {
enum class Fields : uint8_t
{
    kGroupKeySet = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::Type groupKeySet;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySetStruct::DecodableType groupKeySet;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadResponse
namespace KeySetRemove {
enum class Fields : uint8_t
{
    kGroupKeySetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetRemove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetRemove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetRemove
namespace KeySetReadAllIndices {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndices::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::GroupKeyManagement::Commands::KeySetReadAllIndicesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndices::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadAllIndices
namespace KeySetReadAllIndicesResponse {
enum class Fields : uint8_t
{
    kGroupKeySetIDs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndicesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::List<const uint16_t> groupKeySetIDs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndicesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::DecodableList<uint16_t> groupKeySetIDs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadAllIndicesResponse
} // namespace Commands

namespace Attributes {

namespace GroupKeyMap {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GroupKeyManagement::Structs::GroupKeyMapStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupKeyMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GroupKeyMap
namespace GroupTable {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GroupKeyManagement::Structs::GroupInfoMapStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GroupTable
namespace MaxGroupsPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxGroupsPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxGroupsPerFabric
namespace MaxGroupKeysPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxGroupKeysPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxGroupKeysPerFabric
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GroupKeyMap::TypeInfo::DecodableType groupKeyMap;
        Attributes::GroupTable::TypeInfo::DecodableType groupTable;
        Attributes::MaxGroupsPerFabric::TypeInfo::DecodableType maxGroupsPerFabric       = static_cast<uint16_t>(0);
        Attributes::MaxGroupKeysPerFabric::TypeInfo::DecodableType maxGroupKeysPerFabric = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace GroupKeyManagement
namespace FixedLabel {
namespace Structs {
namespace LabelStruct = Clusters::detail::Structs::LabelStruct;
} // namespace Structs

namespace Attributes {

namespace LabelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::FixedLabel::Structs::LabelStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LabelList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LabelList::TypeInfo::DecodableType labelList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FixedLabel
namespace UserLabel {
namespace Structs {
namespace LabelStruct = Clusters::detail::Structs::LabelStruct;
} // namespace Structs

namespace Attributes {

namespace LabelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LabelList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LabelList::TypeInfo::DecodableType labelList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace UserLabel
namespace ProxyConfiguration {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ProxyConfiguration
namespace ProxyDiscovery {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ProxyDiscovery
namespace ProxyValid {

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ProxyValid
namespace BooleanState {

namespace Attributes {

namespace StateValue {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StateValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StateValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::StateValue::TypeInfo::DecodableType stateValue = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kStateValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr bool kIsFabricScoped = false;

    bool stateValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

    bool stateValue = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChange
} // namespace Events
} // namespace BooleanState
namespace IcdManagement {
namespace Structs {
namespace MonitoringRegistrationStruct {
enum class Fields : uint8_t
{
    kCheckInNodeID    = 1,
    kMonitoredSubject = 2,
    kClientType       = 4,
    kFabricIndex      = 254,
};

struct Type
{
public:
    chip::NodeId checkInNodeID    = static_cast<chip::NodeId>(0);
    uint64_t monitoredSubject     = static_cast<uint64_t>(0);
    ClientTypeEnum clientType     = static_cast<ClientTypeEnum>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace MonitoringRegistrationStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RegisterClient {
struct Type;
struct DecodableType;
} // namespace RegisterClient

namespace RegisterClientResponse {
struct Type;
struct DecodableType;
} // namespace RegisterClientResponse

namespace UnregisterClient {
struct Type;
struct DecodableType;
} // namespace UnregisterClient

namespace StayActiveRequest {
struct Type;
struct DecodableType;
} // namespace StayActiveRequest

namespace StayActiveResponse {
struct Type;
struct DecodableType;
} // namespace StayActiveResponse

} // namespace Commands

namespace Commands {
namespace RegisterClient {
enum class Fields : uint8_t
{
    kCheckInNodeID    = 0,
    kMonitoredSubject = 1,
    kKey              = 2,
    kVerificationKey  = 3,
    kClientType       = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RegisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    uint64_t monitoredSubject  = static_cast<uint64_t>(0);
    chip::ByteSpan key;
    Optional<chip::ByteSpan> verificationKey;
    ClientTypeEnum clientType = static_cast<ClientTypeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::IcdManagement::Commands::RegisterClientResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RegisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    uint64_t monitoredSubject  = static_cast<uint64_t>(0);
    chip::ByteSpan key;
    Optional<chip::ByteSpan> verificationKey;
    ClientTypeEnum clientType = static_cast<ClientTypeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RegisterClient
namespace RegisterClientResponse {
enum class Fields : uint8_t
{
    kICDCounter = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RegisterClientResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t ICDCounter = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RegisterClientResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t ICDCounter = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RegisterClientResponse
namespace UnregisterClient {
enum class Fields : uint8_t
{
    kCheckInNodeID   = 0,
    kVerificationKey = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnregisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    Optional<chip::ByteSpan> verificationKey;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnregisterClient::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    chip::NodeId checkInNodeID = static_cast<chip::NodeId>(0);
    Optional<chip::ByteSpan> verificationKey;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnregisterClient
namespace StayActiveRequest {
enum class Fields : uint8_t
{
    kStayActiveDuration = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StayActiveRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t stayActiveDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::IcdManagement::Commands::StayActiveResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StayActiveRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t stayActiveDuration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StayActiveRequest
namespace StayActiveResponse {
enum class Fields : uint8_t
{
    kPromisedActiveDuration = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StayActiveResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t promisedActiveDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StayActiveResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

    uint32_t promisedActiveDuration = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StayActiveResponse
} // namespace Commands

namespace Attributes {

namespace IdleModeDuration {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdleModeDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdleModeDuration
namespace ActiveModeDuration {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveModeDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveModeDuration
namespace ActiveModeThreshold {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveModeThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveModeThreshold
namespace RegisteredClients {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::IcdManagement::Structs::MonitoringRegistrationStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::IcdManagement::Structs::MonitoringRegistrationStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::IcdManagement::Structs::MonitoringRegistrationStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RegisteredClients::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RegisteredClients
namespace ICDCounter {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ICDCounter::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ICDCounter
namespace ClientsSupportedPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClientsSupportedPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClientsSupportedPerFabric
namespace UserActiveModeTriggerHint {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserActiveModeTriggerHint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserActiveModeTriggerHint
namespace UserActiveModeTriggerInstruction {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserActiveModeTriggerInstruction::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 128; }
};
} // namespace UserActiveModeTriggerInstruction
namespace OperatingMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::IcdManagement::OperatingModeEnum;
    using DecodableType    = chip::app::Clusters::IcdManagement::OperatingModeEnum;
    using DecodableArgType = chip::app::Clusters::IcdManagement::OperatingModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperatingMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperatingMode
namespace MaximumCheckInBackOff {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaximumCheckInBackOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaximumCheckInBackOff
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IcdManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::IdleModeDuration::TypeInfo::DecodableType idleModeDuration       = static_cast<uint32_t>(0);
        Attributes::ActiveModeDuration::TypeInfo::DecodableType activeModeDuration   = static_cast<uint32_t>(0);
        Attributes::ActiveModeThreshold::TypeInfo::DecodableType activeModeThreshold = static_cast<uint16_t>(0);
        Attributes::RegisteredClients::TypeInfo::DecodableType registeredClients;
        Attributes::ICDCounter::TypeInfo::DecodableType ICDCounter                               = static_cast<uint32_t>(0);
        Attributes::ClientsSupportedPerFabric::TypeInfo::DecodableType clientsSupportedPerFabric = static_cast<uint16_t>(0);
        Attributes::UserActiveModeTriggerHint::TypeInfo::DecodableType userActiveModeTriggerHint =
            static_cast<chip::BitMask<chip::app::Clusters::IcdManagement::UserActiveModeTriggerBitmap>>(0);
        Attributes::UserActiveModeTriggerInstruction::TypeInfo::DecodableType userActiveModeTriggerInstruction;
        Attributes::OperatingMode::TypeInfo::DecodableType operatingMode =
            static_cast<chip::app::Clusters::IcdManagement::OperatingModeEnum>(0);
        Attributes::MaximumCheckInBackOff::TypeInfo::DecodableType maximumCheckInBackOff = static_cast<uint32_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace IcdManagement
namespace Timer {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetTimer {
struct Type;
struct DecodableType;
} // namespace SetTimer

namespace ResetTimer {
struct Type;
struct DecodableType;
} // namespace ResetTimer

namespace AddTime {
struct Type;
struct DecodableType;
} // namespace AddTime

namespace ReduceTime {
struct Type;
struct DecodableType;
} // namespace ReduceTime

} // namespace Commands

namespace Commands {
namespace SetTimer {
enum class Fields : uint8_t
{
    kNewTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t newTime = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t newTime = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTimer
namespace ResetTimer {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetTimer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetTimer
namespace AddTime {
enum class Fields : uint8_t
{
    kAdditionalTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t additionalTime = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t additionalTime = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddTime
namespace ReduceTime {
enum class Fields : uint8_t
{
    kTimeReduction = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReduceTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t timeReduction = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReduceTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

    uint32_t timeReduction = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReduceTime
} // namespace Commands

namespace Attributes {

namespace SetTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetTime
namespace TimeRemaining {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeRemaining
namespace TimerState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Timer::TimerStatusEnum;
    using DecodableType    = chip::app::Clusters::Timer::TimerStatusEnum;
    using DecodableArgType = chip::app::Clusters::Timer::TimerStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimerState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimerState
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Timer::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SetTime::TypeInfo::DecodableType setTime             = static_cast<uint32_t>(0);
        Attributes::TimeRemaining::TypeInfo::DecodableType timeRemaining = static_cast<uint32_t>(0);
        Attributes::TimerState::TypeInfo::DecodableType timerState = static_cast<chip::app::Clusters::Timer::TimerStatusEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Timer
namespace OvenCavityOperationalState {
namespace Structs {
namespace ErrorStateStruct       = Clusters::detail::Structs::ErrorStateStruct;
namespace OperationalStateStruct = Clusters::detail::Structs::OperationalStateStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace Start {
struct Type;
struct DecodableType;
} // namespace Start

namespace Resume {
struct Type;
struct DecodableType;
} // namespace Resume

namespace OperationalCommandResponse {
struct Type;
struct DecodableType;
} // namespace OperationalCommandResponse

} // namespace Commands

namespace Commands {
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace Start {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Start
namespace Resume {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenCavityOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Resume
namespace OperationalCommandResponse {
enum class Fields : uint8_t
{
    kCommandResponseState = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    Structs::ErrorStateStruct::Type commandResponseState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType commandResponseState;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalCommandResponse
} // namespace Commands

namespace Attributes {

namespace PhaseList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<const chip::CharSpan>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseList
namespace CurrentPhase {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPhase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPhase
namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace OperationalStateList {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::OvenCavityOperationalState::Structs::OperationalStateStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OvenCavityOperationalState::Structs::OperationalStateStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OvenCavityOperationalState::Structs::OperationalStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStateList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStateList
namespace OperationalState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum;
    using DecodableType    = chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum;
    using DecodableArgType = chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalState
namespace OperationalError {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OvenCavityOperationalState::Structs::ErrorStateStruct::Type;
    using DecodableType    = chip::app::Clusters::OvenCavityOperationalState::Structs::ErrorStateStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::OvenCavityOperationalState::Structs::ErrorStateStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalError::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalError
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhaseList::TypeInfo::DecodableType phaseList;
        Attributes::CurrentPhase::TypeInfo::DecodableType currentPhase;
        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::OperationalStateList::TypeInfo::DecodableType operationalStateList;
        Attributes::OperationalState::TypeInfo::DecodableType operationalState =
            static_cast<chip::app::Clusters::OvenCavityOperationalState::OperationalStateEnum>(0);
        Attributes::OperationalError::TypeInfo::DecodableType operationalError;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OperationalError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kErrorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::ErrorStateStruct::Type errorState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType errorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationalError
namespace OperationCompletion {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCompletionErrorCode  = 0,
    kTotalOperationalTime = 1,
    kPausedTime           = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenCavityOperationalState::Id; }

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationCompletion
} // namespace Events
} // namespace OvenCavityOperationalState
namespace OvenMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OvenMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OvenMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OvenMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::OvenMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OvenMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OvenMode
namespace LaundryDryerControls {

namespace Attributes {

namespace SupportedDrynessLevels {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedDrynessLevels::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedDrynessLevels
namespace SelectedDrynessLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::LaundryDryerControls::DrynessLevelEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedDrynessLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedDrynessLevel
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LaundryDryerControls::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedDrynessLevels::TypeInfo::DecodableType supportedDrynessLevels;
        Attributes::SelectedDrynessLevel::TypeInfo::DecodableType selectedDrynessLevel;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LaundryDryerControls
namespace ModeSelect {
namespace Structs {
namespace SemanticTagStruct {
enum class Fields : uint8_t
{
    kMfgCode = 0,
    kValue   = 1,
};

struct Type
{
public:
    chip::VendorId mfgCode = static_cast<chip::VendorId>(0);
    uint16_t value         = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SemanticTagStruct
namespace ModeOptionStruct {
enum class Fields : uint8_t
{
    kLabel        = 0,
    kMode         = 1,
    kSemanticTags = 2,
};

struct Type
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::List<const Structs::SemanticTagStruct::Type> semanticTags;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan label;
    uint8_t mode = static_cast<uint8_t>(0);
    DataModel::DecodableList<Structs::SemanticTagStruct::DecodableType> semanticTags;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ModeOptionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
} // namespace Commands

namespace Attributes {

namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 64; }
};
} // namespace Description
namespace StandardNamespace {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StandardNamespace::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StandardNamespace
namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::StandardNamespace::TypeInfo::DecodableType standardNamespace;
        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ModeSelect
namespace LaundryWasherMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::LaundryWasherMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::LaundryWasherMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryWasherMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::LaundryWasherMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LaundryWasherMode
namespace RefrigeratorAndTemperatureControlledCabinetMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Structs::ModeOptionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAndTemperatureControlledCabinetMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RefrigeratorAndTemperatureControlledCabinetMode
namespace LaundryWasherControls {

namespace Attributes {

namespace SpinSpeeds {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpinSpeeds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpinSpeeds
namespace SpinSpeedCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpinSpeedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpinSpeedCurrent
namespace NumberOfRinses {
struct TypeInfo
{
    using Type             = chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum;
    using DecodableType    = chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum;
    using DecodableArgType = chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfRinses::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfRinses
namespace SupportedRinses {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedRinses::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedRinses
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LaundryWasherControls::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SpinSpeeds::TypeInfo::DecodableType spinSpeeds;
        Attributes::SpinSpeedCurrent::TypeInfo::DecodableType spinSpeedCurrent;
        Attributes::NumberOfRinses::TypeInfo::DecodableType numberOfRinses =
            static_cast<chip::app::Clusters::LaundryWasherControls::NumberOfRinsesEnum>(0);
        Attributes::SupportedRinses::TypeInfo::DecodableType supportedRinses;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LaundryWasherControls
namespace RvcRunMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcRunMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::RvcRunMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::RvcRunMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::RvcRunMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RvcRunMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RvcRunMode
namespace RvcCleanMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcCleanMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::RvcCleanMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::RvcCleanMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::RvcCleanMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RvcCleanMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RvcCleanMode
namespace TemperatureControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetTemperature {
struct Type;
struct DecodableType;
} // namespace SetTemperature

} // namespace Commands

namespace Commands {
namespace SetTemperature {
enum class Fields : uint8_t
{
    kTargetTemperature      = 0,
    kTargetTemperatureLevel = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }

    Optional<int16_t> targetTemperature;
    Optional<uint8_t> targetTemperatureLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }

    Optional<int16_t> targetTemperature;
    Optional<uint8_t> targetTemperatureLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTemperature
} // namespace Commands

namespace Attributes {

namespace TemperatureSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpoint
namespace MinTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinTemperature
namespace MaxTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxTemperature
namespace Step {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Step::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Step
namespace SelectedTemperatureLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedTemperatureLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedTemperatureLevel
namespace SupportedTemperatureLevels {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedTemperatureLevels::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedTemperatureLevels
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TemperatureControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureSetpoint::TypeInfo::DecodableType temperatureSetpoint           = static_cast<int16_t>(0);
        Attributes::MinTemperature::TypeInfo::DecodableType minTemperature                     = static_cast<int16_t>(0);
        Attributes::MaxTemperature::TypeInfo::DecodableType maxTemperature                     = static_cast<int16_t>(0);
        Attributes::Step::TypeInfo::DecodableType step                                         = static_cast<int16_t>(0);
        Attributes::SelectedTemperatureLevel::TypeInfo::DecodableType selectedTemperatureLevel = static_cast<uint8_t>(0);
        Attributes::SupportedTemperatureLevels::TypeInfo::DecodableType supportedTemperatureLevels;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TemperatureControl
namespace RefrigeratorAlarm {

namespace Attributes {

namespace Mask {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mask
namespace State {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::State::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace State
namespace Supported {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Supported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Supported
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Mask::TypeInfo::DecodableType mask =
            static_cast<chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>>(0);
        Attributes::State::TypeInfo::DecodableType state =
            static_cast<chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>>(0);
        Attributes::Supported::TypeInfo::DecodableType supported =
            static_cast<chip::BitMask<chip::app::Clusters::RefrigeratorAlarm::AlarmBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace Notify {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActive   = 0,
    kInactive = 1,
    kState    = 2,
    kMask     = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RefrigeratorAlarm::Id; }

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Notify
} // namespace Events
} // namespace RefrigeratorAlarm
namespace DishwasherMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DishwasherMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::DishwasherMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::DishwasherMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::DishwasherMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace OnMode {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DishwasherMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace DishwasherMode
namespace AirQuality {

namespace Attributes {

namespace AirQuality {
struct TypeInfo
{
    using Type             = chip::app::Clusters::AirQuality::AirQualityEnum;
    using DecodableType    = chip::app::Clusters::AirQuality::AirQualityEnum;
    using DecodableArgType = chip::app::Clusters::AirQuality::AirQualityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AirQuality::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AirQuality
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AirQuality::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AirQuality::TypeInfo::DecodableType airQuality =
            static_cast<chip::app::Clusters::AirQuality::AirQualityEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace AirQuality
namespace SmokeCoAlarm {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelfTestRequest {
struct Type;
struct DecodableType;
} // namespace SelfTestRequest

} // namespace Commands

namespace Commands {
namespace SelfTestRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelfTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelfTestRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelfTestRequest
} // namespace Commands

namespace Attributes {

namespace ExpressedState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpressedState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpressedState
namespace SmokeState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SmokeState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SmokeState
namespace COState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::COState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace COState
namespace BatteryAlert {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAlert::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryAlert
namespace DeviceMuted {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::MuteStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::MuteStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::MuteStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceMuted::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceMuted
namespace TestInProgress {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TestInProgress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TestInProgress
namespace HardwareFaultAlert {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareFaultAlert::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareFaultAlert
namespace EndOfServiceAlert {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndOfServiceAlert::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndOfServiceAlert
namespace InterconnectSmokeAlarm {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterconnectSmokeAlarm::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterconnectSmokeAlarm
namespace InterconnectCOAlarm {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterconnectCOAlarm::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterconnectCOAlarm
namespace ContaminationState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ContaminationState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ContaminationState
namespace SmokeSensitivityLevel {
struct TypeInfo
{
    using Type             = chip::app::Clusters::SmokeCoAlarm::SensitivityEnum;
    using DecodableType    = chip::app::Clusters::SmokeCoAlarm::SensitivityEnum;
    using DecodableArgType = chip::app::Clusters::SmokeCoAlarm::SensitivityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SmokeSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SmokeSensitivityLevel
namespace ExpiryDate {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpiryDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpiryDate
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ExpressedState::TypeInfo::DecodableType expressedState =
            static_cast<chip::app::Clusters::SmokeCoAlarm::ExpressedStateEnum>(0);
        Attributes::SmokeState::TypeInfo::DecodableType smokeState =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::COState::TypeInfo::DecodableType COState = static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::BatteryAlert::TypeInfo::DecodableType batteryAlert =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::DeviceMuted::TypeInfo::DecodableType deviceMuted =
            static_cast<chip::app::Clusters::SmokeCoAlarm::MuteStateEnum>(0);
        Attributes::TestInProgress::TypeInfo::DecodableType testInProgress         = static_cast<bool>(0);
        Attributes::HardwareFaultAlert::TypeInfo::DecodableType hardwareFaultAlert = static_cast<bool>(0);
        Attributes::EndOfServiceAlert::TypeInfo::DecodableType endOfServiceAlert =
            static_cast<chip::app::Clusters::SmokeCoAlarm::EndOfServiceEnum>(0);
        Attributes::InterconnectSmokeAlarm::TypeInfo::DecodableType interconnectSmokeAlarm =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::InterconnectCOAlarm::TypeInfo::DecodableType interconnectCOAlarm =
            static_cast<chip::app::Clusters::SmokeCoAlarm::AlarmStateEnum>(0);
        Attributes::ContaminationState::TypeInfo::DecodableType contaminationState =
            static_cast<chip::app::Clusters::SmokeCoAlarm::ContaminationStateEnum>(0);
        Attributes::SmokeSensitivityLevel::TypeInfo::DecodableType smokeSensitivityLevel =
            static_cast<chip::app::Clusters::SmokeCoAlarm::SensitivityEnum>(0);
        Attributes::ExpiryDate::TypeInfo::DecodableType expiryDate = static_cast<uint32_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SmokeAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SmokeAlarm
namespace COAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::COAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::COAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace COAlarm
namespace LowBattery {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LowBattery::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LowBattery::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LowBattery
namespace HardwareFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::HardwareFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace HardwareFault
namespace EndOfService {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EndOfService::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EndOfService::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EndOfService
namespace SelfTestComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SelfTestComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SelfTestComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SelfTestComplete
namespace AlarmMuted {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmMuted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmMuted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AlarmMuted
namespace MuteEnded {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MuteEnded::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MuteEnded::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MuteEnded
namespace InterconnectSmokeAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectSmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectSmokeAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InterconnectSmokeAlarm
namespace InterconnectCOAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmSeverityLevel = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectCOAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::InterconnectCOAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    AlarmStateEnum alarmSeverityLevel = static_cast<AlarmStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InterconnectCOAlarm
namespace AllClear {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AllClear::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AllClear::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SmokeCoAlarm::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AllClear
} // namespace Events
} // namespace SmokeCoAlarm
namespace DishwasherAlarm {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Reset {
struct Type;
struct DecodableType;
} // namespace Reset

namespace ModifyEnabledAlarms {
struct Type;
struct DecodableType;
} // namespace ModifyEnabledAlarms

} // namespace Commands

namespace Commands {
namespace Reset {
enum class Fields : uint8_t
{
    kAlarms = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Reset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> alarms = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Reset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> alarms = static_cast<chip::BitMask<AlarmBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Reset
namespace ModifyEnabledAlarms {
enum class Fields : uint8_t
{
    kMask = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ModifyEnabledAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> mask = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ModifyEnabledAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> mask = static_cast<chip::BitMask<AlarmBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ModifyEnabledAlarms
} // namespace Commands

namespace Attributes {

namespace Mask {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mask
namespace Latch {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Latch::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Latch
namespace State {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::State::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace State
namespace Supported {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Supported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Supported
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Mask::TypeInfo::DecodableType mask =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::Latch::TypeInfo::DecodableType latch =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::State::TypeInfo::DecodableType state =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::Supported::TypeInfo::DecodableType supported =
            static_cast<chip::BitMask<chip::app::Clusters::DishwasherAlarm::AlarmBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace Notify {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kActive   = 0,
    kInactive = 1,
    kState    = 2,
    kMask     = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Notify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DishwasherAlarm::Id; }

    chip::BitMask<AlarmBitmap> active   = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> inactive = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> state    = static_cast<chip::BitMask<AlarmBitmap>>(0);
    chip::BitMask<AlarmBitmap> mask     = static_cast<chip::BitMask<AlarmBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Notify
} // namespace Events
} // namespace DishwasherAlarm
namespace MicrowaveOvenMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::MicrowaveOvenMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::MicrowaveOvenMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::MicrowaveOvenMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace MicrowaveOvenMode
namespace MicrowaveOvenControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetCookingParameters {
struct Type;
struct DecodableType;
} // namespace SetCookingParameters

namespace AddMoreTime {
struct Type;
struct DecodableType;
} // namespace AddMoreTime

} // namespace Commands

namespace Commands {
namespace SetCookingParameters {
enum class Fields : uint8_t
{
    kCookMode          = 0,
    kCookTime          = 1,
    kPowerSetting      = 2,
    kWattSettingIndex  = 3,
    kStartAfterSetting = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCookingParameters::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    Optional<uint8_t> cookMode;
    Optional<uint32_t> cookTime;
    Optional<uint8_t> powerSetting;
    Optional<uint8_t> wattSettingIndex;
    Optional<bool> startAfterSetting;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCookingParameters::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    Optional<uint8_t> cookMode;
    Optional<uint32_t> cookTime;
    Optional<uint8_t> powerSetting;
    Optional<uint8_t> wattSettingIndex;
    Optional<bool> startAfterSetting;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCookingParameters
namespace AddMoreTime {
enum class Fields : uint8_t
{
    kTimeToAdd = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddMoreTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    uint32_t timeToAdd = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddMoreTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

    uint32_t timeToAdd = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddMoreTime
} // namespace Commands

namespace Attributes {

namespace CookTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CookTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CookTime
namespace MaxCookTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCookTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCookTime
namespace PowerSetting {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerSetting
namespace MinPower {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinPower
namespace MaxPower {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPower
namespace PowerStep {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerStep::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerStep
namespace SupportedWatts {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedWatts::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedWatts
namespace SelectedWattIndex {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedWattIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedWattIndex
namespace WattRating {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WattRating::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WattRating
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MicrowaveOvenControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CookTime::TypeInfo::DecodableType cookTime         = static_cast<uint32_t>(0);
        Attributes::MaxCookTime::TypeInfo::DecodableType maxCookTime   = static_cast<uint32_t>(0);
        Attributes::PowerSetting::TypeInfo::DecodableType powerSetting = static_cast<uint8_t>(0);
        Attributes::MinPower::TypeInfo::DecodableType minPower         = static_cast<uint8_t>(0);
        Attributes::MaxPower::TypeInfo::DecodableType maxPower         = static_cast<uint8_t>(0);
        Attributes::PowerStep::TypeInfo::DecodableType powerStep       = static_cast<uint8_t>(0);
        Attributes::SupportedWatts::TypeInfo::DecodableType supportedWatts;
        Attributes::SelectedWattIndex::TypeInfo::DecodableType selectedWattIndex = static_cast<uint8_t>(0);
        Attributes::WattRating::TypeInfo::DecodableType wattRating               = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace MicrowaveOvenControl
namespace OperationalState {
namespace Structs {
namespace ErrorStateStruct       = Clusters::detail::Structs::ErrorStateStruct;
namespace OperationalStateStruct = Clusters::detail::Structs::OperationalStateStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace Start {
struct Type;
struct DecodableType;
} // namespace Start

namespace Resume {
struct Type;
struct DecodableType;
} // namespace Resume

namespace OperationalCommandResponse {
struct Type;
struct DecodableType;
} // namespace OperationalCommandResponse

} // namespace Commands

namespace Commands {
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace Start {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Start::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Start
namespace Resume {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::OperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Resume
namespace OperationalCommandResponse {
enum class Fields : uint8_t
{
    kCommandResponseState = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    Structs::ErrorStateStruct::Type commandResponseState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType commandResponseState;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalCommandResponse
} // namespace Commands

namespace Attributes {

namespace PhaseList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<const chip::CharSpan>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseList
namespace CurrentPhase {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPhase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPhase
namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace OperationalStateList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OperationalState::Structs::OperationalStateStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalState::Structs::OperationalStateStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalState::Structs::OperationalStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStateList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStateList
namespace OperationalState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OperationalState::OperationalStateEnum;
    using DecodableType    = chip::app::Clusters::OperationalState::OperationalStateEnum;
    using DecodableArgType = chip::app::Clusters::OperationalState::OperationalStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalState
namespace OperationalError {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OperationalState::Structs::ErrorStateStruct::Type;
    using DecodableType    = chip::app::Clusters::OperationalState::Structs::ErrorStateStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::OperationalState::Structs::ErrorStateStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalError::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalError
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhaseList::TypeInfo::DecodableType phaseList;
        Attributes::CurrentPhase::TypeInfo::DecodableType currentPhase;
        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::OperationalStateList::TypeInfo::DecodableType operationalStateList;
        Attributes::OperationalState::TypeInfo::DecodableType operationalState =
            static_cast<chip::app::Clusters::OperationalState::OperationalStateEnum>(0);
        Attributes::OperationalError::TypeInfo::DecodableType operationalError;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OperationalError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kErrorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::ErrorStateStruct::Type errorState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType errorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationalError
namespace OperationCompletion {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCompletionErrorCode  = 0,
    kTotalOperationalTime = 1,
    kPausedTime           = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalState::Id; }

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationCompletion
} // namespace Events
} // namespace OperationalState
namespace RvcOperationalState {
namespace Structs {
namespace ErrorStateStruct       = Clusters::detail::Structs::ErrorStateStruct;
namespace OperationalStateStruct = Clusters::detail::Structs::OperationalStateStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Resume {
struct Type;
struct DecodableType;
} // namespace Resume

namespace OperationalCommandResponse {
struct Type;
struct DecodableType;
} // namespace OperationalCommandResponse

namespace GoHome {
struct Type;
struct DecodableType;
} // namespace GoHome

} // namespace Commands

namespace Commands {
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Resume {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Resume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Resume
namespace OperationalCommandResponse {
enum class Fields : uint8_t
{
    kCommandResponseState = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    Structs::ErrorStateStruct::Type commandResponseState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalCommandResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType commandResponseState;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalCommandResponse
namespace GoHome {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoHome::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::RvcOperationalState::Commands::OperationalCommandResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoHome::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoHome
} // namespace Commands

namespace Attributes {

namespace PhaseList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<const chip::CharSpan>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<chip::CharSpan>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseList
namespace CurrentPhase {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPhase::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPhase
namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace OperationalStateList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::RvcOperationalState::Structs::OperationalStateStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::RvcOperationalState::Structs::OperationalStateStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::RvcOperationalState::Structs::OperationalStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStateList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStateList
namespace OperationalState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalState
namespace OperationalError {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RvcOperationalState::Structs::ErrorStateStruct::Type;
    using DecodableType    = chip::app::Clusters::RvcOperationalState::Structs::ErrorStateStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::RvcOperationalState::Structs::ErrorStateStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalError::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalError
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhaseList::TypeInfo::DecodableType phaseList;
        Attributes::CurrentPhase::TypeInfo::DecodableType currentPhase;
        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::OperationalStateList::TypeInfo::DecodableType operationalStateList;
        Attributes::OperationalState::TypeInfo::DecodableType operationalState = static_cast<uint8_t>(0);
        Attributes::OperationalError::TypeInfo::DecodableType operationalError;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OperationalError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kErrorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::ErrorStateStruct::Type errorState;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationalError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    Structs::ErrorStateStruct::DecodableType errorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationalError
namespace OperationCompletion {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCompletionErrorCode  = 0,
    kTotalOperationalTime = 1,
    kPausedTime           = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OperationCompletion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::RvcOperationalState::Id; }

    uint8_t completionErrorCode = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> pausedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OperationCompletion
} // namespace Events
} // namespace RvcOperationalState
namespace ScenesManagement {
namespace Structs {
namespace AttributeValuePairStruct {
enum class Fields : uint8_t
{
    kAttributeID     = 0,
    kValueUnsigned8  = 1,
    kValueSigned8    = 2,
    kValueUnsigned16 = 3,
    kValueSigned16   = 4,
    kValueUnsigned32 = 5,
    kValueSigned32   = 6,
    kValueUnsigned64 = 7,
    kValueSigned64   = 8,
};

struct Type
{
public:
    chip::AttributeId attributeID = static_cast<chip::AttributeId>(0);
    Optional<uint8_t> valueUnsigned8;
    Optional<int8_t> valueSigned8;
    Optional<uint16_t> valueUnsigned16;
    Optional<int16_t> valueSigned16;
    Optional<uint32_t> valueUnsigned32;
    Optional<int32_t> valueSigned32;
    Optional<uint64_t> valueUnsigned64;
    Optional<int64_t> valueSigned64;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AttributeValuePairStruct
namespace ExtensionFieldSet {
enum class Fields : uint8_t
{
    kClusterID          = 0,
    kAttributeValueList = 1,
};

struct Type
{
public:
    chip::ClusterId clusterID = static_cast<chip::ClusterId>(0);
    DataModel::List<const Structs::AttributeValuePairStruct::Type> attributeValueList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::ClusterId clusterID = static_cast<chip::ClusterId>(0);
    DataModel::DecodableList<Structs::AttributeValuePairStruct::DecodableType> attributeValueList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ExtensionFieldSet
namespace SceneInfoStruct {
enum class Fields : uint8_t
{
    kSceneCount        = 0,
    kCurrentScene      = 1,
    kCurrentGroup      = 2,
    kSceneValid        = 3,
    kRemainingCapacity = 4,
    kFabricIndex       = 254,
};

struct Type
{
public:
    uint8_t sceneCount            = static_cast<uint8_t>(0);
    uint8_t currentScene          = static_cast<uint8_t>(0);
    chip::GroupId currentGroup    = static_cast<chip::GroupId>(0);
    bool sceneValid               = static_cast<bool>(0);
    uint8_t remainingCapacity     = static_cast<uint8_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace SceneInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddScene {
struct Type;
struct DecodableType;
} // namespace AddScene

namespace AddSceneResponse {
struct Type;
struct DecodableType;
} // namespace AddSceneResponse

namespace ViewScene {
struct Type;
struct DecodableType;
} // namespace ViewScene

namespace ViewSceneResponse {
struct Type;
struct DecodableType;
} // namespace ViewSceneResponse

namespace RemoveScene {
struct Type;
struct DecodableType;
} // namespace RemoveScene

namespace RemoveSceneResponse {
struct Type;
struct DecodableType;
} // namespace RemoveSceneResponse

namespace RemoveAllScenes {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenes

namespace RemoveAllScenesResponse {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenesResponse

namespace StoreScene {
struct Type;
struct DecodableType;
} // namespace StoreScene

namespace StoreSceneResponse {
struct Type;
struct DecodableType;
} // namespace StoreSceneResponse

namespace RecallScene {
struct Type;
struct DecodableType;
} // namespace RecallScene

namespace GetSceneMembership {
struct Type;
struct DecodableType;
} // namespace GetSceneMembership

namespace GetSceneMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetSceneMembershipResponse

namespace CopyScene {
struct Type;
struct DecodableType;
} // namespace CopyScene

namespace CopySceneResponse {
struct Type;
struct DecodableType;
} // namespace CopySceneResponse

} // namespace Commands

namespace Commands {
namespace AddScene {
enum class Fields : uint8_t
{
    kGroupID            = 0,
    kSceneID            = 1,
    kTransitionTime     = 2,
    kSceneName          = 3,
    kExtensionFieldSets = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID   = static_cast<chip::GroupId>(0);
    uint8_t sceneID         = static_cast<uint8_t>(0);
    uint32_t transitionTime = static_cast<uint32_t>(0);
    chip::CharSpan sceneName;
    DataModel::List<const Structs::ExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::AddSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID   = static_cast<chip::GroupId>(0);
    uint8_t sceneID         = static_cast<uint8_t>(0);
    uint32_t transitionTime = static_cast<uint32_t>(0);
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::ExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddScene
namespace AddSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddSceneResponse
namespace ViewScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::ViewSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewScene
namespace ViewSceneResponse {
enum class Fields : uint8_t
{
    kStatus             = 0,
    kGroupID            = 1,
    kSceneID            = 2,
    kTransitionTime     = 3,
    kSceneName          = 4,
    kExtensionFieldSets = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<uint32_t> transitionTime;
    Optional<chip::CharSpan> sceneName;
    Optional<DataModel::List<const Structs::ExtensionFieldSet::Type>> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<uint32_t> transitionTime;
    Optional<chip::CharSpan> sceneName;
    Optional<DataModel::DecodableList<Structs::ExtensionFieldSet::DecodableType>> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewSceneResponse
namespace RemoveScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::RemoveSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveScene
namespace RemoveSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveSceneResponse
namespace RemoveAllScenes {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::RemoveAllScenesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenes
namespace RemoveAllScenesResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenesResponse
namespace StoreScene {
enum class Fields : uint8_t
{
    kGroupID = 0,
    kSceneID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::StoreSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreScene
namespace StoreSceneResponse {
enum class Fields : uint8_t
{
    kStatus  = 0,
    kGroupID = 1,
    kSceneID = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status        = static_cast<uint8_t>(0);
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreSceneResponse
namespace RecallScene {
enum class Fields : uint8_t
{
    kGroupID        = 0,
    kSceneID        = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    uint8_t sceneID       = static_cast<uint8_t>(0);
    Optional<DataModel::Nullable<uint32_t>> transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RecallScene
namespace GetSceneMembership {
enum class Fields : uint8_t
{
    kGroupID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::GetSceneMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembership
namespace GetSceneMembershipResponse {
enum class Fields : uint8_t
{
    kStatus    = 0,
    kCapacity  = 1,
    kGroupID   = 2,
    kSceneList = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    DataModel::Nullable<uint8_t> capacity;
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    Optional<DataModel::List<const uint8_t>> sceneList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    DataModel::Nullable<uint8_t> capacity;
    chip::GroupId groupID = static_cast<chip::GroupId>(0);
    Optional<DataModel::DecodableList<uint8_t>> sceneList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembershipResponse
namespace CopyScene {
enum class Fields : uint8_t
{
    kMode                = 0,
    kGroupIdentifierFrom = 1,
    kSceneIdentifierFrom = 2,
    kGroupIdentifierTo   = 3,
    kSceneIdentifierTo   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::BitMask<CopyModeBitmap> mode = static_cast<chip::BitMask<CopyModeBitmap>>(0);
    chip::GroupId groupIdentifierFrom  = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom        = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierTo    = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierTo          = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ScenesManagement::Commands::CopySceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    chip::BitMask<CopyModeBitmap> mode = static_cast<chip::BitMask<CopyModeBitmap>>(0);
    chip::GroupId groupIdentifierFrom  = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom        = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierTo    = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierTo          = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopyScene
namespace CopySceneResponse {
enum class Fields : uint8_t
{
    kStatus              = 0,
    kGroupIdentifierFrom = 1,
    kSceneIdentifierFrom = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status                    = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierFrom = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom       = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

    uint8_t status                    = static_cast<uint8_t>(0);
    chip::GroupId groupIdentifierFrom = static_cast<chip::GroupId>(0);
    uint8_t sceneIdentifierFrom       = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopySceneResponse
} // namespace Commands

namespace Attributes {

namespace LastConfiguredBy {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::NodeId>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::NodeId>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::NodeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConfiguredBy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastConfiguredBy
namespace SceneTableSize {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SceneTableSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SceneTableSize
namespace FabricSceneInfo {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ScenesManagement::Structs::SceneInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ScenesManagement::Structs::SceneInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ScenesManagement::Structs::SceneInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FabricSceneInfo::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FabricSceneInfo
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ScenesManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LastConfiguredBy::TypeInfo::DecodableType lastConfiguredBy;
        Attributes::SceneTableSize::TypeInfo::DecodableType sceneTableSize = static_cast<uint16_t>(0);
        Attributes::FabricSceneInfo::TypeInfo::DecodableType fabricSceneInfo;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ScenesManagement
namespace HepaFilterMonitoring {
namespace Structs {
namespace ReplacementProductStruct {
enum class Fields : uint8_t
{
    kProductIdentifierType  = 0,
    kProductIdentifierValue = 1,
};

struct Type
{
public:
    ProductIdentifierTypeEnum productIdentifierType = static_cast<ProductIdentifierTypeEnum>(0);
    chip::CharSpan productIdentifierValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ReplacementProductStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCondition {
struct Type;
struct DecodableType;
} // namespace ResetCondition

} // namespace Commands

namespace Commands {
namespace ResetCondition {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCondition
} // namespace Commands

namespace Attributes {

namespace Condition {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Condition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Condition
namespace DegradationDirection {
struct TypeInfo
{
    using Type             = chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum;
    using DecodableType    = chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum;
    using DecodableArgType = chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DegradationDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DegradationDirection
namespace ChangeIndication {
struct TypeInfo
{
    using Type             = chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum;
    using DecodableType    = chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum;
    using DecodableArgType = chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChangeIndication::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChangeIndication
namespace InPlaceIndicator {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InPlaceIndicator::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InPlaceIndicator
namespace LastChangedTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastChangedTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastChangedTime
namespace ReplacementProductList {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::HepaFilterMonitoring::Structs::ReplacementProductStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::HepaFilterMonitoring::Structs::ReplacementProductStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::HepaFilterMonitoring::Structs::ReplacementProductStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReplacementProductList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReplacementProductList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::HepaFilterMonitoring::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Condition::TypeInfo::DecodableType condition = static_cast<chip::Percent>(0);
        Attributes::DegradationDirection::TypeInfo::DecodableType degradationDirection =
            static_cast<chip::app::Clusters::HepaFilterMonitoring::DegradationDirectionEnum>(0);
        Attributes::ChangeIndication::TypeInfo::DecodableType changeIndication =
            static_cast<chip::app::Clusters::HepaFilterMonitoring::ChangeIndicationEnum>(0);
        Attributes::InPlaceIndicator::TypeInfo::DecodableType inPlaceIndicator = static_cast<bool>(0);
        Attributes::LastChangedTime::TypeInfo::DecodableType lastChangedTime;
        Attributes::ReplacementProductList::TypeInfo::DecodableType replacementProductList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace HepaFilterMonitoring
namespace ActivatedCarbonFilterMonitoring {
namespace Structs {
namespace ReplacementProductStruct {
enum class Fields : uint8_t
{
    kProductIdentifierType  = 0,
    kProductIdentifierValue = 1,
};

struct Type
{
public:
    ProductIdentifierTypeEnum productIdentifierType = static_cast<ProductIdentifierTypeEnum>(0);
    chip::CharSpan productIdentifierValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ReplacementProductStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCondition {
struct Type;
struct DecodableType;
} // namespace ResetCondition

} // namespace Commands

namespace Commands {
namespace ResetCondition {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCondition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCondition
} // namespace Commands

namespace Attributes {

namespace Condition {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Condition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Condition
namespace DegradationDirection {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum;
    using DecodableType    = chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum;
    using DecodableArgType = chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DegradationDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DegradationDirection
namespace ChangeIndication {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum;
    using DecodableType    = chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum;
    using DecodableArgType = chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChangeIndication::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChangeIndication
namespace InPlaceIndicator {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InPlaceIndicator::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InPlaceIndicator
namespace LastChangedTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastChangedTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastChangedTime
namespace ReplacementProductList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::ActivatedCarbonFilterMonitoring::Structs::ReplacementProductStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ActivatedCarbonFilterMonitoring::Structs::ReplacementProductStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ActivatedCarbonFilterMonitoring::Structs::ReplacementProductStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReplacementProductList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReplacementProductList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ActivatedCarbonFilterMonitoring::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Condition::TypeInfo::DecodableType condition = static_cast<chip::Percent>(0);
        Attributes::DegradationDirection::TypeInfo::DecodableType degradationDirection =
            static_cast<chip::app::Clusters::ActivatedCarbonFilterMonitoring::DegradationDirectionEnum>(0);
        Attributes::ChangeIndication::TypeInfo::DecodableType changeIndication =
            static_cast<chip::app::Clusters::ActivatedCarbonFilterMonitoring::ChangeIndicationEnum>(0);
        Attributes::InPlaceIndicator::TypeInfo::DecodableType inPlaceIndicator = static_cast<bool>(0);
        Attributes::LastChangedTime::TypeInfo::DecodableType lastChangedTime;
        Attributes::ReplacementProductList::TypeInfo::DecodableType replacementProductList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ActivatedCarbonFilterMonitoring
namespace BooleanStateConfiguration {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SuppressAlarm {
struct Type;
struct DecodableType;
} // namespace SuppressAlarm

namespace EnableDisableAlarm {
struct Type;
struct DecodableType;
} // namespace EnableDisableAlarm

} // namespace Commands

namespace Commands {
namespace SuppressAlarm {
enum class Fields : uint8_t
{
    kAlarmsToSuppress = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SuppressAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToSuppress = static_cast<chip::BitMask<AlarmModeBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SuppressAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToSuppress = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SuppressAlarm
namespace EnableDisableAlarm {
enum class Fields : uint8_t
{
    kAlarmsToEnableDisable = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableDisableAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToEnableDisable = static_cast<chip::BitMask<AlarmModeBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableDisableAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsToEnableDisable = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableDisableAlarm
} // namespace Commands

namespace Attributes {

namespace CurrentSensitivityLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSensitivityLevel
namespace SupportedSensitivityLevels {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedSensitivityLevels::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedSensitivityLevels
namespace DefaultSensitivityLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultSensitivityLevel
namespace AlarmsActive {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsActive::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsActive
namespace AlarmsSuppressed {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsSuppressed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsSuppressed
namespace AlarmsEnabled {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsEnabled
namespace AlarmsSupported {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmsSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmsSupported
namespace SensorFault {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SensorFault::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SensorFault
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentSensitivityLevel::TypeInfo::DecodableType currentSensitivityLevel       = static_cast<uint8_t>(0);
        Attributes::SupportedSensitivityLevels::TypeInfo::DecodableType supportedSensitivityLevels = static_cast<uint8_t>(0);
        Attributes::DefaultSensitivityLevel::TypeInfo::DecodableType defaultSensitivityLevel       = static_cast<uint8_t>(0);
        Attributes::AlarmsActive::TypeInfo::DecodableType alarmsActive =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::AlarmsSuppressed::TypeInfo::DecodableType alarmsSuppressed =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::AlarmsEnabled::TypeInfo::DecodableType alarmsEnabled =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::AlarmsSupported::TypeInfo::DecodableType alarmsSupported =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::AlarmModeBitmap>>(0);
        Attributes::SensorFault::TypeInfo::DecodableType sensorFault =
            static_cast<chip::BitMask<chip::app::Clusters::BooleanStateConfiguration::SensorFaultBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace AlarmsStateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kAlarmsActive     = 0,
    kAlarmsSuppressed = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmsStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<AlarmModeBitmap> alarmsActive = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    Optional<chip::BitMask<AlarmModeBitmap>> alarmsSuppressed;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AlarmsStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<AlarmModeBitmap> alarmsActive = static_cast<chip::BitMask<AlarmModeBitmap>>(0);
    Optional<chip::BitMask<AlarmModeBitmap>> alarmsSuppressed;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AlarmsStateChanged
namespace SensorFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSensorFault = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<SensorFaultBitmap> sensorFault = static_cast<chip::BitMask<SensorFaultBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanStateConfiguration::Id; }

    chip::BitMask<SensorFaultBitmap> sensorFault = static_cast<chip::BitMask<SensorFaultBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SensorFault
} // namespace Events
} // namespace BooleanStateConfiguration
namespace ValveConfigurationAndControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Open {
struct Type;
struct DecodableType;
} // namespace Open

namespace Close {
struct Type;
struct DecodableType;
} // namespace Close

} // namespace Commands

namespace Commands {
namespace Open {
enum class Fields : uint8_t
{
    kOpenDuration = 0,
    kTargetLevel  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Open::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    Optional<DataModel::Nullable<uint32_t>> openDuration;
    Optional<chip::Percent> targetLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Open::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    Optional<DataModel::Nullable<uint32_t>> openDuration;
    Optional<chip::Percent> targetLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Open
namespace Close {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Close::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Close::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Close
} // namespace Commands

namespace Attributes {

namespace OpenDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OpenDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OpenDuration
namespace DefaultOpenDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOpenDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOpenDuration
namespace AutoCloseTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AutoCloseTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AutoCloseTime
namespace RemainingDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingDuration
namespace CurrentState {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentState
namespace TargetState {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::ValveConfigurationAndControl::ValveStateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetState
namespace CurrentLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLevel
namespace TargetLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetLevel
namespace DefaultOpenLevel {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOpenLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOpenLevel
namespace ValveFault {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ValveFault::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ValveFault
namespace LevelStep {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelStep::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelStep
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OpenDuration::TypeInfo::DecodableType openDuration;
        Attributes::DefaultOpenDuration::TypeInfo::DecodableType defaultOpenDuration;
        Attributes::AutoCloseTime::TypeInfo::DecodableType autoCloseTime;
        Attributes::RemainingDuration::TypeInfo::DecodableType remainingDuration;
        Attributes::CurrentState::TypeInfo::DecodableType currentState;
        Attributes::TargetState::TypeInfo::DecodableType targetState;
        Attributes::CurrentLevel::TypeInfo::DecodableType currentLevel;
        Attributes::TargetLevel::TypeInfo::DecodableType targetLevel;
        Attributes::DefaultOpenLevel::TypeInfo::DecodableType defaultOpenLevel = static_cast<chip::Percent>(0);
        Attributes::ValveFault::TypeInfo::DecodableType valveFault =
            static_cast<chip::BitMask<chip::app::Clusters::ValveConfigurationAndControl::ValveFaultBitmap>>(0);
        Attributes::LevelStep::TypeInfo::DecodableType levelStep = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace ValveStateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kValveState = 0,
    kValveLevel = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    ValveStateEnum valveState = static_cast<ValveStateEnum>(0);
    Optional<chip::Percent> valveLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveStateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    ValveStateEnum valveState = static_cast<ValveStateEnum>(0);
    Optional<chip::Percent> valveLevel;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ValveStateChanged
namespace ValveFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kValveFault = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<ValveFaultBitmap> valveFault = static_cast<chip::BitMask<ValveFaultBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ValveFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ValveConfigurationAndControl::Id; }

    chip::BitMask<ValveFaultBitmap> valveFault = static_cast<chip::BitMask<ValveFaultBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ValveFault
} // namespace Events
} // namespace ValveConfigurationAndControl
namespace ElectricalPowerMeasurement {
namespace Structs {
namespace MeasurementAccuracyRangeStruct = Clusters::detail::Structs::MeasurementAccuracyRangeStruct;
namespace MeasurementAccuracyStruct      = Clusters::detail::Structs::MeasurementAccuracyStruct;
namespace HarmonicMeasurementStruct {
enum class Fields : uint8_t
{
    kOrder       = 0,
    kMeasurement = 1,
};

struct Type
{
public:
    uint8_t order = static_cast<uint8_t>(0);
    DataModel::Nullable<int64_t> measurement;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace HarmonicMeasurementStruct
namespace MeasurementRangeStruct {
enum class Fields : uint8_t
{
    kMeasurementType = 0,
    kMin             = 1,
    kMax             = 2,
    kStartTimestamp  = 3,
    kEndTimestamp    = 4,
    kMinTimestamp    = 5,
    kMaxTimestamp    = 6,
    kStartSystime    = 7,
    kEndSystime      = 8,
    kMinSystime      = 9,
    kMaxSystime      = 10,
};

struct Type
{
public:
    MeasurementTypeEnum measurementType = static_cast<MeasurementTypeEnum>(0);
    int64_t min                         = static_cast<int64_t>(0);
    int64_t max                         = static_cast<int64_t>(0);
    Optional<uint32_t> startTimestamp;
    Optional<uint32_t> endTimestamp;
    Optional<uint32_t> minTimestamp;
    Optional<uint32_t> maxTimestamp;
    Optional<uint64_t> startSystime;
    Optional<uint64_t> endSystime;
    Optional<uint64_t> minSystime;
    Optional<uint64_t> maxSystime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MeasurementRangeStruct
} // namespace Structs

namespace Attributes {

namespace PowerMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum;
    using DecodableType    = chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum;
    using DecodableArgType = chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerMode
namespace NumberOfMeasurementTypes {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfMeasurementTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfMeasurementTypes
namespace Accuracy {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementAccuracyStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementAccuracyStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementAccuracyStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Accuracy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Accuracy
namespace Ranges {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementRangeStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementRangeStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::MeasurementRangeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Ranges::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Ranges
namespace Voltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Voltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Voltage
namespace ActiveCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCurrent
namespace ReactiveCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactiveCurrent
namespace ApparentCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentCurrent
namespace ActivePower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePower
namespace ReactivePower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePower
namespace ApparentPower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPower
namespace RMSVoltage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RMSVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RMSVoltage
namespace RMSCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RMSCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RMSCurrent
namespace RMSPower {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RMSPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RMSPower
namespace Frequency {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Frequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Frequency
namespace HarmonicCurrents {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<
                    const chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::Type>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
           chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicCurrents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HarmonicCurrents
namespace HarmonicPhases {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::DataModel::List<
                    const chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::Type>>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
           chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::DataModel::DecodableList<
        chip::app::Clusters::ElectricalPowerMeasurement::Structs::HarmonicMeasurementStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicPhases::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HarmonicPhases
namespace PowerFactor {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactor
namespace NeutralCurrent {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeutralCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeutralCurrent
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PowerMode::TypeInfo::DecodableType powerMode =
            static_cast<chip::app::Clusters::ElectricalPowerMeasurement::PowerModeEnum>(0);
        Attributes::NumberOfMeasurementTypes::TypeInfo::DecodableType numberOfMeasurementTypes = static_cast<uint8_t>(0);
        Attributes::Accuracy::TypeInfo::DecodableType accuracy;
        Attributes::Ranges::TypeInfo::DecodableType ranges;
        Attributes::Voltage::TypeInfo::DecodableType voltage;
        Attributes::ActiveCurrent::TypeInfo::DecodableType activeCurrent;
        Attributes::ReactiveCurrent::TypeInfo::DecodableType reactiveCurrent;
        Attributes::ApparentCurrent::TypeInfo::DecodableType apparentCurrent;
        Attributes::ActivePower::TypeInfo::DecodableType activePower;
        Attributes::ReactivePower::TypeInfo::DecodableType reactivePower;
        Attributes::ApparentPower::TypeInfo::DecodableType apparentPower;
        Attributes::RMSVoltage::TypeInfo::DecodableType RMSVoltage;
        Attributes::RMSCurrent::TypeInfo::DecodableType RMSCurrent;
        Attributes::RMSPower::TypeInfo::DecodableType RMSPower;
        Attributes::Frequency::TypeInfo::DecodableType frequency;
        Attributes::HarmonicCurrents::TypeInfo::DecodableType harmonicCurrents;
        Attributes::HarmonicPhases::TypeInfo::DecodableType harmonicPhases;
        Attributes::PowerFactor::TypeInfo::DecodableType powerFactor;
        Attributes::NeutralCurrent::TypeInfo::DecodableType neutralCurrent;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace MeasurementPeriodRanges {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kRanges = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MeasurementPeriodRanges::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const Structs::MeasurementRangeStruct::Type> ranges;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MeasurementPeriodRanges::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalPowerMeasurement::Id; }

    DataModel::DecodableList<Structs::MeasurementRangeStruct::DecodableType> ranges;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MeasurementPeriodRanges
} // namespace Events
} // namespace ElectricalPowerMeasurement
namespace ElectricalEnergyMeasurement {
namespace Structs {
namespace MeasurementAccuracyRangeStruct = Clusters::detail::Structs::MeasurementAccuracyRangeStruct;
namespace MeasurementAccuracyStruct      = Clusters::detail::Structs::MeasurementAccuracyStruct;
namespace CumulativeEnergyResetStruct {
enum class Fields : uint8_t
{
    kImportedResetTimestamp = 0,
    kExportedResetTimestamp = 1,
    kImportedResetSystime   = 2,
    kExportedResetSystime   = 3,
};

struct Type
{
public:
    Optional<DataModel::Nullable<uint32_t>> importedResetTimestamp;
    Optional<DataModel::Nullable<uint32_t>> exportedResetTimestamp;
    Optional<DataModel::Nullable<uint64_t>> importedResetSystime;
    Optional<DataModel::Nullable<uint64_t>> exportedResetSystime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CumulativeEnergyResetStruct
namespace EnergyMeasurementStruct {
enum class Fields : uint8_t
{
    kEnergy         = 0,
    kStartTimestamp = 1,
    kEndTimestamp   = 2,
    kStartSystime   = 3,
    kEndSystime     = 4,
};

struct Type
{
public:
    int64_t energy = static_cast<int64_t>(0);
    Optional<uint32_t> startTimestamp;
    Optional<uint32_t> endTimestamp;
    Optional<uint64_t> startSystime;
    Optional<uint64_t> endSystime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace EnergyMeasurementStruct
} // namespace Structs

namespace Attributes {

namespace Accuracy {
struct TypeInfo
{
    using Type          = chip::app::Clusters::ElectricalEnergyMeasurement::Structs::MeasurementAccuracyStruct::Type;
    using DecodableType = chip::app::Clusters::ElectricalEnergyMeasurement::Structs::MeasurementAccuracyStruct::DecodableType;
    using DecodableArgType =
        const chip::app::Clusters::ElectricalEnergyMeasurement::Structs::MeasurementAccuracyStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Accuracy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Accuracy
namespace CumulativeEnergyImported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CumulativeEnergyImported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CumulativeEnergyImported
namespace CumulativeEnergyExported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CumulativeEnergyExported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CumulativeEnergyExported
namespace PeriodicEnergyImported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeriodicEnergyImported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeriodicEnergyImported
namespace PeriodicEnergyExported {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::EnergyMeasurementStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeriodicEnergyExported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeriodicEnergyExported
namespace CumulativeEnergyReset {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::CumulativeEnergyResetStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::CumulativeEnergyResetStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ElectricalEnergyMeasurement::Structs::CumulativeEnergyResetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CumulativeEnergyReset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CumulativeEnergyReset
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Accuracy::TypeInfo::DecodableType accuracy;
        Attributes::CumulativeEnergyImported::TypeInfo::DecodableType cumulativeEnergyImported;
        Attributes::CumulativeEnergyExported::TypeInfo::DecodableType cumulativeEnergyExported;
        Attributes::PeriodicEnergyImported::TypeInfo::DecodableType periodicEnergyImported;
        Attributes::PeriodicEnergyExported::TypeInfo::DecodableType periodicEnergyExported;
        Attributes::CumulativeEnergyReset::TypeInfo::DecodableType cumulativeEnergyReset;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace CumulativeEnergyMeasured {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kEnergyImported = 0,
    kEnergyExported = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::CumulativeEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<Structs::EnergyMeasurementStruct::Type> energyImported;
    Optional<Structs::EnergyMeasurementStruct::Type> energyExported;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::CumulativeEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }

    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyImported;
    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyExported;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace CumulativeEnergyMeasured
namespace PeriodicEnergyMeasured {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kEnergyImported = 0,
    kEnergyExported = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PeriodicEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<Structs::EnergyMeasurementStruct::Type> energyImported;
    Optional<Structs::EnergyMeasurementStruct::Type> energyExported;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PeriodicEnergyMeasured::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalEnergyMeasurement::Id; }

    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyImported;
    Optional<Structs::EnergyMeasurementStruct::DecodableType> energyExported;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PeriodicEnergyMeasured
} // namespace Events
} // namespace ElectricalEnergyMeasurement
namespace WaterHeaterManagement {
namespace Structs {
namespace WaterHeaterBoostInfoStruct {
enum class Fields : uint8_t
{
    kDuration          = 0,
    kOneShot           = 1,
    kEmergencyBoost    = 2,
    kTemporarySetpoint = 3,
    kTargetPercentage  = 4,
    kTargetReheat      = 5,
};

struct Type
{
public:
    uint32_t duration = static_cast<uint32_t>(0);
    Optional<bool> oneShot;
    Optional<bool> emergencyBoost;
    Optional<int16_t> temporarySetpoint;
    Optional<chip::Percent> targetPercentage;
    Optional<chip::Percent> targetReheat;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace WaterHeaterBoostInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Boost {
struct Type;
struct DecodableType;
} // namespace Boost

namespace CancelBoost {
struct Type;
struct DecodableType;
} // namespace CancelBoost

} // namespace Commands

namespace Commands {
namespace Boost {
enum class Fields : uint8_t
{
    kBoostInfo = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Boost::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

    Structs::WaterHeaterBoostInfoStruct::Type boostInfo;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Boost::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

    Structs::WaterHeaterBoostInfoStruct::DecodableType boostInfo;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Boost
namespace CancelBoost {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelBoost::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelBoost::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelBoost
} // namespace Commands

namespace Attributes {

namespace HeaterTypes {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HeaterTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HeaterTypes
namespace HeatDemand {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HeatDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HeatDemand
namespace TankVolume {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TankVolume::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TankVolume
namespace EstimatedHeatRequired {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EstimatedHeatRequired::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EstimatedHeatRequired
namespace TankPercentage {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TankPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TankPercentage
namespace BoostState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::WaterHeaterManagement::BoostStateEnum;
    using DecodableType    = chip::app::Clusters::WaterHeaterManagement::BoostStateEnum;
    using DecodableArgType = chip::app::Clusters::WaterHeaterManagement::BoostStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BoostState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BoostState
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::HeaterTypes::TypeInfo::DecodableType heaterTypes =
            static_cast<chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>>(0);
        Attributes::HeatDemand::TypeInfo::DecodableType heatDemand =
            static_cast<chip::BitMask<chip::app::Clusters::WaterHeaterManagement::WaterHeaterHeatSourceBitmap>>(0);
        Attributes::TankVolume::TypeInfo::DecodableType tankVolume                       = static_cast<uint16_t>(0);
        Attributes::EstimatedHeatRequired::TypeInfo::DecodableType estimatedHeatRequired = static_cast<int64_t>(0);
        Attributes::TankPercentage::TypeInfo::DecodableType tankPercentage               = static_cast<chip::Percent>(0);
        Attributes::BoostState::TypeInfo::DecodableType boostState =
            static_cast<chip::app::Clusters::WaterHeaterManagement::BoostStateEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace BoostStarted {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kBoostInfo = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BoostStarted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    Structs::WaterHeaterBoostInfoStruct::Type boostInfo;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BoostStarted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

    Structs::WaterHeaterBoostInfoStruct::DecodableType boostInfo;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BoostStarted
namespace BoostEnded {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BoostEnded::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::BoostEnded::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BoostEnded
} // namespace Events
} // namespace WaterHeaterManagement
namespace DemandResponseLoadControl {
namespace Structs {
namespace HeatingSourceControlStruct {
enum class Fields : uint8_t
{
    kHeatingSource = 0,
};

struct Type
{
public:
    HeatingSourceEnum heatingSource = static_cast<HeatingSourceEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace HeatingSourceControlStruct
namespace PowerSavingsControlStruct {
enum class Fields : uint8_t
{
    kPowerSavings = 0,
};

struct Type
{
public:
    chip::Percent powerSavings = static_cast<chip::Percent>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PowerSavingsControlStruct
namespace DutyCycleControlStruct {
enum class Fields : uint8_t
{
    kDutyCycle = 0,
};

struct Type
{
public:
    chip::Percent dutyCycle = static_cast<chip::Percent>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DutyCycleControlStruct
namespace AverageLoadControlStruct {
enum class Fields : uint8_t
{
    kLoadAdjustment = 0,
};

struct Type
{
public:
    int8_t loadAdjustment = static_cast<int8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AverageLoadControlStruct
namespace TemperatureControlStruct {
enum class Fields : uint8_t
{
    kCoolingTempOffset   = 0,
    kHeatingtTempOffset  = 1,
    kCoolingTempSetpoint = 2,
    kHeatingTempSetpoint = 3,
};

struct Type
{
public:
    Optional<DataModel::Nullable<uint16_t>> coolingTempOffset;
    Optional<DataModel::Nullable<uint16_t>> heatingtTempOffset;
    Optional<DataModel::Nullable<int16_t>> coolingTempSetpoint;
    Optional<DataModel::Nullable<int16_t>> heatingTempSetpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TemperatureControlStruct
namespace LoadControlEventTransitionStruct {
enum class Fields : uint8_t
{
    kDuration             = 0,
    kControl              = 1,
    kTemperatureControl   = 2,
    kAverageLoadControl   = 3,
    kDutyCycleControl     = 4,
    kPowerSavingsControl  = 5,
    kHeatingSourceControl = 6,
};

struct Type
{
public:
    uint16_t duration                                   = static_cast<uint16_t>(0);
    chip::BitMask<EventTransitionControlBitmap> control = static_cast<chip::BitMask<EventTransitionControlBitmap>>(0);
    Optional<Structs::TemperatureControlStruct::Type> temperatureControl;
    Optional<Structs::AverageLoadControlStruct::Type> averageLoadControl;
    Optional<Structs::DutyCycleControlStruct::Type> dutyCycleControl;
    Optional<Structs::PowerSavingsControlStruct::Type> powerSavingsControl;
    Optional<Structs::HeatingSourceControlStruct::Type> heatingSourceControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LoadControlEventTransitionStruct
namespace LoadControlEventStruct {
enum class Fields : uint8_t
{
    kEventID         = 0,
    kProgramID       = 1,
    kControl         = 2,
    kDeviceClass     = 3,
    kEnrollmentGroup = 4,
    kCriticality     = 5,
    kStartTime       = 6,
    kTransitions     = 7,
};

struct Type
{
public:
    chip::ByteSpan eventID;
    DataModel::Nullable<chip::ByteSpan> programID;
    chip::BitMask<EventControlBitmap> control    = static_cast<chip::BitMask<EventControlBitmap>>(0);
    chip::BitMask<DeviceClassBitmap> deviceClass = static_cast<chip::BitMask<DeviceClassBitmap>>(0);
    Optional<uint8_t> enrollmentGroup;
    CriticalityLevelEnum criticality = static_cast<CriticalityLevelEnum>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::List<const Structs::LoadControlEventTransitionStruct::Type> transitions;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::ByteSpan eventID;
    DataModel::Nullable<chip::ByteSpan> programID;
    chip::BitMask<EventControlBitmap> control    = static_cast<chip::BitMask<EventControlBitmap>>(0);
    chip::BitMask<DeviceClassBitmap> deviceClass = static_cast<chip::BitMask<DeviceClassBitmap>>(0);
    Optional<uint8_t> enrollmentGroup;
    CriticalityLevelEnum criticality = static_cast<CriticalityLevelEnum>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::DecodableList<Structs::LoadControlEventTransitionStruct::DecodableType> transitions;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace LoadControlEventStruct
namespace LoadControlProgramStruct {
enum class Fields : uint8_t
{
    kProgramID             = 0,
    kName                  = 1,
    kEnrollmentGroup       = 2,
    kRandomStartMinutes    = 3,
    kRandomDurationMinutes = 4,
};

struct Type
{
public:
    chip::ByteSpan programID;
    chip::CharSpan name;
    DataModel::Nullable<uint8_t> enrollmentGroup;
    DataModel::Nullable<uint8_t> randomStartMinutes;
    DataModel::Nullable<uint8_t> randomDurationMinutes;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LoadControlProgramStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RegisterLoadControlProgramRequest {
struct Type;
struct DecodableType;
} // namespace RegisterLoadControlProgramRequest

namespace UnregisterLoadControlProgramRequest {
struct Type;
struct DecodableType;
} // namespace UnregisterLoadControlProgramRequest

namespace AddLoadControlEventRequest {
struct Type;
struct DecodableType;
} // namespace AddLoadControlEventRequest

namespace RemoveLoadControlEventRequest {
struct Type;
struct DecodableType;
} // namespace RemoveLoadControlEventRequest

namespace ClearLoadControlEventsRequest {
struct Type;
struct DecodableType;
} // namespace ClearLoadControlEventsRequest

} // namespace Commands

namespace Commands {
namespace RegisterLoadControlProgramRequest {
enum class Fields : uint8_t
{
    kLoadControlProgram = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RegisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlProgramStruct::Type loadControlProgram;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RegisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlProgramStruct::DecodableType loadControlProgram;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RegisterLoadControlProgramRequest
namespace UnregisterLoadControlProgramRequest {
enum class Fields : uint8_t
{
    kLoadControlProgramID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnregisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan loadControlProgramID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnregisterLoadControlProgramRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan loadControlProgramID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnregisterLoadControlProgramRequest
namespace AddLoadControlEventRequest {
enum class Fields : uint8_t
{
    kEvent = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlEventStruct::Type event;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    Structs::LoadControlEventStruct::DecodableType event;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddLoadControlEventRequest
namespace RemoveLoadControlEventRequest {
enum class Fields : uint8_t
{
    kEventID       = 0,
    kCancelControl = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan eventID;
    chip::BitMask<CancelControlBitmap> cancelControl = static_cast<chip::BitMask<CancelControlBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveLoadControlEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan eventID;
    chip::BitMask<CancelControlBitmap> cancelControl = static_cast<chip::BitMask<CancelControlBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveLoadControlEventRequest
namespace ClearLoadControlEventsRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearLoadControlEventsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearLoadControlEventsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearLoadControlEventsRequest
} // namespace Commands

namespace Attributes {

namespace LoadControlPrograms {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlProgramStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlProgramStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlProgramStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LoadControlPrograms::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LoadControlPrograms
namespace NumberOfLoadControlPrograms {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfLoadControlPrograms::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfLoadControlPrograms
namespace Events {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Events::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Events
namespace ActiveEvents {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DemandResponseLoadControl::Structs::LoadControlEventStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveEvents
namespace NumberOfEventsPerProgram {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfEventsPerProgram::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfEventsPerProgram
namespace NumberOfTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfTransitions
namespace DefaultRandomStart {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultRandomStart::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultRandomStart
namespace DefaultRandomDuration {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultRandomDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultRandomDuration
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LoadControlPrograms::TypeInfo::DecodableType loadControlPrograms;
        Attributes::NumberOfLoadControlPrograms::TypeInfo::DecodableType numberOfLoadControlPrograms = static_cast<uint8_t>(0);
        Attributes::Events::TypeInfo::DecodableType events;
        Attributes::ActiveEvents::TypeInfo::DecodableType activeEvents;
        Attributes::NumberOfEventsPerProgram::TypeInfo::DecodableType numberOfEventsPerProgram = static_cast<uint8_t>(0);
        Attributes::NumberOfTransitions::TypeInfo::DecodableType numberOfTransitions           = static_cast<uint8_t>(0);
        Attributes::DefaultRandomStart::TypeInfo::DecodableType defaultRandomStart             = static_cast<uint8_t>(0);
        Attributes::DefaultRandomDuration::TypeInfo::DecodableType defaultRandomDuration       = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace LoadControlEventStatusChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kEventID              = 0,
    kTransitionIndex      = 1,
    kStatus               = 2,
    kCriticality          = 3,
    kControl              = 4,
    kTemperatureControl   = 5,
    kAverageLoadControl   = 6,
    kDutyCycleControl     = 7,
    kPowerSavingsControl  = 8,
    kHeatingSourceControl = 9,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoadControlEventStatusChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan eventID;
    DataModel::Nullable<uint8_t> transitionIndex;
    LoadControlEventStatusEnum status         = static_cast<LoadControlEventStatusEnum>(0);
    CriticalityLevelEnum criticality          = static_cast<CriticalityLevelEnum>(0);
    chip::BitMask<EventControlBitmap> control = static_cast<chip::BitMask<EventControlBitmap>>(0);
    Optional<DataModel::Nullable<Structs::TemperatureControlStruct::Type>> temperatureControl;
    Optional<DataModel::Nullable<Structs::AverageLoadControlStruct::Type>> averageLoadControl;
    Optional<DataModel::Nullable<Structs::DutyCycleControlStruct::Type>> dutyCycleControl;
    Optional<DataModel::Nullable<Structs::PowerSavingsControlStruct::Type>> powerSavingsControl;
    Optional<DataModel::Nullable<Structs::HeatingSourceControlStruct::Type>> heatingSourceControl;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoadControlEventStatusChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DemandResponseLoadControl::Id; }

    chip::ByteSpan eventID;
    DataModel::Nullable<uint8_t> transitionIndex;
    LoadControlEventStatusEnum status         = static_cast<LoadControlEventStatusEnum>(0);
    CriticalityLevelEnum criticality          = static_cast<CriticalityLevelEnum>(0);
    chip::BitMask<EventControlBitmap> control = static_cast<chip::BitMask<EventControlBitmap>>(0);
    Optional<DataModel::Nullable<Structs::TemperatureControlStruct::DecodableType>> temperatureControl;
    Optional<DataModel::Nullable<Structs::AverageLoadControlStruct::DecodableType>> averageLoadControl;
    Optional<DataModel::Nullable<Structs::DutyCycleControlStruct::DecodableType>> dutyCycleControl;
    Optional<DataModel::Nullable<Structs::PowerSavingsControlStruct::DecodableType>> powerSavingsControl;
    Optional<DataModel::Nullable<Structs::HeatingSourceControlStruct::DecodableType>> heatingSourceControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LoadControlEventStatusChange
} // namespace Events
} // namespace DemandResponseLoadControl
namespace Messages {
namespace Structs {
namespace MessageResponseOptionStruct {
enum class Fields : uint8_t
{
    kMessageResponseID = 0,
    kLabel             = 1,
};

struct Type
{
public:
    Optional<uint32_t> messageResponseID;
    Optional<chip::CharSpan> label;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MessageResponseOptionStruct
namespace MessageStruct {
enum class Fields : uint8_t
{
    kMessageID      = 0,
    kPriority       = 1,
    kMessageControl = 2,
    kStartTime      = 3,
    kDuration       = 4,
    kMessageText    = 5,
    kResponses      = 6,
};

struct Type
{
public:
    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::List<const Structs::MessageResponseOptionStruct::Type>> responses;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::DecodableList<Structs::MessageResponseOptionStruct::DecodableType>> responses;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace MessageStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace PresentMessagesRequest {
struct Type;
struct DecodableType;
} // namespace PresentMessagesRequest

namespace CancelMessagesRequest {
struct Type;
struct DecodableType;
} // namespace CancelMessagesRequest

} // namespace Commands

namespace Commands {
namespace PresentMessagesRequest {
enum class Fields : uint8_t
{
    kMessageID      = 0,
    kPriority       = 1,
    kMessageControl = 2,
    kStartTime      = 3,
    kDuration       = 4,
    kMessageText    = 5,
    kResponses      = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PresentMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::List<const Structs::MessageResponseOptionStruct::Type>> responses;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PresentMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;
    MessagePriorityEnum priority                       = static_cast<MessagePriorityEnum>(0);
    chip::BitMask<MessageControlBitmap> messageControl = static_cast<chip::BitMask<MessageControlBitmap>>(0);
    DataModel::Nullable<uint32_t> startTime;
    DataModel::Nullable<uint64_t> duration;
    chip::CharSpan messageText;
    Optional<DataModel::DecodableList<Structs::MessageResponseOptionStruct::DecodableType>> responses;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PresentMessagesRequest
namespace CancelMessagesRequest {
enum class Fields : uint8_t
{
    kMessageIDs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    DataModel::List<const chip::ByteSpan> messageIDs;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelMessagesRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    DataModel::DecodableList<chip::ByteSpan> messageIDs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelMessagesRequest
} // namespace Commands

namespace Attributes {

namespace Messages {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Messages::Structs::MessageStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Messages::Structs::MessageStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Messages::Structs::MessageStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Messages::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Messages
namespace ActiveMessageIDs {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveMessageIDs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveMessageIDs
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Messages::TypeInfo::DecodableType messages;
        Attributes::ActiveMessageIDs::TypeInfo::DecodableType activeMessageIDs;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace MessageQueued {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kMessageID = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageQueued::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan messageID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageQueued::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MessageQueued
namespace MessagePresented {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kMessageID = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessagePresented::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan messageID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessagePresented::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MessagePresented
namespace MessageComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kMessageID                = 0,
    kResponseID               = 1,
    kReply                    = 2,
    kFutureMessagesPreference = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan messageID;
    Optional<DataModel::Nullable<uint32_t>> responseID;
    Optional<DataModel::Nullable<chip::CharSpan>> reply;
    DataModel::Nullable<FutureMessagePreferenceEnum> futureMessagesPreference;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MessageComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messages::Id; }

    chip::ByteSpan messageID;
    Optional<DataModel::Nullable<uint32_t>> responseID;
    Optional<DataModel::Nullable<chip::CharSpan>> reply;
    DataModel::Nullable<FutureMessagePreferenceEnum> futureMessagesPreference;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MessageComplete
} // namespace Events
} // namespace Messages
namespace DeviceEnergyManagement {
namespace Structs {
namespace CostStruct {
enum class Fields : uint8_t
{
    kCostType      = 0,
    kValue         = 1,
    kDecimalPoints = 2,
    kCurrency      = 3,
};

struct Type
{
public:
    CostTypeEnum costType = static_cast<CostTypeEnum>(0);
    int32_t value         = static_cast<int32_t>(0);
    uint8_t decimalPoints = static_cast<uint8_t>(0);
    Optional<uint16_t> currency;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CostStruct
namespace PowerAdjustStruct {
enum class Fields : uint8_t
{
    kMinPower    = 0,
    kMaxPower    = 1,
    kMinDuration = 2,
    kMaxDuration = 3,
};

struct Type
{
public:
    int64_t minPower     = static_cast<int64_t>(0);
    int64_t maxPower     = static_cast<int64_t>(0);
    uint32_t minDuration = static_cast<uint32_t>(0);
    uint32_t maxDuration = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PowerAdjustStruct
namespace PowerAdjustCapabilityStruct {
enum class Fields : uint8_t
{
    kPowerAdjustCapability = 0,
    kCause                 = 1,
};

struct Type
{
public:
    DataModel::Nullable<DataModel::List<const Structs::PowerAdjustStruct::Type>> powerAdjustCapability;
    PowerAdjustReasonEnum cause = static_cast<PowerAdjustReasonEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<DataModel::DecodableList<Structs::PowerAdjustStruct::DecodableType>> powerAdjustCapability;
    PowerAdjustReasonEnum cause = static_cast<PowerAdjustReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace PowerAdjustCapabilityStruct
namespace SlotStruct {
enum class Fields : uint8_t
{
    kMinDuration           = 0,
    kMaxDuration           = 1,
    kDefaultDuration       = 2,
    kElapsedSlotTime       = 3,
    kRemainingSlotTime     = 4,
    kSlotIsPausable        = 5,
    kMinPauseDuration      = 6,
    kMaxPauseDuration      = 7,
    kManufacturerESAState  = 8,
    kNominalPower          = 9,
    kMinPower              = 10,
    kMaxPower              = 11,
    kNominalEnergy         = 12,
    kCosts                 = 13,
    kMinPowerAdjustment    = 14,
    kMaxPowerAdjustment    = 15,
    kMinDurationAdjustment = 16,
    kMaxDurationAdjustment = 17,
};

struct Type
{
public:
    uint32_t minDuration       = static_cast<uint32_t>(0);
    uint32_t maxDuration       = static_cast<uint32_t>(0);
    uint32_t defaultDuration   = static_cast<uint32_t>(0);
    uint32_t elapsedSlotTime   = static_cast<uint32_t>(0);
    uint32_t remainingSlotTime = static_cast<uint32_t>(0);
    Optional<bool> slotIsPausable;
    Optional<uint32_t> minPauseDuration;
    Optional<uint32_t> maxPauseDuration;
    Optional<uint16_t> manufacturerESAState;
    Optional<int64_t> nominalPower;
    Optional<int64_t> minPower;
    Optional<int64_t> maxPower;
    Optional<int64_t> nominalEnergy;
    Optional<DataModel::List<const Structs::CostStruct::Type>> costs;
    Optional<int64_t> minPowerAdjustment;
    Optional<int64_t> maxPowerAdjustment;
    Optional<uint32_t> minDurationAdjustment;
    Optional<uint32_t> maxDurationAdjustment;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint32_t minDuration       = static_cast<uint32_t>(0);
    uint32_t maxDuration       = static_cast<uint32_t>(0);
    uint32_t defaultDuration   = static_cast<uint32_t>(0);
    uint32_t elapsedSlotTime   = static_cast<uint32_t>(0);
    uint32_t remainingSlotTime = static_cast<uint32_t>(0);
    Optional<bool> slotIsPausable;
    Optional<uint32_t> minPauseDuration;
    Optional<uint32_t> maxPauseDuration;
    Optional<uint16_t> manufacturerESAState;
    Optional<int64_t> nominalPower;
    Optional<int64_t> minPower;
    Optional<int64_t> maxPower;
    Optional<int64_t> nominalEnergy;
    Optional<DataModel::DecodableList<Structs::CostStruct::DecodableType>> costs;
    Optional<int64_t> minPowerAdjustment;
    Optional<int64_t> maxPowerAdjustment;
    Optional<uint32_t> minDurationAdjustment;
    Optional<uint32_t> maxDurationAdjustment;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace SlotStruct
namespace ForecastStruct {
enum class Fields : uint8_t
{
    kForecastID           = 0,
    kActiveSlotNumber     = 1,
    kStartTime            = 2,
    kEndTime              = 3,
    kEarliestStartTime    = 4,
    kLatestEndTime        = 5,
    kIsPausable           = 6,
    kSlots                = 7,
    kForecastUpdateReason = 8,
};

struct Type
{
public:
    uint32_t forecastID = static_cast<uint32_t>(0);
    DataModel::Nullable<uint16_t> activeSlotNumber;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    Optional<DataModel::Nullable<uint32_t>> earliestStartTime;
    Optional<uint32_t> latestEndTime;
    bool isPausable = static_cast<bool>(0);
    DataModel::List<const Structs::SlotStruct::Type> slots;
    ForecastUpdateReasonEnum forecastUpdateReason = static_cast<ForecastUpdateReasonEnum>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint32_t forecastID = static_cast<uint32_t>(0);
    DataModel::Nullable<uint16_t> activeSlotNumber;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    Optional<DataModel::Nullable<uint32_t>> earliestStartTime;
    Optional<uint32_t> latestEndTime;
    bool isPausable = static_cast<bool>(0);
    DataModel::DecodableList<Structs::SlotStruct::DecodableType> slots;
    ForecastUpdateReasonEnum forecastUpdateReason = static_cast<ForecastUpdateReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ForecastStruct
namespace ConstraintsStruct {
enum class Fields : uint8_t
{
    kStartTime     = 0,
    kDuration      = 1,
    kNominalPower  = 2,
    kMaximumEnergy = 3,
    kLoadControl   = 4,
};

struct Type
{
public:
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t duration  = static_cast<uint32_t>(0);
    Optional<int64_t> nominalPower;
    Optional<int64_t> maximumEnergy;
    Optional<int8_t> loadControl;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ConstraintsStruct
namespace SlotAdjustmentStruct {
enum class Fields : uint8_t
{
    kSlotIndex    = 0,
    kNominalPower = 1,
    kDuration     = 2,
};

struct Type
{
public:
    uint8_t slotIndex = static_cast<uint8_t>(0);
    Optional<int64_t> nominalPower;
    uint32_t duration = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SlotAdjustmentStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace PowerAdjustRequest {
struct Type;
struct DecodableType;
} // namespace PowerAdjustRequest

namespace CancelPowerAdjustRequest {
struct Type;
struct DecodableType;
} // namespace CancelPowerAdjustRequest

namespace StartTimeAdjustRequest {
struct Type;
struct DecodableType;
} // namespace StartTimeAdjustRequest

namespace PauseRequest {
struct Type;
struct DecodableType;
} // namespace PauseRequest

namespace ResumeRequest {
struct Type;
struct DecodableType;
} // namespace ResumeRequest

namespace ModifyForecastRequest {
struct Type;
struct DecodableType;
} // namespace ModifyForecastRequest

namespace RequestConstraintBasedForecast {
struct Type;
struct DecodableType;
} // namespace RequestConstraintBasedForecast

namespace CancelRequest {
struct Type;
struct DecodableType;
} // namespace CancelRequest

} // namespace Commands

namespace Commands {
namespace PowerAdjustRequest {
enum class Fields : uint8_t
{
    kPower    = 0,
    kDuration = 1,
    kCause    = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    int64_t power             = static_cast<int64_t>(0);
    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    int64_t power             = static_cast<int64_t>(0);
    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerAdjustRequest
namespace CancelPowerAdjustRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelPowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelPowerAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelPowerAdjustRequest
namespace StartTimeAdjustRequest {
enum class Fields : uint8_t
{
    kRequestedStartTime = 0,
    kCause              = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartTimeAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t requestedStartTime = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause   = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartTimeAdjustRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t requestedStartTime = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause   = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartTimeAdjustRequest
namespace PauseRequest {
enum class Fields : uint8_t
{
    kDuration = 0,
    kCause    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t duration         = static_cast<uint32_t>(0);
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseRequest
namespace ResumeRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResumeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResumeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResumeRequest
namespace ModifyForecastRequest {
enum class Fields : uint8_t
{
    kForecastID      = 0,
    kSlotAdjustments = 1,
    kCause           = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ModifyForecastRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t forecastID = static_cast<uint32_t>(0);
    DataModel::List<const Structs::SlotAdjustmentStruct::Type> slotAdjustments;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ModifyForecastRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    uint32_t forecastID = static_cast<uint32_t>(0);
    DataModel::DecodableList<Structs::SlotAdjustmentStruct::DecodableType> slotAdjustments;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ModifyForecastRequest
namespace RequestConstraintBasedForecast {
enum class Fields : uint8_t
{
    kConstraints = 0,
    kCause       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RequestConstraintBasedForecast::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    DataModel::List<const Structs::ConstraintsStruct::Type> constraints;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RequestConstraintBasedForecast::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    DataModel::DecodableList<Structs::ConstraintsStruct::DecodableType> constraints;
    AdjustmentCauseEnum cause = static_cast<AdjustmentCauseEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RequestConstraintBasedForecast
namespace CancelRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelRequest
} // namespace Commands

namespace Attributes {

namespace ESAType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum;
    using DecodableType    = chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum;
    using DecodableArgType = chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ESAType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ESAType
namespace ESACanGenerate {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ESACanGenerate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ESACanGenerate
namespace ESAState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum;
    using DecodableType    = chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum;
    using DecodableArgType = chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ESAState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ESAState
namespace AbsMinPower {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinPower
namespace AbsMaxPower {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxPower
namespace PowerAdjustmentCapability {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::PowerAdjustCapabilityStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::Clusters::DeviceEnergyManagement::Structs::PowerAdjustCapabilityStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::DeviceEnergyManagement::Structs::PowerAdjustCapabilityStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerAdjustmentCapability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerAdjustmentCapability
namespace Forecast {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::ForecastStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::ForecastStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::DeviceEnergyManagement::Structs::ForecastStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Forecast::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Forecast
namespace OptOutState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum;
    using DecodableType    = chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum;
    using DecodableArgType = chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OptOutState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OptOutState
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ESAType::TypeInfo::DecodableType ESAType =
            static_cast<chip::app::Clusters::DeviceEnergyManagement::ESATypeEnum>(0);
        Attributes::ESACanGenerate::TypeInfo::DecodableType ESACanGenerate = static_cast<bool>(0);
        Attributes::ESAState::TypeInfo::DecodableType ESAState =
            static_cast<chip::app::Clusters::DeviceEnergyManagement::ESAStateEnum>(0);
        Attributes::AbsMinPower::TypeInfo::DecodableType absMinPower = static_cast<int64_t>(0);
        Attributes::AbsMaxPower::TypeInfo::DecodableType absMaxPower = static_cast<int64_t>(0);
        Attributes::PowerAdjustmentCapability::TypeInfo::DecodableType powerAdjustmentCapability;
        Attributes::Forecast::TypeInfo::DecodableType forecast;
        Attributes::OptOutState::TypeInfo::DecodableType optOutState =
            static_cast<chip::app::Clusters::DeviceEnergyManagement::OptOutStateEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace PowerAdjustStart {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustStart::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustStart::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerAdjustStart
namespace PowerAdjustEnd {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCause     = 0,
    kDuration  = 1,
    kEnergyUse = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustEnd::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CauseEnum cause   = static_cast<CauseEnum>(0);
    uint32_t duration = static_cast<uint32_t>(0);
    int64_t energyUse = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerAdjustEnd::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CauseEnum cause   = static_cast<CauseEnum>(0);
    uint32_t duration = static_cast<uint32_t>(0);
    int64_t energyUse = static_cast<int64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerAdjustEnd
namespace Paused {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Paused::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Paused::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Paused
namespace Resumed {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCause = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Resumed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    CauseEnum cause = static_cast<CauseEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Resumed::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagement::Id; }

    CauseEnum cause = static_cast<CauseEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Resumed
} // namespace Events
} // namespace DeviceEnergyManagement
namespace EnergyEvse {
namespace Structs {
namespace ChargingTargetStruct {
enum class Fields : uint8_t
{
    kTargetTimeMinutesPastMidnight = 0,
    kTargetSoC                     = 1,
    kAddedEnergy                   = 2,
};

struct Type
{
public:
    uint16_t targetTimeMinutesPastMidnight = static_cast<uint16_t>(0);
    Optional<chip::Percent> targetSoC;
    Optional<int64_t> addedEnergy;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChargingTargetStruct
namespace ChargingTargetScheduleStruct {
enum class Fields : uint8_t
{
    kDayOfWeekForSequence = 0,
    kChargingTargets      = 1,
};

struct Type
{
public:
    chip::BitMask<TargetDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<TargetDayOfWeekBitmap>>(0);
    DataModel::List<const Structs::ChargingTargetStruct::Type> chargingTargets;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::BitMask<TargetDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<TargetDayOfWeekBitmap>>(0);
    DataModel::DecodableList<Structs::ChargingTargetStruct::DecodableType> chargingTargets;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ChargingTargetScheduleStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetTargetsResponse {
struct Type;
struct DecodableType;
} // namespace GetTargetsResponse

namespace Disable {
struct Type;
struct DecodableType;
} // namespace Disable

namespace EnableCharging {
struct Type;
struct DecodableType;
} // namespace EnableCharging

namespace EnableDischarging {
struct Type;
struct DecodableType;
} // namespace EnableDischarging

namespace StartDiagnostics {
struct Type;
struct DecodableType;
} // namespace StartDiagnostics

namespace SetTargets {
struct Type;
struct DecodableType;
} // namespace SetTargets

namespace GetTargets {
struct Type;
struct DecodableType;
} // namespace GetTargets

namespace ClearTargets {
struct Type;
struct DecodableType;
} // namespace ClearTargets

} // namespace Commands

namespace Commands {
namespace GetTargetsResponse {
enum class Fields : uint8_t
{
    kChargingTargetSchedules = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetTargetsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::List<const Structs::ChargingTargetScheduleStruct::Type> chargingTargetSchedules;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetTargetsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::DecodableList<Structs::ChargingTargetScheduleStruct::DecodableType> chargingTargetSchedules;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetTargetsResponse
namespace Disable {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Disable
namespace EnableCharging {
enum class Fields : uint8_t
{
    kChargingEnabledUntil = 0,
    kMinimumChargeCurrent = 1,
    kMaximumChargeCurrent = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableCharging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> chargingEnabledUntil;
    int64_t minimumChargeCurrent = static_cast<int64_t>(0);
    int64_t maximumChargeCurrent = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableCharging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> chargingEnabledUntil;
    int64_t minimumChargeCurrent = static_cast<int64_t>(0);
    int64_t maximumChargeCurrent = static_cast<int64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableCharging
namespace EnableDischarging {
enum class Fields : uint8_t
{
    kDischargingEnabledUntil = 0,
    kMaximumDischargeCurrent = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableDischarging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> dischargingEnabledUntil;
    int64_t maximumDischargeCurrent = static_cast<int64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableDischarging::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> dischargingEnabledUntil;
    int64_t maximumDischargeCurrent = static_cast<int64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableDischarging
namespace StartDiagnostics {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartDiagnostics::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartDiagnostics::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartDiagnostics
namespace SetTargets {
enum class Fields : uint8_t
{
    kChargingTargetSchedules = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::List<const Structs::ChargingTargetScheduleStruct::Type> chargingTargetSchedules;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::DecodableList<Structs::ChargingTargetScheduleStruct::DecodableType> chargingTargetSchedules;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTargets
namespace GetTargets {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::EnergyEvse::Commands::GetTargetsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetTargets
namespace ClearTargets {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearTargets::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearTargets
} // namespace Commands

namespace Attributes {

namespace State {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::EnergyEvse::StateEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::EnergyEvse::StateEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::EnergyEvse::StateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::State::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace State
namespace SupplyState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::EnergyEvse::SupplyStateEnum;
    using DecodableType    = chip::app::Clusters::EnergyEvse::SupplyStateEnum;
    using DecodableArgType = chip::app::Clusters::EnergyEvse::SupplyStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupplyState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupplyState
namespace FaultState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::EnergyEvse::FaultStateEnum;
    using DecodableType    = chip::app::Clusters::EnergyEvse::FaultStateEnum;
    using DecodableArgType = chip::app::Clusters::EnergyEvse::FaultStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FaultState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FaultState
namespace ChargingEnabledUntil {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChargingEnabledUntil::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChargingEnabledUntil
namespace DischargingEnabledUntil {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DischargingEnabledUntil::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DischargingEnabledUntil
namespace CircuitCapacity {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CircuitCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CircuitCapacity
namespace MinimumChargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinimumChargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinimumChargeCurrent
namespace MaximumChargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaximumChargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaximumChargeCurrent
namespace MaximumDischargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaximumDischargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaximumDischargeCurrent
namespace UserMaximumChargeCurrent {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserMaximumChargeCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserMaximumChargeCurrent
namespace RandomizationDelayWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RandomizationDelayWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RandomizationDelayWindow
namespace NextChargeStartTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeStartTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeStartTime
namespace NextChargeTargetTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeTargetTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeTargetTime
namespace NextChargeRequiredEnergy {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeRequiredEnergy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeRequiredEnergy
namespace NextChargeTargetSoC {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NextChargeTargetSoC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NextChargeTargetSoC
namespace ApproximateEVEfficiency {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApproximateEVEfficiency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApproximateEVEfficiency
namespace StateOfCharge {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StateOfCharge::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StateOfCharge
namespace BatteryCapacity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryCapacity
namespace VehicleID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VehicleID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VehicleID
namespace SessionID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionID
namespace SessionDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionDuration
namespace SessionEnergyCharged {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionEnergyCharged::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionEnergyCharged
namespace SessionEnergyDischarged {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SessionEnergyDischarged::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SessionEnergyDischarged
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::State::TypeInfo::DecodableType state;
        Attributes::SupplyState::TypeInfo::DecodableType supplyState =
            static_cast<chip::app::Clusters::EnergyEvse::SupplyStateEnum>(0);
        Attributes::FaultState::TypeInfo::DecodableType faultState =
            static_cast<chip::app::Clusters::EnergyEvse::FaultStateEnum>(0);
        Attributes::ChargingEnabledUntil::TypeInfo::DecodableType chargingEnabledUntil;
        Attributes::DischargingEnabledUntil::TypeInfo::DecodableType dischargingEnabledUntil;
        Attributes::CircuitCapacity::TypeInfo::DecodableType circuitCapacity                   = static_cast<int64_t>(0);
        Attributes::MinimumChargeCurrent::TypeInfo::DecodableType minimumChargeCurrent         = static_cast<int64_t>(0);
        Attributes::MaximumChargeCurrent::TypeInfo::DecodableType maximumChargeCurrent         = static_cast<int64_t>(0);
        Attributes::MaximumDischargeCurrent::TypeInfo::DecodableType maximumDischargeCurrent   = static_cast<int64_t>(0);
        Attributes::UserMaximumChargeCurrent::TypeInfo::DecodableType userMaximumChargeCurrent = static_cast<int64_t>(0);
        Attributes::RandomizationDelayWindow::TypeInfo::DecodableType randomizationDelayWindow = static_cast<uint32_t>(0);
        Attributes::NextChargeStartTime::TypeInfo::DecodableType nextChargeStartTime;
        Attributes::NextChargeTargetTime::TypeInfo::DecodableType nextChargeTargetTime;
        Attributes::NextChargeRequiredEnergy::TypeInfo::DecodableType nextChargeRequiredEnergy;
        Attributes::NextChargeTargetSoC::TypeInfo::DecodableType nextChargeTargetSoC;
        Attributes::ApproximateEVEfficiency::TypeInfo::DecodableType approximateEVEfficiency;
        Attributes::StateOfCharge::TypeInfo::DecodableType stateOfCharge;
        Attributes::BatteryCapacity::TypeInfo::DecodableType batteryCapacity;
        Attributes::VehicleID::TypeInfo::DecodableType vehicleID;
        Attributes::SessionID::TypeInfo::DecodableType sessionID;
        Attributes::SessionDuration::TypeInfo::DecodableType sessionDuration;
        Attributes::SessionEnergyCharged::TypeInfo::DecodableType sessionEnergyCharged;
        Attributes::SessionEnergyDischarged::TypeInfo::DecodableType sessionEnergyDischarged;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace EVConnected {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVConnected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVConnected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EVConnected
namespace EVNotDetected {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID               = 0,
    kState                   = 1,
    kSessionDuration         = 2,
    kSessionEnergyCharged    = 3,
    kSessionEnergyDischarged = 4,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVNotDetected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID           = static_cast<uint32_t>(0);
    StateEnum state              = static_cast<StateEnum>(0);
    uint32_t sessionDuration     = static_cast<uint32_t>(0);
    int64_t sessionEnergyCharged = static_cast<int64_t>(0);
    Optional<int64_t> sessionEnergyDischarged;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EVNotDetected::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID           = static_cast<uint32_t>(0);
    StateEnum state              = static_cast<StateEnum>(0);
    uint32_t sessionDuration     = static_cast<uint32_t>(0);
    int64_t sessionEnergyCharged = static_cast<int64_t>(0);
    Optional<int64_t> sessionEnergyDischarged;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EVNotDetected
namespace EnergyTransferStarted {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID               = 0,
    kState                   = 1,
    kMaximumCurrent          = 2,
    kMaximumDischargeCurrent = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStarted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID     = static_cast<uint32_t>(0);
    StateEnum state        = static_cast<StateEnum>(0);
    int64_t maximumCurrent = static_cast<int64_t>(0);
    Optional<int64_t> maximumDischargeCurrent;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStarted::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID     = static_cast<uint32_t>(0);
    StateEnum state        = static_cast<StateEnum>(0);
    int64_t maximumCurrent = static_cast<int64_t>(0);
    Optional<int64_t> maximumDischargeCurrent;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EnergyTransferStarted
namespace EnergyTransferStopped {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kSessionID         = 0,
    kState             = 1,
    kReason            = 2,
    kEnergyTransferred = 4,
    kEnergyDischarged  = 5,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStopped::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint32_t sessionID                     = static_cast<uint32_t>(0);
    StateEnum state                        = static_cast<StateEnum>(0);
    EnergyTransferStoppedReasonEnum reason = static_cast<EnergyTransferStoppedReasonEnum>(0);
    int64_t energyTransferred              = static_cast<int64_t>(0);
    Optional<int64_t> energyDischarged;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::EnergyTransferStopped::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    uint32_t sessionID                     = static_cast<uint32_t>(0);
    StateEnum state                        = static_cast<StateEnum>(0);
    EnergyTransferStoppedReasonEnum reason = static_cast<EnergyTransferStoppedReasonEnum>(0);
    int64_t energyTransferred              = static_cast<int64_t>(0);
    Optional<int64_t> energyDischarged;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace EnergyTransferStopped
namespace Fault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kSessionID               = 0,
    kState                   = 1,
    kFaultStatePreviousState = 2,
    kFaultStateCurrentState  = 4,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Fault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::Nullable<uint32_t> sessionID;
    StateEnum state                        = static_cast<StateEnum>(0);
    FaultStateEnum faultStatePreviousState = static_cast<FaultStateEnum>(0);
    FaultStateEnum faultStateCurrentState  = static_cast<FaultStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Fault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    DataModel::Nullable<uint32_t> sessionID;
    StateEnum state                        = static_cast<StateEnum>(0);
    FaultStateEnum faultStatePreviousState = static_cast<FaultStateEnum>(0);
    FaultStateEnum faultStateCurrentState  = static_cast<FaultStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Fault
namespace Rfid {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kUid = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Rfid::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::ByteSpan uid;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Rfid::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvse::Id; }

    chip::ByteSpan uid;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Rfid
} // namespace Events
} // namespace EnergyEvse
namespace EnergyPreference {
namespace Structs {
namespace BalanceStruct {
enum class Fields : uint8_t
{
    kStep  = 0,
    kLabel = 1,
};

struct Type
{
public:
    chip::Percent step = static_cast<chip::Percent>(0);
    Optional<chip::CharSpan> label;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace BalanceStruct
} // namespace Structs

namespace Attributes {

namespace EnergyBalances {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyBalances::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnergyBalances
namespace CurrentEnergyBalance {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentEnergyBalance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentEnergyBalance
namespace EnergyPriorities {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::EnergyPreference::EnergyPriorityEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::EnergyPriorityEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::EnergyPriorityEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyPriorities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnergyPriorities
namespace LowPowerModeSensitivities {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyPreference::Structs::BalanceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LowPowerModeSensitivities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LowPowerModeSensitivities
namespace CurrentLowPowerModeSensitivity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLowPowerModeSensitivity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLowPowerModeSensitivity
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EnergyPreference::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::EnergyBalances::TypeInfo::DecodableType energyBalances;
        Attributes::CurrentEnergyBalance::TypeInfo::DecodableType currentEnergyBalance = static_cast<uint8_t>(0);
        Attributes::EnergyPriorities::TypeInfo::DecodableType energyPriorities;
        Attributes::LowPowerModeSensitivities::TypeInfo::DecodableType lowPowerModeSensitivities;
        Attributes::CurrentLowPowerModeSensitivity::TypeInfo::DecodableType currentLowPowerModeSensitivity =
            static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EnergyPreference
namespace PowerTopology {

namespace Attributes {

namespace AvailableEndpoints {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailableEndpoints::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailableEndpoints
namespace ActiveEndpoints {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveEndpoints::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveEndpoints
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerTopology::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AvailableEndpoints::TypeInfo::DecodableType availableEndpoints;
        Attributes::ActiveEndpoints::TypeInfo::DecodableType activeEndpoints;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PowerTopology
namespace EnergyEvseMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::EnergyEvseMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EnergyEvseMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyEvseMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::EnergyEvseMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EnergyEvseMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EnergyEvseMode
namespace WaterHeaterMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::WaterHeaterMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::WaterHeaterMode::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::WaterHeaterMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::WaterHeaterMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WaterHeaterMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WaterHeaterMode
namespace DeviceEnergyManagementMode {
namespace Structs {
namespace ModeTagStruct    = Clusters::detail::Structs::ModeTagStruct;
namespace ModeOptionStruct = Clusters::detail::Structs::ModeOptionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

namespace ChangeToModeResponse {
struct Type;
struct DecodableType;
} // namespace ChangeToModeResponse

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields : uint8_t
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DeviceEnergyManagementMode::Commands::ChangeToModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t newMode = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
namespace ChangeToModeResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

    uint8_t status = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToModeResponse
} // namespace Commands

namespace Attributes {

namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::DeviceEnergyManagementMode::Structs::ModeOptionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::DeviceEnergyManagementMode::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::DeviceEnergyManagementMode::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DeviceEnergyManagementMode::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::CurrentMode::TypeInfo::DecodableType currentMode = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace DeviceEnergyManagementMode
namespace DoorLock {
namespace Structs {
namespace CredentialStruct {
enum class Fields : uint8_t
{
    kCredentialType  = 0,
    kCredentialIndex = 1,
};

struct Type
{
public:
    CredentialTypeEnum credentialType = static_cast<CredentialTypeEnum>(0);
    uint16_t credentialIndex          = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CredentialStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LockDoor {
struct Type;
struct DecodableType;
} // namespace LockDoor

namespace UnlockDoor {
struct Type;
struct DecodableType;
} // namespace UnlockDoor

namespace UnlockWithTimeout {
struct Type;
struct DecodableType;
} // namespace UnlockWithTimeout

namespace SetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeekDaySchedule

namespace GetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeekDaySchedule

namespace GetWeekDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeekDayScheduleResponse

namespace ClearWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeekDaySchedule

namespace SetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetYearDaySchedule

namespace GetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetYearDaySchedule

namespace GetYearDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetYearDayScheduleResponse

namespace ClearYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearYearDaySchedule

namespace SetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace SetHolidaySchedule

namespace GetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace GetHolidaySchedule

namespace GetHolidayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetHolidayScheduleResponse

namespace ClearHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearHolidaySchedule

namespace SetUser {
struct Type;
struct DecodableType;
} // namespace SetUser

namespace GetUser {
struct Type;
struct DecodableType;
} // namespace GetUser

namespace GetUserResponse {
struct Type;
struct DecodableType;
} // namespace GetUserResponse

namespace ClearUser {
struct Type;
struct DecodableType;
} // namespace ClearUser

namespace SetCredential {
struct Type;
struct DecodableType;
} // namespace SetCredential

namespace SetCredentialResponse {
struct Type;
struct DecodableType;
} // namespace SetCredentialResponse

namespace GetCredentialStatus {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatus

namespace GetCredentialStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatusResponse

namespace ClearCredential {
struct Type;
struct DecodableType;
} // namespace ClearCredential

namespace UnboltDoor {
struct Type;
struct DecodableType;
} // namespace UnboltDoor

namespace SetAliroReaderConfig {
struct Type;
struct DecodableType;
} // namespace SetAliroReaderConfig

namespace ClearAliroReaderConfig {
struct Type;
struct DecodableType;
} // namespace ClearAliroReaderConfig

} // namespace Commands

namespace Commands {
namespace LockDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LockDoor
namespace UnlockDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockDoor
namespace UnlockWithTimeout {
enum class Fields : uint8_t
{
    kTimeout = 0,
    kPINCode = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockWithTimeout
namespace SetWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kDaysMask     = 2,
    kStartHour    = 3,
    kStartMinute  = 4,
    kEndHour      = 5,
    kEndMinute    = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex                = static_cast<uint8_t>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    chip::BitMask<DaysMaskMap> daysMask = static_cast<chip::BitMask<DaysMaskMap>>(0);
    uint8_t startHour                   = static_cast<uint8_t>(0);
    uint8_t startMinute                 = static_cast<uint8_t>(0);
    uint8_t endHour                     = static_cast<uint8_t>(0);
    uint8_t endMinute                   = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex                = static_cast<uint8_t>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    chip::BitMask<DaysMaskMap> daysMask = static_cast<chip::BitMask<DaysMaskMap>>(0);
    uint8_t startHour                   = static_cast<uint8_t>(0);
    uint8_t startMinute                 = static_cast<uint8_t>(0);
    uint8_t endHour                     = static_cast<uint8_t>(0);
    uint8_t endMinute                   = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeekDaySchedule
namespace GetWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDaySchedule
namespace GetWeekDayScheduleResponse {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kStatus       = 2,
    kDaysMask     = 3,
    kStartHour    = 4,
    kStartMinute  = 5,
    kEndHour      = 6,
    kEndMinute    = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<chip::BitMask<DaysMaskMap>> daysMask;
    Optional<uint8_t> startHour;
    Optional<uint8_t> startMinute;
    Optional<uint8_t> endHour;
    Optional<uint8_t> endMinute;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<chip::BitMask<DaysMaskMap>> daysMask;
    Optional<uint8_t> startHour;
    Optional<uint8_t> startMinute;
    Optional<uint8_t> endHour;
    Optional<uint8_t> endMinute;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDayScheduleResponse
namespace ClearWeekDaySchedule {
enum class Fields : uint8_t
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeekDaySchedule
namespace SetYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex    = static_cast<uint8_t>(0);
    uint16_t userIndex      = static_cast<uint16_t>(0);
    uint32_t localStartTime = static_cast<uint32_t>(0);
    uint32_t localEndTime   = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex    = static_cast<uint8_t>(0);
    uint16_t userIndex      = static_cast<uint16_t>(0);
    uint32_t localStartTime = static_cast<uint32_t>(0);
    uint32_t localEndTime   = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetYearDaySchedule
namespace GetYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDaySchedule
namespace GetYearDayScheduleResponse {
enum class Fields : uint8_t
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kStatus         = 2,
    kLocalStartTime = 3,
    kLocalEndTime   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDayScheduleResponse
namespace ClearYearDaySchedule {
enum class Fields : uint8_t
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex = static_cast<uint8_t>(0);
    uint16_t userIndex   = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearYearDaySchedule
namespace SetHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex   = 0,
    kLocalStartTime = 1,
    kLocalEndTime   = 2,
    kOperatingMode  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex            = static_cast<uint8_t>(0);
    uint32_t localStartTime         = static_cast<uint32_t>(0);
    uint32_t localEndTime           = static_cast<uint32_t>(0);
    OperatingModeEnum operatingMode = static_cast<OperatingModeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex            = static_cast<uint8_t>(0);
    uint32_t localStartTime         = static_cast<uint32_t>(0);
    uint32_t localEndTime           = static_cast<uint32_t>(0);
    OperatingModeEnum operatingMode = static_cast<OperatingModeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetHolidaySchedule
namespace GetHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetHolidayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidaySchedule
namespace GetHolidayScheduleResponse {
enum class Fields : uint8_t
{
    kHolidayIndex   = 0,
    kStatus         = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
    kOperatingMode  = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    Optional<OperatingModeEnum> operatingMode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    DlStatus status      = static_cast<DlStatus>(0);
    Optional<uint32_t> localStartTime;
    Optional<uint32_t> localEndTime;
    Optional<OperatingModeEnum> operatingMode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidayScheduleResponse
namespace ClearHolidaySchedule {
enum class Fields : uint8_t
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearHolidaySchedule
namespace SetUser {
enum class Fields : uint8_t
{
    kOperationType  = 0,
    kUserIndex      = 1,
    kUserName       = 2,
    kUserUniqueID   = 3,
    kUserStatus     = 4,
    kUserType       = 5,
    kCredentialRule = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    uint16_t userIndex                  = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUser
namespace GetUser {
enum class Fields : uint8_t
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetUserResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUser
namespace GetUserResponse {
enum class Fields : uint8_t
{
    kUserIndex               = 0,
    kUserName                = 1,
    kUserUniqueID            = 2,
    kUserStatus              = 3,
    kUserType                = 4,
    kCredentialRule          = 5,
    kCredentials             = 6,
    kCreatorFabricIndex      = 7,
    kLastModifiedFabricIndex = 8,
    kNextUserIndex           = 9,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextUserIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueID;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    DataModel::Nullable<CredentialRuleEnum> credentialRule;
    DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextUserIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserResponse
namespace ClearUser {
enum class Fields : uint8_t
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearUser
namespace SetCredential {
enum class Fields : uint8_t
{
    kOperationType  = 0,
    kCredential     = 1,
    kCredentialData = 2,
    kUserIndex      = 3,
    kUserStatus     = 4,
    kUserType       = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    Structs::CredentialStruct::Type credential;
    chip::ByteSpan credentialData;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataOperationTypeEnum operationType = static_cast<DataOperationTypeEnum>(0);
    Structs::CredentialStruct::DecodableType credential;
    chip::ByteSpan credentialData;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<UserStatusEnum> userStatus;
    DataModel::Nullable<UserTypeEnum> userType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredential
namespace SetCredentialResponse {
enum class Fields : uint8_t
{
    kStatus              = 0,
    kUserIndex           = 1,
    kNextCredentialIndex = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status = static_cast<DlStatus>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status = static_cast<DlStatus>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredentialResponse
namespace GetCredentialStatus {
enum class Fields : uint8_t
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::CredentialStruct::Type credential;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::CredentialStruct::DecodableType credential;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatus
namespace GetCredentialStatusResponse {
enum class Fields : uint8_t
{
    kCredentialExists        = 0,
    kUserIndex               = 1,
    kCreatorFabricIndex      = 2,
    kLastModifiedFabricIndex = 3,
    kNextCredentialIndex     = 4,
    kCredentialData          = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists = static_cast<bool>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    Optional<DataModel::Nullable<chip::ByteSpan>> credentialData;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists = static_cast<bool>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    Optional<DataModel::Nullable<chip::ByteSpan>> credentialData;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatusResponse
namespace ClearCredential {
enum class Fields : uint8_t
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataModel::Nullable<Structs::CredentialStruct::Type> credential;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DataModel::Nullable<Structs::CredentialStruct::DecodableType> credential;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearCredential
namespace UnboltDoor {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnboltDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnboltDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnboltDoor
namespace SetAliroReaderConfig {
enum class Fields : uint8_t
{
    kSigningKey        = 0,
    kVerificationKey   = 1,
    kGroupIdentifier   = 2,
    kGroupResolvingKey = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    chip::ByteSpan signingKey;
    chip::ByteSpan verificationKey;
    chip::ByteSpan groupIdentifier;
    Optional<chip::ByteSpan> groupResolvingKey;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    chip::ByteSpan signingKey;
    chip::ByteSpan verificationKey;
    chip::ByteSpan groupIdentifier;
    Optional<chip::ByteSpan> groupResolvingKey;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetAliroReaderConfig
namespace ClearAliroReaderConfig {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearAliroReaderConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAliroReaderConfig
} // namespace Commands

namespace Attributes {

namespace LockState {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LockState
namespace LockType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DoorLock::DlLockType;
    using DecodableType    = chip::app::Clusters::DoorLock::DlLockType;
    using DecodableArgType = chip::app::Clusters::DoorLock::DlLockType;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LockType
namespace ActuatorEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActuatorEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActuatorEnabled
namespace DoorState {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DoorStateEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorState
namespace DoorOpenEvents {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorOpenEvents
namespace DoorClosedEvents {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorClosedEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorClosedEvents
namespace OpenPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OpenPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OpenPeriod
namespace NumberOfTotalUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfTotalUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfTotalUsersSupported
namespace NumberOfPINUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPINUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPINUsersSupported
namespace NumberOfRFIDUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfRFIDUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfRFIDUsersSupported
namespace NumberOfWeekDaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeekDaySchedulesSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfWeekDaySchedulesSupportedPerUser
namespace NumberOfYearDaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfYearDaySchedulesSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfYearDaySchedulesSupportedPerUser
namespace NumberOfHolidaySchedulesSupported {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfHolidaySchedulesSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfHolidaySchedulesSupported
namespace MaxPINCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPINCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPINCodeLength
namespace MinPINCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinPINCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinPINCodeLength
namespace MaxRFIDCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxRFIDCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxRFIDCodeLength
namespace MinRFIDCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinRFIDCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinRFIDCodeLength
namespace CredentialRulesSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CredentialRulesSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CredentialRulesSupport
namespace NumberOfCredentialsSupportedPerUser {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfCredentialsSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfCredentialsSupportedPerUser
namespace Language {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Language::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 3; }
};
} // namespace Language
namespace LEDSettings {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LEDSettings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LEDSettings
namespace AutoRelockTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AutoRelockTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AutoRelockTime
namespace SoundVolume {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoundVolume::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoundVolume
namespace OperatingMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DoorLock::OperatingModeEnum;
    using DecodableType    = chip::app::Clusters::DoorLock::OperatingModeEnum;
    using DecodableArgType = chip::app::Clusters::DoorLock::OperatingModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperatingMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperatingMode
namespace SupportedOperatingModes {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedOperatingModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedOperatingModes
namespace DefaultConfigurationRegister {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultConfigurationRegister::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultConfigurationRegister
namespace EnableLocalProgramming {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableLocalProgramming::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableLocalProgramming
namespace EnableOneTouchLocking {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableOneTouchLocking::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableOneTouchLocking
namespace EnableInsideStatusLED {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableInsideStatusLED::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableInsideStatusLED
namespace EnablePrivacyModeButton {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnablePrivacyModeButton::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnablePrivacyModeButton
namespace LocalProgrammingFeatures {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalProgrammingFeatures::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalProgrammingFeatures
namespace WrongCodeEntryLimit {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WrongCodeEntryLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WrongCodeEntryLimit
namespace UserCodeTemporaryDisableTime {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserCodeTemporaryDisableTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserCodeTemporaryDisableTime
namespace SendPINOverTheAir {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SendPINOverTheAir::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SendPINOverTheAir
namespace RequirePINforRemoteOperation {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RequirePINforRemoteOperation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RequirePINforRemoteOperation
namespace ExpiringUserTimeout {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpiringUserTimeout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpiringUserTimeout
namespace AliroReaderVerificationKey {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroReaderVerificationKey::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 65; }
};
} // namespace AliroReaderVerificationKey
namespace AliroReaderGroupIdentifier {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroReaderGroupIdentifier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace AliroReaderGroupIdentifier
namespace AliroReaderGroupSubIdentifier {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroReaderGroupSubIdentifier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace AliroReaderGroupSubIdentifier
namespace AliroExpeditedTransactionSupportedProtocolVersions {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroExpeditedTransactionSupportedProtocolVersions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AliroExpeditedTransactionSupportedProtocolVersions
namespace AliroGroupResolvingKey {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroGroupResolvingKey::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace AliroGroupResolvingKey
namespace AliroSupportedBLEUWBProtocolVersions {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroSupportedBLEUWBProtocolVersions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AliroSupportedBLEUWBProtocolVersions
namespace AliroBLEAdvertisingVersion {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AliroBLEAdvertisingVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AliroBLEAdvertisingVersion
namespace NumberOfAliroCredentialIssuerKeysSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfAliroCredentialIssuerKeysSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfAliroCredentialIssuerKeysSupported
namespace NumberOfAliroEndpointKeysSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfAliroEndpointKeysSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfAliroEndpointKeysSupported
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LockState::TypeInfo::DecodableType lockState;
        Attributes::LockType::TypeInfo::DecodableType lockType = static_cast<chip::app::Clusters::DoorLock::DlLockType>(0);
        Attributes::ActuatorEnabled::TypeInfo::DecodableType actuatorEnabled = static_cast<bool>(0);
        Attributes::DoorState::TypeInfo::DecodableType doorState;
        Attributes::DoorOpenEvents::TypeInfo::DecodableType doorOpenEvents                           = static_cast<uint32_t>(0);
        Attributes::DoorClosedEvents::TypeInfo::DecodableType doorClosedEvents                       = static_cast<uint32_t>(0);
        Attributes::OpenPeriod::TypeInfo::DecodableType openPeriod                                   = static_cast<uint16_t>(0);
        Attributes::NumberOfTotalUsersSupported::TypeInfo::DecodableType numberOfTotalUsersSupported = static_cast<uint16_t>(0);
        Attributes::NumberOfPINUsersSupported::TypeInfo::DecodableType numberOfPINUsersSupported     = static_cast<uint16_t>(0);
        Attributes::NumberOfRFIDUsersSupported::TypeInfo::DecodableType numberOfRFIDUsersSupported   = static_cast<uint16_t>(0);
        Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo::DecodableType numberOfWeekDaySchedulesSupportedPerUser =
            static_cast<uint8_t>(0);
        Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo::DecodableType numberOfYearDaySchedulesSupportedPerUser =
            static_cast<uint8_t>(0);
        Attributes::NumberOfHolidaySchedulesSupported::TypeInfo::DecodableType numberOfHolidaySchedulesSupported =
            static_cast<uint8_t>(0);
        Attributes::MaxPINCodeLength::TypeInfo::DecodableType maxPINCodeLength   = static_cast<uint8_t>(0);
        Attributes::MinPINCodeLength::TypeInfo::DecodableType minPINCodeLength   = static_cast<uint8_t>(0);
        Attributes::MaxRFIDCodeLength::TypeInfo::DecodableType maxRFIDCodeLength = static_cast<uint8_t>(0);
        Attributes::MinRFIDCodeLength::TypeInfo::DecodableType minRFIDCodeLength = static_cast<uint8_t>(0);
        Attributes::CredentialRulesSupport::TypeInfo::DecodableType credentialRulesSupport =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlCredentialRuleMask>>(0);
        Attributes::NumberOfCredentialsSupportedPerUser::TypeInfo::DecodableType numberOfCredentialsSupportedPerUser =
            static_cast<uint8_t>(0);
        Attributes::Language::TypeInfo::DecodableType language;
        Attributes::LEDSettings::TypeInfo::DecodableType LEDSettings       = static_cast<uint8_t>(0);
        Attributes::AutoRelockTime::TypeInfo::DecodableType autoRelockTime = static_cast<uint32_t>(0);
        Attributes::SoundVolume::TypeInfo::DecodableType soundVolume       = static_cast<uint8_t>(0);
        Attributes::OperatingMode::TypeInfo::DecodableType operatingMode =
            static_cast<chip::app::Clusters::DoorLock::OperatingModeEnum>(0);
        Attributes::SupportedOperatingModes::TypeInfo::DecodableType supportedOperatingModes =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlSupportedOperatingModes>>(0);
        Attributes::DefaultConfigurationRegister::TypeInfo::DecodableType defaultConfigurationRegister =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlDefaultConfigurationRegister>>(0);
        Attributes::EnableLocalProgramming::TypeInfo::DecodableType enableLocalProgramming   = static_cast<bool>(0);
        Attributes::EnableOneTouchLocking::TypeInfo::DecodableType enableOneTouchLocking     = static_cast<bool>(0);
        Attributes::EnableInsideStatusLED::TypeInfo::DecodableType enableInsideStatusLED     = static_cast<bool>(0);
        Attributes::EnablePrivacyModeButton::TypeInfo::DecodableType enablePrivacyModeButton = static_cast<bool>(0);
        Attributes::LocalProgrammingFeatures::TypeInfo::DecodableType localProgrammingFeatures =
            static_cast<chip::BitMask<chip::app::Clusters::DoorLock::DlLocalProgrammingFeatures>>(0);
        Attributes::WrongCodeEntryLimit::TypeInfo::DecodableType wrongCodeEntryLimit                   = static_cast<uint8_t>(0);
        Attributes::UserCodeTemporaryDisableTime::TypeInfo::DecodableType userCodeTemporaryDisableTime = static_cast<uint8_t>(0);
        Attributes::SendPINOverTheAir::TypeInfo::DecodableType sendPINOverTheAir                       = static_cast<bool>(0);
        Attributes::RequirePINforRemoteOperation::TypeInfo::DecodableType requirePINforRemoteOperation = static_cast<bool>(0);
        Attributes::ExpiringUserTimeout::TypeInfo::DecodableType expiringUserTimeout                   = static_cast<uint16_t>(0);
        Attributes::AliroReaderVerificationKey::TypeInfo::DecodableType aliroReaderVerificationKey;
        Attributes::AliroReaderGroupIdentifier::TypeInfo::DecodableType aliroReaderGroupIdentifier;
        Attributes::AliroReaderGroupSubIdentifier::TypeInfo::DecodableType aliroReaderGroupSubIdentifier;
        Attributes::AliroExpeditedTransactionSupportedProtocolVersions::TypeInfo::DecodableType
            aliroExpeditedTransactionSupportedProtocolVersions;
        Attributes::AliroGroupResolvingKey::TypeInfo::DecodableType aliroGroupResolvingKey;
        Attributes::AliroSupportedBLEUWBProtocolVersions::TypeInfo::DecodableType aliroSupportedBLEUWBProtocolVersions;
        Attributes::AliroBLEAdvertisingVersion::TypeInfo::DecodableType aliroBLEAdvertisingVersion = static_cast<uint8_t>(0);
        Attributes::NumberOfAliroCredentialIssuerKeysSupported::TypeInfo::DecodableType numberOfAliroCredentialIssuerKeysSupported =
            static_cast<uint16_t>(0);
        Attributes::NumberOfAliroEndpointKeysSupported::TypeInfo::DecodableType numberOfAliroEndpointKeysSupported =
            static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace DoorLockAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kAlarmCode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorLockAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    AlarmCodeEnum alarmCode = static_cast<AlarmCodeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorLockAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    AlarmCodeEnum alarmCode = static_cast<AlarmCodeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DoorLockAlarm
namespace DoorStateChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kDoorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorStateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    DoorStateEnum doorState = static_cast<DoorStateEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DoorStateChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DoorStateEnum doorState = static_cast<DoorStateEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DoorStateChange
namespace LockOperation {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kLockOperationType = 0,
    kOperationSource   = 1,
    kUserIndex         = 2,
    kFabricIndex       = 3,
    kSourceNode        = 4,
    kCredentials       = 5,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>>> credentials;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>>> credentials;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockOperation
namespace LockOperationError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kLockOperationType = 0,
    kOperationSource   = 1,
    kOperationError    = 2,
    kUserIndex         = 3,
    kFabricIndex       = 4,
    kSourceNode        = 5,
    kCredentials       = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperationError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    OperationErrorEnum operationError       = static_cast<OperationErrorEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::List<const Structs::CredentialStruct::Type>>> credentials;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockOperationError::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    LockOperationTypeEnum lockOperationType = static_cast<LockOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    OperationErrorEnum operationError       = static_cast<OperationErrorEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::CredentialStruct::DecodableType>>> credentials;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockOperationError
namespace LockUserChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kLockDataType      = 0,
    kDataOperationType = 1,
    kOperationSource   = 2,
    kUserIndex         = 3,
    kFabricIndex       = 4,
    kSourceNode        = 5,
    kDataIndex         = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockUserChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr bool kIsFabricScoped = false;

    LockDataTypeEnum lockDataType           = static_cast<LockDataTypeEnum>(0);
    DataOperationTypeEnum dataOperationType = static_cast<DataOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    DataModel::Nullable<uint16_t> dataIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LockUserChange::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    LockDataTypeEnum lockDataType           = static_cast<LockDataTypeEnum>(0);
    DataOperationTypeEnum dataOperationType = static_cast<DataOperationTypeEnum>(0);
    OperationSourceEnum operationSource     = static_cast<OperationSourceEnum>(0);
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    DataModel::Nullable<uint16_t> dataIndex;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockUserChange
} // namespace Events
} // namespace DoorLock
namespace WindowCovering {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace UpOrOpen {
struct Type;
struct DecodableType;
} // namespace UpOrOpen

namespace DownOrClose {
struct Type;
struct DecodableType;
} // namespace DownOrClose

namespace StopMotion {
struct Type;
struct DecodableType;
} // namespace StopMotion

namespace GoToLiftValue {
struct Type;
struct DecodableType;
} // namespace GoToLiftValue

namespace GoToLiftPercentage {
struct Type;
struct DecodableType;
} // namespace GoToLiftPercentage

namespace GoToTiltValue {
struct Type;
struct DecodableType;
} // namespace GoToTiltValue

namespace GoToTiltPercentage {
struct Type;
struct DecodableType;
} // namespace GoToTiltPercentage

} // namespace Commands

namespace Commands {
namespace UpOrOpen {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpOrOpen
namespace DownOrClose {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DownOrClose
namespace StopMotion {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMotion
namespace GoToLiftValue {
enum class Fields : uint8_t
{
    kLiftValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t liftValue = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t liftValue = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftValue
namespace GoToLiftPercentage {
enum class Fields : uint8_t
{
    kLiftPercent100thsValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths liftPercent100thsValue = static_cast<chip::Percent100ths>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths liftPercent100thsValue = static_cast<chip::Percent100ths>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftPercentage
namespace GoToTiltValue {
enum class Fields : uint8_t
{
    kTiltValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t tiltValue = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t tiltValue = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltValue
namespace GoToTiltPercentage {
enum class Fields : uint8_t
{
    kTiltPercent100thsValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths tiltPercent100thsValue = static_cast<chip::Percent100ths>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent100ths tiltPercent100thsValue = static_cast<chip::Percent100ths>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltPercentage
} // namespace Commands

namespace Attributes {

namespace Type {
struct TypeInfo
{
    using Type             = chip::app::Clusters::WindowCovering::Type;
    using DecodableType    = chip::app::Clusters::WindowCovering::Type;
    using DecodableArgType = chip::app::Clusters::WindowCovering::Type;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Type::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Type
namespace PhysicalClosedLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimitLift
namespace PhysicalClosedLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimitTilt
namespace CurrentPositionLift {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLift
namespace CurrentPositionTilt {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTilt
namespace NumberOfActuationsLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfActuationsLift
namespace NumberOfActuationsTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfActuationsTilt
namespace ConfigStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConfigStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ConfigStatus
namespace CurrentPositionLiftPercentage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLiftPercentage
namespace CurrentPositionTiltPercentage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTiltPercentage
namespace OperationalStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStatus
namespace TargetPositionLiftPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionLiftPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetPositionLiftPercent100ths
namespace TargetPositionTiltPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionTiltPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetPositionTiltPercent100ths
namespace EndProductType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::WindowCovering::EndProductType;
    using DecodableType    = chip::app::Clusters::WindowCovering::EndProductType;
    using DecodableArgType = chip::app::Clusters::WindowCovering::EndProductType;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndProductType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndProductType
namespace CurrentPositionLiftPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLiftPercent100ths
namespace CurrentPositionTiltPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTiltPercent100ths
namespace InstalledOpenLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledOpenLimitLift
namespace InstalledClosedLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledClosedLimitLift
namespace InstalledOpenLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledOpenLimitTilt
namespace InstalledClosedLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledClosedLimitTilt
namespace Mode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::Mode>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::Mode>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::Mode>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mode
namespace SafetyStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SafetyStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SafetyStatus
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Type::TypeInfo::DecodableType type = static_cast<chip::app::Clusters::WindowCovering::Type>(0);
        Attributes::PhysicalClosedLimitLift::TypeInfo::DecodableType physicalClosedLimitLift = static_cast<uint16_t>(0);
        Attributes::PhysicalClosedLimitTilt::TypeInfo::DecodableType physicalClosedLimitTilt = static_cast<uint16_t>(0);
        Attributes::CurrentPositionLift::TypeInfo::DecodableType currentPositionLift;
        Attributes::CurrentPositionTilt::TypeInfo::DecodableType currentPositionTilt;
        Attributes::NumberOfActuationsLift::TypeInfo::DecodableType numberOfActuationsLift = static_cast<uint16_t>(0);
        Attributes::NumberOfActuationsTilt::TypeInfo::DecodableType numberOfActuationsTilt = static_cast<uint16_t>(0);
        Attributes::ConfigStatus::TypeInfo::DecodableType configStatus =
            static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::ConfigStatus>>(0);
        Attributes::CurrentPositionLiftPercentage::TypeInfo::DecodableType currentPositionLiftPercentage;
        Attributes::CurrentPositionTiltPercentage::TypeInfo::DecodableType currentPositionTiltPercentage;
        Attributes::OperationalStatus::TypeInfo::DecodableType operationalStatus =
            static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::OperationalStatus>>(0);
        Attributes::TargetPositionLiftPercent100ths::TypeInfo::DecodableType targetPositionLiftPercent100ths;
        Attributes::TargetPositionTiltPercent100ths::TypeInfo::DecodableType targetPositionTiltPercent100ths;
        Attributes::EndProductType::TypeInfo::DecodableType endProductType =
            static_cast<chip::app::Clusters::WindowCovering::EndProductType>(0);
        Attributes::CurrentPositionLiftPercent100ths::TypeInfo::DecodableType currentPositionLiftPercent100ths;
        Attributes::CurrentPositionTiltPercent100ths::TypeInfo::DecodableType currentPositionTiltPercent100ths;
        Attributes::InstalledOpenLimitLift::TypeInfo::DecodableType installedOpenLimitLift     = static_cast<uint16_t>(0);
        Attributes::InstalledClosedLimitLift::TypeInfo::DecodableType installedClosedLimitLift = static_cast<uint16_t>(0);
        Attributes::InstalledOpenLimitTilt::TypeInfo::DecodableType installedOpenLimitTilt     = static_cast<uint16_t>(0);
        Attributes::InstalledClosedLimitTilt::TypeInfo::DecodableType installedClosedLimitTilt = static_cast<uint16_t>(0);
        Attributes::Mode::TypeInfo::DecodableType mode = static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::Mode>>(0);
        Attributes::SafetyStatus::TypeInfo::DecodableType safetyStatus =
            static_cast<chip::BitMask<chip::app::Clusters::WindowCovering::SafetyStatus>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WindowCovering
namespace ClosureControl {
namespace Structs {
namespace OverallStateStruct {
enum class Fields : uint8_t
{
    kPositioning = 0,
    kLatching    = 1,
    kSpeed       = 2,
    kExtraInfo   = 3,
};

struct Type
{
public:
    Optional<PositioningEnum> positioning;
    Optional<LatchingEnum> latching;
    Optional<Globals::ThreeLevelAutoEnum> speed;
    Optional<uint32_t> extraInfo;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OverallStateStruct
namespace OverallTargetStruct {
enum class Fields : uint8_t
{
    kTagPosition = 0,
    kTagLatch    = 1,
    kSpeed       = 2,
};

struct Type
{
public:
    Optional<TagPositionEnum> tagPosition;
    Optional<TagLatchEnum> tagLatch;
    Optional<Globals::ThreeLevelAutoEnum> speed;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OverallTargetStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace MoveTo {
struct Type;
struct DecodableType;
} // namespace MoveTo

namespace Calibrate {
struct Type;
struct DecodableType;
} // namespace Calibrate

namespace ConfigureFallback {
struct Type;
struct DecodableType;
} // namespace ConfigureFallback

namespace CancelFallback {
struct Type;
struct DecodableType;
} // namespace CancelFallback

} // namespace Commands

namespace Commands {
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace MoveTo {
enum class Fields : uint8_t
{
    kTag   = 0,
    kLatch = 1,
    kSpeed = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveTo::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    Optional<TagPositionEnum> tag;
    Optional<TagLatchEnum> latch;
    Optional<Globals::ThreeLevelAutoEnum> speed;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveTo::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    Optional<TagPositionEnum> tag;
    Optional<TagLatchEnum> latch;
    Optional<Globals::ThreeLevelAutoEnum> speed;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveTo
namespace Calibrate {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Calibrate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Calibrate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Calibrate
namespace ConfigureFallback {
enum class Fields : uint8_t
{
    kRestingProcedure = 0,
    kTriggerCondition = 1,
    kTriggerPosition  = 2,
    kWaitingDelay     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConfigureFallback::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    Optional<RestingProcedureEnum> restingProcedure;
    Optional<TriggerConditionEnum> triggerCondition;
    Optional<TriggerPositionEnum> triggerPosition;
    Optional<uint32_t> waitingDelay;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConfigureFallback::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    Optional<RestingProcedureEnum> restingProcedure;
    Optional<TriggerConditionEnum> triggerCondition;
    Optional<TriggerPositionEnum> triggerPosition;
    Optional<uint32_t> waitingDelay;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConfigureFallback
namespace CancelFallback {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelFallback::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelFallback::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelFallback
} // namespace Commands

namespace Attributes {

namespace CountdownTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CountdownTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CountdownTime
namespace MainState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ClosureControl::MainStateEnum;
    using DecodableType    = chip::app::Clusters::ClosureControl::MainStateEnum;
    using DecodableArgType = chip::app::Clusters::ClosureControl::MainStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainState
namespace CurrentErrorList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::ClosureControl::ClosureErrorEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::ClosureControl::ClosureErrorEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::ClosureControl::ClosureErrorEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentErrorList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentErrorList
namespace OverallState {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::ClosureControl::Structs::OverallStateStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::ClosureControl::Structs::OverallStateStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::ClosureControl::Structs::OverallStateStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverallState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverallState
namespace OverallTarget {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::ClosureControl::Structs::OverallTargetStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::ClosureControl::Structs::OverallTargetStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::ClosureControl::Structs::OverallTargetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverallTarget::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverallTarget
namespace RestingProcedure {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ClosureControl::RestingProcedureEnum;
    using DecodableType    = chip::app::Clusters::ClosureControl::RestingProcedureEnum;
    using DecodableArgType = chip::app::Clusters::ClosureControl::RestingProcedureEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RestingProcedure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RestingProcedure
namespace TriggerCondition {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ClosureControl::TriggerConditionEnum;
    using DecodableType    = chip::app::Clusters::ClosureControl::TriggerConditionEnum;
    using DecodableArgType = chip::app::Clusters::ClosureControl::TriggerConditionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TriggerCondition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TriggerCondition
namespace TriggerPosition {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ClosureControl::TriggerPositionEnum;
    using DecodableType    = chip::app::Clusters::ClosureControl::TriggerPositionEnum;
    using DecodableArgType = chip::app::Clusters::ClosureControl::TriggerPositionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TriggerPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TriggerPosition
namespace WaitingDelay {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WaitingDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WaitingDelay
namespace KickoffTimer {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KickoffTimer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace KickoffTimer
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ClosureControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CountdownTime::TypeInfo::DecodableType countdownTime;
        Attributes::MainState::TypeInfo::DecodableType mainState =
            static_cast<chip::app::Clusters::ClosureControl::MainStateEnum>(0);
        Attributes::CurrentErrorList::TypeInfo::DecodableType currentErrorList;
        Attributes::OverallState::TypeInfo::DecodableType overallState;
        Attributes::OverallTarget::TypeInfo::DecodableType overallTarget;
        Attributes::RestingProcedure::TypeInfo::DecodableType restingProcedure =
            static_cast<chip::app::Clusters::ClosureControl::RestingProcedureEnum>(0);
        Attributes::TriggerCondition::TypeInfo::DecodableType triggerCondition =
            static_cast<chip::app::Clusters::ClosureControl::TriggerConditionEnum>(0);
        Attributes::TriggerPosition::TypeInfo::DecodableType triggerPosition =
            static_cast<chip::app::Clusters::ClosureControl::TriggerPositionEnum>(0);
        Attributes::WaitingDelay::TypeInfo::DecodableType waitingDelay = static_cast<uint32_t>(0);
        Attributes::KickoffTimer::TypeInfo::DecodableType kickoffTimer = static_cast<uint32_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ClosureControl
namespace ServiceArea {
namespace Structs {
namespace LandmarkInfoStruct {
enum class Fields : uint8_t
{
    kLandmarkTag         = 0,
    kRelativePositionTag = 1,
};

struct Type
{
public:
    Globals::LandmarkTag landmarkTag = static_cast<Globals::LandmarkTag>(0);
    DataModel::Nullable<Globals::RelativePositionTag> relativePositionTag;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LandmarkInfoStruct
namespace AreaInfoStruct {
enum class Fields : uint8_t
{
    kLocationInfo = 0,
    kLandmarkInfo = 1,
};

struct Type
{
public:
    DataModel::Nullable<Globals::Structs::LocationDescriptorStruct::Type> locationInfo;
    DataModel::Nullable<Structs::LandmarkInfoStruct::Type> landmarkInfo;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AreaInfoStruct
namespace AreaStruct {
enum class Fields : uint8_t
{
    kAreaID   = 0,
    kMapID    = 1,
    kAreaInfo = 2,
};

struct Type
{
public:
    uint32_t areaID = static_cast<uint32_t>(0);
    DataModel::Nullable<uint32_t> mapID;
    Structs::AreaInfoStruct::Type areaInfo;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AreaStruct
namespace MapStruct {
enum class Fields : uint8_t
{
    kMapID = 0,
    kName  = 1,
};

struct Type
{
public:
    uint32_t mapID = static_cast<uint32_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MapStruct
namespace ProgressStruct {
enum class Fields : uint8_t
{
    kAreaID               = 0,
    kStatus               = 1,
    kTotalOperationalTime = 2,
    kEstimatedTime        = 3,
};

struct Type
{
public:
    uint32_t areaID              = static_cast<uint32_t>(0);
    OperationalStatusEnum status = static_cast<OperationalStatusEnum>(0);
    Optional<DataModel::Nullable<uint32_t>> totalOperationalTime;
    Optional<DataModel::Nullable<uint32_t>> estimatedTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProgressStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectAreas {
struct Type;
struct DecodableType;
} // namespace SelectAreas

namespace SelectAreasResponse {
struct Type;
struct DecodableType;
} // namespace SelectAreasResponse

namespace SkipArea {
struct Type;
struct DecodableType;
} // namespace SkipArea

namespace SkipAreaResponse {
struct Type;
struct DecodableType;
} // namespace SkipAreaResponse

} // namespace Commands

namespace Commands {
namespace SelectAreas {
enum class Fields : uint8_t
{
    kNewAreas = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectAreas::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    DataModel::List<const uint32_t> newAreas;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ServiceArea::Commands::SelectAreasResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectAreas::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    DataModel::DecodableList<uint32_t> newAreas;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectAreas
namespace SelectAreasResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectAreasResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    SelectAreasStatus status = static_cast<SelectAreasStatus>(0);
    chip::CharSpan statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectAreasResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    SelectAreasStatus status = static_cast<SelectAreasStatus>(0);
    chip::CharSpan statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectAreasResponse
namespace SkipArea {
enum class Fields : uint8_t
{
    kSkippedArea = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipArea::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    uint32_t skippedArea = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ServiceArea::Commands::SkipAreaResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipArea::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    uint32_t skippedArea = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipArea
namespace SkipAreaResponse {
enum class Fields : uint8_t
{
    kStatus     = 0,
    kStatusText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipAreaResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    SkipAreaStatus status = static_cast<SkipAreaStatus>(0);
    chip::CharSpan statusText;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipAreaResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

    SkipAreaStatus status = static_cast<SkipAreaStatus>(0);
    chip::CharSpan statusText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipAreaResponse
} // namespace Commands

namespace Attributes {

namespace SupportedAreas {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::ServiceArea::Structs::AreaStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::ServiceArea::Structs::AreaStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ServiceArea::Structs::AreaStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedAreas::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedAreas
namespace SupportedMaps {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::ServiceArea::Structs::MapStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::ServiceArea::Structs::MapStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ServiceArea::Structs::MapStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedMaps::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedMaps
namespace SelectedAreas {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint32_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedAreas::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedAreas
namespace CurrentArea {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentArea::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentArea
namespace EstimatedEndTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EstimatedEndTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EstimatedEndTime
namespace Progress {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ServiceArea::Structs::ProgressStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ServiceArea::Structs::ProgressStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ServiceArea::Structs::ProgressStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Progress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Progress
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ServiceArea::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedAreas::TypeInfo::DecodableType supportedAreas;
        Attributes::SupportedMaps::TypeInfo::DecodableType supportedMaps;
        Attributes::SelectedAreas::TypeInfo::DecodableType selectedAreas;
        Attributes::CurrentArea::TypeInfo::DecodableType currentArea;
        Attributes::EstimatedEndTime::TypeInfo::DecodableType estimatedEndTime;
        Attributes::Progress::TypeInfo::DecodableType progress;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ServiceArea
namespace PumpConfigurationAndControl {

namespace Attributes {

namespace MaxPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPressure
namespace MaxSpeed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxSpeed
namespace MaxFlow {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxFlow
namespace MinConstPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstPressure
namespace MaxConstPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstPressure
namespace MinCompPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCompPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinCompPressure
namespace MaxCompPressure {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCompPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCompPressure
namespace MinConstSpeed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstSpeed
namespace MaxConstSpeed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstSpeed
namespace MinConstFlow {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstFlow
namespace MaxConstFlow {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstFlow
namespace MinConstTemp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstTemp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstTemp
namespace MaxConstTemp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstTemp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstTemp
namespace PumpStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PumpStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PumpStatus
namespace EffectiveOperationMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveOperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EffectiveOperationMode
namespace EffectiveControlMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveControlMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EffectiveControlMode
namespace Capacity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Capacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Capacity
namespace Speed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Speed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Speed
namespace LifetimeRunningHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeRunningHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LifetimeRunningHours
namespace Power {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Power::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Power
namespace LifetimeEnergyConsumed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeEnergyConsumed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LifetimeEnergyConsumed
namespace OperationMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationMode
namespace ControlMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableType    = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;
    using DecodableArgType = chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ControlMode
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxPressure::TypeInfo::DecodableType maxPressure;
        Attributes::MaxSpeed::TypeInfo::DecodableType maxSpeed;
        Attributes::MaxFlow::TypeInfo::DecodableType maxFlow;
        Attributes::MinConstPressure::TypeInfo::DecodableType minConstPressure;
        Attributes::MaxConstPressure::TypeInfo::DecodableType maxConstPressure;
        Attributes::MinCompPressure::TypeInfo::DecodableType minCompPressure;
        Attributes::MaxCompPressure::TypeInfo::DecodableType maxCompPressure;
        Attributes::MinConstSpeed::TypeInfo::DecodableType minConstSpeed;
        Attributes::MaxConstSpeed::TypeInfo::DecodableType maxConstSpeed;
        Attributes::MinConstFlow::TypeInfo::DecodableType minConstFlow;
        Attributes::MaxConstFlow::TypeInfo::DecodableType maxConstFlow;
        Attributes::MinConstTemp::TypeInfo::DecodableType minConstTemp;
        Attributes::MaxConstTemp::TypeInfo::DecodableType maxConstTemp;
        Attributes::PumpStatus::TypeInfo::DecodableType pumpStatus =
            static_cast<chip::BitMask<chip::app::Clusters::PumpConfigurationAndControl::PumpStatusBitmap>>(0);
        Attributes::EffectiveOperationMode::TypeInfo::DecodableType effectiveOperationMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum>(0);
        Attributes::EffectiveControlMode::TypeInfo::DecodableType effectiveControlMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum>(0);
        Attributes::Capacity::TypeInfo::DecodableType capacity;
        Attributes::Speed::TypeInfo::DecodableType speed;
        Attributes::LifetimeRunningHours::TypeInfo::DecodableType lifetimeRunningHours;
        Attributes::Power::TypeInfo::DecodableType power;
        Attributes::LifetimeEnergyConsumed::TypeInfo::DecodableType lifetimeEnergyConsumed;
        Attributes::OperationMode::TypeInfo::DecodableType operationMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::OperationModeEnum>(0);
        Attributes::ControlMode::TypeInfo::DecodableType controlMode =
            static_cast<chip::app::Clusters::PumpConfigurationAndControl::ControlModeEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace SupplyVoltageLow {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SupplyVoltageLow
namespace SupplyVoltageHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SupplyVoltageHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SupplyVoltageHigh
namespace PowerMissingPhase {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerMissingPhase::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PowerMissingPhase::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerMissingPhase
namespace SystemPressureLow {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureLow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SystemPressureLow
namespace SystemPressureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SystemPressureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SystemPressureHigh
namespace DryRunning {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DryRunning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::DryRunning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DryRunning
namespace MotorTemperatureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MotorTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::MotorTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MotorTemperatureHigh
namespace PumpMotorFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpMotorFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpMotorFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PumpMotorFatalFailure
namespace ElectronicTemperatureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicTemperatureHigh::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicTemperatureHigh
namespace PumpBlocked {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpBlocked::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PumpBlocked::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PumpBlocked
namespace SensorFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::SensorFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SensorFailure
namespace ElectronicNonFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicNonFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicNonFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicNonFatalFailure
namespace ElectronicFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ElectronicFatalFailure::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicFatalFailure
namespace GeneralFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::GeneralFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::GeneralFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace GeneralFault
namespace Leakage {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leakage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::Leakage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leakage
namespace AirDetection {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AirDetection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::AirDetection::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AirDetection
namespace TurbineOperation {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TurbineOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TurbineOperation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TurbineOperation
} // namespace Events
} // namespace PumpConfigurationAndControl
namespace Thermostat {
namespace Structs {
namespace ScheduleTransitionStruct {
enum class Fields : uint8_t
{
    kDayOfWeek       = 0,
    kTransitionTime  = 1,
    kPresetHandle    = 2,
    kSystemMode      = 3,
    kCoolingSetpoint = 4,
    kHeatingSetpoint = 5,
};

struct Type
{
public:
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeek = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    uint16_t transitionTime                          = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> presetHandle;
    Optional<SystemModeEnum> systemMode;
    Optional<int16_t> coolingSetpoint;
    Optional<int16_t> heatingSetpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ScheduleTransitionStruct
namespace ScheduleStruct {
enum class Fields : uint8_t
{
    kScheduleHandle = 0,
    kSystemMode     = 1,
    kName           = 2,
    kPresetHandle   = 3,
    kTransitions    = 4,
    kBuiltIn        = 5,
};

struct Type
{
public:
    DataModel::Nullable<chip::ByteSpan> scheduleHandle;
    SystemModeEnum systemMode = static_cast<SystemModeEnum>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> presetHandle;
    DataModel::List<const Structs::ScheduleTransitionStruct::Type> transitions;
    DataModel::Nullable<bool> builtIn;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<chip::ByteSpan> scheduleHandle;
    SystemModeEnum systemMode = static_cast<SystemModeEnum>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::ByteSpan> presetHandle;
    DataModel::DecodableList<Structs::ScheduleTransitionStruct::DecodableType> transitions;
    DataModel::Nullable<bool> builtIn;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ScheduleStruct
namespace PresetStruct {
enum class Fields : uint8_t
{
    kPresetHandle    = 0,
    kPresetScenario  = 1,
    kName            = 2,
    kCoolingSetpoint = 3,
    kHeatingSetpoint = 4,
    kBuiltIn         = 5,
};

struct Type
{
public:
    DataModel::Nullable<chip::ByteSpan> presetHandle;
    PresetScenarioEnum presetScenario = static_cast<PresetScenarioEnum>(0);
    Optional<DataModel::Nullable<chip::CharSpan>> name;
    Optional<int16_t> coolingSetpoint;
    Optional<int16_t> heatingSetpoint;
    DataModel::Nullable<bool> builtIn;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PresetStruct
namespace PresetTypeStruct {
enum class Fields : uint8_t
{
    kPresetScenario     = 0,
    kNumberOfPresets    = 1,
    kPresetTypeFeatures = 2,
};

struct Type
{
public:
    PresetScenarioEnum presetScenario                          = static_cast<PresetScenarioEnum>(0);
    uint8_t numberOfPresets                                    = static_cast<uint8_t>(0);
    chip::BitMask<PresetTypeFeaturesBitmap> presetTypeFeatures = static_cast<chip::BitMask<PresetTypeFeaturesBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PresetTypeStruct
namespace ScheduleTypeStruct {
enum class Fields : uint8_t
{
    kSystemMode           = 0,
    kNumberOfSchedules    = 1,
    kScheduleTypeFeatures = 2,
};

struct Type
{
public:
    SystemModeEnum systemMode                                      = static_cast<SystemModeEnum>(0);
    uint8_t numberOfSchedules                                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleTypeFeaturesBitmap> scheduleTypeFeatures = static_cast<chip::BitMask<ScheduleTypeFeaturesBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ScheduleTypeStruct
namespace WeeklyScheduleTransitionStruct {
enum class Fields : uint8_t
{
    kTransitionTime = 0,
    kHeatSetpoint   = 1,
    kCoolSetpoint   = 2,
};

struct Type
{
public:
    uint16_t transitionTime = static_cast<uint16_t>(0);
    DataModel::Nullable<int16_t> heatSetpoint;
    DataModel::Nullable<int16_t> coolSetpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace WeeklyScheduleTransitionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetpointRaiseLower {
struct Type;
struct DecodableType;
} // namespace SetpointRaiseLower

namespace GetWeeklyScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeeklyScheduleResponse

namespace SetWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeeklySchedule

namespace GetWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeeklySchedule

namespace ClearWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeeklySchedule

namespace SetActiveScheduleRequest {
struct Type;
struct DecodableType;
} // namespace SetActiveScheduleRequest

namespace SetActivePresetRequest {
struct Type;
struct DecodableType;
} // namespace SetActivePresetRequest

namespace AtomicResponse {
struct Type;
struct DecodableType;
} // namespace AtomicResponse

namespace AtomicRequest {
struct Type;
struct DecodableType;
} // namespace AtomicRequest

} // namespace Commands

namespace Commands {
namespace SetpointRaiseLower {
enum class Fields : uint8_t
{
    kMode   = 0,
    kAmount = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    SetpointRaiseLowerModeEnum mode = static_cast<SetpointRaiseLowerModeEnum>(0);
    int8_t amount                   = static_cast<int8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    SetpointRaiseLowerModeEnum mode = static_cast<SetpointRaiseLowerModeEnum>(0);
    int8_t amount                   = static_cast<int8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetpointRaiseLower
namespace GetWeeklyScheduleResponse {
enum class Fields : uint8_t
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kTransitions                    = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklyScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::List<const Structs::WeeklyScheduleTransitionStruct::Type> transitions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklyScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::DecodableList<Structs::WeeklyScheduleTransitionStruct::DecodableType> transitions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklyScheduleResponse
namespace SetWeeklySchedule {
enum class Fields : uint8_t
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kTransitions                    = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::List<const Structs::WeeklyScheduleTransitionStruct::Type> transitions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence                      = static_cast<uint8_t>(0);
    chip::BitMask<ScheduleDayOfWeekBitmap> dayOfWeekForSequence = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeForSequence           = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    DataModel::DecodableList<Structs::WeeklyScheduleTransitionStruct::DecodableType> transitions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeeklySchedule
namespace GetWeeklySchedule {
enum class Fields : uint8_t
{
    kDaysToReturn = 0,
    kModeToReturn = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitMask<ScheduleDayOfWeekBitmap> daysToReturn = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeToReturn      = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Thermostat::Commands::GetWeeklyScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitMask<ScheduleDayOfWeekBitmap> daysToReturn = static_cast<chip::BitMask<ScheduleDayOfWeekBitmap>>(0);
    chip::BitMask<ScheduleModeBitmap> modeToReturn      = static_cast<chip::BitMask<ScheduleModeBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklySchedule
namespace ClearWeeklySchedule {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeeklySchedule
namespace SetActiveScheduleRequest {
enum class Fields : uint8_t
{
    kScheduleHandle = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetActiveScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::ByteSpan scheduleHandle;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetActiveScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::ByteSpan scheduleHandle;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetActiveScheduleRequest
namespace SetActivePresetRequest {
enum class Fields : uint8_t
{
    kPresetHandle = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetActivePresetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    DataModel::Nullable<chip::ByteSpan> presetHandle;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetActivePresetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    DataModel::Nullable<chip::ByteSpan> presetHandle;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetActivePresetRequest
namespace AtomicResponse {
enum class Fields : uint8_t
{
    kStatusCode      = 0,
    kAttributeStatus = 1,
    kTimeout         = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AtomicResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t statusCode = static_cast<uint8_t>(0);
    DataModel::List<const Globals::Structs::AtomicAttributeStatusStruct::Type> attributeStatus;
    Optional<uint16_t> timeout;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AtomicResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t statusCode = static_cast<uint8_t>(0);
    DataModel::DecodableList<Globals::Structs::AtomicAttributeStatusStruct::DecodableType> attributeStatus;
    Optional<uint16_t> timeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AtomicResponse
namespace AtomicRequest {
enum class Fields : uint8_t
{
    kRequestType       = 0,
    kAttributeRequests = 1,
    kTimeout           = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AtomicRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    Globals::AtomicRequestTypeEnum requestType = static_cast<Globals::AtomicRequestTypeEnum>(0);
    DataModel::List<const chip::AttributeId> attributeRequests;
    Optional<uint16_t> timeout;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Thermostat::Commands::AtomicResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AtomicRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    Globals::AtomicRequestTypeEnum requestType = static_cast<Globals::AtomicRequestTypeEnum>(0);
    DataModel::DecodableList<chip::AttributeId> attributeRequests;
    Optional<uint16_t> timeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AtomicRequest
} // namespace Commands

namespace Attributes {

namespace LocalTemperature {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTemperature
namespace OutdoorTemperature {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutdoorTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutdoorTemperature
namespace Occupancy {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::OccupancyBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::OccupancyBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::OccupancyBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Occupancy
namespace AbsMinHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinHeatSetpointLimit
namespace AbsMaxHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxHeatSetpointLimit
namespace AbsMinCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinCoolSetpointLimit
namespace AbsMaxCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxCoolSetpointLimit
namespace PICoolingDemand {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PICoolingDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PICoolingDemand
namespace PIHeatingDemand {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIHeatingDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIHeatingDemand
namespace HVACSystemTypeConfiguration {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::HVACSystemTypeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::HVACSystemTypeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::HVACSystemTypeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HVACSystemTypeConfiguration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HVACSystemTypeConfiguration
namespace LocalTemperatureCalibration {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperatureCalibration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTemperatureCalibration
namespace OccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedCoolingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedCoolingSetpoint
namespace OccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedHeatingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedHeatingSetpoint
namespace UnoccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedCoolingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedCoolingSetpoint
namespace UnoccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedHeatingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedHeatingSetpoint
namespace MinHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinHeatSetpointLimit
namespace MaxHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxHeatSetpointLimit
namespace MinCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinCoolSetpointLimit
namespace MaxCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCoolSetpointLimit
namespace MinSetpointDeadBand {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinSetpointDeadBand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinSetpointDeadBand
namespace RemoteSensing {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemoteSensing::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemoteSensing
namespace ControlSequenceOfOperation {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlSequenceOfOperation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ControlSequenceOfOperation
namespace SystemMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::SystemModeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::SystemModeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::SystemModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SystemMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SystemMode
namespace ThermostatRunningMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ThermostatRunningModeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ThermostatRunningModeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ThermostatRunningModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatRunningMode
namespace StartOfWeek {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::StartOfWeekEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::StartOfWeekEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::StartOfWeekEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartOfWeek::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartOfWeek
namespace NumberOfWeeklyTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeeklyTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfWeeklyTransitions
namespace NumberOfDailyTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfDailyTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfDailyTransitions
namespace TemperatureSetpointHold {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHold
namespace TemperatureSetpointHoldDuration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHoldDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHoldDuration
namespace ThermostatProgrammingOperationMode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatProgrammingOperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatProgrammingOperationMode
namespace ThermostatRunningState {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatRunningState
namespace SetpointChangeSource {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::SetpointChangeSourceEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::SetpointChangeSourceEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::SetpointChangeSourceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeSource
namespace SetpointChangeAmount {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeAmount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeAmount
namespace SetpointChangeSourceTimestamp {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSourceTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeSourceTimestamp
namespace OccupiedSetback {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedSetback::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedSetback
namespace OccupiedSetbackMin {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedSetbackMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedSetbackMin
namespace OccupiedSetbackMax {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedSetbackMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedSetbackMax
namespace UnoccupiedSetback {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedSetback::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedSetback
namespace UnoccupiedSetbackMin {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedSetbackMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedSetbackMin
namespace UnoccupiedSetbackMax {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedSetbackMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedSetbackMax
namespace EmergencyHeatDelta {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EmergencyHeatDelta::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EmergencyHeatDelta
namespace ACType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACTypeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACTypeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACType
namespace ACCapacity {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCapacity
namespace ACRefrigerantType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACRefrigerantType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACRefrigerantType
namespace ACCompressorType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACCompressorTypeEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACCompressorTypeEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACCompressorTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCompressorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCompressorType
namespace ACErrorCode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACErrorCode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACErrorCode
namespace ACLouverPosition {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACLouverPositionEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACLouverPositionEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACLouverPositionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACLouverPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACLouverPosition
namespace ACCoilTemperature {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCoilTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCoilTemperature
namespace ACCapacityformat {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Thermostat::ACCapacityFormatEnum;
    using DecodableType    = chip::app::Clusters::Thermostat::ACCapacityFormatEnum;
    using DecodableArgType = chip::app::Clusters::Thermostat::ACCapacityFormatEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ACCapacityformat::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ACCapacityformat
namespace PresetTypes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::PresetTypeStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetTypeStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetTypeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PresetTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PresetTypes
namespace ScheduleTypes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::ScheduleTypeStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleTypeStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleTypeStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleTypes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduleTypes
namespace NumberOfPresets {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPresets::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPresets
namespace NumberOfSchedules {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfSchedules::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfSchedules
namespace NumberOfScheduleTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfScheduleTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfScheduleTransitions
namespace NumberOfScheduleTransitionPerDay {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfScheduleTransitionPerDay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfScheduleTransitionPerDay
namespace ActivePresetHandle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePresetHandle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ActivePresetHandle
namespace ActiveScheduleHandle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveScheduleHandle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace ActiveScheduleHandle
namespace Presets {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::PresetStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::PresetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Presets::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Presets
namespace Schedules {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Thermostat::Structs::ScheduleStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Thermostat::Structs::ScheduleStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Schedules::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Schedules
namespace SetpointHoldExpiryTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointHoldExpiryTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointHoldExpiryTimestamp
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LocalTemperature::TypeInfo::DecodableType localTemperature;
        Attributes::OutdoorTemperature::TypeInfo::DecodableType outdoorTemperature;
        Attributes::Occupancy::TypeInfo::DecodableType occupancy =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::OccupancyBitmap>>(0);
        Attributes::AbsMinHeatSetpointLimit::TypeInfo::DecodableType absMinHeatSetpointLimit = static_cast<int16_t>(0);
        Attributes::AbsMaxHeatSetpointLimit::TypeInfo::DecodableType absMaxHeatSetpointLimit = static_cast<int16_t>(0);
        Attributes::AbsMinCoolSetpointLimit::TypeInfo::DecodableType absMinCoolSetpointLimit = static_cast<int16_t>(0);
        Attributes::AbsMaxCoolSetpointLimit::TypeInfo::DecodableType absMaxCoolSetpointLimit = static_cast<int16_t>(0);
        Attributes::PICoolingDemand::TypeInfo::DecodableType PICoolingDemand                 = static_cast<uint8_t>(0);
        Attributes::PIHeatingDemand::TypeInfo::DecodableType PIHeatingDemand                 = static_cast<uint8_t>(0);
        Attributes::HVACSystemTypeConfiguration::TypeInfo::DecodableType HVACSystemTypeConfiguration =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::HVACSystemTypeBitmap>>(0);
        Attributes::LocalTemperatureCalibration::TypeInfo::DecodableType localTemperatureCalibration = static_cast<int8_t>(0);
        Attributes::OccupiedCoolingSetpoint::TypeInfo::DecodableType occupiedCoolingSetpoint         = static_cast<int16_t>(0);
        Attributes::OccupiedHeatingSetpoint::TypeInfo::DecodableType occupiedHeatingSetpoint         = static_cast<int16_t>(0);
        Attributes::UnoccupiedCoolingSetpoint::TypeInfo::DecodableType unoccupiedCoolingSetpoint     = static_cast<int16_t>(0);
        Attributes::UnoccupiedHeatingSetpoint::TypeInfo::DecodableType unoccupiedHeatingSetpoint     = static_cast<int16_t>(0);
        Attributes::MinHeatSetpointLimit::TypeInfo::DecodableType minHeatSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MaxHeatSetpointLimit::TypeInfo::DecodableType maxHeatSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MinCoolSetpointLimit::TypeInfo::DecodableType minCoolSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MaxCoolSetpointLimit::TypeInfo::DecodableType maxCoolSetpointLimit               = static_cast<int16_t>(0);
        Attributes::MinSetpointDeadBand::TypeInfo::DecodableType minSetpointDeadBand                 = static_cast<int8_t>(0);
        Attributes::RemoteSensing::TypeInfo::DecodableType remoteSensing =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::RemoteSensingBitmap>>(0);
        Attributes::ControlSequenceOfOperation::TypeInfo::DecodableType controlSequenceOfOperation =
            static_cast<chip::app::Clusters::Thermostat::ControlSequenceOfOperationEnum>(0);
        Attributes::SystemMode::TypeInfo::DecodableType systemMode =
            static_cast<chip::app::Clusters::Thermostat::SystemModeEnum>(0);
        Attributes::ThermostatRunningMode::TypeInfo::DecodableType thermostatRunningMode =
            static_cast<chip::app::Clusters::Thermostat::ThermostatRunningModeEnum>(0);
        Attributes::StartOfWeek::TypeInfo::DecodableType startOfWeek =
            static_cast<chip::app::Clusters::Thermostat::StartOfWeekEnum>(0);
        Attributes::NumberOfWeeklyTransitions::TypeInfo::DecodableType numberOfWeeklyTransitions = static_cast<uint8_t>(0);
        Attributes::NumberOfDailyTransitions::TypeInfo::DecodableType numberOfDailyTransitions   = static_cast<uint8_t>(0);
        Attributes::TemperatureSetpointHold::TypeInfo::DecodableType temperatureSetpointHold =
            static_cast<chip::app::Clusters::Thermostat::TemperatureSetpointHoldEnum>(0);
        Attributes::TemperatureSetpointHoldDuration::TypeInfo::DecodableType temperatureSetpointHoldDuration;
        Attributes::ThermostatProgrammingOperationMode::TypeInfo::DecodableType thermostatProgrammingOperationMode =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::ProgrammingOperationModeBitmap>>(0);
        Attributes::ThermostatRunningState::TypeInfo::DecodableType thermostatRunningState =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::RelayStateBitmap>>(0);
        Attributes::SetpointChangeSource::TypeInfo::DecodableType setpointChangeSource =
            static_cast<chip::app::Clusters::Thermostat::SetpointChangeSourceEnum>(0);
        Attributes::SetpointChangeAmount::TypeInfo::DecodableType setpointChangeAmount;
        Attributes::SetpointChangeSourceTimestamp::TypeInfo::DecodableType setpointChangeSourceTimestamp = static_cast<uint32_t>(0);
        Attributes::OccupiedSetback::TypeInfo::DecodableType occupiedSetback;
        Attributes::OccupiedSetbackMin::TypeInfo::DecodableType occupiedSetbackMin;
        Attributes::OccupiedSetbackMax::TypeInfo::DecodableType occupiedSetbackMax;
        Attributes::UnoccupiedSetback::TypeInfo::DecodableType unoccupiedSetback;
        Attributes::UnoccupiedSetbackMin::TypeInfo::DecodableType unoccupiedSetbackMin;
        Attributes::UnoccupiedSetbackMax::TypeInfo::DecodableType unoccupiedSetbackMax;
        Attributes::EmergencyHeatDelta::TypeInfo::DecodableType emergencyHeatDelta = static_cast<uint8_t>(0);
        Attributes::ACType::TypeInfo::DecodableType ACType         = static_cast<chip::app::Clusters::Thermostat::ACTypeEnum>(0);
        Attributes::ACCapacity::TypeInfo::DecodableType ACCapacity = static_cast<uint16_t>(0);
        Attributes::ACRefrigerantType::TypeInfo::DecodableType ACRefrigerantType =
            static_cast<chip::app::Clusters::Thermostat::ACRefrigerantTypeEnum>(0);
        Attributes::ACCompressorType::TypeInfo::DecodableType ACCompressorType =
            static_cast<chip::app::Clusters::Thermostat::ACCompressorTypeEnum>(0);
        Attributes::ACErrorCode::TypeInfo::DecodableType ACErrorCode =
            static_cast<chip::BitMask<chip::app::Clusters::Thermostat::ACErrorCodeBitmap>>(0);
        Attributes::ACLouverPosition::TypeInfo::DecodableType ACLouverPosition =
            static_cast<chip::app::Clusters::Thermostat::ACLouverPositionEnum>(0);
        Attributes::ACCoilTemperature::TypeInfo::DecodableType ACCoilTemperature;
        Attributes::ACCapacityformat::TypeInfo::DecodableType ACCapacityformat =
            static_cast<chip::app::Clusters::Thermostat::ACCapacityFormatEnum>(0);
        Attributes::PresetTypes::TypeInfo::DecodableType presetTypes;
        Attributes::ScheduleTypes::TypeInfo::DecodableType scheduleTypes;
        Attributes::NumberOfPresets::TypeInfo::DecodableType numberOfPresets                         = static_cast<uint8_t>(0);
        Attributes::NumberOfSchedules::TypeInfo::DecodableType numberOfSchedules                     = static_cast<uint8_t>(0);
        Attributes::NumberOfScheduleTransitions::TypeInfo::DecodableType numberOfScheduleTransitions = static_cast<uint8_t>(0);
        Attributes::NumberOfScheduleTransitionPerDay::TypeInfo::DecodableType numberOfScheduleTransitionPerDay;
        Attributes::ActivePresetHandle::TypeInfo::DecodableType activePresetHandle;
        Attributes::ActiveScheduleHandle::TypeInfo::DecodableType activeScheduleHandle;
        Attributes::Presets::TypeInfo::DecodableType presets;
        Attributes::Schedules::TypeInfo::DecodableType schedules;
        Attributes::SetpointHoldExpiryTimestamp::TypeInfo::DecodableType setpointHoldExpiryTimestamp;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Thermostat
namespace FanControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Step {
struct Type;
struct DecodableType;
} // namespace Step

} // namespace Commands

namespace Commands {
namespace Step {
enum class Fields : uint8_t
{
    kDirection = 0,
    kWrap      = 1,
    kLowestOff = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

    StepDirectionEnum direction = static_cast<StepDirectionEnum>(0);
    Optional<bool> wrap;
    Optional<bool> lowestOff;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

    StepDirectionEnum direction = static_cast<StepDirectionEnum>(0);
    Optional<bool> wrap;
    Optional<bool> lowestOff;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Step
} // namespace Commands

namespace Attributes {

namespace FanMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FanControl::FanModeEnum;
    using DecodableType    = chip::app::Clusters::FanControl::FanModeEnum;
    using DecodableArgType = chip::app::Clusters::FanControl::FanModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FanMode
namespace FanModeSequence {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FanControl::FanModeSequenceEnum;
    using DecodableType    = chip::app::Clusters::FanControl::FanModeSequenceEnum;
    using DecodableArgType = chip::app::Clusters::FanControl::FanModeSequenceEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanModeSequence::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FanModeSequence
namespace PercentSetting {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PercentSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PercentSetting
namespace PercentCurrent {
struct TypeInfo
{
    using Type             = chip::Percent;
    using DecodableType    = chip::Percent;
    using DecodableArgType = chip::Percent;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PercentCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PercentCurrent
namespace SpeedMax {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeedMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeedMax
namespace SpeedSetting {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeedSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeedSetting
namespace SpeedCurrent {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeedCurrent
namespace RockSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RockSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RockSupport
namespace RockSetting {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RockSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RockSetting
namespace WindSupport {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindSupport
namespace WindSetting {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindSetting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindSetting
namespace AirflowDirection {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FanControl::AirflowDirectionEnum;
    using DecodableType    = chip::app::Clusters::FanControl::AirflowDirectionEnum;
    using DecodableArgType = chip::app::Clusters::FanControl::AirflowDirectionEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AirflowDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AirflowDirection
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::FanMode::TypeInfo::DecodableType fanMode = static_cast<chip::app::Clusters::FanControl::FanModeEnum>(0);
        Attributes::FanModeSequence::TypeInfo::DecodableType fanModeSequence =
            static_cast<chip::app::Clusters::FanControl::FanModeSequenceEnum>(0);
        Attributes::PercentSetting::TypeInfo::DecodableType percentSetting;
        Attributes::PercentCurrent::TypeInfo::DecodableType percentCurrent = static_cast<chip::Percent>(0);
        Attributes::SpeedMax::TypeInfo::DecodableType speedMax             = static_cast<uint8_t>(0);
        Attributes::SpeedSetting::TypeInfo::DecodableType speedSetting;
        Attributes::SpeedCurrent::TypeInfo::DecodableType speedCurrent = static_cast<uint8_t>(0);
        Attributes::RockSupport::TypeInfo::DecodableType rockSupport =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>>(0);
        Attributes::RockSetting::TypeInfo::DecodableType rockSetting =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::RockBitmap>>(0);
        Attributes::WindSupport::TypeInfo::DecodableType windSupport =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>>(0);
        Attributes::WindSetting::TypeInfo::DecodableType windSetting =
            static_cast<chip::BitMask<chip::app::Clusters::FanControl::WindBitmap>>(0);
        Attributes::AirflowDirection::TypeInfo::DecodableType airflowDirection =
            static_cast<chip::app::Clusters::FanControl::AirflowDirectionEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FanControl
namespace ThermostatUserInterfaceConfiguration {

namespace Attributes {

namespace TemperatureDisplayMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum;
    using DecodableType    = chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum;
    using DecodableArgType = chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureDisplayMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureDisplayMode
namespace KeypadLockout {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum;
    using DecodableType    = chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum;
    using DecodableArgType = chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadLockout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace KeypadLockout
namespace ScheduleProgrammingVisibility {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum;
    using DecodableType    = chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum;
    using DecodableArgType = chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleProgrammingVisibility::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduleProgrammingVisibility
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureDisplayMode::TypeInfo::DecodableType temperatureDisplayMode =
            static_cast<chip::app::Clusters::ThermostatUserInterfaceConfiguration::TemperatureDisplayModeEnum>(0);
        Attributes::KeypadLockout::TypeInfo::DecodableType keypadLockout =
            static_cast<chip::app::Clusters::ThermostatUserInterfaceConfiguration::KeypadLockoutEnum>(0);
        Attributes::ScheduleProgrammingVisibility::TypeInfo::DecodableType scheduleProgrammingVisibility =
            static_cast<chip::app::Clusters::ThermostatUserInterfaceConfiguration::ScheduleProgrammingVisibilityEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ThermostatUserInterfaceConfiguration
namespace ColorControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToHue {
struct Type;
struct DecodableType;
} // namespace MoveToHue

namespace MoveHue {
struct Type;
struct DecodableType;
} // namespace MoveHue

namespace StepHue {
struct Type;
struct DecodableType;
} // namespace StepHue

namespace MoveToSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToSaturation

namespace MoveSaturation {
struct Type;
struct DecodableType;
} // namespace MoveSaturation

namespace StepSaturation {
struct Type;
struct DecodableType;
} // namespace StepSaturation

namespace MoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToHueAndSaturation

namespace MoveToColor {
struct Type;
struct DecodableType;
} // namespace MoveToColor

namespace MoveColor {
struct Type;
struct DecodableType;
} // namespace MoveColor

namespace StepColor {
struct Type;
struct DecodableType;
} // namespace StepColor

namespace MoveToColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveToColorTemperature

namespace EnhancedMoveToHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHue

namespace EnhancedMoveHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveHue

namespace EnhancedStepHue {
struct Type;
struct DecodableType;
} // namespace EnhancedStepHue

namespace EnhancedMoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHueAndSaturation

namespace ColorLoopSet {
struct Type;
struct DecodableType;
} // namespace ColorLoopSet

namespace StopMoveStep {
struct Type;
struct DecodableType;
} // namespace StopMoveStep

namespace MoveColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveColorTemperature

namespace StepColorTemperature {
struct Type;
struct DecodableType;
} // namespace StepColorTemperature

} // namespace Commands

namespace Commands {
namespace MoveToHue {
enum class Fields : uint8_t
{
    kHue             = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHue
namespace MoveHue {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveHue
namespace StepHue {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepHue
namespace MoveToSaturation {
enum class Fields : uint8_t
{
    kSaturation      = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToSaturation
namespace MoveSaturation {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint8_t rate                                 = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveSaturation
namespace StepSaturation {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint8_t stepSize                             = static_cast<uint8_t>(0);
    uint8_t transitionTime                       = static_cast<uint8_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepSaturation
namespace MoveToHueAndSaturation {
enum class Fields : uint8_t
{
    kHue             = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue                                  = static_cast<uint8_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHueAndSaturation
namespace MoveToColor {
enum class Fields : uint8_t
{
    kColorX          = 0,
    kColorY          = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX                              = static_cast<uint16_t>(0);
    uint16_t colorY                              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX                              = static_cast<uint16_t>(0);
    uint16_t colorY                              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColor
namespace MoveColor {
enum class Fields : uint8_t
{
    kRateX           = 0,
    kRateY           = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX                                = static_cast<int16_t>(0);
    int16_t rateY                                = static_cast<int16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX                                = static_cast<int16_t>(0);
    int16_t rateY                                = static_cast<int16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColor
namespace StepColor {
enum class Fields : uint8_t
{
    kStepX           = 0,
    kStepY           = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX                                = static_cast<int16_t>(0);
    int16_t stepY                                = static_cast<int16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX                                = static_cast<int16_t>(0);
    int16_t stepY                                = static_cast<int16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColor
namespace MoveToColorTemperature {
enum class Fields : uint8_t
{
    kColorTemperatureMireds = 0,
    kTransitionTime         = 1,
    kOptionsMask            = 2,
    kOptionsOverride        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperatureMireds              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperatureMireds              = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColorTemperature
namespace EnhancedMoveToHue {
enum class Fields : uint8_t
{
    kEnhancedHue     = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    DirectionEnum direction                      = static_cast<DirectionEnum>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHue
namespace EnhancedMoveHue {
enum class Fields : uint8_t
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveHue
namespace EnhancedStepHue {
enum class Fields : uint8_t
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedStepHue
namespace EnhancedMoveToHueAndSaturation {
enum class Fields : uint8_t
{
    kEnhancedHue     = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue                         = static_cast<uint16_t>(0);
    uint8_t saturation                           = static_cast<uint8_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHueAndSaturation
namespace ColorLoopSet {
enum class Fields : uint8_t
{
    kUpdateFlags     = 0,
    kAction          = 1,
    kDirection       = 2,
    kTime            = 3,
    kStartHue        = 4,
    kOptionsMask     = 5,
    kOptionsOverride = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<UpdateFlagsBitmap> updateFlags = static_cast<chip::BitMask<UpdateFlagsBitmap>>(0);
    ColorLoopActionEnum action                   = static_cast<ColorLoopActionEnum>(0);
    ColorLoopDirectionEnum direction             = static_cast<ColorLoopDirectionEnum>(0);
    uint16_t time                                = static_cast<uint16_t>(0);
    uint16_t startHue                            = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<UpdateFlagsBitmap> updateFlags = static_cast<chip::BitMask<UpdateFlagsBitmap>>(0);
    ColorLoopActionEnum action                   = static_cast<ColorLoopActionEnum>(0);
    ColorLoopDirectionEnum direction             = static_cast<ColorLoopDirectionEnum>(0);
    uint16_t time                                = static_cast<uint16_t>(0);
    uint16_t startHue                            = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ColorLoopSet
namespace StopMoveStep {
enum class Fields : uint8_t
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMoveStep
namespace MoveColorTemperature {
enum class Fields : uint8_t
{
    kMoveMode                      = 0,
    kRate                          = 1,
    kColorTemperatureMinimumMireds = 2,
    kColorTemperatureMaximumMireds = 3,
    kOptionsMask                   = 4,
    kOptionsOverride               = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    MoveModeEnum moveMode                        = static_cast<MoveModeEnum>(0);
    uint16_t rate                                = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColorTemperature
namespace StepColorTemperature {
enum class Fields : uint8_t
{
    kStepMode                      = 0,
    kStepSize                      = 1,
    kTransitionTime                = 2,
    kColorTemperatureMinimumMireds = 3,
    kColorTemperatureMaximumMireds = 4,
    kOptionsMask                   = 5,
    kOptionsOverride               = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    StepModeEnum stepMode                        = static_cast<StepModeEnum>(0);
    uint16_t stepSize                            = static_cast<uint16_t>(0);
    uint16_t transitionTime                      = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMinimumMireds       = static_cast<uint16_t>(0);
    uint16_t colorTemperatureMaximumMireds       = static_cast<uint16_t>(0);
    chip::BitMask<OptionsBitmap> optionsMask     = static_cast<chip::BitMask<OptionsBitmap>>(0);
    chip::BitMask<OptionsBitmap> optionsOverride = static_cast<chip::BitMask<OptionsBitmap>>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColorTemperature
} // namespace Commands

namespace Attributes {

namespace CurrentHue {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHue
namespace CurrentSaturation {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSaturation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSaturation
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace CurrentX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentX
namespace CurrentY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentY
namespace DriftCompensation {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ColorControl::DriftCompensationEnum;
    using DecodableType    = chip::app::Clusters::ColorControl::DriftCompensationEnum;
    using DecodableArgType = chip::app::Clusters::ColorControl::DriftCompensationEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DriftCompensation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DriftCompensation
namespace CompensationText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompensationText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 254; }
};
} // namespace CompensationText
namespace ColorTemperatureMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTemperatureMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTemperatureMireds
namespace ColorMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ColorControl::ColorModeEnum;
    using DecodableType    = chip::app::Clusters::ColorControl::ColorModeEnum;
    using DecodableArgType = chip::app::Clusters::ColorControl::ColorModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorMode
namespace Options {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::ColorControl::OptionsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::ColorControl::OptionsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::ColorControl::OptionsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Options::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Options
namespace NumberOfPrimaries {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPrimaries::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPrimaries
namespace Primary1X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1X
namespace Primary1Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1Y
namespace Primary1Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1Intensity
namespace Primary2X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2X
namespace Primary2Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2Y
namespace Primary2Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2Intensity
namespace Primary3X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3X
namespace Primary3Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3Y
namespace Primary3Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3Intensity
namespace Primary4X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4X
namespace Primary4Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4Y
namespace Primary4Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4Intensity
namespace Primary5X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5X
namespace Primary5Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5Y
namespace Primary5Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5Intensity
namespace Primary6X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6X
namespace Primary6Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6Y
namespace Primary6Intensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6Intensity
namespace WhitePointX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WhitePointX
namespace WhitePointY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WhitePointY
namespace ColorPointRX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRX
namespace ColorPointRY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRY
namespace ColorPointRIntensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRIntensity
namespace ColorPointGX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGX
namespace ColorPointGY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGY
namespace ColorPointGIntensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGIntensity
namespace ColorPointBX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBX
namespace ColorPointBY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBY
namespace ColorPointBIntensity {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBIntensity
namespace EnhancedCurrentHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedCurrentHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnhancedCurrentHue
namespace EnhancedColorMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ColorControl::EnhancedColorModeEnum;
    using DecodableType    = chip::app::Clusters::ColorControl::EnhancedColorModeEnum;
    using DecodableArgType = chip::app::Clusters::ColorControl::EnhancedColorModeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedColorMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnhancedColorMode
namespace ColorLoopActive {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopActive::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopActive
namespace ColorLoopDirection {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopDirection
namespace ColorLoopTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopTime
namespace ColorLoopStartEnhancedHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStartEnhancedHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopStartEnhancedHue
namespace ColorLoopStoredEnhancedHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStoredEnhancedHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopStoredEnhancedHue
namespace ColorCapabilities {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::ColorControl::ColorCapabilitiesBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::ColorControl::ColorCapabilitiesBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::ColorControl::ColorCapabilitiesBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorCapabilities
namespace ColorTempPhysicalMinMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMinMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTempPhysicalMinMireds
namespace ColorTempPhysicalMaxMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMaxMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTempPhysicalMaxMireds
namespace CoupleColorTempToLevelMinMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CoupleColorTempToLevelMinMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CoupleColorTempToLevelMinMireds
namespace StartUpColorTemperatureMireds {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpColorTemperatureMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpColorTemperatureMireds
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentHue::TypeInfo::DecodableType currentHue               = static_cast<uint8_t>(0);
        Attributes::CurrentSaturation::TypeInfo::DecodableType currentSaturation = static_cast<uint8_t>(0);
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime         = static_cast<uint16_t>(0);
        Attributes::CurrentX::TypeInfo::DecodableType currentX                   = static_cast<uint16_t>(0);
        Attributes::CurrentY::TypeInfo::DecodableType currentY                   = static_cast<uint16_t>(0);
        Attributes::DriftCompensation::TypeInfo::DecodableType driftCompensation =
            static_cast<chip::app::Clusters::ColorControl::DriftCompensationEnum>(0);
        Attributes::CompensationText::TypeInfo::DecodableType compensationText;
        Attributes::ColorTemperatureMireds::TypeInfo::DecodableType colorTemperatureMireds = static_cast<uint16_t>(0);
        Attributes::ColorMode::TypeInfo::DecodableType colorMode = static_cast<chip::app::Clusters::ColorControl::ColorModeEnum>(0);
        Attributes::Options::TypeInfo::DecodableType options =
            static_cast<chip::BitMask<chip::app::Clusters::ColorControl::OptionsBitmap>>(0);
        Attributes::NumberOfPrimaries::TypeInfo::DecodableType numberOfPrimaries;
        Attributes::Primary1X::TypeInfo::DecodableType primary1X = static_cast<uint16_t>(0);
        Attributes::Primary1Y::TypeInfo::DecodableType primary1Y = static_cast<uint16_t>(0);
        Attributes::Primary1Intensity::TypeInfo::DecodableType primary1Intensity;
        Attributes::Primary2X::TypeInfo::DecodableType primary2X = static_cast<uint16_t>(0);
        Attributes::Primary2Y::TypeInfo::DecodableType primary2Y = static_cast<uint16_t>(0);
        Attributes::Primary2Intensity::TypeInfo::DecodableType primary2Intensity;
        Attributes::Primary3X::TypeInfo::DecodableType primary3X = static_cast<uint16_t>(0);
        Attributes::Primary3Y::TypeInfo::DecodableType primary3Y = static_cast<uint16_t>(0);
        Attributes::Primary3Intensity::TypeInfo::DecodableType primary3Intensity;
        Attributes::Primary4X::TypeInfo::DecodableType primary4X = static_cast<uint16_t>(0);
        Attributes::Primary4Y::TypeInfo::DecodableType primary4Y = static_cast<uint16_t>(0);
        Attributes::Primary4Intensity::TypeInfo::DecodableType primary4Intensity;
        Attributes::Primary5X::TypeInfo::DecodableType primary5X = static_cast<uint16_t>(0);
        Attributes::Primary5Y::TypeInfo::DecodableType primary5Y = static_cast<uint16_t>(0);
        Attributes::Primary5Intensity::TypeInfo::DecodableType primary5Intensity;
        Attributes::Primary6X::TypeInfo::DecodableType primary6X = static_cast<uint16_t>(0);
        Attributes::Primary6Y::TypeInfo::DecodableType primary6Y = static_cast<uint16_t>(0);
        Attributes::Primary6Intensity::TypeInfo::DecodableType primary6Intensity;
        Attributes::WhitePointX::TypeInfo::DecodableType whitePointX   = static_cast<uint16_t>(0);
        Attributes::WhitePointY::TypeInfo::DecodableType whitePointY   = static_cast<uint16_t>(0);
        Attributes::ColorPointRX::TypeInfo::DecodableType colorPointRX = static_cast<uint16_t>(0);
        Attributes::ColorPointRY::TypeInfo::DecodableType colorPointRY = static_cast<uint16_t>(0);
        Attributes::ColorPointRIntensity::TypeInfo::DecodableType colorPointRIntensity;
        Attributes::ColorPointGX::TypeInfo::DecodableType colorPointGX = static_cast<uint16_t>(0);
        Attributes::ColorPointGY::TypeInfo::DecodableType colorPointGY = static_cast<uint16_t>(0);
        Attributes::ColorPointGIntensity::TypeInfo::DecodableType colorPointGIntensity;
        Attributes::ColorPointBX::TypeInfo::DecodableType colorPointBX = static_cast<uint16_t>(0);
        Attributes::ColorPointBY::TypeInfo::DecodableType colorPointBY = static_cast<uint16_t>(0);
        Attributes::ColorPointBIntensity::TypeInfo::DecodableType colorPointBIntensity;
        Attributes::EnhancedCurrentHue::TypeInfo::DecodableType enhancedCurrentHue = static_cast<uint16_t>(0);
        Attributes::EnhancedColorMode::TypeInfo::DecodableType enhancedColorMode =
            static_cast<chip::app::Clusters::ColorControl::EnhancedColorModeEnum>(0);
        Attributes::ColorLoopActive::TypeInfo::DecodableType colorLoopActive                       = static_cast<uint8_t>(0);
        Attributes::ColorLoopDirection::TypeInfo::DecodableType colorLoopDirection                 = static_cast<uint8_t>(0);
        Attributes::ColorLoopTime::TypeInfo::DecodableType colorLoopTime                           = static_cast<uint16_t>(0);
        Attributes::ColorLoopStartEnhancedHue::TypeInfo::DecodableType colorLoopStartEnhancedHue   = static_cast<uint16_t>(0);
        Attributes::ColorLoopStoredEnhancedHue::TypeInfo::DecodableType colorLoopStoredEnhancedHue = static_cast<uint16_t>(0);
        Attributes::ColorCapabilities::TypeInfo::DecodableType colorCapabilities =
            static_cast<chip::BitMask<chip::app::Clusters::ColorControl::ColorCapabilitiesBitmap>>(0);
        Attributes::ColorTempPhysicalMinMireds::TypeInfo::DecodableType colorTempPhysicalMinMireds = static_cast<uint16_t>(0);
        Attributes::ColorTempPhysicalMaxMireds::TypeInfo::DecodableType colorTempPhysicalMaxMireds = static_cast<uint16_t>(0);
        Attributes::CoupleColorTempToLevelMinMireds::TypeInfo::DecodableType coupleColorTempToLevelMinMireds =
            static_cast<uint16_t>(0);
        Attributes::StartUpColorTemperatureMireds::TypeInfo::DecodableType startUpColorTemperatureMireds;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ColorControl
namespace BallastConfiguration {

namespace Attributes {

namespace PhysicalMinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalMinLevel
namespace PhysicalMaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalMaxLevel
namespace BallastStatus {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BallastStatus
namespace MinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxLevel
namespace IntrinsicBallastFactor {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IntrinsicBallastFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IntrinsicBallastFactor
namespace BallastFactorAdjustment {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastFactorAdjustment::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BallastFactorAdjustment
namespace LampQuantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampQuantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampQuantity
namespace LampType {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace LampType
namespace LampManufacturer {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampManufacturer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace LampManufacturer
namespace LampRatedHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampRatedHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampRatedHours
namespace LampBurnHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampBurnHours
namespace LampAlarmMode {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampAlarmMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampAlarmMode
namespace LampBurnHoursTripPoint {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHoursTripPoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampBurnHoursTripPoint
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhysicalMinLevel::TypeInfo::DecodableType physicalMinLevel = static_cast<uint8_t>(0);
        Attributes::PhysicalMaxLevel::TypeInfo::DecodableType physicalMaxLevel = static_cast<uint8_t>(0);
        Attributes::BallastStatus::TypeInfo::DecodableType ballastStatus =
            static_cast<chip::BitMask<chip::app::Clusters::BallastConfiguration::BallastStatusBitmap>>(0);
        Attributes::MinLevel::TypeInfo::DecodableType minLevel = static_cast<uint8_t>(0);
        Attributes::MaxLevel::TypeInfo::DecodableType maxLevel = static_cast<uint8_t>(0);
        Attributes::IntrinsicBallastFactor::TypeInfo::DecodableType intrinsicBallastFactor;
        Attributes::BallastFactorAdjustment::TypeInfo::DecodableType ballastFactorAdjustment;
        Attributes::LampQuantity::TypeInfo::DecodableType lampQuantity = static_cast<uint8_t>(0);
        Attributes::LampType::TypeInfo::DecodableType lampType;
        Attributes::LampManufacturer::TypeInfo::DecodableType lampManufacturer;
        Attributes::LampRatedHours::TypeInfo::DecodableType lampRatedHours;
        Attributes::LampBurnHours::TypeInfo::DecodableType lampBurnHours;
        Attributes::LampAlarmMode::TypeInfo::DecodableType lampAlarmMode =
            static_cast<chip::BitMask<chip::app::Clusters::BallastConfiguration::LampAlarmModeBitmap>>(0);
        Attributes::LampBurnHoursTripPoint::TypeInfo::DecodableType lampBurnHoursTripPoint;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace BallastConfiguration
namespace IlluminanceMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace LightSensorType {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorTypeEnum>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorTypeEnum>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::IlluminanceMeasurement::LightSensorTypeEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LightSensorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LightSensorType
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::LightSensorType::TypeInfo::DecodableType lightSensorType;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace IlluminanceMeasurement
namespace TemperatureMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TemperatureMeasurement
namespace PressureMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace ScaledValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScaledValue
namespace MinScaledValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinScaledValue
namespace MaxScaledValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxScaledValue
namespace ScaledTolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledTolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScaledTolerance
namespace Scale {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Scale::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Scale
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::ScaledValue::TypeInfo::DecodableType scaledValue;
        Attributes::MinScaledValue::TypeInfo::DecodableType minScaledValue;
        Attributes::MaxScaledValue::TypeInfo::DecodableType maxScaledValue;
        Attributes::ScaledTolerance::TypeInfo::DecodableType scaledTolerance = static_cast<uint16_t>(0);
        Attributes::Scale::TypeInfo::DecodableType scale                     = static_cast<int8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace PressureMeasurement
namespace FlowMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FlowMeasurement
namespace RelativeHumidityMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance = static_cast<uint16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RelativeHumidityMeasurement
namespace OccupancySensing {
namespace Structs {
namespace HoldTimeLimitsStruct {
enum class Fields : uint8_t
{
    kHoldTimeMin     = 0,
    kHoldTimeMax     = 1,
    kHoldTimeDefault = 2,
};

struct Type
{
public:
    uint16_t holdTimeMin     = static_cast<uint16_t>(0);
    uint16_t holdTimeMax     = static_cast<uint16_t>(0);
    uint16_t holdTimeDefault = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace HoldTimeLimitsStruct
} // namespace Structs

namespace Attributes {

namespace Occupancy {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Occupancy
namespace OccupancySensorType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum;
    using DecodableType    = chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum;
    using DecodableArgType = chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupancySensorType
namespace OccupancySensorTypeBitmap {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorTypeBitmap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupancySensorTypeBitmap
namespace HoldTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HoldTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HoldTime
namespace HoldTimeLimits {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OccupancySensing::Structs::HoldTimeLimitsStruct::Type;
    using DecodableType    = chip::app::Clusters::OccupancySensing::Structs::HoldTimeLimitsStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::OccupancySensing::Structs::HoldTimeLimitsStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HoldTimeLimits::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HoldTimeLimits
namespace PIROccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIROccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIROccupiedToUnoccupiedDelay
namespace PIRUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIRUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIRUnoccupiedToOccupiedDelay
namespace PIRUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PIRUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PIRUnoccupiedToOccupiedThreshold
namespace UltrasonicOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicOccupiedToUnoccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicUnoccupiedToOccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicUnoccupiedToOccupiedThreshold
namespace PhysicalContactOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactOccupiedToUnoccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedThreshold
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Occupancy::TypeInfo::DecodableType occupancy =
            static_cast<chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancyBitmap>>(0);
        Attributes::OccupancySensorType::TypeInfo::DecodableType occupancySensorType =
            static_cast<chip::app::Clusters::OccupancySensing::OccupancySensorTypeEnum>(0);
        Attributes::OccupancySensorTypeBitmap::TypeInfo::DecodableType occupancySensorTypeBitmap =
            static_cast<chip::BitMask<chip::app::Clusters::OccupancySensing::OccupancySensorTypeBitmap>>(0);
        Attributes::HoldTime::TypeInfo::DecodableType holdTime = static_cast<uint16_t>(0);
        Attributes::HoldTimeLimits::TypeInfo::DecodableType holdTimeLimits;
        Attributes::PIROccupiedToUnoccupiedDelay::TypeInfo::DecodableType PIROccupiedToUnoccupiedDelay = static_cast<uint16_t>(0);
        Attributes::PIRUnoccupiedToOccupiedDelay::TypeInfo::DecodableType PIRUnoccupiedToOccupiedDelay = static_cast<uint16_t>(0);
        Attributes::PIRUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType PIRUnoccupiedToOccupiedThreshold =
            static_cast<uint8_t>(0);
        Attributes::UltrasonicOccupiedToUnoccupiedDelay::TypeInfo::DecodableType ultrasonicOccupiedToUnoccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::UltrasonicUnoccupiedToOccupiedDelay::TypeInfo::DecodableType ultrasonicUnoccupiedToOccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::UltrasonicUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType ultrasonicUnoccupiedToOccupiedThreshold =
            static_cast<uint8_t>(0);
        Attributes::PhysicalContactOccupiedToUnoccupiedDelay::TypeInfo::DecodableType physicalContactOccupiedToUnoccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::PhysicalContactUnoccupiedToOccupiedDelay::TypeInfo::DecodableType physicalContactUnoccupiedToOccupiedDelay =
            static_cast<uint16_t>(0);
        Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType
            physicalContactUnoccupiedToOccupiedThreshold = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace OccupancyChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kOccupancy = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OccupancyChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr bool kIsFabricScoped = false;

    chip::BitMask<OccupancyBitmap> occupancy = static_cast<chip::BitMask<OccupancyBitmap>>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::OccupancyChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }

    chip::BitMask<OccupancyBitmap> occupancy = static_cast<chip::BitMask<OccupancyBitmap>>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace OccupancyChanged
} // namespace Events
} // namespace OccupancySensing
namespace CarbonMonoxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::CarbonMonoxideConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace CarbonMonoxideConcentrationMeasurement
namespace CarbonDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::CarbonDioxideConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::CarbonDioxideConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace CarbonDioxideConcentrationMeasurement
namespace NitrogenDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::NitrogenDioxideConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace NitrogenDioxideConcentrationMeasurement
namespace OzoneConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::OzoneConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::OzoneConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace OzoneConcentrationMeasurement
namespace Pm25ConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Pm25ConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::Pm25ConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::Pm25ConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Pm25ConcentrationMeasurement
namespace FormaldehydeConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FormaldehydeConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::FormaldehydeConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::FormaldehydeConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FormaldehydeConcentrationMeasurement
namespace Pm1ConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Pm1ConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::Pm1ConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::Pm1ConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Pm1ConcentrationMeasurement
namespace Pm10ConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Pm10ConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::Pm10ConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::Pm10ConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Pm10ConcentrationMeasurement
namespace TotalVolatileOrganicCompoundsConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::TotalVolatileOrganicCompoundsConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TotalVolatileOrganicCompoundsConcentrationMeasurement
namespace RadonConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace PeakMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValue
namespace PeakMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PeakMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PeakMeasuredValueWindow
namespace AverageMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValue
namespace AverageMeasuredValueWindow {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageMeasuredValueWindow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageMeasuredValueWindow
namespace Uncertainty {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Uncertainty::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Uncertainty
namespace MeasurementUnit {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableType    = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum;
    using DecodableArgType = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementUnit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementUnit
namespace MeasurementMedium {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableType    = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum;
    using DecodableArgType = chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementMedium::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementMedium
namespace LevelValue {
struct TypeInfo
{
    using Type             = chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum;
    using DecodableType    = chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum;
    using DecodableArgType = chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LevelValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LevelValue
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RadonConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::PeakMeasuredValue::TypeInfo::DecodableType peakMeasuredValue;
        Attributes::PeakMeasuredValueWindow::TypeInfo::DecodableType peakMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::AverageMeasuredValue::TypeInfo::DecodableType averageMeasuredValue;
        Attributes::AverageMeasuredValueWindow::TypeInfo::DecodableType averageMeasuredValueWindow = static_cast<uint32_t>(0);
        Attributes::Uncertainty::TypeInfo::DecodableType uncertainty                               = static_cast<float>(0);
        Attributes::MeasurementUnit::TypeInfo::DecodableType measurementUnit =
            static_cast<chip::app::Clusters::RadonConcentrationMeasurement::MeasurementUnitEnum>(0);
        Attributes::MeasurementMedium::TypeInfo::DecodableType measurementMedium =
            static_cast<chip::app::Clusters::RadonConcentrationMeasurement::MeasurementMediumEnum>(0);
        Attributes::LevelValue::TypeInfo::DecodableType levelValue =
            static_cast<chip::app::Clusters::RadonConcentrationMeasurement::LevelValueEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace RadonConcentrationMeasurement
namespace WiFiNetworkManagement {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace NetworkPassphraseRequest {
struct Type;
struct DecodableType;
} // namespace NetworkPassphraseRequest

namespace NetworkPassphraseResponse {
struct Type;
struct DecodableType;
} // namespace NetworkPassphraseResponse

} // namespace Commands

namespace Commands {
namespace NetworkPassphraseRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::WiFiNetworkManagement::Commands::NetworkPassphraseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkPassphraseRequest
namespace NetworkPassphraseResponse {
enum class Fields : uint8_t
{
    kPassphrase = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    chip::ByteSpan passphrase;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkPassphraseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

    chip::ByteSpan passphrase;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkPassphraseResponse
} // namespace Commands

namespace Attributes {

namespace Ssid {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Ssid::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace Ssid
namespace PassphraseSurrogate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PassphraseSurrogate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PassphraseSurrogate
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Ssid::TypeInfo::DecodableType ssid;
        Attributes::PassphraseSurrogate::TypeInfo::DecodableType passphraseSurrogate;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WiFiNetworkManagement
namespace ThreadBorderRouterManagement {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetActiveDatasetRequest {
struct Type;
struct DecodableType;
} // namespace GetActiveDatasetRequest

namespace GetPendingDatasetRequest {
struct Type;
struct DecodableType;
} // namespace GetPendingDatasetRequest

namespace DatasetResponse {
struct Type;
struct DecodableType;
} // namespace DatasetResponse

namespace SetActiveDatasetRequest {
struct Type;
struct DecodableType;
} // namespace SetActiveDatasetRequest

namespace SetPendingDatasetRequest {
struct Type;
struct DecodableType;
} // namespace SetPendingDatasetRequest

} // namespace Commands

namespace Commands {
namespace GetActiveDatasetRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetActiveDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ThreadBorderRouterManagement::Commands::DatasetResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetActiveDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetActiveDatasetRequest
namespace GetPendingDatasetRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPendingDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ThreadBorderRouterManagement::Commands::DatasetResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPendingDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPendingDatasetRequest
namespace DatasetResponse {
enum class Fields : uint8_t
{
    kDataset = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DatasetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    chip::ByteSpan dataset;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DatasetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    chip::ByteSpan dataset;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DatasetResponse
namespace SetActiveDatasetRequest {
enum class Fields : uint8_t
{
    kActiveDataset = 0,
    kBreadcrumb    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetActiveDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    chip::ByteSpan activeDataset;
    Optional<uint64_t> breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetActiveDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    chip::ByteSpan activeDataset;
    Optional<uint64_t> breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetActiveDatasetRequest
namespace SetPendingDatasetRequest {
enum class Fields : uint8_t
{
    kPendingDataset = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetPendingDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    chip::ByteSpan pendingDataset;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetPendingDatasetRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

    chip::ByteSpan pendingDataset;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetPendingDatasetRequest
} // namespace Commands

namespace Attributes {

namespace BorderRouterName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BorderRouterName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 63; }
};
} // namespace BorderRouterName
namespace BorderAgentID {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BorderAgentID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 254; }
};
} // namespace BorderAgentID
namespace ThreadVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadVersion
namespace InterfaceEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterfaceEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterfaceEnabled
namespace ActiveDatasetTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveDatasetTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveDatasetTimestamp
namespace PendingDatasetTimestamp {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PendingDatasetTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PendingDatasetTimestamp
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThreadBorderRouterManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::BorderRouterName::TypeInfo::DecodableType borderRouterName;
        Attributes::BorderAgentID::TypeInfo::DecodableType borderAgentID;
        Attributes::ThreadVersion::TypeInfo::DecodableType threadVersion       = static_cast<uint16_t>(0);
        Attributes::InterfaceEnabled::TypeInfo::DecodableType interfaceEnabled = static_cast<bool>(0);
        Attributes::ActiveDatasetTimestamp::TypeInfo::DecodableType activeDatasetTimestamp;
        Attributes::PendingDatasetTimestamp::TypeInfo::DecodableType pendingDatasetTimestamp;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ThreadBorderRouterManagement
namespace ThreadNetworkDirectory {
namespace Structs {
namespace ThreadNetworkStruct {
enum class Fields : uint8_t
{
    kExtendedPanID   = 0,
    kNetworkName     = 1,
    kChannel         = 2,
    kActiveTimestamp = 3,
};

struct Type
{
public:
    chip::ByteSpan extendedPanID;
    chip::CharSpan networkName;
    uint16_t channel         = static_cast<uint16_t>(0);
    uint64_t activeTimestamp = static_cast<uint64_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ThreadNetworkStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddNetwork {
struct Type;
struct DecodableType;
} // namespace AddNetwork

namespace RemoveNetwork {
struct Type;
struct DecodableType;
} // namespace RemoveNetwork

namespace GetOperationalDataset {
struct Type;
struct DecodableType;
} // namespace GetOperationalDataset

namespace OperationalDatasetResponse {
struct Type;
struct DecodableType;
} // namespace OperationalDatasetResponse

} // namespace Commands

namespace Commands {
namespace AddNetwork {
enum class Fields : uint8_t
{
    kOperationalDataset = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan operationalDataset;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan operationalDataset;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddNetwork
namespace RemoveNetwork {
enum class Fields : uint8_t
{
    kExtendedPanID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan extendedPanID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan extendedPanID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveNetwork
namespace GetOperationalDataset {
enum class Fields : uint8_t
{
    kExtendedPanID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetOperationalDataset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan extendedPanID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ThreadNetworkDirectory::Commands::OperationalDatasetResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetOperationalDataset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan extendedPanID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetOperationalDataset
namespace OperationalDatasetResponse {
enum class Fields : uint8_t
{
    kOperationalDataset = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperationalDatasetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan operationalDataset;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperationalDatasetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

    chip::ByteSpan operationalDataset;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperationalDatasetResponse
} // namespace Commands

namespace Attributes {

namespace PreferredExtendedPanID {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PreferredExtendedPanID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 8; }
};
} // namespace PreferredExtendedPanID
namespace ThreadNetworks {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDirectory::Structs::ThreadNetworkStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDirectory::Structs::ThreadNetworkStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDirectory::Structs::ThreadNetworkStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadNetworks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadNetworks
namespace ThreadNetworkTableSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadNetworkTableSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadNetworkTableSize
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDirectory::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PreferredExtendedPanID::TypeInfo::DecodableType preferredExtendedPanID;
        Attributes::ThreadNetworks::TypeInfo::DecodableType threadNetworks;
        Attributes::ThreadNetworkTableSize::TypeInfo::DecodableType threadNetworkTableSize = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ThreadNetworkDirectory
namespace WakeOnLan {

namespace Attributes {

namespace MACAddress {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MACAddress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 12; }
};
} // namespace MACAddress
namespace LinkLocalAddress {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LinkLocalAddress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 16; }
};
} // namespace LinkLocalAddress
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MACAddress::TypeInfo::DecodableType MACAddress;
        Attributes::LinkLocalAddress::TypeInfo::DecodableType linkLocalAddress;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WakeOnLan
namespace Channel {
namespace Structs {
namespace ProgramCastStruct {
enum class Fields : uint8_t
{
    kName = 0,
    kRole = 1,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan role;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProgramCastStruct
namespace ProgramCategoryStruct {
enum class Fields : uint8_t
{
    kCategory    = 0,
    kSubCategory = 1,
};

struct Type
{
public:
    chip::CharSpan category;
    Optional<chip::CharSpan> subCategory;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ProgramCategoryStruct
namespace SeriesInfoStruct {
enum class Fields : uint8_t
{
    kSeason  = 0,
    kEpisode = 1,
};

struct Type
{
public:
    chip::CharSpan season;
    chip::CharSpan episode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SeriesInfoStruct
namespace ChannelInfoStruct {
enum class Fields : uint8_t
{
    kMajorNumber       = 0,
    kMinorNumber       = 1,
    kName              = 2,
    kCallSign          = 3,
    kAffiliateCallSign = 4,
    kIdentifier        = 5,
    kType              = 6,
};

struct Type
{
public:
    uint16_t majorNumber = static_cast<uint16_t>(0);
    uint16_t minorNumber = static_cast<uint16_t>(0);
    Optional<chip::CharSpan> name;
    Optional<chip::CharSpan> callSign;
    Optional<chip::CharSpan> affiliateCallSign;
    Optional<chip::CharSpan> identifier;
    Optional<ChannelTypeEnum> type;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChannelInfoStruct
namespace ProgramStruct {
enum class Fields : uint8_t
{
    kIdentifier           = 0,
    kChannel              = 1,
    kStartTime            = 2,
    kEndTime              = 3,
    kTitle                = 4,
    kSubtitle             = 5,
    kDescription          = 6,
    kAudioLanguages       = 7,
    kRatings              = 8,
    kThumbnailUrl         = 9,
    kPosterArtUrl         = 10,
    kDvbiUrl              = 11,
    kReleaseDate          = 12,
    kParentalGuidanceText = 13,
    kRecordingFlag        = 14,
    kSeriesInfo           = 15,
    kCategoryList         = 16,
    kCastList             = 17,
    kExternalIDList       = 18,
};

struct Type
{
public:
    chip::CharSpan identifier;
    Structs::ChannelInfoStruct::Type channel;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    chip::CharSpan title;
    Optional<chip::CharSpan> subtitle;
    Optional<chip::CharSpan> description;
    Optional<DataModel::List<const chip::CharSpan>> audioLanguages;
    Optional<DataModel::List<const chip::CharSpan>> ratings;
    Optional<chip::CharSpan> thumbnailUrl;
    Optional<chip::CharSpan> posterArtUrl;
    Optional<chip::CharSpan> dvbiUrl;
    Optional<chip::CharSpan> releaseDate;
    Optional<chip::CharSpan> parentalGuidanceText;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::Nullable<Structs::SeriesInfoStruct::Type>> seriesInfo;
    Optional<DataModel::List<const Structs::ProgramCategoryStruct::Type>> categoryList;
    Optional<DataModel::List<const Structs::ProgramCastStruct::Type>> castList;
    Optional<DataModel::List<const Structs::ProgramCastStruct::Type>> externalIDList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan identifier;
    Structs::ChannelInfoStruct::DecodableType channel;
    uint32_t startTime = static_cast<uint32_t>(0);
    uint32_t endTime   = static_cast<uint32_t>(0);
    chip::CharSpan title;
    Optional<chip::CharSpan> subtitle;
    Optional<chip::CharSpan> description;
    Optional<DataModel::DecodableList<chip::CharSpan>> audioLanguages;
    Optional<DataModel::DecodableList<chip::CharSpan>> ratings;
    Optional<chip::CharSpan> thumbnailUrl;
    Optional<chip::CharSpan> posterArtUrl;
    Optional<chip::CharSpan> dvbiUrl;
    Optional<chip::CharSpan> releaseDate;
    Optional<chip::CharSpan> parentalGuidanceText;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::Nullable<Structs::SeriesInfoStruct::DecodableType>> seriesInfo;
    Optional<DataModel::DecodableList<Structs::ProgramCategoryStruct::DecodableType>> categoryList;
    Optional<DataModel::DecodableList<Structs::ProgramCastStruct::DecodableType>> castList;
    Optional<DataModel::DecodableList<Structs::ProgramCastStruct::DecodableType>> externalIDList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ProgramStruct
namespace PageTokenStruct {
enum class Fields : uint8_t
{
    kLimit  = 0,
    kAfter  = 1,
    kBefore = 2,
};

struct Type
{
public:
    Optional<uint16_t> limit;
    Optional<chip::CharSpan> after;
    Optional<chip::CharSpan> before;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PageTokenStruct
namespace ChannelPagingStruct {
enum class Fields : uint8_t
{
    kPreviousToken = 0,
    kNextToken     = 1,
};

struct Type
{
public:
    Optional<DataModel::Nullable<Structs::PageTokenStruct::Type>> previousToken;
    Optional<DataModel::Nullable<Structs::PageTokenStruct::Type>> nextToken;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChannelPagingStruct
namespace AdditionalInfoStruct {
enum class Fields : uint8_t
{
    kName  = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan value;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AdditionalInfoStruct
namespace LineupInfoStruct {
enum class Fields : uint8_t
{
    kOperatorName   = 0,
    kLineupName     = 1,
    kPostalCode     = 2,
    kLineupInfoType = 3,
};

struct Type
{
public:
    chip::CharSpan operatorName;
    Optional<chip::CharSpan> lineupName;
    Optional<chip::CharSpan> postalCode;
    LineupInfoTypeEnum lineupInfoType = static_cast<LineupInfoTypeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace LineupInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeChannel {
struct Type;
struct DecodableType;
} // namespace ChangeChannel

namespace ChangeChannelResponse {
struct Type;
struct DecodableType;
} // namespace ChangeChannelResponse

namespace ChangeChannelByNumber {
struct Type;
struct DecodableType;
} // namespace ChangeChannelByNumber

namespace SkipChannel {
struct Type;
struct DecodableType;
} // namespace SkipChannel

namespace GetProgramGuide {
struct Type;
struct DecodableType;
} // namespace GetProgramGuide

namespace ProgramGuideResponse {
struct Type;
struct DecodableType;
} // namespace ProgramGuideResponse

namespace RecordProgram {
struct Type;
struct DecodableType;
} // namespace RecordProgram

namespace CancelRecordProgram {
struct Type;
struct DecodableType;
} // namespace CancelRecordProgram

} // namespace Commands

namespace Commands {
namespace ChangeChannel {
enum class Fields : uint8_t
{
    kMatch = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan match;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Channel::Commands::ChangeChannelResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan match;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannel
namespace ChangeChannelResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelResponse
namespace ChangeChannelByNumber {
enum class Fields : uint8_t
{
    kMajorNumber = 0,
    kMinorNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t majorNumber = static_cast<uint16_t>(0);
    uint16_t minorNumber = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t majorNumber = static_cast<uint16_t>(0);
    uint16_t minorNumber = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelByNumber
namespace SkipChannel {
enum class Fields : uint8_t
{
    kCount = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    int16_t count = static_cast<int16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    int16_t count = static_cast<int16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipChannel
namespace GetProgramGuide {
enum class Fields : uint8_t
{
    kStartTime      = 0,
    kEndTime        = 1,
    kChannelList    = 2,
    kPageToken      = 3,
    kRecordingFlag  = 4,
    kExternalIDList = 5,
    kData           = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetProgramGuide::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Optional<uint32_t> startTime;
    Optional<uint32_t> endTime;
    Optional<DataModel::List<const Structs::ChannelInfoStruct::Type>> channelList;
    Optional<Structs::PageTokenStruct::Type> pageToken;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::List<const Structs::AdditionalInfoStruct::Type>> externalIDList;
    Optional<chip::ByteSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::Channel::Commands::ProgramGuideResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetProgramGuide::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Optional<uint32_t> startTime;
    Optional<uint32_t> endTime;
    Optional<DataModel::DecodableList<Structs::ChannelInfoStruct::DecodableType>> channelList;
    Optional<Structs::PageTokenStruct::DecodableType> pageToken;
    Optional<chip::BitMask<RecordingFlagBitmap>> recordingFlag;
    Optional<DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType>> externalIDList;
    Optional<chip::ByteSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProgramGuide
namespace ProgramGuideResponse {
enum class Fields : uint8_t
{
    kPaging      = 0,
    kProgramList = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProgramGuideResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Structs::ChannelPagingStruct::Type paging;
    DataModel::List<const Structs::ProgramStruct::Type> programList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProgramGuideResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Structs::ChannelPagingStruct::DecodableType paging;
    DataModel::DecodableList<Structs::ProgramStruct::DecodableType> programList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProgramGuideResponse
namespace RecordProgram {
enum class Fields : uint8_t
{
    kProgramIdentifier  = 0,
    kShouldRecordSeries = 1,
    kExternalIDList     = 2,
    kData               = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::List<const Structs::AdditionalInfoStruct::Type> externalIDList;
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType> externalIDList;
    chip::ByteSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RecordProgram
namespace CancelRecordProgram {
enum class Fields : uint8_t
{
    kProgramIdentifier  = 0,
    kShouldRecordSeries = 1,
    kExternalIDList     = 2,
    kData               = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelRecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::List<const Structs::AdditionalInfoStruct::Type> externalIDList;
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelRecordProgram::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan programIdentifier;
    bool shouldRecordSeries = static_cast<bool>(0);
    DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType> externalIDList;
    chip::ByteSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelRecordProgram
} // namespace Commands

namespace Attributes {

namespace ChannelList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::Channel::Structs::ChannelInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelList
namespace Lineup {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfoStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::LineupInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Lineup::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Lineup
namespace CurrentChannel {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::Channel::Structs::ChannelInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentChannel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentChannel
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ChannelList::TypeInfo::DecodableType channelList;
        Attributes::Lineup::TypeInfo::DecodableType lineup;
        Attributes::CurrentChannel::TypeInfo::DecodableType currentChannel;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Channel
namespace TargetNavigator {
namespace Structs {
namespace TargetInfoStruct {
enum class Fields : uint8_t
{
    kIdentifier = 0,
    kName       = 1,
};

struct Type
{
public:
    uint8_t identifier = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TargetInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace NavigateTarget {
struct Type;
struct DecodableType;
} // namespace NavigateTarget

namespace NavigateTargetResponse {
struct Type;
struct DecodableType;
} // namespace NavigateTargetResponse

} // namespace Commands

namespace Commands {
namespace NavigateTarget {
enum class Fields : uint8_t
{
    kTarget = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    uint8_t target = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    uint8_t target = static_cast<uint8_t>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTarget
namespace NavigateTargetResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTargetResponse
} // namespace Commands

namespace Attributes {

namespace TargetList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TargetNavigator::Structs::TargetInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::TargetInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetList
namespace CurrentTarget {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentTarget::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentTarget
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TargetList::TypeInfo::DecodableType targetList;
        Attributes::CurrentTarget::TypeInfo::DecodableType currentTarget = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace TargetUpdated {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kTargetList    = 0,
    kCurrentTarget = 1,
    kData          = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TargetUpdated::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const Structs::TargetInfoStruct::Type> targetList;
    uint8_t currentTarget = static_cast<uint8_t>(0);
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TargetUpdated::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    DataModel::DecodableList<Structs::TargetInfoStruct::DecodableType> targetList;
    uint8_t currentTarget = static_cast<uint8_t>(0);
    chip::ByteSpan data;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TargetUpdated
} // namespace Events
} // namespace TargetNavigator
namespace MediaPlayback {
namespace Structs {
namespace TrackAttributesStruct {
enum class Fields : uint8_t
{
    kLanguageCode = 0,
    kDisplayName  = 1,
};

struct Type
{
public:
    chip::CharSpan languageCode;
    Optional<DataModel::Nullable<chip::CharSpan>> displayName;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TrackAttributesStruct
namespace TrackStruct {
enum class Fields : uint8_t
{
    kId              = 0,
    kTrackAttributes = 1,
};

struct Type
{
public:
    chip::CharSpan id;
    DataModel::Nullable<Structs::TrackAttributesStruct::Type> trackAttributes;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TrackStruct
namespace PlaybackPositionStruct {
enum class Fields : uint8_t
{
    kUpdatedAt = 0,
    kPosition  = 1,
};

struct Type
{
public:
    uint64_t updatedAt = static_cast<uint64_t>(0);
    DataModel::Nullable<uint64_t> position;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace PlaybackPositionStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Play {
struct Type;
struct DecodableType;
} // namespace Play

namespace Pause {
struct Type;
struct DecodableType;
} // namespace Pause

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace StartOver {
struct Type;
struct DecodableType;
} // namespace StartOver

namespace Previous {
struct Type;
struct DecodableType;
} // namespace Previous

namespace Next {
struct Type;
struct DecodableType;
} // namespace Next

namespace Rewind {
struct Type;
struct DecodableType;
} // namespace Rewind

namespace FastForward {
struct Type;
struct DecodableType;
} // namespace FastForward

namespace SkipForward {
struct Type;
struct DecodableType;
} // namespace SkipForward

namespace SkipBackward {
struct Type;
struct DecodableType;
} // namespace SkipBackward

namespace PlaybackResponse {
struct Type;
struct DecodableType;
} // namespace PlaybackResponse

namespace Seek {
struct Type;
struct DecodableType;
} // namespace Seek

namespace ActivateAudioTrack {
struct Type;
struct DecodableType;
} // namespace ActivateAudioTrack

namespace ActivateTextTrack {
struct Type;
struct DecodableType;
} // namespace ActivateTextTrack

namespace DeactivateTextTrack {
struct Type;
struct DecodableType;
} // namespace DeactivateTextTrack

} // namespace Commands

namespace Commands {
namespace Play {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Play::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Play::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Play
namespace Pause {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Pause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Pause
namespace Stop {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace StartOver {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartOver::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartOver::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartOver
namespace Previous {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Previous::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Previous::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Previous
namespace Next {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Next::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Next::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Next
namespace Rewind {
enum class Fields : uint8_t
{
    kAudioAdvanceUnmuted = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Rewind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Rewind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Rewind
namespace FastForward {
enum class Fields : uint8_t
{
    kAudioAdvanceUnmuted = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FastForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FastForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    Optional<bool> audioAdvanceUnmuted;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FastForward
namespace SkipForward {
enum class Fields : uint8_t
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipForward
namespace SkipBackward {
enum class Fields : uint8_t
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipBackward
namespace PlaybackResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PlaybackResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PlaybackResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PlaybackResponse
namespace Seek {
enum class Fields : uint8_t
{
    kPosition = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Seek::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t position = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::PlaybackResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Seek::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t position = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Seek
namespace ActivateAudioTrack {
enum class Fields : uint8_t
{
    kTrackID          = 0,
    kAudioOutputIndex = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ActivateAudioTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ActivateAudioTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ActivateAudioTrack
namespace ActivateTextTrack {
enum class Fields : uint8_t
{
    kTrackID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ActivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ActivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    chip::CharSpan trackID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ActivateTextTrack
namespace DeactivateTextTrack {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DeactivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DeactivateTextTrack::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DeactivateTextTrack
} // namespace Commands

namespace Attributes {

namespace CurrentState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::MediaPlayback::PlaybackStateEnum;
    using DecodableType    = chip::app::Clusters::MediaPlayback::PlaybackStateEnum;
    using DecodableArgType = chip::app::Clusters::MediaPlayback::PlaybackStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentState
namespace StartTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartTime
namespace Duration {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Duration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Duration
namespace SampledPosition {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPositionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPositionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::PlaybackPositionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SampledPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SampledPosition
namespace PlaybackSpeed {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PlaybackSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PlaybackSpeed
namespace SeekRangeEnd {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeEnd::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SeekRangeEnd
namespace SeekRangeStart {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeStart::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SeekRangeStart
namespace ActiveAudioTrack {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveAudioTrack::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveAudioTrack
namespace AvailableAudioTracks {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::DataModel::List<const chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailableAudioTracks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailableAudioTracks
namespace ActiveTextTrack {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveTextTrack::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveTextTrack
namespace AvailableTextTracks {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<
        chip::app::DataModel::List<const chip::app::Clusters::MediaPlayback::Structs::TrackStruct::Type>>;
    using DecodableType = chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaPlayback::Structs::TrackStruct::DecodableType>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailableTextTracks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailableTextTracks
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentState::TypeInfo::DecodableType currentState =
            static_cast<chip::app::Clusters::MediaPlayback::PlaybackStateEnum>(0);
        Attributes::StartTime::TypeInfo::DecodableType startTime;
        Attributes::Duration::TypeInfo::DecodableType duration;
        Attributes::SampledPosition::TypeInfo::DecodableType sampledPosition;
        Attributes::PlaybackSpeed::TypeInfo::DecodableType playbackSpeed = static_cast<float>(0);
        Attributes::SeekRangeEnd::TypeInfo::DecodableType seekRangeEnd;
        Attributes::SeekRangeStart::TypeInfo::DecodableType seekRangeStart;
        Attributes::ActiveAudioTrack::TypeInfo::DecodableType activeAudioTrack;
        Attributes::AvailableAudioTracks::TypeInfo::DecodableType availableAudioTracks;
        Attributes::ActiveTextTrack::TypeInfo::DecodableType activeTextTrack;
        Attributes::AvailableTextTracks::TypeInfo::DecodableType availableTextTracks;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace StateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCurrentState        = 0,
    kStartTime           = 1,
    kDuration            = 2,
    kSampledPosition     = 3,
    kPlaybackSpeed       = 4,
    kSeekRangeEnd        = 5,
    kSeekRangeStart      = 6,
    kData                = 7,
    kAudioAdvanceUnmuted = 8,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr bool kIsFabricScoped = false;

    PlaybackStateEnum currentState = static_cast<PlaybackStateEnum>(0);
    uint64_t startTime             = static_cast<uint64_t>(0);
    uint64_t duration              = static_cast<uint64_t>(0);
    Structs::PlaybackPositionStruct::Type sampledPosition;
    float playbackSpeed     = static_cast<float>(0);
    uint64_t seekRangeEnd   = static_cast<uint64_t>(0);
    uint64_t seekRangeStart = static_cast<uint64_t>(0);
    Optional<chip::ByteSpan> data;
    bool audioAdvanceUnmuted = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::StateChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    PlaybackStateEnum currentState = static_cast<PlaybackStateEnum>(0);
    uint64_t startTime             = static_cast<uint64_t>(0);
    uint64_t duration              = static_cast<uint64_t>(0);
    Structs::PlaybackPositionStruct::DecodableType sampledPosition;
    float playbackSpeed     = static_cast<float>(0);
    uint64_t seekRangeEnd   = static_cast<uint64_t>(0);
    uint64_t seekRangeStart = static_cast<uint64_t>(0);
    Optional<chip::ByteSpan> data;
    bool audioAdvanceUnmuted = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChanged
} // namespace Events
} // namespace MediaPlayback
namespace MediaInput {
namespace Structs {
namespace InputInfoStruct {
enum class Fields : uint8_t
{
    kIndex       = 0,
    kInputType   = 1,
    kName        = 2,
    kDescription = 3,
};

struct Type
{
public:
    uint8_t index           = static_cast<uint8_t>(0);
    InputTypeEnum inputType = static_cast<InputTypeEnum>(0);
    chip::CharSpan name;
    chip::CharSpan description;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace InputInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectInput {
struct Type;
struct DecodableType;
} // namespace SelectInput

namespace ShowInputStatus {
struct Type;
struct DecodableType;
} // namespace ShowInputStatus

namespace HideInputStatus {
struct Type;
struct DecodableType;
} // namespace HideInputStatus

namespace RenameInput {
struct Type;
struct DecodableType;
} // namespace RenameInput

} // namespace Commands

namespace Commands {
namespace SelectInput {
enum class Fields : uint8_t
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectInput
namespace ShowInputStatus {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShowInputStatus
namespace HideInputStatus {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideInputStatus
namespace RenameInput {
enum class Fields : uint8_t
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameInput
} // namespace Commands

namespace Attributes {

namespace InputList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::MediaInput::Structs::InputInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::InputInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InputList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InputList
namespace CurrentInput {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentInput::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentInput
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::InputList::TypeInfo::DecodableType inputList;
        Attributes::CurrentInput::TypeInfo::DecodableType currentInput = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace MediaInput
namespace LowPower {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Sleep {
struct Type;
struct DecodableType;
} // namespace Sleep

} // namespace Commands

namespace Commands {
namespace Sleep {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Sleep
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace LowPower
namespace KeypadInput {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SendKey {
struct Type;
struct DecodableType;
} // namespace SendKey

namespace SendKeyResponse {
struct Type;
struct DecodableType;
} // namespace SendKeyResponse

} // namespace Commands

namespace Commands {
namespace SendKey {
enum class Fields : uint8_t
{
    kKeyCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    CECKeyCodeEnum keyCode = static_cast<CECKeyCodeEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    CECKeyCodeEnum keyCode = static_cast<CECKeyCodeEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKey
namespace SendKeyResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKeyResponse
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace KeypadInput
namespace ContentLauncher {
namespace Structs {
namespace DimensionStruct {
enum class Fields : uint8_t
{
    kWidth  = 0,
    kHeight = 1,
    kMetric = 2,
};

struct Type
{
public:
    double width          = static_cast<double>(0);
    double height         = static_cast<double>(0);
    MetricTypeEnum metric = static_cast<MetricTypeEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace DimensionStruct
namespace TrackPreferenceStruct {
enum class Fields : uint8_t
{
    kLanguageCode     = 0,
    kCharacteristics  = 1,
    kAudioOutputIndex = 2,
};

struct Type
{
public:
    chip::CharSpan languageCode;
    Optional<DataModel::List<const CharacteristicEnum>> characteristics;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan languageCode;
    Optional<DataModel::DecodableList<CharacteristicEnum>> characteristics;
    uint8_t audioOutputIndex = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TrackPreferenceStruct
namespace PlaybackPreferencesStruct {
enum class Fields : uint8_t
{
    kPlaybackPosition = 0,
    kTextTrack        = 1,
    kAudioTracks      = 2,
};

struct Type
{
public:
    uint64_t playbackPosition = static_cast<uint64_t>(0);
    Structs::TrackPreferenceStruct::Type textTrack;
    Optional<DataModel::List<const Structs::TrackPreferenceStruct::Type>> audioTracks;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint64_t playbackPosition = static_cast<uint64_t>(0);
    Structs::TrackPreferenceStruct::DecodableType textTrack;
    Optional<DataModel::DecodableList<Structs::TrackPreferenceStruct::DecodableType>> audioTracks;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace PlaybackPreferencesStruct
namespace AdditionalInfoStruct {
enum class Fields : uint8_t
{
    kName  = 0,
    kValue = 1,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan value;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AdditionalInfoStruct
namespace ParameterStruct {
enum class Fields : uint8_t
{
    kType           = 0,
    kValue          = 1,
    kExternalIDList = 2,
};

struct Type
{
public:
    ParameterEnum type = static_cast<ParameterEnum>(0);
    chip::CharSpan value;
    Optional<DataModel::List<const Structs::AdditionalInfoStruct::Type>> externalIDList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    ParameterEnum type = static_cast<ParameterEnum>(0);
    chip::CharSpan value;
    Optional<DataModel::DecodableList<Structs::AdditionalInfoStruct::DecodableType>> externalIDList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ParameterStruct
namespace ContentSearchStruct {
enum class Fields : uint8_t
{
    kParameterList = 0,
};

struct Type
{
public:
    DataModel::List<const Structs::ParameterStruct::Type> parameterList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<Structs::ParameterStruct::DecodableType> parameterList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace ContentSearchStruct
namespace StyleInformationStruct {
enum class Fields : uint8_t
{
    kImageURL = 0,
    kColor    = 1,
    kSize     = 2,
};

struct Type
{
public:
    Optional<chip::CharSpan> imageURL;
    Optional<chip::CharSpan> color;
    Optional<Structs::DimensionStruct::Type> size;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace StyleInformationStruct
namespace BrandingInformationStruct {
enum class Fields : uint8_t
{
    kProviderName = 0,
    kBackground   = 1,
    kLogo         = 2,
    kProgressBar  = 3,
    kSplash       = 4,
    kWaterMark    = 5,
};

struct Type
{
public:
    chip::CharSpan providerName;
    Optional<Structs::StyleInformationStruct::Type> background;
    Optional<Structs::StyleInformationStruct::Type> logo;
    Optional<Structs::StyleInformationStruct::Type> progressBar;
    Optional<Structs::StyleInformationStruct::Type> splash;
    Optional<Structs::StyleInformationStruct::Type> waterMark;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace BrandingInformationStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LaunchContent {
struct Type;
struct DecodableType;
} // namespace LaunchContent

namespace LaunchURL {
struct Type;
struct DecodableType;
} // namespace LaunchURL

namespace LauncherResponse {
struct Type;
struct DecodableType;
} // namespace LauncherResponse

} // namespace Commands

namespace Commands {
namespace LaunchContent {
enum class Fields : uint8_t
{
    kSearch              = 0,
    kAutoPlay            = 1,
    kData                = 2,
    kPlaybackPreferences = 3,
    kUseCurrentContext   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    Structs::ContentSearchStruct::Type search;
    bool autoPlay = static_cast<bool>(0);
    Optional<chip::CharSpan> data;
    Optional<Structs::PlaybackPreferencesStruct::Type> playbackPreferences;
    Optional<bool> useCurrentContext;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    Structs::ContentSearchStruct::DecodableType search;
    bool autoPlay = static_cast<bool>(0);
    Optional<chip::CharSpan> data;
    Optional<Structs::PlaybackPreferencesStruct::DecodableType> playbackPreferences;
    Optional<bool> useCurrentContext;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchContent
namespace LaunchURL {
enum class Fields : uint8_t
{
    kContentURL          = 0,
    kDisplayString       = 1,
    kBrandingInformation = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    chip::CharSpan contentURL;
    Optional<chip::CharSpan> displayString;
    Optional<Structs::BrandingInformationStruct::Type> brandingInformation;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    chip::CharSpan contentURL;
    Optional<chip::CharSpan> displayString;
    Optional<Structs::BrandingInformationStruct::DecodableType> brandingInformation;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchURL
namespace LauncherResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LauncherResponse
} // namespace Commands

namespace Attributes {

namespace AcceptHeader {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcceptHeader::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcceptHeader
namespace SupportedStreamingProtocols {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedStreamingProtocols::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedStreamingProtocols
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AcceptHeader::TypeInfo::DecodableType acceptHeader;
        Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType supportedStreamingProtocols =
            static_cast<chip::BitMask<chip::app::Clusters::ContentLauncher::SupportedProtocolsBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ContentLauncher
namespace AudioOutput {
namespace Structs {
namespace OutputInfoStruct {
enum class Fields : uint8_t
{
    kIndex      = 0,
    kOutputType = 1,
    kName       = 2,
};

struct Type
{
public:
    uint8_t index             = static_cast<uint8_t>(0);
    OutputTypeEnum outputType = static_cast<OutputTypeEnum>(0);
    chip::CharSpan name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace OutputInfoStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectOutput {
struct Type;
struct DecodableType;
} // namespace SelectOutput

namespace RenameOutput {
struct Type;
struct DecodableType;
} // namespace RenameOutput

} // namespace Commands

namespace Commands {
namespace SelectOutput {
enum class Fields : uint8_t
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectOutput
namespace RenameOutput {
enum class Fields : uint8_t
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index = static_cast<uint8_t>(0);
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameOutput
} // namespace Commands

namespace Attributes {

namespace OutputList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AudioOutput::Structs::OutputInfoStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfoStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::OutputInfoStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutputList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutputList
namespace CurrentOutput {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentOutput::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentOutput
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OutputList::TypeInfo::DecodableType outputList;
        Attributes::CurrentOutput::TypeInfo::DecodableType currentOutput = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace AudioOutput
namespace ApplicationLauncher {
namespace Structs {
namespace ApplicationStruct = Clusters::detail::Structs::ApplicationStruct;
namespace ApplicationEPStruct {
enum class Fields : uint8_t
{
    kApplication = 0,
    kEndpoint    = 1,
};

struct Type
{
public:
    Structs::ApplicationStruct::Type application;
    Optional<chip::EndpointId> endpoint;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ApplicationEPStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LaunchApp {
struct Type;
struct DecodableType;
} // namespace LaunchApp

namespace StopApp {
struct Type;
struct DecodableType;
} // namespace StopApp

namespace HideApp {
struct Type;
struct DecodableType;
} // namespace HideApp

namespace LauncherResponse {
struct Type;
struct DecodableType;
} // namespace LauncherResponse

} // namespace Commands

namespace Commands {
namespace LaunchApp {
enum class Fields : uint8_t
{
    kApplication = 0,
    kData        = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::Type> application;
    Optional<chip::ByteSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::DecodableType> application;
    Optional<chip::ByteSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchApp
namespace StopApp {
enum class Fields : uint8_t
{
    kApplication = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::Type> application;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::DecodableType> application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopApp
namespace HideApp {
enum class Fields : uint8_t
{
    kApplication = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::Type> application;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LauncherResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Optional<Structs::ApplicationStruct::DecodableType> application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideApp
namespace LauncherResponse {
enum class Fields : uint8_t
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::ByteSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LauncherResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::ByteSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LauncherResponse
} // namespace Commands

namespace Attributes {

namespace CatalogList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CatalogList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CatalogList
namespace CurrentApp {
struct TypeInfo
{
    using Type = chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEPStruct::Type>;
    using DecodableType =
        chip::app::DataModel::Nullable<chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEPStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::Nullable<
        chip::app::Clusters::ApplicationLauncher::Structs::ApplicationEPStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentApp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentApp
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CatalogList::TypeInfo::DecodableType catalogList;
        Attributes::CurrentApp::TypeInfo::DecodableType currentApp;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ApplicationLauncher
namespace ApplicationBasic {
namespace Structs {
namespace ApplicationStruct = Clusters::detail::Structs::ApplicationStruct;
} // namespace Structs

namespace Attributes {

namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ApplicationName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 256; }
};
} // namespace ApplicationName
namespace ProductID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductID
namespace Application {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ApplicationBasic::Structs::ApplicationStruct::Type;
    using DecodableType    = chip::app::Clusters::ApplicationBasic::Structs::ApplicationStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::ApplicationBasic::Structs::ApplicationStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Application::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Application
namespace Status {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum;
    using DecodableType    = chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum;
    using DecodableArgType = chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Status
namespace ApplicationVersion {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 32; }
};
} // namespace ApplicationVersion
namespace AllowedVendorList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::VendorId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::VendorId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::VendorId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AllowedVendorList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AllowedVendorList
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID = static_cast<chip::VendorId>(0);
        Attributes::ApplicationName::TypeInfo::DecodableType applicationName;
        Attributes::ProductID::TypeInfo::DecodableType productID = static_cast<uint16_t>(0);
        Attributes::Application::TypeInfo::DecodableType application;
        Attributes::Status::TypeInfo::DecodableType status =
            static_cast<chip::app::Clusters::ApplicationBasic::ApplicationStatusEnum>(0);
        Attributes::ApplicationVersion::TypeInfo::DecodableType applicationVersion;
        Attributes::AllowedVendorList::TypeInfo::DecodableType allowedVendorList;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ApplicationBasic
namespace AccountLogin {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetSetupPIN {
struct Type;
struct DecodableType;
} // namespace GetSetupPIN

namespace GetSetupPINResponse {
struct Type;
struct DecodableType;
} // namespace GetSetupPINResponse

namespace Login {
struct Type;
struct DecodableType;
} // namespace Login

namespace Logout {
struct Type;
struct DecodableType;
} // namespace Logout

} // namespace Commands

namespace Commands {
namespace GetSetupPIN {
enum class Fields : uint8_t
{
    kTempAccountIdentifier = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPIN
namespace GetSetupPINResponse {
enum class Fields : uint8_t
{
    kSetupPIN = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan setupPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan setupPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPINResponse
namespace Login {
enum class Fields : uint8_t
{
    kTempAccountIdentifier = 0,
    kSetupPIN              = 1,
    kNode                  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Login::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    chip::CharSpan setupPIN;
    Optional<chip::NodeId> node;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Login::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    chip::CharSpan setupPIN;
    Optional<chip::NodeId> node;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Login
namespace Logout {
enum class Fields : uint8_t
{
    kNode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Logout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    Optional<chip::NodeId> node;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Logout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    Optional<chip::NodeId> node;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Logout
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace LoggedOut {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;

enum class Fields : uint8_t
{
    kNode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoggedOut::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
    static constexpr bool kIsFabricScoped = false;

    Optional<chip::NodeId> node;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::LoggedOut::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    Optional<chip::NodeId> node;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LoggedOut
} // namespace Events
} // namespace AccountLogin
namespace ContentControl {
namespace Structs {
namespace RatingNameStruct {
enum class Fields : uint8_t
{
    kRatingName     = 0,
    kRatingNameDesc = 1,
};

struct Type
{
public:
    chip::CharSpan ratingName;
    Optional<chip::CharSpan> ratingNameDesc;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace RatingNameStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace UpdatePIN {
struct Type;
struct DecodableType;
} // namespace UpdatePIN

namespace ResetPIN {
struct Type;
struct DecodableType;
} // namespace ResetPIN

namespace ResetPINResponse {
struct Type;
struct DecodableType;
} // namespace ResetPINResponse

namespace Enable {
struct Type;
struct DecodableType;
} // namespace Enable

namespace Disable {
struct Type;
struct DecodableType;
} // namespace Disable

namespace AddBonusTime {
struct Type;
struct DecodableType;
} // namespace AddBonusTime

namespace SetScreenDailyTime {
struct Type;
struct DecodableType;
} // namespace SetScreenDailyTime

namespace BlockUnratedContent {
struct Type;
struct DecodableType;
} // namespace BlockUnratedContent

namespace UnblockUnratedContent {
struct Type;
struct DecodableType;
} // namespace UnblockUnratedContent

namespace SetOnDemandRatingThreshold {
struct Type;
struct DecodableType;
} // namespace SetOnDemandRatingThreshold

namespace SetScheduledContentRatingThreshold {
struct Type;
struct DecodableType;
} // namespace SetScheduledContentRatingThreshold

} // namespace Commands

namespace Commands {
namespace UpdatePIN {
enum class Fields : uint8_t
{
    kOldPIN = 0,
    kNewPIN = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdatePIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> oldPIN;
    chip::CharSpan newPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdatePIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> oldPIN;
    chip::CharSpan newPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdatePIN
namespace ResetPIN {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentControl::Commands::ResetPINResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetPIN
namespace ResetPINResponse {
enum class Fields : uint8_t
{
    kPINCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan PINCode;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan PINCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetPINResponse
namespace Enable {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Enable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Enable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Enable
namespace Disable {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Disable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Disable
namespace AddBonusTime {
enum class Fields : uint8_t
{
    kPINCode   = 0,
    kBonusTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddBonusTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> PINCode;
    Optional<uint32_t> bonusTime;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddBonusTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    Optional<chip::CharSpan> PINCode;
    Optional<uint32_t> bonusTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddBonusTime
namespace SetScreenDailyTime {
enum class Fields : uint8_t
{
    kScreenTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetScreenDailyTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    uint32_t screenTime = static_cast<uint32_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetScreenDailyTime::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    uint32_t screenTime = static_cast<uint32_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetScreenDailyTime
namespace BlockUnratedContent {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BlockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BlockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BlockUnratedContent
namespace UnblockUnratedContent {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnblockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnblockUnratedContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnblockUnratedContent
namespace SetOnDemandRatingThreshold {
enum class Fields : uint8_t
{
    kRating = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetOnDemandRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetOnDemandRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetOnDemandRatingThreshold
namespace SetScheduledContentRatingThreshold {
enum class Fields : uint8_t
{
    kRating = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetScheduledContentRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetScheduledContentRatingThreshold::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    chip::CharSpan rating;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetScheduledContentRatingThreshold
} // namespace Commands

namespace Attributes {

namespace Enabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enabled
namespace OnDemandRatings {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ContentControl::Structs::RatingNameStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnDemandRatings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnDemandRatings
namespace OnDemandRatingThreshold {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnDemandRatingThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 8; }
};
} // namespace OnDemandRatingThreshold
namespace ScheduledContentRatings {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ContentControl::Structs::RatingNameStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ContentControl::Structs::RatingNameStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduledContentRatings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduledContentRatings
namespace ScheduledContentRatingThreshold {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduledContentRatingThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 8; }
};
} // namespace ScheduledContentRatingThreshold
namespace ScreenDailyTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScreenDailyTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScreenDailyTime
namespace RemainingScreenTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingScreenTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingScreenTime
namespace BlockUnrated {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BlockUnrated::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BlockUnrated
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Enabled::TypeInfo::DecodableType enabled = static_cast<bool>(0);
        Attributes::OnDemandRatings::TypeInfo::DecodableType onDemandRatings;
        Attributes::OnDemandRatingThreshold::TypeInfo::DecodableType onDemandRatingThreshold;
        Attributes::ScheduledContentRatings::TypeInfo::DecodableType scheduledContentRatings;
        Attributes::ScheduledContentRatingThreshold::TypeInfo::DecodableType scheduledContentRatingThreshold;
        Attributes::ScreenDailyTime::TypeInfo::DecodableType screenDailyTime         = static_cast<uint32_t>(0);
        Attributes::RemainingScreenTime::TypeInfo::DecodableType remainingScreenTime = static_cast<uint32_t>(0);
        Attributes::BlockUnrated::TypeInfo::DecodableType blockUnrated               = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace RemainingScreenTimeExpired {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RemainingScreenTimeExpired::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }
    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::RemainingScreenTimeExpired::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace RemainingScreenTimeExpired
} // namespace Events
} // namespace ContentControl
namespace ContentAppObserver {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ContentAppMessage {
struct Type;
struct DecodableType;
} // namespace ContentAppMessage

namespace ContentAppMessageResponse {
struct Type;
struct DecodableType;
} // namespace ContentAppMessageResponse

} // namespace Commands

namespace Commands {
namespace ContentAppMessage {
enum class Fields : uint8_t
{
    kData         = 0,
    kEncodingHint = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    Optional<chip::CharSpan> data;
    chip::CharSpan encodingHint;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ContentAppObserver::Commands::ContentAppMessageResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    Optional<chip::CharSpan> data;
    chip::CharSpan encodingHint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ContentAppMessage
namespace ContentAppMessageResponse {
enum class Fields : uint8_t
{
    kStatus       = 0,
    kData         = 1,
    kEncodingHint = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    Optional<chip::CharSpan> encodingHint;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ContentAppMessageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

    StatusEnum status = static_cast<StatusEnum>(0);
    Optional<chip::CharSpan> data;
    Optional<chip::CharSpan> encodingHint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ContentAppMessageResponse
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentAppObserver::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace ContentAppObserver
namespace ZoneManagement {
namespace Structs {
namespace TwoDCartesianVertexStruct {
enum class Fields : uint8_t
{
    kX = 0,
    kY = 1,
};

struct Type
{
public:
    uint16_t x = static_cast<uint16_t>(0);
    uint16_t y = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TwoDCartesianVertexStruct
namespace TwoDCartesianZoneStruct {
enum class Fields : uint8_t
{
    kName     = 0,
    kUse      = 1,
    kVertices = 2,
    kColor    = 3,
};

struct Type
{
public:
    chip::CharSpan name;
    ZoneUseEnum use = static_cast<ZoneUseEnum>(0);
    DataModel::List<const Structs::TwoDCartesianVertexStruct::Type> vertices;
    Optional<chip::CharSpan> color;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    chip::CharSpan name;
    ZoneUseEnum use = static_cast<ZoneUseEnum>(0);
    DataModel::DecodableList<Structs::TwoDCartesianVertexStruct::DecodableType> vertices;
    Optional<chip::CharSpan> color;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TwoDCartesianZoneStruct
namespace ZoneInformationStruct {
enum class Fields : uint8_t
{
    kZoneID     = 0,
    kZoneType   = 1,
    kZoneSource = 2,
};

struct Type
{
public:
    uint16_t zoneID           = static_cast<uint16_t>(0);
    ZoneTypeEnum zoneType     = static_cast<ZoneTypeEnum>(0);
    ZoneSourceEnum zoneSource = static_cast<ZoneSourceEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ZoneInformationStruct
namespace ZoneTriggerControlStruct {
enum class Fields : uint8_t
{
    kInitialDuration      = 0,
    kAugmentationDuration = 1,
    kMaxDuration          = 2,
    kBlindDuration        = 3,
    kSensitivity          = 4,
};

struct Type
{
public:
    uint16_t initialDuration      = static_cast<uint16_t>(0);
    uint16_t augmentationDuration = static_cast<uint16_t>(0);
    uint32_t maxDuration          = static_cast<uint32_t>(0);
    uint16_t blindDuration        = static_cast<uint16_t>(0);
    Optional<uint8_t> sensitivity;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ZoneTriggerControlStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace CreateTwoDCartesianZone {
struct Type;
struct DecodableType;
} // namespace CreateTwoDCartesianZone

namespace CreateTwoDCartesianZoneResponse {
struct Type;
struct DecodableType;
} // namespace CreateTwoDCartesianZoneResponse

namespace UpdateTwoDCartesianZone {
struct Type;
struct DecodableType;
} // namespace UpdateTwoDCartesianZone

namespace GetTwoDCartesianZone {
struct Type;
struct DecodableType;
} // namespace GetTwoDCartesianZone

namespace GetTwoDCartesianZoneResponse {
struct Type;
struct DecodableType;
} // namespace GetTwoDCartesianZoneResponse

namespace RemoveZone {
struct Type;
struct DecodableType;
} // namespace RemoveZone

} // namespace Commands

namespace Commands {
namespace CreateTwoDCartesianZone {
enum class Fields : uint8_t
{
    kZone = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CreateTwoDCartesianZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    Structs::TwoDCartesianZoneStruct::Type zone;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ZoneManagement::Commands::CreateTwoDCartesianZoneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CreateTwoDCartesianZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    Structs::TwoDCartesianZoneStruct::DecodableType zone;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CreateTwoDCartesianZone
namespace CreateTwoDCartesianZoneResponse {
enum class Fields : uint8_t
{
    kZoneID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CreateTwoDCartesianZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    uint16_t zoneID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CreateTwoDCartesianZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    uint16_t zoneID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CreateTwoDCartesianZoneResponse
namespace UpdateTwoDCartesianZone {
enum class Fields : uint8_t
{
    kZoneID = 0,
    kZone   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateTwoDCartesianZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    uint16_t zoneID = static_cast<uint16_t>(0);
    Structs::TwoDCartesianZoneStruct::Type zone;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateTwoDCartesianZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    uint16_t zoneID = static_cast<uint16_t>(0);
    Structs::TwoDCartesianZoneStruct::DecodableType zone;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateTwoDCartesianZone
namespace GetTwoDCartesianZone {
enum class Fields : uint8_t
{
    kZoneID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetTwoDCartesianZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    Optional<DataModel::Nullable<uint16_t>> zoneID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::ZoneManagement::Commands::GetTwoDCartesianZoneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetTwoDCartesianZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    Optional<DataModel::Nullable<uint16_t>> zoneID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetTwoDCartesianZone
namespace GetTwoDCartesianZoneResponse {
enum class Fields : uint8_t
{
    kZones = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetTwoDCartesianZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    DataModel::List<const Structs::TwoDCartesianZoneStruct::Type> zones;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetTwoDCartesianZoneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    DataModel::DecodableList<Structs::TwoDCartesianZoneStruct::DecodableType> zones;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetTwoDCartesianZoneResponse
namespace RemoveZone {
enum class Fields : uint8_t
{
    kZoneID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    uint16_t zoneID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveZone::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    uint16_t zoneID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveZone
} // namespace Commands

namespace Attributes {

namespace SupportedZoneSources {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::app::Clusters::ZoneManagement::ZoneSourceEnum>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::app::Clusters::ZoneManagement::ZoneSourceEnum>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::app::Clusters::ZoneManagement::ZoneSourceEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedZoneSources::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedZoneSources
namespace Zones {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ZoneManagement::Structs::ZoneInformationStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ZoneManagement::Structs::ZoneInformationStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ZoneManagement::Structs::ZoneInformationStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Zones::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Zones
namespace Triggers {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ZoneManagement::Structs::ZoneTriggerControlStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ZoneManagement::Structs::ZoneTriggerControlStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ZoneManagement::Structs::ZoneTriggerControlStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Triggers::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Triggers
namespace Sensitivity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Sensitivity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Sensitivity
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedZoneSources::TypeInfo::DecodableType supportedZoneSources;
        Attributes::Zones::TypeInfo::DecodableType zones;
        Attributes::Triggers::TypeInfo::DecodableType triggers;
        Attributes::Sensitivity::TypeInfo::DecodableType sensitivity = static_cast<uint8_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace ZoneTriggered {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kZones  = 0,
    kReason = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ZoneTriggered::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const uint16_t> zones;
    ZoneEventTriggeredReasonEnum reason = static_cast<ZoneEventTriggeredReasonEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ZoneTriggered::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    DataModel::DecodableList<uint16_t> zones;
    ZoneEventTriggeredReasonEnum reason = static_cast<ZoneEventTriggeredReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ZoneTriggered
namespace ZoneStopped {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kZones  = 0,
    kReason = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ZoneStopped::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }
    static constexpr bool kIsFabricScoped = false;

    DataModel::List<const uint16_t> zones;
    ZoneEventStoppedReasonEnum reason = static_cast<ZoneEventStoppedReasonEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::ZoneStopped::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ZoneManagement::Id; }

    DataModel::DecodableList<uint16_t> zones;
    ZoneEventStoppedReasonEnum reason = static_cast<ZoneEventStoppedReasonEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ZoneStopped
} // namespace Events
} // namespace ZoneManagement
namespace CameraAvStreamManagement {
namespace Structs {
namespace VideoResolutionStruct {
enum class Fields : uint8_t
{
    kWidth  = 0,
    kHeight = 1,
};

struct Type
{
public:
    uint16_t width  = static_cast<uint16_t>(0);
    uint16_t height = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace VideoResolutionStruct
namespace VideoStreamStruct {
enum class Fields : uint8_t
{
    kVideoStreamID    = 0,
    kStreamUsage      = 1,
    kVideoCodec       = 2,
    kMinFrameRate     = 3,
    kMaxFrameRate     = 4,
    kMinResolution    = 5,
    kMaxResolution    = 6,
    kMinBitRate       = 7,
    kMaxBitRate       = 8,
    kMinFragmentLen   = 9,
    kMaxFragmentLen   = 10,
    kWatermarkEnabled = 11,
    kOSDEnabled       = 12,
    kReferenceCount   = 13,
};

struct Type
{
public:
    uint16_t videoStreamID      = static_cast<uint16_t>(0);
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    VideoCodecEnum videoCodec   = static_cast<VideoCodecEnum>(0);
    uint16_t minFrameRate       = static_cast<uint16_t>(0);
    uint16_t maxFrameRate       = static_cast<uint16_t>(0);
    Structs::VideoResolutionStruct::Type minResolution;
    Structs::VideoResolutionStruct::Type maxResolution;
    uint32_t minBitRate     = static_cast<uint32_t>(0);
    uint32_t maxBitRate     = static_cast<uint32_t>(0);
    uint16_t minFragmentLen = static_cast<uint16_t>(0);
    uint16_t maxFragmentLen = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;
    uint8_t referenceCount = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace VideoStreamStruct
namespace SnapshotStreamStruct {
enum class Fields : uint8_t
{
    kSnapshotStreamID = 0,
    kImageCodec       = 1,
    kFrameRate        = 2,
    kBitRate          = 3,
    kMinResolution    = 4,
    kMaxResolution    = 5,
    kQuality          = 6,
    kReferenceCount   = 7,
};

struct Type
{
public:
    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    ImageCodecEnum imageCodec = static_cast<ImageCodecEnum>(0);
    uint16_t frameRate        = static_cast<uint16_t>(0);
    uint32_t bitRate          = static_cast<uint32_t>(0);
    Structs::VideoResolutionStruct::Type minResolution;
    Structs::VideoResolutionStruct::Type maxResolution;
    uint8_t quality        = static_cast<uint8_t>(0);
    uint8_t referenceCount = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SnapshotStreamStruct
namespace SnapshotParamsStruct {
enum class Fields : uint8_t
{
    kResolution   = 0,
    kMaxFrameRate = 1,
    kImageCodec   = 2,
};

struct Type
{
public:
    Structs::VideoResolutionStruct::Type resolution;
    uint16_t maxFrameRate     = static_cast<uint16_t>(0);
    ImageCodecEnum imageCodec = static_cast<ImageCodecEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SnapshotParamsStruct
namespace RateDistortionTradeOffPointsStruct {
enum class Fields : uint8_t
{
    kCodec      = 0,
    kResolution = 1,
    kMinBitRate = 2,
};

struct Type
{
public:
    VideoCodecEnum codec = static_cast<VideoCodecEnum>(0);
    Structs::VideoResolutionStruct::Type resolution;
    uint32_t minBitRate = static_cast<uint32_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace RateDistortionTradeOffPointsStruct
namespace AudioCapabilitiesStruct {
enum class Fields : uint8_t
{
    kMaxNumberOfChannels  = 0,
    kSupportedCodecs      = 1,
    kSupportedSampleRates = 2,
    kSupportedBitDepths   = 3,
};

struct Type
{
public:
    uint8_t maxNumberOfChannels = static_cast<uint8_t>(0);
    DataModel::List<const AudioCodecEnum> supportedCodecs;
    DataModel::List<const uint32_t> supportedSampleRates;
    DataModel::List<const uint8_t> supportedBitDepths;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint8_t maxNumberOfChannels = static_cast<uint8_t>(0);
    DataModel::DecodableList<AudioCodecEnum> supportedCodecs;
    DataModel::DecodableList<uint32_t> supportedSampleRates;
    DataModel::DecodableList<uint8_t> supportedBitDepths;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace AudioCapabilitiesStruct
namespace AudioStreamStruct {
enum class Fields : uint8_t
{
    kAudioStreamID  = 0,
    kStreamUsage    = 1,
    kAudioCodec     = 2,
    kChannelCount   = 3,
    kSampleRate     = 4,
    kBitRate        = 5,
    kBitDepth       = 6,
    kReferenceCount = 7,
};

struct Type
{
public:
    uint16_t audioStreamID      = static_cast<uint16_t>(0);
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    AudioCodecEnum audioCodec   = static_cast<AudioCodecEnum>(0);
    uint8_t channelCount        = static_cast<uint8_t>(0);
    uint32_t sampleRate         = static_cast<uint32_t>(0);
    uint32_t bitRate            = static_cast<uint32_t>(0);
    uint8_t bitDepth            = static_cast<uint8_t>(0);
    uint8_t referenceCount      = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace AudioStreamStruct
namespace VideoSensorParamsStruct {
enum class Fields : uint8_t
{
    kSensorWidth  = 0,
    kSensorHeight = 1,
    kMaxFPS       = 2,
    kMaxHDRFPS    = 3,
};

struct Type
{
public:
    uint16_t sensorWidth  = static_cast<uint16_t>(0);
    uint16_t sensorHeight = static_cast<uint16_t>(0);
    uint16_t maxFPS       = static_cast<uint16_t>(0);
    Optional<uint16_t> maxHDRFPS;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace VideoSensorParamsStruct
namespace ViewportStruct = Clusters::detail::Structs::ViewportStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AudioStreamAllocate {
struct Type;
struct DecodableType;
} // namespace AudioStreamAllocate

namespace AudioStreamAllocateResponse {
struct Type;
struct DecodableType;
} // namespace AudioStreamAllocateResponse

namespace AudioStreamDeallocate {
struct Type;
struct DecodableType;
} // namespace AudioStreamDeallocate

namespace VideoStreamAllocate {
struct Type;
struct DecodableType;
} // namespace VideoStreamAllocate

namespace VideoStreamAllocateResponse {
struct Type;
struct DecodableType;
} // namespace VideoStreamAllocateResponse

namespace VideoStreamModify {
struct Type;
struct DecodableType;
} // namespace VideoStreamModify

namespace VideoStreamDeallocate {
struct Type;
struct DecodableType;
} // namespace VideoStreamDeallocate

namespace SnapshotStreamAllocate {
struct Type;
struct DecodableType;
} // namespace SnapshotStreamAllocate

namespace SnapshotStreamAllocateResponse {
struct Type;
struct DecodableType;
} // namespace SnapshotStreamAllocateResponse

namespace SnapshotStreamModify {
struct Type;
struct DecodableType;
} // namespace SnapshotStreamModify

namespace SnapshotStreamDeallocate {
struct Type;
struct DecodableType;
} // namespace SnapshotStreamDeallocate

namespace SetStreamPriorities {
struct Type;
struct DecodableType;
} // namespace SetStreamPriorities

namespace CaptureSnapshot {
struct Type;
struct DecodableType;
} // namespace CaptureSnapshot

namespace CaptureSnapshotResponse {
struct Type;
struct DecodableType;
} // namespace CaptureSnapshotResponse

} // namespace Commands

namespace Commands {
namespace AudioStreamAllocate {
enum class Fields : uint8_t
{
    kStreamUsage  = 0,
    kAudioCodec   = 1,
    kChannelCount = 2,
    kSampleRate   = 3,
    kBitRate      = 4,
    kBitDepth     = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AudioStreamAllocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    AudioCodecEnum audioCodec   = static_cast<AudioCodecEnum>(0);
    uint8_t channelCount        = static_cast<uint8_t>(0);
    uint32_t sampleRate         = static_cast<uint32_t>(0);
    uint32_t bitRate            = static_cast<uint32_t>(0);
    uint8_t bitDepth            = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::CameraAvStreamManagement::Commands::AudioStreamAllocateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AudioStreamAllocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    AudioCodecEnum audioCodec   = static_cast<AudioCodecEnum>(0);
    uint8_t channelCount        = static_cast<uint8_t>(0);
    uint32_t sampleRate         = static_cast<uint32_t>(0);
    uint32_t bitRate            = static_cast<uint32_t>(0);
    uint8_t bitDepth            = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AudioStreamAllocate
namespace AudioStreamAllocateResponse {
enum class Fields : uint8_t
{
    kAudioStreamID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AudioStreamAllocateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t audioStreamID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AudioStreamAllocateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t audioStreamID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AudioStreamAllocateResponse
namespace AudioStreamDeallocate {
enum class Fields : uint8_t
{
    kAudioStreamID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AudioStreamDeallocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t audioStreamID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AudioStreamDeallocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t audioStreamID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AudioStreamDeallocate
namespace VideoStreamAllocate {
enum class Fields : uint8_t
{
    kStreamUsage      = 0,
    kVideoCodec       = 1,
    kMinFrameRate     = 2,
    kMaxFrameRate     = 3,
    kMinResolution    = 4,
    kMaxResolution    = 5,
    kMinBitRate       = 6,
    kMaxBitRate       = 7,
    kMinFragmentLen   = 8,
    kMaxFragmentLen   = 9,
    kWatermarkEnabled = 10,
    kOSDEnabled       = 11,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamAllocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    VideoCodecEnum videoCodec   = static_cast<VideoCodecEnum>(0);
    uint16_t minFrameRate       = static_cast<uint16_t>(0);
    uint16_t maxFrameRate       = static_cast<uint16_t>(0);
    Structs::VideoResolutionStruct::Type minResolution;
    Structs::VideoResolutionStruct::Type maxResolution;
    uint32_t minBitRate     = static_cast<uint32_t>(0);
    uint32_t maxBitRate     = static_cast<uint32_t>(0);
    uint16_t minFragmentLen = static_cast<uint16_t>(0);
    uint16_t maxFragmentLen = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::CameraAvStreamManagement::Commands::VideoStreamAllocateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamAllocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    VideoCodecEnum videoCodec   = static_cast<VideoCodecEnum>(0);
    uint16_t minFrameRate       = static_cast<uint16_t>(0);
    uint16_t maxFrameRate       = static_cast<uint16_t>(0);
    Structs::VideoResolutionStruct::DecodableType minResolution;
    Structs::VideoResolutionStruct::DecodableType maxResolution;
    uint32_t minBitRate     = static_cast<uint32_t>(0);
    uint32_t maxBitRate     = static_cast<uint32_t>(0);
    uint16_t minFragmentLen = static_cast<uint16_t>(0);
    uint16_t maxFragmentLen = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace VideoStreamAllocate
namespace VideoStreamAllocateResponse {
enum class Fields : uint8_t
{
    kVideoStreamID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamAllocateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamAllocateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace VideoStreamAllocateResponse
namespace VideoStreamModify {
enum class Fields : uint8_t
{
    kVideoStreamID    = 0,
    kWatermarkEnabled = 1,
    kOSDEnabled       = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamModify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamModify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace VideoStreamModify
namespace VideoStreamDeallocate {
enum class Fields : uint8_t
{
    kVideoStreamID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamDeallocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::VideoStreamDeallocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace VideoStreamDeallocate
namespace SnapshotStreamAllocate {
enum class Fields : uint8_t
{
    kImageCodec       = 0,
    kMaxFrameRate     = 1,
    kBitRate          = 2,
    kMinResolution    = 3,
    kMaxResolution    = 4,
    kQuality          = 5,
    kWatermarkEnabled = 6,
    kOSDEnabled       = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamAllocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    ImageCodecEnum imageCodec = static_cast<ImageCodecEnum>(0);
    uint16_t maxFrameRate     = static_cast<uint16_t>(0);
    uint32_t bitRate          = static_cast<uint32_t>(0);
    Structs::VideoResolutionStruct::Type minResolution;
    Structs::VideoResolutionStruct::Type maxResolution;
    uint8_t quality = static_cast<uint8_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::CameraAvStreamManagement::Commands::SnapshotStreamAllocateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamAllocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    ImageCodecEnum imageCodec = static_cast<ImageCodecEnum>(0);
    uint16_t maxFrameRate     = static_cast<uint16_t>(0);
    uint32_t bitRate          = static_cast<uint32_t>(0);
    Structs::VideoResolutionStruct::DecodableType minResolution;
    Structs::VideoResolutionStruct::DecodableType maxResolution;
    uint8_t quality = static_cast<uint8_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SnapshotStreamAllocate
namespace SnapshotStreamAllocateResponse {
enum class Fields : uint8_t
{
    kSnapshotStreamID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamAllocateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamAllocateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SnapshotStreamAllocateResponse
namespace SnapshotStreamModify {
enum class Fields : uint8_t
{
    kSnapshotStreamID = 0,
    kWatermarkEnabled = 1,
    kOSDEnabled       = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamModify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamModify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    Optional<bool> watermarkEnabled;
    Optional<bool> OSDEnabled;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SnapshotStreamModify
namespace SnapshotStreamDeallocate {
enum class Fields : uint8_t
{
    kSnapshotStreamID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamDeallocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SnapshotStreamDeallocate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SnapshotStreamDeallocate
namespace SetStreamPriorities {
enum class Fields : uint8_t
{
    kStreamPriorities = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetStreamPriorities::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    DataModel::List<const StreamUsageEnum> streamPriorities;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetStreamPriorities::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    DataModel::DecodableList<StreamUsageEnum> streamPriorities;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetStreamPriorities
namespace CaptureSnapshot {
enum class Fields : uint8_t
{
    kSnapshotStreamID    = 0,
    kRequestedResolution = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CaptureSnapshot::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    Structs::VideoResolutionStruct::Type requestedResolution;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::CameraAvStreamManagement::Commands::CaptureSnapshotResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CaptureSnapshot::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    uint16_t snapshotStreamID = static_cast<uint16_t>(0);
    Structs::VideoResolutionStruct::DecodableType requestedResolution;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CaptureSnapshot
namespace CaptureSnapshotResponse {
enum class Fields : uint8_t
{
    kData       = 0,
    kImageCodec = 1,
    kResolution = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CaptureSnapshotResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    chip::ByteSpan data;
    ImageCodecEnum imageCodec = static_cast<ImageCodecEnum>(0);
    Structs::VideoResolutionStruct::Type resolution;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CaptureSnapshotResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

    chip::ByteSpan data;
    ImageCodecEnum imageCodec = static_cast<ImageCodecEnum>(0);
    Structs::VideoResolutionStruct::DecodableType resolution;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CaptureSnapshotResponse
} // namespace Commands

namespace Attributes {

namespace MaxConcurrentVideoEncoders {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConcurrentVideoEncoders::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConcurrentVideoEncoders
namespace MaxEncodedPixelRate {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxEncodedPixelRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxEncodedPixelRate
namespace VideoSensorParams {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::Structs::VideoSensorParamsStruct::Type;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::Structs::VideoSensorParamsStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::CameraAvStreamManagement::Structs::VideoSensorParamsStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VideoSensorParams::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VideoSensorParams
namespace NightVisionCapable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NightVisionCapable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NightVisionCapable
namespace MinViewport {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::Structs::VideoResolutionStruct::Type;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::Structs::VideoResolutionStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::CameraAvStreamManagement::Structs::VideoResolutionStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinViewport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinViewport
namespace RateDistortionTradeOffPoints {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::CameraAvStreamManagement::Structs::RateDistortionTradeOffPointsStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::RateDistortionTradeOffPointsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::RateDistortionTradeOffPointsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RateDistortionTradeOffPoints::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RateDistortionTradeOffPoints
namespace MaxContentBufferSize {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxContentBufferSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxContentBufferSize
namespace MicrophoneCapabilities {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::Structs::AudioCapabilitiesStruct::Type;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::Structs::AudioCapabilitiesStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::CameraAvStreamManagement::Structs::AudioCapabilitiesStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MicrophoneCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MicrophoneCapabilities
namespace SpeakerCapabilities {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::Structs::AudioCapabilitiesStruct::Type;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::Structs::AudioCapabilitiesStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::CameraAvStreamManagement::Structs::AudioCapabilitiesStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeakerCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeakerCapabilities
namespace TwoWayTalkSupport {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::TwoWayTalkSupportTypeEnum;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::TwoWayTalkSupportTypeEnum;
    using DecodableArgType = chip::app::Clusters::CameraAvStreamManagement::TwoWayTalkSupportTypeEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TwoWayTalkSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TwoWayTalkSupport
namespace SupportedSnapshotParams {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::CameraAvStreamManagement::Structs::SnapshotParamsStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::SnapshotParamsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::SnapshotParamsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedSnapshotParams::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedSnapshotParams
namespace MaxNetworkBandwidth {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxNetworkBandwidth::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxNetworkBandwidth
namespace CurrentFrameRate {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFrameRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFrameRate
namespace HDRModeEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HDRModeEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HDRModeEnabled
namespace SupportedStreamUsages {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::CameraAvStreamManagement::StreamUsageEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::CameraAvStreamManagement::StreamUsageEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::CameraAvStreamManagement::StreamUsageEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedStreamUsages::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedStreamUsages
namespace AllocatedVideoStreams {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::CameraAvStreamManagement::Structs::VideoStreamStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::VideoStreamStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::VideoStreamStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AllocatedVideoStreams::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AllocatedVideoStreams
namespace AllocatedAudioStreams {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::CameraAvStreamManagement::Structs::AudioStreamStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::AudioStreamStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::AudioStreamStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AllocatedAudioStreams::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AllocatedAudioStreams
namespace AllocatedSnapshotStreams {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::CameraAvStreamManagement::Structs::SnapshotStreamStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::SnapshotStreamStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvStreamManagement::Structs::SnapshotStreamStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AllocatedSnapshotStreams::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AllocatedSnapshotStreams
namespace RankedVideoStreamPrioritiesList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::CameraAvStreamManagement::StreamUsageEnum>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::CameraAvStreamManagement::StreamUsageEnum>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::CameraAvStreamManagement::StreamUsageEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RankedVideoStreamPrioritiesList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RankedVideoStreamPrioritiesList
namespace SoftRecordingPrivacyModeEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftRecordingPrivacyModeEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftRecordingPrivacyModeEnabled
namespace SoftLivestreamPrivacyModeEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftLivestreamPrivacyModeEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftLivestreamPrivacyModeEnabled
namespace HardPrivacyModeOn {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardPrivacyModeOn::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardPrivacyModeOn
namespace NightVision {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum;
    using DecodableArgType = chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NightVision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NightVision
namespace NightVisionIllum {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum;
    using DecodableArgType = chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NightVisionIllum::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NightVisionIllum
namespace Viewport {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvStreamManagement::Structs::ViewportStruct::Type;
    using DecodableType    = chip::app::Clusters::CameraAvStreamManagement::Structs::ViewportStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::CameraAvStreamManagement::Structs::ViewportStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Viewport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Viewport
namespace SpeakerMuted {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeakerMuted::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeakerMuted
namespace SpeakerVolumeLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeakerVolumeLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeakerVolumeLevel
namespace SpeakerMaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeakerMaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeakerMaxLevel
namespace SpeakerMinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SpeakerMinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SpeakerMinLevel
namespace MicrophoneMuted {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MicrophoneMuted::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MicrophoneMuted
namespace MicrophoneVolumeLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MicrophoneVolumeLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MicrophoneVolumeLevel
namespace MicrophoneMaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MicrophoneMaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MicrophoneMaxLevel
namespace MicrophoneMinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MicrophoneMinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MicrophoneMinLevel
namespace MicrophoneAGCEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MicrophoneAGCEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MicrophoneAGCEnabled
namespace ImageRotation {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ImageRotation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ImageRotation
namespace ImageFlipHorizontal {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ImageFlipHorizontal::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ImageFlipHorizontal
namespace ImageFlipVertical {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ImageFlipVertical::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ImageFlipVertical
namespace LocalVideoRecordingEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalVideoRecordingEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalVideoRecordingEnabled
namespace LocalSnapshotRecordingEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalSnapshotRecordingEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalSnapshotRecordingEnabled
namespace StatusLightEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StatusLightEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StatusLightEnabled
namespace StatusLightBrightness {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Globals::ThreeLevelAutoEnum;
    using DecodableType    = chip::app::Clusters::Globals::ThreeLevelAutoEnum;
    using DecodableArgType = chip::app::Clusters::Globals::ThreeLevelAutoEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StatusLightBrightness::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StatusLightBrightness
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CameraAvStreamManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxConcurrentVideoEncoders::TypeInfo::DecodableType maxConcurrentVideoEncoders = static_cast<uint8_t>(0);
        Attributes::MaxEncodedPixelRate::TypeInfo::DecodableType maxEncodedPixelRate               = static_cast<uint32_t>(0);
        Attributes::VideoSensorParams::TypeInfo::DecodableType videoSensorParams;
        Attributes::NightVisionCapable::TypeInfo::DecodableType nightVisionCapable = static_cast<bool>(0);
        Attributes::MinViewport::TypeInfo::DecodableType minViewport;
        Attributes::RateDistortionTradeOffPoints::TypeInfo::DecodableType rateDistortionTradeOffPoints;
        Attributes::MaxContentBufferSize::TypeInfo::DecodableType maxContentBufferSize = static_cast<uint32_t>(0);
        Attributes::MicrophoneCapabilities::TypeInfo::DecodableType microphoneCapabilities;
        Attributes::SpeakerCapabilities::TypeInfo::DecodableType speakerCapabilities;
        Attributes::TwoWayTalkSupport::TypeInfo::DecodableType twoWayTalkSupport =
            static_cast<chip::app::Clusters::CameraAvStreamManagement::TwoWayTalkSupportTypeEnum>(0);
        Attributes::SupportedSnapshotParams::TypeInfo::DecodableType supportedSnapshotParams;
        Attributes::MaxNetworkBandwidth::TypeInfo::DecodableType maxNetworkBandwidth = static_cast<uint32_t>(0);
        Attributes::CurrentFrameRate::TypeInfo::DecodableType currentFrameRate       = static_cast<uint16_t>(0);
        Attributes::HDRModeEnabled::TypeInfo::DecodableType HDRModeEnabled           = static_cast<bool>(0);
        Attributes::SupportedStreamUsages::TypeInfo::DecodableType supportedStreamUsages;
        Attributes::AllocatedVideoStreams::TypeInfo::DecodableType allocatedVideoStreams;
        Attributes::AllocatedAudioStreams::TypeInfo::DecodableType allocatedAudioStreams;
        Attributes::AllocatedSnapshotStreams::TypeInfo::DecodableType allocatedSnapshotStreams;
        Attributes::RankedVideoStreamPrioritiesList::TypeInfo::DecodableType rankedVideoStreamPrioritiesList;
        Attributes::SoftRecordingPrivacyModeEnabled::TypeInfo::DecodableType softRecordingPrivacyModeEnabled = static_cast<bool>(0);
        Attributes::SoftLivestreamPrivacyModeEnabled::TypeInfo::DecodableType softLivestreamPrivacyModeEnabled =
            static_cast<bool>(0);
        Attributes::HardPrivacyModeOn::TypeInfo::DecodableType hardPrivacyModeOn = static_cast<bool>(0);
        Attributes::NightVision::TypeInfo::DecodableType nightVision =
            static_cast<chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum>(0);
        Attributes::NightVisionIllum::TypeInfo::DecodableType nightVisionIllum =
            static_cast<chip::app::Clusters::CameraAvStreamManagement::TriStateAutoEnum>(0);
        Attributes::Viewport::TypeInfo::DecodableType viewport;
        Attributes::SpeakerMuted::TypeInfo::DecodableType speakerMuted                                   = static_cast<bool>(0);
        Attributes::SpeakerVolumeLevel::TypeInfo::DecodableType speakerVolumeLevel                       = static_cast<uint8_t>(0);
        Attributes::SpeakerMaxLevel::TypeInfo::DecodableType speakerMaxLevel                             = static_cast<uint8_t>(0);
        Attributes::SpeakerMinLevel::TypeInfo::DecodableType speakerMinLevel                             = static_cast<uint8_t>(0);
        Attributes::MicrophoneMuted::TypeInfo::DecodableType microphoneMuted                             = static_cast<bool>(0);
        Attributes::MicrophoneVolumeLevel::TypeInfo::DecodableType microphoneVolumeLevel                 = static_cast<uint8_t>(0);
        Attributes::MicrophoneMaxLevel::TypeInfo::DecodableType microphoneMaxLevel                       = static_cast<uint8_t>(0);
        Attributes::MicrophoneMinLevel::TypeInfo::DecodableType microphoneMinLevel                       = static_cast<uint8_t>(0);
        Attributes::MicrophoneAGCEnabled::TypeInfo::DecodableType microphoneAGCEnabled                   = static_cast<bool>(0);
        Attributes::ImageRotation::TypeInfo::DecodableType imageRotation                                 = static_cast<uint16_t>(0);
        Attributes::ImageFlipHorizontal::TypeInfo::DecodableType imageFlipHorizontal                     = static_cast<bool>(0);
        Attributes::ImageFlipVertical::TypeInfo::DecodableType imageFlipVertical                         = static_cast<bool>(0);
        Attributes::LocalVideoRecordingEnabled::TypeInfo::DecodableType localVideoRecordingEnabled       = static_cast<bool>(0);
        Attributes::LocalSnapshotRecordingEnabled::TypeInfo::DecodableType localSnapshotRecordingEnabled = static_cast<bool>(0);
        Attributes::StatusLightEnabled::TypeInfo::DecodableType statusLightEnabled                       = static_cast<bool>(0);
        Attributes::StatusLightBrightness::TypeInfo::DecodableType statusLightBrightness =
            static_cast<chip::app::Clusters::Globals::ThreeLevelAutoEnum>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace CameraAvStreamManagement
namespace CameraAvSettingsUserLevelManagement {
namespace Structs {
namespace MPTZStruct {
enum class Fields : uint8_t
{
    kPan  = 0,
    kTilt = 1,
    kZoom = 2,
};

struct Type
{
public:
    Optional<int16_t> pan;
    Optional<int16_t> tilt;
    Optional<uint8_t> zoom;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MPTZStruct
namespace MPTZPresetStruct {
enum class Fields : uint8_t
{
    kPresetID = 0,
    kName     = 1,
    kSettings = 2,
};

struct Type
{
public:
    uint8_t presetID = static_cast<uint8_t>(0);
    chip::CharSpan name;
    Structs::MPTZStruct::Type settings;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MPTZPresetStruct
namespace ViewportStruct = Clusters::detail::Structs::ViewportStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MPTZSetPosition {
struct Type;
struct DecodableType;
} // namespace MPTZSetPosition

namespace MPTZRelativeMove {
struct Type;
struct DecodableType;
} // namespace MPTZRelativeMove

namespace MPTZMoveToPreset {
struct Type;
struct DecodableType;
} // namespace MPTZMoveToPreset

namespace MPTZSavePreset {
struct Type;
struct DecodableType;
} // namespace MPTZSavePreset

namespace MPTZRemovePreset {
struct Type;
struct DecodableType;
} // namespace MPTZRemovePreset

namespace DPTZSetViewport {
struct Type;
struct DecodableType;
} // namespace DPTZSetViewport

namespace DPTZRelativeMove {
struct Type;
struct DecodableType;
} // namespace DPTZRelativeMove

} // namespace Commands

namespace Commands {
namespace MPTZSetPosition {
enum class Fields : uint8_t
{
    kPan  = 0,
    kTilt = 1,
    kZoom = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MPTZSetPosition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    Optional<int16_t> pan;
    Optional<int16_t> tilt;
    Optional<uint8_t> zoom;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MPTZSetPosition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    Optional<int16_t> pan;
    Optional<int16_t> tilt;
    Optional<uint8_t> zoom;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MPTZSetPosition
namespace MPTZRelativeMove {
enum class Fields : uint8_t
{
    kPanDelta  = 0,
    kTiltDelta = 1,
    kZoomDelta = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MPTZRelativeMove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    Optional<int16_t> panDelta;
    Optional<int16_t> tiltDelta;
    Optional<int8_t> zoomDelta;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MPTZRelativeMove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    Optional<int16_t> panDelta;
    Optional<int16_t> tiltDelta;
    Optional<int8_t> zoomDelta;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MPTZRelativeMove
namespace MPTZMoveToPreset {
enum class Fields : uint8_t
{
    kPresetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MPTZMoveToPreset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint8_t presetID = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MPTZMoveToPreset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint8_t presetID = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MPTZMoveToPreset
namespace MPTZSavePreset {
enum class Fields : uint8_t
{
    kPresetID = 0,
    kName     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MPTZSavePreset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    Optional<uint8_t> presetID;
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MPTZSavePreset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    Optional<uint8_t> presetID;
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MPTZSavePreset
namespace MPTZRemovePreset {
enum class Fields : uint8_t
{
    kPresetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MPTZRemovePreset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint8_t presetID = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MPTZRemovePreset::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint8_t presetID = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MPTZRemovePreset
namespace DPTZSetViewport {
enum class Fields : uint8_t
{
    kVideoStreamID = 0,
    kViewport      = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DPTZSetViewport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    Structs::ViewportStruct::Type viewport;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DPTZSetViewport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    Structs::ViewportStruct::DecodableType viewport;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DPTZSetViewport
namespace DPTZRelativeMove {
enum class Fields : uint8_t
{
    kVideoStreamID = 0,
    kDeltaX        = 1,
    kDeltaY        = 2,
    kZoomDelta     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DPTZRelativeMove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    Optional<int16_t> deltaX;
    Optional<int16_t> deltaY;
    Optional<int8_t> zoomDelta;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DPTZRelativeMove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

    uint16_t videoStreamID = static_cast<uint16_t>(0);
    Optional<int16_t> deltaX;
    Optional<int16_t> deltaY;
    Optional<int8_t> zoomDelta;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DPTZRelativeMove
} // namespace Commands

namespace Attributes {

namespace MPTZPosition {
struct TypeInfo
{
    using Type             = chip::app::Clusters::CameraAvSettingsUserLevelManagement::Structs::MPTZStruct::Type;
    using DecodableType    = chip::app::Clusters::CameraAvSettingsUserLevelManagement::Structs::MPTZStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::CameraAvSettingsUserLevelManagement::Structs::MPTZStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MPTZPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MPTZPosition
namespace MaxPresets {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPresets::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPresets
namespace MPTZPresets {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::CameraAvSettingsUserLevelManagement::Structs::MPTZPresetStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvSettingsUserLevelManagement::Structs::MPTZPresetStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::CameraAvSettingsUserLevelManagement::Structs::MPTZPresetStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MPTZPresets::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MPTZPresets
namespace DPTZRelativeMove {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DPTZRelativeMove::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DPTZRelativeMove
namespace ZoomMax {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoomMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ZoomMax
namespace TiltMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TiltMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TiltMin
namespace TiltMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TiltMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TiltMax
namespace PanMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PanMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PanMin
namespace PanMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PanMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PanMax
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CameraAvSettingsUserLevelManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MPTZPosition::TypeInfo::DecodableType MPTZPosition;
        Attributes::MaxPresets::TypeInfo::DecodableType maxPresets = static_cast<uint8_t>(0);
        Attributes::MPTZPresets::TypeInfo::DecodableType MPTZPresets;
        Attributes::DPTZRelativeMove::TypeInfo::DecodableType DPTZRelativeMove;
        Attributes::ZoomMax::TypeInfo::DecodableType zoomMax = static_cast<uint8_t>(0);
        Attributes::TiltMin::TypeInfo::DecodableType tiltMin = static_cast<int16_t>(0);
        Attributes::TiltMax::TypeInfo::DecodableType tiltMax = static_cast<int16_t>(0);
        Attributes::PanMin::TypeInfo::DecodableType panMin   = static_cast<int16_t>(0);
        Attributes::PanMax::TypeInfo::DecodableType panMax   = static_cast<int16_t>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace CameraAvSettingsUserLevelManagement
namespace WebRTCTransportProvider {
namespace Structs {
namespace ICEServerStruct     = Clusters::detail::Structs::ICEServerStruct;
namespace WebRTCSessionStruct = Clusters::detail::Structs::WebRTCSessionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SolicitOffer {
struct Type;
struct DecodableType;
} // namespace SolicitOffer

namespace SolicitOfferResponse {
struct Type;
struct DecodableType;
} // namespace SolicitOfferResponse

namespace ProvideOffer {
struct Type;
struct DecodableType;
} // namespace ProvideOffer

namespace ProvideOfferResponse {
struct Type;
struct DecodableType;
} // namespace ProvideOfferResponse

namespace ProvideAnswer {
struct Type;
struct DecodableType;
} // namespace ProvideAnswer

namespace ProvideICECandidates {
struct Type;
struct DecodableType;
} // namespace ProvideICECandidates

namespace EndSession {
struct Type;
struct DecodableType;
} // namespace EndSession

} // namespace Commands

namespace Commands {
namespace SolicitOffer {
enum class Fields : uint8_t
{
    kStreamUsage        = 0,
    kVideoStreamID      = 1,
    kAudioStreamID      = 2,
    kICEServers         = 3,
    kICETransportPolicy = 4,
    kMetadataOptions    = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SolicitOffer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;
    Optional<DataModel::List<const Structs::ICEServerStruct::Type>> ICEServers;
    Optional<chip::CharSpan> ICETransportPolicy;
    Optional<chip::BitMask<WebRTCMetadataOptionsBitmap>> metadataOptions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::WebRTCTransportProvider::Commands::SolicitOfferResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SolicitOffer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;
    Optional<DataModel::DecodableList<Structs::ICEServerStruct::DecodableType>> ICEServers;
    Optional<chip::CharSpan> ICETransportPolicy;
    Optional<chip::BitMask<WebRTCMetadataOptionsBitmap>> metadataOptions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SolicitOffer
namespace SolicitOfferResponse {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kDeferredOffer   = 1,
    kVideoStreamID   = 2,
    kAudioStreamID   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SolicitOfferResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    bool deferredOffer       = static_cast<bool>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SolicitOfferResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    bool deferredOffer       = static_cast<bool>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SolicitOfferResponse
namespace ProvideOffer {
enum class Fields : uint8_t
{
    kWebRTCSessionID    = 0,
    kSdp                = 1,
    kStreamUsage        = 2,
    kVideoStreamID      = 3,
    kAudioStreamID      = 4,
    kICEServers         = 5,
    kICETransportPolicy = 6,
    kMetadataOptions    = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvideOffer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    DataModel::Nullable<uint16_t> webRTCSessionID;
    chip::CharSpan sdp;
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;
    Optional<DataModel::List<const Structs::ICEServerStruct::Type>> ICEServers;
    Optional<chip::CharSpan> ICETransportPolicy;
    Optional<chip::BitMask<WebRTCMetadataOptionsBitmap>> metadataOptions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::WebRTCTransportProvider::Commands::ProvideOfferResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvideOffer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    DataModel::Nullable<uint16_t> webRTCSessionID;
    chip::CharSpan sdp;
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;
    Optional<DataModel::DecodableList<Structs::ICEServerStruct::DecodableType>> ICEServers;
    Optional<chip::CharSpan> ICETransportPolicy;
    Optional<chip::BitMask<WebRTCMetadataOptionsBitmap>> metadataOptions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvideOffer
namespace ProvideOfferResponse {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kVideoStreamID   = 1,
    kAudioStreamID   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvideOfferResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvideOfferResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    Optional<DataModel::Nullable<uint16_t>> videoStreamID;
    Optional<DataModel::Nullable<uint16_t>> audioStreamID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvideOfferResponse
namespace ProvideAnswer {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kSdp             = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvideAnswer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    chip::CharSpan sdp;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvideAnswer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    chip::CharSpan sdp;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvideAnswer
namespace ProvideICECandidates {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kICECandidates   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvideICECandidates::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    DataModel::List<const chip::CharSpan> ICECandidates;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvideICECandidates::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    DataModel::DecodableList<chip::CharSpan> ICECandidates;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvideICECandidates
namespace EndSession {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kReason          = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EndSession::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID   = static_cast<uint16_t>(0);
    WebRTCEndReasonEnum reason = static_cast<WebRTCEndReasonEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EndSession::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

    uint16_t webRTCSessionID   = static_cast<uint16_t>(0);
    WebRTCEndReasonEnum reason = static_cast<WebRTCEndReasonEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EndSession
} // namespace Commands

namespace Attributes {

namespace CurrentSessions {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::WebRTCTransportProvider::Structs::WebRTCSessionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::WebRTCTransportProvider::Structs::WebRTCSessionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::WebRTCTransportProvider::Structs::WebRTCSessionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSessions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSessions
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportProvider::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentSessions::TypeInfo::DecodableType currentSessions;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WebRTCTransportProvider
namespace WebRTCTransportRequestor {
namespace Structs {
namespace ICEServerStruct     = Clusters::detail::Structs::ICEServerStruct;
namespace WebRTCSessionStruct = Clusters::detail::Structs::WebRTCSessionStruct;
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Offer {
struct Type;
struct DecodableType;
} // namespace Offer

namespace Answer {
struct Type;
struct DecodableType;
} // namespace Answer

namespace ICECandidates {
struct Type;
struct DecodableType;
} // namespace ICECandidates

namespace End {
struct Type;
struct DecodableType;
} // namespace End

} // namespace Commands

namespace Commands {
namespace Offer {
enum class Fields : uint8_t
{
    kWebRTCSessionID    = 0,
    kSdp                = 1,
    kICEServers         = 2,
    kICETransportPolicy = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Offer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    chip::CharSpan sdp;
    Optional<DataModel::List<const Structs::ICEServerStruct::Type>> ICEServers;
    Optional<chip::CharSpan> ICETransportPolicy;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Offer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    chip::CharSpan sdp;
    Optional<DataModel::DecodableList<Structs::ICEServerStruct::DecodableType>> ICEServers;
    Optional<chip::CharSpan> ICETransportPolicy;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Offer
namespace Answer {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kSdp             = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Answer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    chip::CharSpan sdp;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Answer::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    chip::CharSpan sdp;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Answer
namespace ICECandidates {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kICECandidates   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ICECandidates::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    DataModel::List<const chip::CharSpan> ICECandidates;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ICECandidates::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID = static_cast<uint16_t>(0);
    DataModel::DecodableList<chip::CharSpan> ICECandidates;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ICECandidates
namespace End {
enum class Fields : uint8_t
{
    kWebRTCSessionID = 0,
    kReason          = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::End::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID   = static_cast<uint16_t>(0);
    WebRTCEndReasonEnum reason = static_cast<WebRTCEndReasonEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::End::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

    uint16_t webRTCSessionID   = static_cast<uint16_t>(0);
    WebRTCEndReasonEnum reason = static_cast<WebRTCEndReasonEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace End
} // namespace Commands

namespace Attributes {

namespace CurrentSessions {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::WebRTCTransportRequestor::Structs::WebRTCSessionStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::WebRTCTransportRequestor::Structs::WebRTCSessionStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::WebRTCTransportRequestor::Structs::WebRTCSessionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSessions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSessions
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WebRTCTransportRequestor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentSessions::TypeInfo::DecodableType currentSessions;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace WebRTCTransportRequestor
namespace PushAvStreamTransport {
namespace Structs {
namespace TransportMotionTriggerTimeControlStruct {
enum class Fields : uint8_t
{
    kInitialDuration      = 0,
    kAugmentationDuration = 1,
    kMaxDuration          = 2,
    kBlindDuration        = 3,
};

struct Type
{
public:
    uint16_t initialDuration      = static_cast<uint16_t>(0);
    uint16_t augmentationDuration = static_cast<uint16_t>(0);
    uint32_t maxDuration          = static_cast<uint32_t>(0);
    uint16_t blindDuration        = static_cast<uint16_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TransportMotionTriggerTimeControlStruct
namespace TransportZoneOptionsStruct {
enum class Fields : uint8_t
{
    kZone        = 1,
    kSensitivity = 2,
};

struct Type
{
public:
    DataModel::Nullable<uint16_t> zone;
    Optional<uint8_t> sensitivity;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TransportZoneOptionsStruct
namespace MetadataOptionsStruct {
enum class Fields : uint8_t
{
    kMultiplexing                   = 0,
    kIncludeMotionZones             = 1,
    kEnableMetadataPrivacySensitive = 2,
};

struct Type
{
public:
    StreamMultiplexingEnum multiplexing = static_cast<StreamMultiplexingEnum>(0);
    bool includeMotionZones             = static_cast<bool>(0);
    bool enableMetadataPrivacySensitive = static_cast<bool>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace MetadataOptionsStruct
namespace TransportTriggerOptionsStruct {
enum class Fields : uint8_t
{
    kTriggerType       = 0,
    kMotionZones       = 1,
    kMotionSensitivity = 2,
    kMotionTimeControl = 3,
    kMaxPreRollLen     = 4,
};

struct Type
{
public:
    TransportTriggerTypeEnum triggerType = static_cast<TransportTriggerTypeEnum>(0);
    Optional<DataModel::Nullable<DataModel::List<const Structs::TransportZoneOptionsStruct::Type>>> motionZones;
    Optional<DataModel::Nullable<uint8_t>> motionSensitivity;
    Optional<Structs::TransportMotionTriggerTimeControlStruct::Type> motionTimeControl;
    Optional<uint16_t> maxPreRollLen;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    TransportTriggerTypeEnum triggerType = static_cast<TransportTriggerTypeEnum>(0);
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::TransportZoneOptionsStruct::DecodableType>>> motionZones;
    Optional<DataModel::Nullable<uint8_t>> motionSensitivity;
    Optional<Structs::TransportMotionTriggerTimeControlStruct::DecodableType> motionTimeControl;
    Optional<uint16_t> maxPreRollLen;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TransportTriggerOptionsStruct
namespace CMAFContainerOptionsStruct {
enum class Fields : uint8_t
{
    kChunkDuration = 0,
    kCENCKey       = 1,
};

struct Type
{
public:
    uint16_t chunkDuration = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> CENCKey;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace CMAFContainerOptionsStruct
namespace ContainerOptionsStruct {
enum class Fields : uint8_t
{
    kContainerType        = 0,
    kCMAFContainerOptions = 1,
};

struct Type
{
public:
    ContainerFormatEnum containerType = static_cast<ContainerFormatEnum>(0);
    Optional<Structs::CMAFContainerOptionsStruct::Type> CMAFContainerOptions;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ContainerOptionsStruct
namespace TransportOptionsStruct {
enum class Fields : uint8_t
{
    kStreamUsage      = 0,
    kVideoStreamID    = 1,
    kAudioStreamID    = 2,
    kEndpointID       = 3,
    kUrl              = 4,
    kTriggerOptions   = 5,
    kIngestMethod     = 6,
    kContainerFormat  = 7,
    kContainerOptions = 8,
    kMetadataOptions  = 9,
    kExpiryTime       = 10,
};

struct Type
{
public:
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    Optional<uint16_t> videoStreamID;
    Optional<uint16_t> audioStreamID;
    uint16_t endpointID = static_cast<uint16_t>(0);
    chip::CharSpan url;
    Structs::TransportTriggerOptionsStruct::Type triggerOptions;
    IngestMethodsEnum ingestMethod      = static_cast<IngestMethodsEnum>(0);
    ContainerFormatEnum containerFormat = static_cast<ContainerFormatEnum>(0);
    Structs::ContainerOptionsStruct::Type containerOptions;
    Optional<Structs::MetadataOptionsStruct::Type> metadataOptions;
    Optional<uint32_t> expiryTime;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    StreamUsageEnum streamUsage = static_cast<StreamUsageEnum>(0);
    Optional<uint16_t> videoStreamID;
    Optional<uint16_t> audioStreamID;
    uint16_t endpointID = static_cast<uint16_t>(0);
    chip::CharSpan url;
    Structs::TransportTriggerOptionsStruct::DecodableType triggerOptions;
    IngestMethodsEnum ingestMethod      = static_cast<IngestMethodsEnum>(0);
    ContainerFormatEnum containerFormat = static_cast<ContainerFormatEnum>(0);
    Structs::ContainerOptionsStruct::DecodableType containerOptions;
    Optional<Structs::MetadataOptionsStruct::DecodableType> metadataOptions;
    Optional<uint32_t> expiryTime;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TransportOptionsStruct
namespace TransportConfigurationStruct {
enum class Fields : uint8_t
{
    kConnectionID     = 0,
    kTransportStatus  = 1,
    kTransportOptions = 2,
};

struct Type
{
public:
    uint16_t connectionID               = static_cast<uint16_t>(0);
    TransportStatusEnum transportStatus = static_cast<TransportStatusEnum>(0);
    Structs::TransportOptionsStruct::Type transportOptions;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint16_t connectionID               = static_cast<uint16_t>(0);
    TransportStatusEnum transportStatus = static_cast<TransportStatusEnum>(0);
    Structs::TransportOptionsStruct::DecodableType transportOptions;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TransportConfigurationStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AllocatePushTransport {
struct Type;
struct DecodableType;
} // namespace AllocatePushTransport

namespace AllocatePushTransportResponse {
struct Type;
struct DecodableType;
} // namespace AllocatePushTransportResponse

namespace DeallocatePushTransport {
struct Type;
struct DecodableType;
} // namespace DeallocatePushTransport

namespace ModifyPushTransport {
struct Type;
struct DecodableType;
} // namespace ModifyPushTransport

namespace SetTransportStatus {
struct Type;
struct DecodableType;
} // namespace SetTransportStatus

namespace ManuallyTriggerTransport {
struct Type;
struct DecodableType;
} // namespace ManuallyTriggerTransport

namespace FindTransport {
struct Type;
struct DecodableType;
} // namespace FindTransport

namespace FindTransportResponse {
struct Type;
struct DecodableType;
} // namespace FindTransportResponse

} // namespace Commands

namespace Commands {
namespace AllocatePushTransport {
enum class Fields : uint8_t
{
    kTransportOptions = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AllocatePushTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    Structs::TransportOptionsStruct::Type transportOptions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::PushAvStreamTransport::Commands::AllocatePushTransportResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AllocatePushTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    Structs::TransportOptionsStruct::DecodableType transportOptions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AllocatePushTransport
namespace AllocatePushTransportResponse {
enum class Fields : uint8_t
{
    kConnectionID     = 0,
    kTransportOptions = 1,
    kTransportStatus  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AllocatePushTransportResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID = static_cast<uint16_t>(0);
    Structs::TransportOptionsStruct::Type transportOptions;
    TransportStatusEnum transportStatus = static_cast<TransportStatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AllocatePushTransportResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID = static_cast<uint16_t>(0);
    Structs::TransportOptionsStruct::DecodableType transportOptions;
    TransportStatusEnum transportStatus = static_cast<TransportStatusEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AllocatePushTransportResponse
namespace DeallocatePushTransport {
enum class Fields : uint8_t
{
    kConnectionID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DeallocatePushTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DeallocatePushTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DeallocatePushTransport
namespace ModifyPushTransport {
enum class Fields : uint8_t
{
    kConnectionID     = 0,
    kTransportOptions = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ModifyPushTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID = static_cast<uint16_t>(0);
    Structs::TransportOptionsStruct::Type transportOptions;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ModifyPushTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID = static_cast<uint16_t>(0);
    Structs::TransportOptionsStruct::DecodableType transportOptions;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ModifyPushTransport
namespace SetTransportStatus {
enum class Fields : uint8_t
{
    kConnectionID    = 0,
    kTransportStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetTransportStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID               = static_cast<uint16_t>(0);
    TransportStatusEnum transportStatus = static_cast<TransportStatusEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetTransportStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID               = static_cast<uint16_t>(0);
    TransportStatusEnum transportStatus = static_cast<TransportStatusEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetTransportStatus
namespace ManuallyTriggerTransport {
enum class Fields : uint8_t
{
    kConnectionID     = 0,
    kActivationReason = 1,
    kTimeControl      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ManuallyTriggerTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID                        = static_cast<uint16_t>(0);
    TriggerActivationReasonEnum activationReason = static_cast<TriggerActivationReasonEnum>(0);
    Optional<Structs::TransportMotionTriggerTimeControlStruct::Type> timeControl;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ManuallyTriggerTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID                        = static_cast<uint16_t>(0);
    TriggerActivationReasonEnum activationReason = static_cast<TriggerActivationReasonEnum>(0);
    Optional<Structs::TransportMotionTriggerTimeControlStruct::DecodableType> timeControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ManuallyTriggerTransport
namespace FindTransport {
enum class Fields : uint8_t
{
    kConnectionID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    Optional<DataModel::Nullable<uint16_t>> connectionID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::PushAvStreamTransport::Commands::FindTransportResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindTransport::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    Optional<DataModel::Nullable<uint16_t>> connectionID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindTransport
namespace FindTransportResponse {
enum class Fields : uint8_t
{
    kStreamConfigurations = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindTransportResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    DataModel::List<const Structs::TransportConfigurationStruct::Type> streamConfigurations;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindTransportResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    DataModel::DecodableList<Structs::TransportConfigurationStruct::DecodableType> streamConfigurations;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindTransportResponse
} // namespace Commands

namespace Attributes {

namespace SupportedContainerFormats {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedContainerFormatsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedContainerFormatsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedContainerFormatsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedContainerFormats::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedContainerFormats
namespace SupportedIngestMethods {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedIngestMethodsBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedIngestMethodsBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedIngestMethodsBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedIngestMethods::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedIngestMethods
namespace CurrentConnections {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentConnections::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentConnections
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedContainerFormats::TypeInfo::DecodableType supportedContainerFormats =
            static_cast<chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedContainerFormatsBitmap>>(0);
        Attributes::SupportedIngestMethods::TypeInfo::DecodableType supportedIngestMethods =
            static_cast<chip::BitMask<chip::app::Clusters::PushAvStreamTransport::SupportedIngestMethodsBitmap>>(0);
        Attributes::CurrentConnections::TypeInfo::DecodableType currentConnections;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace PushTransportBegin {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kConnectionID     = 0,
    kTriggerType      = 1,
    kActivationReason = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PushTransportBegin::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t connectionID                = static_cast<uint16_t>(0);
    TransportTriggerTypeEnum triggerType = static_cast<TransportTriggerTypeEnum>(0);
    Optional<TriggerActivationReasonEnum> activationReason;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PushTransportBegin::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID                = static_cast<uint16_t>(0);
    TransportTriggerTypeEnum triggerType = static_cast<TransportTriggerTypeEnum>(0);
    Optional<TriggerActivationReasonEnum> activationReason;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PushTransportBegin
namespace PushTransportEnd {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kConnectionID     = 0,
    kTriggerType      = 1,
    kActivationReason = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PushTransportEnd::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint16_t connectionID                = static_cast<uint16_t>(0);
    TransportTriggerTypeEnum triggerType = static_cast<TransportTriggerTypeEnum>(0);
    Optional<TriggerActivationReasonEnum> activationReason;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PushTransportEnd::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PushAvStreamTransport::Id; }

    uint16_t connectionID                = static_cast<uint16_t>(0);
    TransportTriggerTypeEnum triggerType = static_cast<TransportTriggerTypeEnum>(0);
    Optional<TriggerActivationReasonEnum> activationReason;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PushTransportEnd
} // namespace Events
} // namespace PushAvStreamTransport
namespace Chime {
namespace Structs {
namespace ChimeSoundStruct {
enum class Fields : uint8_t
{
    kChimeID = 0,
    kName    = 1,
};

struct Type
{
public:
    uint8_t chimeID = static_cast<uint8_t>(0);
    chip::CharSpan name;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace ChimeSoundStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace PlayChimeSound {
struct Type;
struct DecodableType;
} // namespace PlayChimeSound

} // namespace Commands

namespace Commands {
namespace PlayChimeSound {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PlayChimeSound::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PlayChimeSound::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PlayChimeSound
} // namespace Commands

namespace Attributes {

namespace InstalledChimeSounds {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Chime::Structs::ChimeSoundStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Chime::Structs::ChimeSoundStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Chime::Structs::ChimeSoundStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledChimeSounds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledChimeSounds
namespace SelectedChime {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SelectedChime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SelectedChime
namespace Enabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enabled
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Chime::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::InstalledChimeSounds::TypeInfo::DecodableType installedChimeSounds;
        Attributes::SelectedChime::TypeInfo::DecodableType selectedChime = static_cast<uint8_t>(0);
        Attributes::Enabled::TypeInfo::DecodableType enabled             = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace Chime
namespace EcosystemInformation {
namespace Structs {
namespace DeviceTypeStruct = Clusters::detail::Structs::DeviceTypeStruct;
namespace EcosystemDeviceStruct {
enum class Fields : uint8_t
{
    kDeviceName                = 0,
    kDeviceNameLastEdit        = 1,
    kBridgedEndpoint           = 2,
    kOriginalEndpoint          = 3,
    kDeviceTypes               = 4,
    kUniqueLocationIDs         = 5,
    kUniqueLocationIDsLastEdit = 6,
    kFabricIndex               = 254,
};

struct Type
{
public:
    Optional<chip::CharSpan> deviceName;
    Optional<uint64_t> deviceNameLastEdit;
    chip::EndpointId bridgedEndpoint  = static_cast<chip::EndpointId>(0);
    chip::EndpointId originalEndpoint = static_cast<chip::EndpointId>(0);
    DataModel::List<const Structs::DeviceTypeStruct::Type> deviceTypes;
    DataModel::List<const chip::CharSpan> uniqueLocationIDs;
    uint64_t uniqueLocationIDsLastEdit = static_cast<uint64_t>(0);
    chip::FabricIndex fabricIndex      = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    Optional<chip::CharSpan> deviceName;
    Optional<uint64_t> deviceNameLastEdit;
    chip::EndpointId bridgedEndpoint  = static_cast<chip::EndpointId>(0);
    chip::EndpointId originalEndpoint = static_cast<chip::EndpointId>(0);
    DataModel::DecodableList<Structs::DeviceTypeStruct::DecodableType> deviceTypes;
    DataModel::DecodableList<chip::CharSpan> uniqueLocationIDs;
    uint64_t uniqueLocationIDsLastEdit = static_cast<uint64_t>(0);
    chip::FabricIndex fabricIndex      = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace EcosystemDeviceStruct
namespace EcosystemLocationStruct {
enum class Fields : uint8_t
{
    kUniqueLocationID           = 0,
    kLocationDescriptor         = 1,
    kLocationDescriptorLastEdit = 2,
    kFabricIndex                = 254,
};

struct Type
{
public:
    chip::CharSpan uniqueLocationID;
    Globals::Structs::LocationDescriptorStruct::Type locationDescriptor;
    uint64_t locationDescriptorLastEdit = static_cast<uint64_t>(0);
    chip::FabricIndex fabricIndex       = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

using DecodableType = Type;

} // namespace EcosystemLocationStruct
} // namespace Structs

namespace Attributes {

namespace DeviceDirectory {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::EcosystemInformation::Structs::EcosystemDeviceStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::EcosystemInformation::Structs::EcosystemDeviceStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::EcosystemInformation::Structs::EcosystemDeviceStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceDirectory::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceDirectory
namespace LocationDirectory {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::EcosystemInformation::Structs::EcosystemLocationStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::EcosystemInformation::Structs::EcosystemLocationStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::EcosystemInformation::Structs::EcosystemLocationStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocationDirectory::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocationDirectory
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EcosystemInformation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DeviceDirectory::TypeInfo::DecodableType deviceDirectory;
        Attributes::LocationDirectory::TypeInfo::DecodableType locationDirectory;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace EcosystemInformation
namespace CommissionerControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RequestCommissioningApproval {
struct Type;
struct DecodableType;
} // namespace RequestCommissioningApproval

namespace CommissionNode {
struct Type;
struct DecodableType;
} // namespace CommissionNode

namespace ReverseOpenCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace ReverseOpenCommissioningWindow

} // namespace Commands

namespace Commands {
namespace RequestCommissioningApproval {
enum class Fields : uint8_t
{
    kRequestID = 0,
    kVendorID  = 1,
    kProductID = 2,
    kLabel     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RequestCommissioningApproval::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint64_t requestID      = static_cast<uint64_t>(0);
    chip::VendorId vendorID = static_cast<chip::VendorId>(0);
    uint16_t productID      = static_cast<uint16_t>(0);
    Optional<chip::CharSpan> label;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RequestCommissioningApproval::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint64_t requestID      = static_cast<uint64_t>(0);
    chip::VendorId vendorID = static_cast<chip::VendorId>(0);
    uint16_t productID      = static_cast<uint16_t>(0);
    Optional<chip::CharSpan> label;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RequestCommissioningApproval
namespace CommissionNode {
enum class Fields : uint8_t
{
    kRequestID              = 0,
    kResponseTimeoutSeconds = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissionNode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint64_t requestID              = static_cast<uint64_t>(0);
    uint16_t responseTimeoutSeconds = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::CommissionerControl::Commands::ReverseOpenCommissioningWindow::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissionNode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint64_t requestID              = static_cast<uint64_t>(0);
    uint16_t responseTimeoutSeconds = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissionNode
namespace ReverseOpenCommissioningWindow {
enum class Fields : uint8_t
{
    kCommissioningTimeout = 0,
    kPAKEPasscodeVerifier = 1,
    kDiscriminator        = 2,
    kIterations           = 3,
    kSalt                 = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReverseOpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    chip::ByteSpan PAKEPasscodeVerifier;
    uint16_t discriminator = static_cast<uint16_t>(0);
    uint32_t iterations    = static_cast<uint32_t>(0);
    chip::ByteSpan salt;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReverseOpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint16_t commissioningTimeout = static_cast<uint16_t>(0);
    chip::ByteSpan PAKEPasscodeVerifier;
    uint16_t discriminator = static_cast<uint16_t>(0);
    uint32_t iterations    = static_cast<uint32_t>(0);
    chip::ByteSpan salt;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReverseOpenCommissioningWindow
} // namespace Commands

namespace Attributes {

namespace SupportedDeviceCategories {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::CommissionerControl::SupportedDeviceCategoryBitmap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::CommissionerControl::SupportedDeviceCategoryBitmap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::CommissionerControl::SupportedDeviceCategoryBitmap>;

    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedDeviceCategories::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedDeviceCategories
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SupportedDeviceCategories::TypeInfo::DecodableType supportedDeviceCategories =
            static_cast<chip::BitMask<chip::app::Clusters::CommissionerControl::SupportedDeviceCategoryBitmap>>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace CommissioningRequestResult {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kRequestID    = 0,
    kClientNodeID = 1,
    kStatusCode   = 2,
    kFabricIndex  = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::CommissioningRequestResult::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }
    static constexpr bool kIsFabricScoped = true;

    uint64_t requestID            = static_cast<uint64_t>(0);
    chip::NodeId clientNodeID     = static_cast<chip::NodeId>(0);
    uint8_t statusCode            = static_cast<uint8_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::CommissioningRequestResult::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::CommissionerControl::Id; }

    uint64_t requestID            = static_cast<uint64_t>(0);
    chip::NodeId clientNodeID     = static_cast<chip::NodeId>(0);
    uint8_t statusCode            = static_cast<uint8_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace CommissioningRequestResult
} // namespace Events
} // namespace CommissionerControl
namespace TlsCertificateManagement {
namespace Structs {
namespace TLSCertStruct {
enum class Fields : uint8_t
{
    kCaid        = 0,
    kCertificate = 1,
};

struct Type
{
public:
    uint16_t caid = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> certificate;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TLSCertStruct
namespace TLSClientCertificateDetailStruct {
enum class Fields : uint8_t
{
    kCcdid                    = 0,
    kClientCertificate        = 1,
    kIntermediateCertificates = 2,
};

struct Type
{
public:
    uint16_t ccdid = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> clientCertificate;
    Optional<DataModel::List<const chip::ByteSpan>> intermediateCertificates;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint16_t ccdid = static_cast<uint16_t>(0);
    Optional<chip::ByteSpan> clientCertificate;
    Optional<DataModel::DecodableList<chip::ByteSpan>> intermediateCertificates;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace TLSClientCertificateDetailStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ProvisionRootCertificate {
struct Type;
struct DecodableType;
} // namespace ProvisionRootCertificate

namespace ProvisionRootCertificateResponse {
struct Type;
struct DecodableType;
} // namespace ProvisionRootCertificateResponse

namespace FindRootCertificate {
struct Type;
struct DecodableType;
} // namespace FindRootCertificate

namespace FindRootCertificateResponse {
struct Type;
struct DecodableType;
} // namespace FindRootCertificateResponse

namespace LookupRootCertificate {
struct Type;
struct DecodableType;
} // namespace LookupRootCertificate

namespace LookupRootCertificateResponse {
struct Type;
struct DecodableType;
} // namespace LookupRootCertificateResponse

namespace RemoveRootCertificate {
struct Type;
struct DecodableType;
} // namespace RemoveRootCertificate

namespace TLSClientCSR {
struct Type;
struct DecodableType;
} // namespace TLSClientCSR

namespace TLSClientCSRResponse {
struct Type;
struct DecodableType;
} // namespace TLSClientCSRResponse

namespace ProvisionClientCertificate {
struct Type;
struct DecodableType;
} // namespace ProvisionClientCertificate

namespace FindClientCertificate {
struct Type;
struct DecodableType;
} // namespace FindClientCertificate

namespace FindClientCertificateResponse {
struct Type;
struct DecodableType;
} // namespace FindClientCertificateResponse

namespace LookupClientCertificate {
struct Type;
struct DecodableType;
} // namespace LookupClientCertificate

namespace LookupClientCertificateResponse {
struct Type;
struct DecodableType;
} // namespace LookupClientCertificateResponse

namespace RemoveClientCertificate {
struct Type;
struct DecodableType;
} // namespace RemoveClientCertificate

} // namespace Commands

namespace Commands {
namespace ProvisionRootCertificate {
enum class Fields : uint8_t
{
    kCertificate = 0,
    kCaid        = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvisionRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan certificate;
    DataModel::Nullable<uint16_t> caid;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsCertificateManagement::Commands::ProvisionRootCertificateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvisionRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan certificate;
    DataModel::Nullable<uint16_t> caid;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvisionRootCertificate
namespace ProvisionRootCertificateResponse {
enum class Fields : uint8_t
{
    kCaid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvisionRootCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t caid = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvisionRootCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t caid = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvisionRootCertificateResponse
namespace FindRootCertificate {
enum class Fields : uint8_t
{
    kCaid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::Nullable<uint16_t> caid;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsCertificateManagement::Commands::FindRootCertificateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::Nullable<uint16_t> caid;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindRootCertificate
namespace FindRootCertificateResponse {
enum class Fields : uint8_t
{
    kCertificateDetails = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindRootCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::List<const Structs::TLSCertStruct::Type> certificateDetails;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindRootCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::DecodableList<Structs::TLSCertStruct::DecodableType> certificateDetails;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindRootCertificateResponse
namespace LookupRootCertificate {
enum class Fields : uint8_t
{
    kFingerprint = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LookupRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan fingerprint;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsCertificateManagement::Commands::LookupRootCertificateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LookupRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan fingerprint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LookupRootCertificate
namespace LookupRootCertificateResponse {
enum class Fields : uint8_t
{
    kCaid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LookupRootCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t caid = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LookupRootCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t caid = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LookupRootCertificateResponse
namespace RemoveRootCertificate {
enum class Fields : uint8_t
{
    kCaid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t caid = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t caid = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveRootCertificate
namespace TLSClientCSR {
enum class Fields : uint8_t
{
    kNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TLSClientCSR::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan nonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsCertificateManagement::Commands::TLSClientCSRResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TLSClientCSR::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan nonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TLSClientCSR
namespace TLSClientCSRResponse {
enum class Fields : uint8_t
{
    kCcdid = 0,
    kCsr   = 1,
    kNonce = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TLSClientCSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);
    chip::ByteSpan csr;
    chip::ByteSpan nonce;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TLSClientCSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);
    chip::ByteSpan csr;
    chip::ByteSpan nonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TLSClientCSRResponse
namespace ProvisionClientCertificate {
enum class Fields : uint8_t
{
    kCcdid                    = 0,
    kClientCertificateDetails = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvisionClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);
    Structs::TLSClientCertificateDetailStruct::Type clientCertificateDetails;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvisionClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);
    Structs::TLSClientCertificateDetailStruct::DecodableType clientCertificateDetails;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvisionClientCertificate
namespace FindClientCertificate {
enum class Fields : uint8_t
{
    kCcdid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::Nullable<uint16_t> ccdid;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsCertificateManagement::Commands::FindClientCertificateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::Nullable<uint16_t> ccdid;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindClientCertificate
namespace FindClientCertificateResponse {
enum class Fields : uint8_t
{
    kCertificateDetails = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindClientCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::List<const Structs::TLSClientCertificateDetailStruct::Type> certificateDetails;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindClientCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    DataModel::DecodableList<Structs::TLSClientCertificateDetailStruct::DecodableType> certificateDetails;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindClientCertificateResponse
namespace LookupClientCertificate {
enum class Fields : uint8_t
{
    kFingerprint = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LookupClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan fingerprint;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsCertificateManagement::Commands::LookupClientCertificateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LookupClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    chip::ByteSpan fingerprint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LookupClientCertificate
namespace LookupClientCertificateResponse {
enum class Fields : uint8_t
{
    kCcdid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LookupClientCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LookupClientCertificateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LookupClientCertificateResponse
namespace RemoveClientCertificate {
enum class Fields : uint8_t
{
    kCcdid = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveClientCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

    uint16_t ccdid = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveClientCertificate
} // namespace Commands

namespace Attributes {

namespace MaxRootCertificates {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxRootCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxRootCertificates
namespace ProvisionedRootCertificates {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TlsCertificateManagement::Structs::TLSCertStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TlsCertificateManagement::Structs::TLSCertStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TlsCertificateManagement::Structs::TLSCertStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProvisionedRootCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProvisionedRootCertificates
namespace MaxClientCertificates {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxClientCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxClientCertificates
namespace ProvisionedClientCertificates {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::TlsCertificateManagement::Structs::TLSClientCertificateDetailStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::TlsCertificateManagement::Structs::TLSClientCertificateDetailStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TlsCertificateManagement::Structs::TLSClientCertificateDetailStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProvisionedClientCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProvisionedClientCertificates
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TlsCertificateManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxRootCertificates::TypeInfo::DecodableType maxRootCertificates = static_cast<uint8_t>(0);
        Attributes::ProvisionedRootCertificates::TypeInfo::DecodableType provisionedRootCertificates;
        Attributes::MaxClientCertificates::TypeInfo::DecodableType maxClientCertificates = static_cast<uint8_t>(0);
        Attributes::ProvisionedClientCertificates::TypeInfo::DecodableType provisionedClientCertificates;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TlsCertificateManagement
namespace TlsClientManagement {
namespace Structs {
namespace TLSEndpointStruct {
enum class Fields : uint8_t
{
    kEndpointID = 0,
    kHostname   = 1,
    kPort       = 2,
    kCaid       = 3,
    kCcdid      = 4,
    kStatus     = 5,
};

struct Type
{
public:
    uint16_t endpointID = static_cast<uint16_t>(0);
    chip::ByteSpan hostname;
    uint16_t port = static_cast<uint16_t>(0);
    uint16_t caid = static_cast<uint16_t>(0);
    DataModel::Nullable<uint16_t> ccdid;
    TLSEndpointStatusEnum status = static_cast<TLSEndpointStatusEnum>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TLSEndpointStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ProvisionEndpoint {
struct Type;
struct DecodableType;
} // namespace ProvisionEndpoint

namespace ProvisionEndpointResponse {
struct Type;
struct DecodableType;
} // namespace ProvisionEndpointResponse

namespace FindEndpoint {
struct Type;
struct DecodableType;
} // namespace FindEndpoint

namespace FindEndpointResponse {
struct Type;
struct DecodableType;
} // namespace FindEndpointResponse

namespace RemoveEndpoint {
struct Type;
struct DecodableType;
} // namespace RemoveEndpoint

} // namespace Commands

namespace Commands {
namespace ProvisionEndpoint {
enum class Fields : uint8_t
{
    kHostname   = 0,
    kPort       = 1,
    kCaid       = 2,
    kCcdid      = 3,
    kEndpointID = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvisionEndpoint::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    chip::ByteSpan hostname;
    uint16_t port = static_cast<uint16_t>(0);
    uint16_t caid = static_cast<uint16_t>(0);
    DataModel::Nullable<uint16_t> ccdid;
    DataModel::Nullable<uint16_t> endpointID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsClientManagement::Commands::ProvisionEndpointResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvisionEndpoint::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    chip::ByteSpan hostname;
    uint16_t port = static_cast<uint16_t>(0);
    uint16_t caid = static_cast<uint16_t>(0);
    DataModel::Nullable<uint16_t> ccdid;
    DataModel::Nullable<uint16_t> endpointID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvisionEndpoint
namespace ProvisionEndpointResponse {
enum class Fields : uint8_t
{
    kEndpointID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProvisionEndpointResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    uint16_t endpointID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProvisionEndpointResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    uint16_t endpointID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProvisionEndpointResponse
namespace FindEndpoint {
enum class Fields : uint8_t
{
    kEndpointID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindEndpoint::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    DataModel::Nullable<uint16_t> endpointID;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::TlsClientManagement::Commands::FindEndpointResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindEndpoint::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    DataModel::Nullable<uint16_t> endpointID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindEndpoint
namespace FindEndpointResponse {
enum class Fields : uint8_t
{
    kEndpoints = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FindEndpointResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    DataModel::List<const Structs::TLSEndpointStruct::Type> endpoints;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FindEndpointResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    DataModel::DecodableList<Structs::TLSEndpointStruct::DecodableType> endpoints;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FindEndpointResponse
namespace RemoveEndpoint {
enum class Fields : uint8_t
{
    kEndpointID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveEndpoint::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    uint16_t endpointID = static_cast<uint16_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveEndpoint::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

    uint16_t endpointID = static_cast<uint16_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveEndpoint
} // namespace Commands

namespace Attributes {

namespace MaxProvisioned {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxProvisioned::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxProvisioned
namespace ProvisionedEndpoints {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TlsClientManagement::Structs::TLSEndpointStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TlsClientManagement::Structs::TLSEndpointStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TlsClientManagement::Structs::TLSEndpointStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProvisionedEndpoints::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProvisionedEndpoints
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TlsClientManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxProvisioned::TypeInfo::DecodableType maxProvisioned = static_cast<uint8_t>(0);
        Attributes::ProvisionedEndpoints::TypeInfo::DecodableType provisionedEndpoints;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace TlsClientManagement
namespace UnitTesting {
namespace Structs {
namespace SimpleStruct {
enum class Fields : uint8_t
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
    kE = 4,
    kF = 5,
    kG = 6,
    kH = 7,
    kI = 8,
};

struct Type
{
public:
    uint8_t a    = static_cast<uint8_t>(0);
    bool b       = static_cast<bool>(0);
    SimpleEnum c = static_cast<SimpleEnum>(0);
    chip::ByteSpan d;
    chip::CharSpan e;
    chip::BitMask<SimpleBitmap> f = static_cast<chip::BitMask<SimpleBitmap>>(0);
    float g                       = static_cast<float>(0);
    double h                      = static_cast<double>(0);
    Optional<Globals::TestGlobalEnum> i;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace SimpleStruct
namespace TestFabricScoped {
enum class Fields : uint8_t
{
    kFabricSensitiveInt8u                 = 1,
    kOptionalFabricSensitiveInt8u         = 2,
    kNullableFabricSensitiveInt8u         = 3,
    kNullableOptionalFabricSensitiveInt8u = 4,
    kFabricSensitiveCharString            = 5,
    kFabricSensitiveStruct                = 6,
    kFabricSensitiveInt8uList             = 7,
    kFabricIndex                          = 254,
};

struct Type
{
public:
    uint8_t fabricSensitiveInt8u = static_cast<uint8_t>(0);
    Optional<uint8_t> optionalFabricSensitiveInt8u;
    DataModel::Nullable<uint8_t> nullableFabricSensitiveInt8u;
    Optional<DataModel::Nullable<uint8_t>> nullableOptionalFabricSensitiveInt8u;
    chip::CharSpan fabricSensitiveCharString;
    Structs::SimpleStruct::Type fabricSensitiveStruct;
    DataModel::List<const uint8_t> fabricSensitiveInt8uList;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }

    CHIP_ERROR EncodeForWrite(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
    CHIP_ERROR EncodeForRead(TLV::TLVWriter & aWriter, TLV::Tag aTag, FabricIndex aAccessingFabricIndex) const;

private:
    CHIP_ERROR DoEncode(TLV::TLVWriter & aWriter, TLV::Tag aTag, const Optional<FabricIndex> & aAccessingFabricIndex) const;
};

struct DecodableType
{
public:
    uint8_t fabricSensitiveInt8u = static_cast<uint8_t>(0);
    Optional<uint8_t> optionalFabricSensitiveInt8u;
    DataModel::Nullable<uint8_t> nullableFabricSensitiveInt8u;
    Optional<DataModel::Nullable<uint8_t>> nullableOptionalFabricSensitiveInt8u;
    chip::CharSpan fabricSensitiveCharString;
    Structs::SimpleStruct::DecodableType fabricSensitiveStruct;
    DataModel::DecodableList<uint8_t> fabricSensitiveInt8uList;
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = true;

    auto GetFabricIndex() const { return fabricIndex; }

    void SetFabricIndex(chip::FabricIndex fabricIndex_) { fabricIndex = fabricIndex_; }
};

} // namespace TestFabricScoped
namespace NullablesAndOptionalsStruct {
enum class Fields : uint8_t
{
    kNullableInt            = 0,
    kOptionalInt            = 1,
    kNullableOptionalInt    = 2,
    kNullableString         = 3,
    kOptionalString         = 4,
    kNullableOptionalString = 5,
    kNullableStruct         = 6,
    kOptionalStruct         = 7,
    kNullableOptionalStruct = 8,
    kNullableList           = 9,
    kOptionalList           = 10,
    kNullableOptionalList   = 11,
};

struct Type
{
public:
    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace NullablesAndOptionalsStruct
namespace NestedStruct {
enum class Fields : uint8_t
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
};

struct Type
{
public:
    uint8_t a = static_cast<uint8_t>(0);
    bool b    = static_cast<bool>(0);
    Structs::SimpleStruct::Type c;
    Optional<Globals::Structs::TestGlobalStruct::Type> d;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace NestedStruct
namespace NestedStructList {
enum class Fields : uint8_t
{
    kA = 0,
    kB = 1,
    kC = 2,
    kD = 3,
    kE = 4,
    kF = 5,
    kG = 6,
};

struct Type
{
public:
    uint8_t a = static_cast<uint8_t>(0);
    bool b    = static_cast<bool>(0);
    Structs::SimpleStruct::Type c;
    DataModel::List<const Structs::SimpleStruct::Type> d;
    DataModel::List<const uint32_t> e;
    DataModel::List<const chip::ByteSpan> f;
    DataModel::List<const uint8_t> g;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    uint8_t a = static_cast<uint8_t>(0);
    bool b    = static_cast<bool>(0);
    Structs::SimpleStruct::DecodableType c;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> d;
    DataModel::DecodableList<uint32_t> e;
    DataModel::DecodableList<chip::ByteSpan> f;
    DataModel::DecodableList<uint8_t> g;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace NestedStructList
namespace DoubleNestedStructList {
enum class Fields : uint8_t
{
    kA = 0,
};

struct Type
{
public:
    DataModel::List<const Structs::NestedStructList::Type> a;

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<Structs::NestedStructList::DecodableType> a;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;
};

} // namespace DoubleNestedStructList
namespace TestListStructOctet {
enum class Fields : uint8_t
{
    kMember1 = 0,
    kMember2 = 1,
};

struct Type
{
public:
    uint64_t member1 = static_cast<uint64_t>(0);
    chip::ByteSpan member2;

    CHIP_ERROR Decode(TLV::TLVReader & reader);

    static constexpr bool kIsFabricScoped = false;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

using DecodableType = Type;

} // namespace TestListStructOctet
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Test {
struct Type;
struct DecodableType;
} // namespace Test

namespace TestSpecificResponse {
struct Type;
struct DecodableType;
} // namespace TestSpecificResponse

namespace TestNotHandled {
struct Type;
struct DecodableType;
} // namespace TestNotHandled

namespace TestAddArgumentsResponse {
struct Type;
struct DecodableType;
} // namespace TestAddArgumentsResponse

namespace TestSpecific {
struct Type;
struct DecodableType;
} // namespace TestSpecific

namespace TestSimpleArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentResponse

namespace TestUnknownCommand {
struct Type;
struct DecodableType;
} // namespace TestUnknownCommand

namespace TestStructArrayArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentResponse

namespace TestAddArguments {
struct Type;
struct DecodableType;
} // namespace TestAddArguments

namespace TestListInt8UReverseResponse {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseResponse

namespace TestSimpleArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentRequest

namespace TestEnumsResponse {
struct Type;
struct DecodableType;
} // namespace TestEnumsResponse

namespace TestStructArrayArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentRequest

namespace TestNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalResponse

namespace TestStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArgumentRequest

namespace TestComplexNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalResponse

namespace TestNestedStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructArgumentRequest

namespace BooleanResponse {
struct Type;
struct DecodableType;
} // namespace BooleanResponse

namespace TestListStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListStructArgumentRequest

namespace SimpleStructResponse {
struct Type;
struct DecodableType;
} // namespace SimpleStructResponse

namespace TestListInt8UArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UArgumentRequest

namespace TestEmitTestEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventResponse

namespace TestNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructListArgumentRequest

namespace TestEmitTestFabricScopedEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestFabricScopedEventResponse

namespace TestListNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListNestedStructListArgumentRequest

namespace TestBatchHelperResponse {
struct Type;
struct DecodableType;
} // namespace TestBatchHelperResponse

namespace TestListInt8UReverseRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseRequest

namespace StringEchoResponse {
struct Type;
struct DecodableType;
} // namespace StringEchoResponse

namespace TestEnumsRequest {
struct Type;
struct DecodableType;
} // namespace TestEnumsRequest

namespace GlobalEchoResponse {
struct Type;
struct DecodableType;
} // namespace GlobalEchoResponse

namespace TestNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalRequest

namespace TestComplexNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalRequest

namespace SimpleStructEchoRequest {
struct Type;
struct DecodableType;
} // namespace SimpleStructEchoRequest

namespace TimedInvokeRequest {
struct Type;
struct DecodableType;
} // namespace TimedInvokeRequest

namespace TestSimpleOptionalArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleOptionalArgumentRequest

namespace TestEmitTestEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventRequest

namespace TestEmitTestFabricScopedEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestFabricScopedEventRequest

namespace TestBatchHelperRequest {
struct Type;
struct DecodableType;
} // namespace TestBatchHelperRequest

namespace TestSecondBatchHelperRequest {
struct Type;
struct DecodableType;
} // namespace TestSecondBatchHelperRequest

namespace StringEchoRequest {
struct Type;
struct DecodableType;
} // namespace StringEchoRequest

namespace GlobalEchoRequest {
struct Type;
struct DecodableType;
} // namespace GlobalEchoRequest

namespace TestDifferentVendorMeiRequest {
struct Type;
struct DecodableType;
} // namespace TestDifferentVendorMeiRequest

namespace TestDifferentVendorMeiResponse {
struct Type;
struct DecodableType;
} // namespace TestDifferentVendorMeiResponse

} // namespace Commands

namespace Commands {
namespace Test {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Test
namespace TestSpecificResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecificResponse
namespace TestNotHandled {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNotHandled
namespace TestAddArgumentsResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArgumentsResponse
namespace TestSpecific {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestSpecificResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecific
namespace TestSimpleArgumentResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool returnValue = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool returnValue = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentResponse
namespace TestUnknownCommand {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestUnknownCommand
namespace TestStructArrayArgumentResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentResponse
namespace TestAddArguments {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestAddArgumentsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArguments
namespace TestListInt8UReverseResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseResponse
namespace TestSimpleArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool arg1 = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestSimpleArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool arg1 = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentRequest
namespace TestEnumsResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsResponse
namespace TestStructArrayArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestStructArrayArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5 = static_cast<SimpleEnum>(0);
    bool arg6       = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentRequest
namespace TestNullableOptionalResponse {
enum class Fields : uint8_t
{
    kWasPresent    = 0,
    kWasNull       = 1,
    kValue         = 2,
    kOriginalValue = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool wasPresent = static_cast<bool>(0);
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool wasPresent = static_cast<bool>(0);
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalResponse
namespace TestStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArgumentRequest
namespace TestComplexNullableOptionalResponse {
enum class Fields : uint8_t
{
    kNullableIntWasNull               = 0,
    kNullableIntValue                 = 1,
    kOptionalIntWasPresent            = 2,
    kOptionalIntValue                 = 3,
    kNullableOptionalIntWasPresent    = 4,
    kNullableOptionalIntWasNull       = 5,
    kNullableOptionalIntValue         = 6,
    kNullableStringWasNull            = 7,
    kNullableStringValue              = 8,
    kOptionalStringWasPresent         = 9,
    kOptionalStringValue              = 10,
    kNullableOptionalStringWasPresent = 11,
    kNullableOptionalStringWasNull    = 12,
    kNullableOptionalStringValue      = 13,
    kNullableStructWasNull            = 14,
    kNullableStructValue              = 15,
    kOptionalStructWasPresent         = 16,
    kOptionalStructValue              = 17,
    kNullableOptionalStructWasPresent = 18,
    kNullableOptionalStructWasNull    = 19,
    kNullableOptionalStructValue      = 20,
    kNullableListWasNull              = 21,
    kNullableListValue                = 22,
    kOptionalListWasPresent           = 23,
    kOptionalListValue                = 24,
    kNullableOptionalListWasPresent   = 25,
    kNullableOptionalListWasNull      = 26,
    kNullableOptionalListValue        = 27,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool nullableIntWasNull = static_cast<bool>(0);
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent = static_cast<bool>(0);
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull = static_cast<bool>(0);
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent = static_cast<bool>(0);
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::Type> nullableStructValue;
    bool optionalStructWasPresent = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::Type> optionalStructValue;
    bool nullableOptionalStructWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::Type> nullableOptionalStructValue;
    bool nullableListWasNull = static_cast<bool>(0);
    Optional<DataModel::List<const SimpleEnum>> nullableListValue;
    bool optionalListWasPresent = static_cast<bool>(0);
    Optional<DataModel::List<const SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::List<const SimpleEnum>> nullableOptionalListValue;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool nullableIntWasNull = static_cast<bool>(0);
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent = static_cast<bool>(0);
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull = static_cast<bool>(0);
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent = static_cast<bool>(0);
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::DecodableType> nullableStructValue;
    bool optionalStructWasPresent = static_cast<bool>(0);
    Optional<Structs::SimpleStruct::DecodableType> optionalStructValue;
    bool nullableOptionalStructWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::DecodableType> nullableOptionalStructValue;
    bool nullableListWasNull = static_cast<bool>(0);
    Optional<DataModel::DecodableList<SimpleEnum>> nullableListValue;
    bool optionalListWasPresent = static_cast<bool>(0);
    Optional<DataModel::DecodableList<SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent = static_cast<bool>(0);
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::DecodableList<SimpleEnum>> nullableOptionalListValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalResponse
namespace TestNestedStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructArgumentRequest
namespace BooleanResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool value = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    bool value = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BooleanResponse
namespace TestListStructArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::SimpleStruct::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListStructArgumentRequest
namespace SimpleStructResponse {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructResponse
namespace TestListInt8UArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UArgumentRequest
namespace TestEmitTestEventResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventResponse
namespace TestNestedStructListArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStructList::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::NestedStructList::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructListArgumentRequest
namespace TestEmitTestFabricScopedEventResponse {
enum class Fields : uint8_t
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint64_t value = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestFabricScopedEventResponse
namespace TestListNestedStructListArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListNestedStructListArgumentRequest
namespace TestBatchHelperResponse {
enum class Fields : uint8_t
{
    kBuffer = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan buffer;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan buffer;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestBatchHelperResponse
namespace TestListInt8UReverseRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestListInt8UReverseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseRequest
namespace StringEchoResponse {
enum class Fields : uint8_t
{
    kPayload = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StringEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StringEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StringEchoResponse
namespace TestEnumsRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEnumsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::VendorId arg1 = static_cast<chip::VendorId>(0);
    SimpleEnum arg2     = static_cast<SimpleEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsRequest
namespace GlobalEchoResponse {
enum class Fields : uint8_t
{
    kField1 = 0,
    kField2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::Type field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::DecodableType field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GlobalEchoResponse
namespace TestNullableOptionalRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalRequest
namespace TestComplexNullableOptionalRequest {
enum class Fields : uint8_t
{
    kNullableInt            = 0,
    kOptionalInt            = 1,
    kNullableOptionalInt    = 2,
    kNullableString         = 3,
    kOptionalString         = 4,
    kNullableOptionalString = 5,
    kNullableStruct         = 6,
    kOptionalStruct         = 7,
    kNullableOptionalStruct = 8,
    kNullableList           = 9,
    kOptionalList           = 10,
    kNullableOptionalList   = 11,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestComplexNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalRequest
namespace SimpleStructEchoRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::SimpleStructResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructEchoRequest
namespace TimedInvokeRequest {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimedInvokeRequest
namespace TestSimpleOptionalArgumentRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<bool> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Optional<bool> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleOptionalArgumentRequest
namespace TestEmitTestEventRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEmitTestEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventRequest
namespace TestEmitTestFabricScopedEventRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestEmitTestFabricScopedEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestFabricScopedEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestFabricScopedEventRequest
namespace TestBatchHelperRequest {
enum class Fields : uint8_t
{
    kSleepBeforeResponseTimeMs = 0,
    kSizeOfResponseBuffer      = 1,
    kFillCharacter             = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestBatchHelperResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestBatchHelperRequest
namespace TestSecondBatchHelperRequest {
enum class Fields : uint8_t
{
    kSleepBeforeResponseTimeMs = 0,
    kSizeOfResponseBuffer      = 1,
    kFillCharacter             = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSecondBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestBatchHelperResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSecondBatchHelperRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint16_t sleepBeforeResponseTimeMs = static_cast<uint16_t>(0);
    uint16_t sizeOfResponseBuffer      = static_cast<uint16_t>(0);
    uint8_t fillCharacter              = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSecondBatchHelperRequest
namespace StringEchoRequest {
enum class Fields : uint8_t
{
    kPayload = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StringEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::StringEchoResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StringEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::ByteSpan payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StringEchoRequest
namespace GlobalEchoRequest {
enum class Fields : uint8_t
{
    kField1 = 0,
    kField2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::Type field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::GlobalEchoResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GlobalEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    Globals::Structs::TestGlobalStruct::DecodableType field1;
    Globals::TestGlobalEnum field2 = static_cast<Globals::TestGlobalEnum>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GlobalEchoRequest
namespace TestDifferentVendorMeiRequest {
enum class Fields : uint8_t
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::UnitTesting::Commands::TestDifferentVendorMeiResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestDifferentVendorMeiRequest
namespace TestDifferentVendorMeiResponse {
enum class Fields : uint8_t
{
    kArg1        = 0,
    kEventNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1         = static_cast<uint8_t>(0);
    uint64_t eventNumber = static_cast<uint64_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestDifferentVendorMeiResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1         = static_cast<uint8_t>(0);
    uint64_t eventNumber = static_cast<uint64_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestDifferentVendorMeiResponse
} // namespace Commands

namespace Attributes {

namespace Boolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Boolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Boolean
namespace Bitmap8 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap8
namespace Bitmap16 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap16
namespace Bitmap32 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap32::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap32
namespace Bitmap64 {
struct TypeInfo
{
    using Type             = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>;
    using DecodableType    = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>;
    using DecodableArgType = chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap64::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap64
namespace Int8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int8u
namespace Int16u {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int16u
namespace Int24u {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int24u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int24u
namespace Int32u {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int32u
namespace Int40u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int40u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int40u
namespace Int48u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int48u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int48u
namespace Int56u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int56u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int56u
namespace Int64u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int64u
namespace Int8s {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int8s
namespace Int16s {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int16s
namespace Int24s {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int24s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int24s
namespace Int32s {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int32s
namespace Int40s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int40s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int40s
namespace Int48s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int48s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int48s
namespace Int56s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int56s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int56s
namespace Int64s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int64s
namespace Enum8 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enum8
namespace Enum16 {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enum16
namespace FloatSingle {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FloatSingle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FloatSingle
namespace FloatDouble {
struct TypeInfo
{
    using Type             = double;
    using DecodableType    = double;
    using DecodableArgType = double;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FloatDouble::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FloatDouble
namespace OctetString {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace OctetString
namespace ListInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListInt8u
namespace ListOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListOctetString
namespace ListStructOctetString {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::UnitTesting::Structs::TestListStructOctet::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestListStructOctet::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestListStructOctet::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListStructOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListStructOctetString
namespace LongOctetString {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 1000; }
};
} // namespace LongOctetString
namespace CharString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace CharString
namespace LongCharString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongCharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 1000; }
};
} // namespace LongCharString
namespace EpochUs {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochUs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EpochUs
namespace EpochS {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochS::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EpochS
namespace VendorId {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorId
namespace ListNullablesAndOptionalsStruct {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::UnitTesting::Structs::NullablesAndOptionalsStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::NullablesAndOptionalsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::UnitTesting::Structs::NullablesAndOptionalsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListNullablesAndOptionalsStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListNullablesAndOptionalsStruct
namespace EnumAttr {
struct TypeInfo
{
    using Type             = chip::app::Clusters::UnitTesting::SimpleEnum;
    using DecodableType    = chip::app::Clusters::UnitTesting::SimpleEnum;
    using DecodableArgType = chip::app::Clusters::UnitTesting::SimpleEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnumAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnumAttr
namespace StructAttr {
struct TypeInfo
{
    using Type             = chip::app::Clusters::UnitTesting::Structs::SimpleStruct::Type;
    using DecodableType    = chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StructAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StructAttr
namespace RangeRestrictedInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt8u
namespace RangeRestrictedInt8s {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt8s
namespace RangeRestrictedInt16u {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt16u
namespace RangeRestrictedInt16s {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt16s
namespace ListLongOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListLongOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListLongOctetString
namespace ListFabricScoped {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::UnitTesting::Structs::TestFabricScoped::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestFabricScoped::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UnitTesting::Structs::TestFabricScoped::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListFabricScoped::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListFabricScoped
namespace TimedWriteBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimedWriteBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return true; }
};
} // namespace TimedWriteBoolean
namespace GeneralErrorBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GeneralErrorBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GeneralErrorBoolean
namespace ClusterErrorBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterErrorBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterErrorBoolean
namespace GlobalEnum {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Globals::TestGlobalEnum;
    using DecodableType    = chip::app::Clusters::Globals::TestGlobalEnum;
    using DecodableArgType = chip::app::Clusters::Globals::TestGlobalEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GlobalEnum::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GlobalEnum
namespace GlobalStruct {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Globals::Structs::TestGlobalStruct::Type;
    using DecodableType    = chip::app::Clusters::Globals::Structs::TestGlobalStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::Globals::Structs::TestGlobalStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GlobalStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GlobalStruct
namespace Unsupported {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Unsupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Unsupported
namespace ReadFailureCode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReadFailureCode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReadFailureCode
namespace FailureInt32U {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FailureInt32U::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FailureInt32U
namespace NullableBoolean {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBoolean
namespace NullableBitmap8 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap8
namespace NullableBitmap16 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap16
namespace NullableBitmap32 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap32::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap32
namespace NullableBitmap64 {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>>;
    using DecodableType = chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap64::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap64
namespace NullableInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt8u
namespace NullableInt16u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt16u
namespace NullableInt24u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt24u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt24u
namespace NullableInt32u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt32u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt32u
namespace NullableInt40u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt40u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt40u
namespace NullableInt48u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt48u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt48u
namespace NullableInt56u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt56u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt56u
namespace NullableInt64u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt64u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt64u
namespace NullableInt8s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt8s
namespace NullableInt16s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt16s
namespace NullableInt24s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt24s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt24s
namespace NullableInt32s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt32s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt32s
namespace NullableInt40s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt40s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt40s
namespace NullableInt48s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt48s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt48s
namespace NullableInt56s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt56s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt56s
namespace NullableInt64s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt64s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt64s
namespace NullableEnum8 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnum8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnum8
namespace NullableEnum16 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnum16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnum16
namespace NullableFloatSingle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableFloatSingle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableFloatSingle
namespace NullableFloatDouble {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<double>;
    using DecodableType    = chip::app::DataModel::Nullable<double>;
    using DecodableArgType = const chip::app::DataModel::Nullable<double> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableFloatDouble::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableFloatDouble
namespace NullableOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace NullableOctetString
namespace NullableCharString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableCharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
    static constexpr size_t MaxLength() { return 10; }
};
} // namespace NullableCharString
namespace NullableEnumAttr {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::SimpleEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnumAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnumAttr
namespace NullableStruct {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::Structs::SimpleStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::UnitTesting::Structs::SimpleStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableStruct
namespace NullableRangeRestrictedInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt8u
namespace NullableRangeRestrictedInt8s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt8s
namespace NullableRangeRestrictedInt16u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt16u
namespace NullableRangeRestrictedInt16s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt16s
namespace WriteOnlyInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WriteOnlyInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WriteOnlyInt8u
namespace NullableGlobalEnum {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::Globals::TestGlobalEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::Globals::TestGlobalEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::Globals::TestGlobalEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableGlobalEnum::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableGlobalEnum
namespace NullableGlobalStruct {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::Globals::Structs::TestGlobalStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::Globals::Structs::TestGlobalStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::Globals::Structs::TestGlobalStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableGlobalStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableGlobalStruct
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
};
} // namespace ClusterRevision
namespace MeiInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeiInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeiInt8u

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Boolean::TypeInfo::DecodableType boolean = static_cast<bool>(0);
        Attributes::Bitmap8::TypeInfo::DecodableType bitmap8 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap8MaskMap>>(0);
        Attributes::Bitmap16::TypeInfo::DecodableType bitmap16 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap16MaskMap>>(0);
        Attributes::Bitmap32::TypeInfo::DecodableType bitmap32 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap32MaskMap>>(0);
        Attributes::Bitmap64::TypeInfo::DecodableType bitmap64 =
            static_cast<chip::BitMask<chip::app::Clusters::UnitTesting::Bitmap64MaskMap>>(0);
        Attributes::Int8u::TypeInfo::DecodableType int8u             = static_cast<uint8_t>(0);
        Attributes::Int16u::TypeInfo::DecodableType int16u           = static_cast<uint16_t>(0);
        Attributes::Int24u::TypeInfo::DecodableType int24u           = static_cast<uint32_t>(0);
        Attributes::Int32u::TypeInfo::DecodableType int32u           = static_cast<uint32_t>(0);
        Attributes::Int40u::TypeInfo::DecodableType int40u           = static_cast<uint64_t>(0);
        Attributes::Int48u::TypeInfo::DecodableType int48u           = static_cast<uint64_t>(0);
        Attributes::Int56u::TypeInfo::DecodableType int56u           = static_cast<uint64_t>(0);
        Attributes::Int64u::TypeInfo::DecodableType int64u           = static_cast<uint64_t>(0);
        Attributes::Int8s::TypeInfo::DecodableType int8s             = static_cast<int8_t>(0);
        Attributes::Int16s::TypeInfo::DecodableType int16s           = static_cast<int16_t>(0);
        Attributes::Int24s::TypeInfo::DecodableType int24s           = static_cast<int32_t>(0);
        Attributes::Int32s::TypeInfo::DecodableType int32s           = static_cast<int32_t>(0);
        Attributes::Int40s::TypeInfo::DecodableType int40s           = static_cast<int64_t>(0);
        Attributes::Int48s::TypeInfo::DecodableType int48s           = static_cast<int64_t>(0);
        Attributes::Int56s::TypeInfo::DecodableType int56s           = static_cast<int64_t>(0);
        Attributes::Int64s::TypeInfo::DecodableType int64s           = static_cast<int64_t>(0);
        Attributes::Enum8::TypeInfo::DecodableType enum8             = static_cast<uint8_t>(0);
        Attributes::Enum16::TypeInfo::DecodableType enum16           = static_cast<uint16_t>(0);
        Attributes::FloatSingle::TypeInfo::DecodableType floatSingle = static_cast<float>(0);
        Attributes::FloatDouble::TypeInfo::DecodableType floatDouble = static_cast<double>(0);
        Attributes::OctetString::TypeInfo::DecodableType octetString;
        Attributes::ListInt8u::TypeInfo::DecodableType listInt8u;
        Attributes::ListOctetString::TypeInfo::DecodableType listOctetString;
        Attributes::ListStructOctetString::TypeInfo::DecodableType listStructOctetString;
        Attributes::LongOctetString::TypeInfo::DecodableType longOctetString;
        Attributes::CharString::TypeInfo::DecodableType charString;
        Attributes::LongCharString::TypeInfo::DecodableType longCharString;
        Attributes::EpochUs::TypeInfo::DecodableType epochUs   = static_cast<uint64_t>(0);
        Attributes::EpochS::TypeInfo::DecodableType epochS     = static_cast<uint32_t>(0);
        Attributes::VendorId::TypeInfo::DecodableType vendorId = static_cast<chip::VendorId>(0);
        Attributes::ListNullablesAndOptionalsStruct::TypeInfo::DecodableType listNullablesAndOptionalsStruct;
        Attributes::EnumAttr::TypeInfo::DecodableType enumAttr = static_cast<chip::app::Clusters::UnitTesting::SimpleEnum>(0);
        Attributes::StructAttr::TypeInfo::DecodableType structAttr;
        Attributes::RangeRestrictedInt8u::TypeInfo::DecodableType rangeRestrictedInt8u   = static_cast<uint8_t>(0);
        Attributes::RangeRestrictedInt8s::TypeInfo::DecodableType rangeRestrictedInt8s   = static_cast<int8_t>(0);
        Attributes::RangeRestrictedInt16u::TypeInfo::DecodableType rangeRestrictedInt16u = static_cast<uint16_t>(0);
        Attributes::RangeRestrictedInt16s::TypeInfo::DecodableType rangeRestrictedInt16s = static_cast<int16_t>(0);
        Attributes::ListLongOctetString::TypeInfo::DecodableType listLongOctetString;
        Attributes::ListFabricScoped::TypeInfo::DecodableType listFabricScoped;
        Attributes::TimedWriteBoolean::TypeInfo::DecodableType timedWriteBoolean     = static_cast<bool>(0);
        Attributes::GeneralErrorBoolean::TypeInfo::DecodableType generalErrorBoolean = static_cast<bool>(0);
        Attributes::ClusterErrorBoolean::TypeInfo::DecodableType clusterErrorBoolean = static_cast<bool>(0);
        Attributes::GlobalEnum::TypeInfo::DecodableType globalEnum = static_cast<chip::app::Clusters::Globals::TestGlobalEnum>(0);
        Attributes::GlobalStruct::TypeInfo::DecodableType globalStruct;
        Attributes::Unsupported::TypeInfo::DecodableType unsupported         = static_cast<bool>(0);
        Attributes::ReadFailureCode::TypeInfo::DecodableType readFailureCode = static_cast<uint8_t>(0);
        Attributes::FailureInt32U::TypeInfo::DecodableType failureInt32U     = static_cast<uint32_t>(0);
        Attributes::NullableBoolean::TypeInfo::DecodableType nullableBoolean;
        Attributes::NullableBitmap8::TypeInfo::DecodableType nullableBitmap8;
        Attributes::NullableBitmap16::TypeInfo::DecodableType nullableBitmap16;
        Attributes::NullableBitmap32::TypeInfo::DecodableType nullableBitmap32;
        Attributes::NullableBitmap64::TypeInfo::DecodableType nullableBitmap64;
        Attributes::NullableInt8u::TypeInfo::DecodableType nullableInt8u;
        Attributes::NullableInt16u::TypeInfo::DecodableType nullableInt16u;
        Attributes::NullableInt24u::TypeInfo::DecodableType nullableInt24u;
        Attributes::NullableInt32u::TypeInfo::DecodableType nullableInt32u;
        Attributes::NullableInt40u::TypeInfo::DecodableType nullableInt40u;
        Attributes::NullableInt48u::TypeInfo::DecodableType nullableInt48u;
        Attributes::NullableInt56u::TypeInfo::DecodableType nullableInt56u;
        Attributes::NullableInt64u::TypeInfo::DecodableType nullableInt64u;
        Attributes::NullableInt8s::TypeInfo::DecodableType nullableInt8s;
        Attributes::NullableInt16s::TypeInfo::DecodableType nullableInt16s;
        Attributes::NullableInt24s::TypeInfo::DecodableType nullableInt24s;
        Attributes::NullableInt32s::TypeInfo::DecodableType nullableInt32s;
        Attributes::NullableInt40s::TypeInfo::DecodableType nullableInt40s;
        Attributes::NullableInt48s::TypeInfo::DecodableType nullableInt48s;
        Attributes::NullableInt56s::TypeInfo::DecodableType nullableInt56s;
        Attributes::NullableInt64s::TypeInfo::DecodableType nullableInt64s;
        Attributes::NullableEnum8::TypeInfo::DecodableType nullableEnum8;
        Attributes::NullableEnum16::TypeInfo::DecodableType nullableEnum16;
        Attributes::NullableFloatSingle::TypeInfo::DecodableType nullableFloatSingle;
        Attributes::NullableFloatDouble::TypeInfo::DecodableType nullableFloatDouble;
        Attributes::NullableOctetString::TypeInfo::DecodableType nullableOctetString;
        Attributes::NullableCharString::TypeInfo::DecodableType nullableCharString;
        Attributes::NullableEnumAttr::TypeInfo::DecodableType nullableEnumAttr;
        Attributes::NullableStruct::TypeInfo::DecodableType nullableStruct;
        Attributes::NullableRangeRestrictedInt8u::TypeInfo::DecodableType nullableRangeRestrictedInt8u;
        Attributes::NullableRangeRestrictedInt8s::TypeInfo::DecodableType nullableRangeRestrictedInt8s;
        Attributes::NullableRangeRestrictedInt16u::TypeInfo::DecodableType nullableRangeRestrictedInt16u;
        Attributes::NullableRangeRestrictedInt16s::TypeInfo::DecodableType nullableRangeRestrictedInt16s;
        Attributes::WriteOnlyInt8u::TypeInfo::DecodableType writeOnlyInt8u = static_cast<uint8_t>(0);
        Attributes::NullableGlobalEnum::TypeInfo::DecodableType nullableGlobalEnum;
        Attributes::NullableGlobalStruct::TypeInfo::DecodableType nullableGlobalStruct;
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
        Attributes::MeiInt8u::TypeInfo::DecodableType meiInt8u               = static_cast<uint8_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace TestEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kArg1 = 1,
    kArg2 = 2,
    kArg3 = 3,
    kArg4 = 4,
    kArg5 = 5,
    kArg6 = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);
    Structs::SimpleStruct::Type arg4;
    DataModel::List<const Structs::SimpleStruct::Type> arg5;
    DataModel::List<const SimpleEnum> arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1    = static_cast<uint8_t>(0);
    SimpleEnum arg2 = static_cast<SimpleEnum>(0);
    bool arg3       = static_cast<bool>(0);
    Structs::SimpleStruct::DecodableType arg4;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg5;
    DataModel::DecodableList<SimpleEnum> arg6;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestEvent
namespace TestFabricScopedEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kFabricIndex = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestFabricScopedEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = true;

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestFabricScopedEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestFabricScopedEvent
namespace TestDifferentVendorMeiEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kArg1 = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestDifferentVendorMeiEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }
    static constexpr bool kIsFabricScoped = false;

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::TestDifferentVendorMeiEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::UnitTesting::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestDifferentVendorMeiEvent
} // namespace Events
} // namespace UnitTesting
namespace FaultInjection {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace FailAtFault {
struct Type;
struct DecodableType;
} // namespace FailAtFault

namespace FailRandomlyAtFault {
struct Type;
struct DecodableType;
} // namespace FailRandomlyAtFault

} // namespace Commands

namespace Commands {
namespace FailAtFault {
enum class Fields : uint8_t
{
    kType           = 0,
    kId             = 1,
    kNumCallsToSkip = 2,
    kNumCallsToFail = 3,
    kTakeMutex      = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FailAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type          = static_cast<FaultType>(0);
    uint32_t id             = static_cast<uint32_t>(0);
    uint32_t numCallsToSkip = static_cast<uint32_t>(0);
    uint32_t numCallsToFail = static_cast<uint32_t>(0);
    bool takeMutex          = static_cast<bool>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FailAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type          = static_cast<FaultType>(0);
    uint32_t id             = static_cast<uint32_t>(0);
    uint32_t numCallsToSkip = static_cast<uint32_t>(0);
    uint32_t numCallsToFail = static_cast<uint32_t>(0);
    bool takeMutex          = static_cast<bool>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FailAtFault
namespace FailRandomlyAtFault {
enum class Fields : uint8_t
{
    kType       = 0,
    kId         = 1,
    kPercentage = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FailRandomlyAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type     = static_cast<FaultType>(0);
    uint32_t id        = static_cast<uint32_t>(0);
    uint8_t percentage = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FailRandomlyAtFault::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

    FaultType type     = static_cast<FaultType>(0);
    uint32_t id        = static_cast<uint32_t>(0);
    uint8_t percentage = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FailRandomlyAtFault
} // namespace Commands

namespace Attributes {

namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FaultInjection::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
} // namespace FaultInjection
namespace SampleMei {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Ping {
struct Type;
struct DecodableType;
} // namespace Ping

namespace AddArgumentsResponse {
struct Type;
struct DecodableType;
} // namespace AddArgumentsResponse

namespace AddArguments {
struct Type;
struct DecodableType;
} // namespace AddArguments

} // namespace Commands

namespace Commands {
namespace Ping {
enum class Fields : uint8_t
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Ping::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Ping::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Ping
namespace AddArgumentsResponse {
enum class Fields : uint8_t
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t returnValue = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddArgumentsResponse
namespace AddArguments {
enum class Fields : uint8_t
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;

    using ResponseType = Clusters::SampleMei::Commands::AddArgumentsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint8_t arg1 = static_cast<uint8_t>(0);
    uint8_t arg2 = static_cast<uint8_t>(0);
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddArguments
} // namespace Commands

namespace Attributes {

namespace FlipFlop {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FlipFlop::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FlipFlop
namespace GeneratedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::GeneratedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace GeneratedCommandList
namespace AcceptedCommandList {
struct TypeInfo : public Clusters::Globals::Attributes::AcceptedCommandList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace AcceptedCommandList
namespace AttributeList {
struct TypeInfo : public Clusters::Globals::Attributes::AttributeList::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo : public Clusters::Globals::Attributes::FeatureMap::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo : public Clusters::Globals::Attributes::ClusterRevision::TypeInfo
{
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::FlipFlop::TypeInfo::DecodableType flipFlop = static_cast<bool>(0);
        Attributes::GeneratedCommandList::TypeInfo::DecodableType generatedCommandList;
        Attributes::AcceptedCommandList::TypeInfo::DecodableType acceptedCommandList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap           = static_cast<uint32_t>(0);
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision = static_cast<uint16_t>(0);
    };
};
} // namespace Attributes
namespace Events {
namespace PingCountEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;

enum class Fields : uint8_t
{
    kCount       = 1,
    kFabricIndex = 254,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PingCountEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }
    static constexpr bool kIsFabricScoped = true;

    uint32_t count                = static_cast<uint32_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    auto GetFabricIndex() const { return fabricIndex; }

    CHIP_ERROR Encode(TLV::TLVWriter & aWriter, TLV::Tag aTag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return Events::PingCountEvent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SampleMei::Id; }

    uint32_t count                = static_cast<uint32_t>(0);
    chip::FabricIndex fabricIndex = static_cast<chip::FabricIndex>(0);

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PingCountEvent
} // namespace Events
} // namespace SampleMei

} // namespace Clusters

bool CommandNeedsTimedInvoke(ClusterId aCluster, CommandId aCommand);
bool CommandIsFabricScoped(ClusterId aCluster, CommandId aCommand);
bool CommandHasLargePayload(ClusterId aCluster, CommandId aCommand);

} // namespace app
} // namespace chip
