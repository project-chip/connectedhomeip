/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/util/basic-types.h>

namespace chip {
namespace app {
namespace clusters {

namespace AccountLogin {
constexpr ClusterId kClusterId = 0x50E;

} // namespace AccountLogin
namespace AdministratorCommissioning {
constexpr ClusterId kClusterId = 0x3C;
// Enum for StatusCode
enum class StatusCode : uint8_t
{
    STATUS_CODE_SUCCESS       = 0x00,
    STATUS_CODE_BUSY          = 0x01,
    STATUS_CODE_GENERAL_ERROR = 0x02,
};

} // namespace AdministratorCommissioning
namespace ApplicationBasic {
constexpr ClusterId kClusterId = 0x50D;
// Enum for ApplicationBasicStatus
enum class ApplicationBasicStatus : uint8_t
{
    APPLICATION_BASIC_STATUS_STOPPED                  = 0x00,
    APPLICATION_BASIC_STATUS_ACTIVE_VISIBLE_FOCUS     = 0x01,
    APPLICATION_BASIC_STATUS_ACTIVE_HIDDEN            = 0x02,
    APPLICATION_BASIC_STATUS_ACTIVE_VISIBLE_NOT_FOCUS = 0x03,
};

} // namespace ApplicationBasic
namespace ApplicationLauncher {
constexpr ClusterId kClusterId = 0x50C;
// Enum for ApplicationLauncherStatus
enum class ApplicationLauncherStatus : uint8_t
{
    APPLICATION_LAUNCHER_STATUS_SUCCESS           = 0x00,
    APPLICATION_LAUNCHER_STATUS_APP_NOT_AVAILABLE = 0x01,
    APPLICATION_LAUNCHER_STATUS_SYSTEM_BUSY       = 0x02,
};

namespace ApplicationLauncherApp {
enum FieldId
{
    kCatalogVendorIdFieldId = 0,
    kApplicationIdFieldId   = 1,
};

struct Type
{
public:
    uint16_t catalogVendorId;
    Span<const char> applicationId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ApplicationLauncherApp

} // namespace ApplicationLauncher
namespace AudioOutput {
constexpr ClusterId kClusterId = 0x50B;
// Enum for AudioOutputType
enum class AudioOutputType : uint8_t
{
    AUDIO_OUTPUT_TYPE_HDMI      = 0x00,
    AUDIO_OUTPUT_TYPE_BT        = 0x01,
    AUDIO_OUTPUT_TYPE_OPTICAL   = 0x02,
    AUDIO_OUTPUT_TYPE_HEADPHONE = 0x03,
    AUDIO_OUTPUT_TYPE_INTERNAL  = 0x04,
    AUDIO_OUTPUT_TYPE_OTHER     = 0x05,
};

namespace AudioOutputInfo {
enum FieldId
{
    kIndexFieldId      = 0,
    kOutputTypeFieldId = 1,
    kNameFieldId       = 2,
};

struct Type
{
public:
    uint8_t index;
    AudioOutputType outputType;
    chip::ByteSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace AudioOutputInfo

} // namespace AudioOutput
namespace BarrierControl {
constexpr ClusterId kClusterId = 0x103;

} // namespace BarrierControl
namespace Basic {
constexpr ClusterId kClusterId = 0x28;

} // namespace Basic
namespace BinaryInputBasic {
constexpr ClusterId kClusterId = 0x0F;

} // namespace BinaryInputBasic
namespace Binding {
constexpr ClusterId kClusterId = 0xF000;

} // namespace Binding
namespace BridgedDeviceBasic {
constexpr ClusterId kClusterId = 0x39;

} // namespace BridgedDeviceBasic
namespace ColorControl {
constexpr ClusterId kClusterId = 0x300;

} // namespace ColorControl
namespace ContentLauncher {
constexpr ClusterId kClusterId = 0x50A;
// Enum for ContentLaunchMetricType
enum class ContentLaunchMetricType : uint8_t
{
    CONTENT_LAUNCH_METRIC_TYPE_PIXELS     = 0x00,
    CONTENT_LAUNCH_METRIC_TYPE_PERCENTAGE = 0x01,
};
// Enum for ContentLaunchParameterEnum
enum class ContentLaunchParameterEnum : uint8_t
{
    CONTENT_LAUNCH_PARAMETER_ENUM_ACTOR       = 0x00,
    CONTENT_LAUNCH_PARAMETER_ENUM_CHANNEL     = 0x01,
    CONTENT_LAUNCH_PARAMETER_ENUM_CHARACTER   = 0x02,
    CONTENT_LAUNCH_PARAMETER_ENUM_EVENT       = 0x03,
    CONTENT_LAUNCH_PARAMETER_ENUM_FRANCHISE   = 0x04,
    CONTENT_LAUNCH_PARAMETER_ENUM_GENRE       = 0x05,
    CONTENT_LAUNCH_PARAMETER_ENUM_LEAGUE      = 0x06,
    CONTENT_LAUNCH_PARAMETER_ENUM_POPULARITY  = 0x07,
    CONTENT_LAUNCH_PARAMETER_ENUM_SPORT       = 0x08,
    CONTENT_LAUNCH_PARAMETER_ENUM_SPORTS_TEAM = 0x09,
    CONTENT_LAUNCH_PARAMETER_ENUM_VIDEO       = 0x0A,
};
// Enum for ContentLaunchStatus
enum class ContentLaunchStatus : uint8_t
{
    CONTENT_LAUNCH_STATUS_SUCCESS           = 0x00,
    CONTENT_LAUNCH_STATUS_URL_NOT_AVAILABLE = 0x01,
    CONTENT_LAUNCH_STATUS_AUTH_FAILED       = 0x02,
};
// Enum for ContentLaunchStreamingType
enum class ContentLaunchStreamingType : uint8_t
{
    CONTENT_LAUNCH_STREAMING_TYPE_DASH = 0x00,
    CONTENT_LAUNCH_STREAMING_TYPE_HLS  = 0x01,
};

namespace ContentLaunchAdditionalInfo {
enum FieldId
{
    kNameFieldId  = 0,
    kValueFieldId = 1,
};

struct Type
{
public:
    Span<const char> name;
    Span<const char> value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchAdditionalInfo
namespace ContentLaunchParamater {
enum FieldId
{
    kTypeFieldId           = 0,
    kValueFieldId          = 1,
    kExternalIDListFieldId = 2,
};

struct Type
{
public:
    ContentLaunchParameterEnum type;
    Span<const char> value;
    DataModel::List<ContentLaunchAdditionalInfo::Type> externalIDList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

struct DecodableType
{
public:
    ContentLaunchParameterEnum type;
    Span<const char> value;
    DataModel::DecodableList<ContentLaunchAdditionalInfo::Type> externalIDList;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchParamater
namespace ContentLaunchBrandingInformation {
enum FieldId
{
    kProviderNameFieldId = 0,
    kBackgroundFieldId   = 1,
    kLogoFieldId         = 2,
    kProgressBarFieldId  = 3,
    kSplashFieldId       = 4,
    kWaterMarkFieldId    = 5,
};

struct Type
{
public:
    Span<const char> providerName;
    uint8_t background;
    uint8_t logo;
    uint8_t progressBar;
    uint8_t splash;
    uint8_t waterMark;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchBrandingInformation
namespace ContentLaunchDimension {
enum FieldId
{
    kWidthFieldId  = 0,
    kHeightFieldId = 1,
    kMetricFieldId = 2,
};

struct Type
{
public:
    Span<const char> width;
    Span<const char> height;
    ContentLaunchMetricType metric;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchDimension
namespace ContentLaunchStyleInformation {
enum FieldId
{
    kImageUrlFieldId = 0,
    kColorFieldId    = 1,
    kSizeFieldId     = 2,
};

struct Type
{
public:
    Span<const char> imageUrl;
    Span<const char> color;
    uint8_t size;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchStyleInformation

} // namespace ContentLauncher
namespace Descriptor {
constexpr ClusterId kClusterId = 0x1D;

namespace DeviceType {
enum FieldId
{
    kTypeFieldId     = 0,
    kRevisionFieldId = 1,
};

struct Type
{
public:
    uint32_t type;
    uint16_t revision;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace DeviceType

} // namespace Descriptor
namespace DiagnosticLogs {
constexpr ClusterId kClusterId = 0x32;
// Enum for LogsIntent
enum class LogsIntent : uint8_t
{
    LOGS_INTENT_END_USER_SUPPORT = 0x00,
    LOGS_INTENT_NETWORK_DIAG     = 0x01,
    LOGS_INTENT_CRASH_LOGS       = 0x02,
};
// Enum for LogsStatus
enum class LogsStatus : uint8_t
{
    LOGS_STATUS_SUCCESS   = 0x00,
    LOGS_STATUS_EXHAUSTED = 0x01,
    LOGS_STATUS_NO_LOGS   = 0x02,
    LOGS_STATUS_BUSY      = 0x03,
    LOGS_STATUS_DENIED    = 0x04,
};
// Enum for LogsTransferProtocol
enum class LogsTransferProtocol : uint8_t
{
    LOGS_TRANSFER_PROTOCOL_RESPONSE_PAYLOAD = 0x00,
    LOGS_TRANSFER_PROTOCOL_BDX              = 0x01,
};

} // namespace DiagnosticLogs
namespace DoorLock {
constexpr ClusterId kClusterId = 0x101;

} // namespace DoorLock
namespace ElectricalMeasurement {
constexpr ClusterId kClusterId = 0xB04;

} // namespace ElectricalMeasurement
namespace EthernetNetworkDiagnostics {
constexpr ClusterId kClusterId = 0x37;
// Enum for PHYRateType
enum class PHYRateType : uint8_t
{
    PHY_RATE_TYPE_10_M   = 0x00,
    PHY_RATE_TYPE_100_M  = 0x01,
    PHY_RATE_TYPE_1000_M = 0x02,
    PHY_RATE_TYPE_2__5_G = 0x03,
    PHY_RATE_TYPE_5_G    = 0x04,
    PHY_RATE_TYPE_10_G   = 0x05,
    PHY_RATE_TYPE_40_G   = 0x06,
    PHY_RATE_TYPE_100_G  = 0x07,
    PHY_RATE_TYPE_200_G  = 0x08,
    PHY_RATE_TYPE_400_G  = 0x09,
};

} // namespace EthernetNetworkDiagnostics
namespace FixedLabel {
constexpr ClusterId kClusterId = 0x40;

namespace LabelStruct {
enum FieldId
{
    kLabelFieldId = 0,
    kValueFieldId = 1,
};

struct Type
{
public:
    chip::ByteSpan label;
    chip::ByteSpan value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace LabelStruct

} // namespace FixedLabel
namespace FlowMeasurement {
constexpr ClusterId kClusterId = 0x404;

} // namespace FlowMeasurement
namespace GeneralCommissioning {
constexpr ClusterId kClusterId = 0x30;
// Enum for GeneralCommissioningError
enum class GeneralCommissioningError : uint8_t
{
    GENERAL_COMMISSIONING_ERROR_OK                     = 0x00,
    GENERAL_COMMISSIONING_ERROR_VALUE_OUTSIDE_RANGE    = 0x01,
    GENERAL_COMMISSIONING_ERROR_INVALID_AUTHENTICATION = 0x02,
};
// Enum for RegulatoryLocationType
enum class RegulatoryLocationType : uint8_t
{
    REGULATORY_LOCATION_TYPE_INDOOR         = 0x00,
    REGULATORY_LOCATION_TYPE_OUTDOOR        = 0x01,
    REGULATORY_LOCATION_TYPE_INDOOR_OUTDOOR = 0x02,
};

namespace BasicCommissioningInfoType {
enum FieldId
{
    kFailSafeExpiryLengthMsFieldId = 0,
};

struct Type
{
public:
    uint32_t failSafeExpiryLengthMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace BasicCommissioningInfoType

} // namespace GeneralCommissioning
namespace GeneralDiagnostics {
constexpr ClusterId kClusterId = 0x33;
// Enum for BootReasonType
enum class BootReasonType : uint8_t
{
    BOOT_REASON_TYPE_UNSPECIFIED               = 0x00,
    BOOT_REASON_TYPE_POWER_ON_REBOOT           = 0x01,
    BOOT_REASON_TYPE_BROWN_OUT_RESET           = 0x02,
    BOOT_REASON_TYPE_SOFTWARE_WATCHDOG_RESET   = 0x03,
    BOOT_REASON_TYPE_HARDWARE_WATCHDOG_RESET   = 0x04,
    BOOT_REASON_TYPE_SOFTWARE_UPDATE_COMPLETED = 0x05,
    BOOT_REASON_TYPE_SOFTWARE_RESET            = 0x06,
};
// Enum for HardwareFaultType
enum class HardwareFaultType : uint8_t
{
    HARDWARE_FAULT_TYPE_UNSPECIFIED               = 0x00,
    HARDWARE_FAULT_TYPE_RADIO                     = 0x01,
    HARDWARE_FAULT_TYPE_SENSOR                    = 0x02,
    HARDWARE_FAULT_TYPE_RESETTABLE_OVER_TEMP      = 0x03,
    HARDWARE_FAULT_TYPE_NON_RESETTABLE_OVER_TEMP  = 0x04,
    HARDWARE_FAULT_TYPE_POWER_SOURCE              = 0x05,
    HARDWARE_FAULT_TYPE_VISUAL_DISPLAY_FAULT      = 0x06,
    HARDWARE_FAULT_TYPE_AUDIO_OUTPUT_FAULT        = 0x07,
    HARDWARE_FAULT_TYPE_USER_INTERFACE_FAULT      = 0x08,
    HARDWARE_FAULT_TYPE_NON_VOLATILE_MEMORY_ERROR = 0x09,
    HARDWARE_FAULT_TYPE_TAMPER_DETECTED           = 0x0A,
};
// Enum for InterfaceType
enum class InterfaceType : uint8_t
{
    INTERFACE_TYPE_UNSPECIFIED = 0x00,
    INTERFACE_TYPE_WI_FI       = 0x01,
    INTERFACE_TYPE_ETHERNET    = 0x02,
    INTERFACE_TYPE_CELLULAR    = 0x03,
    INTERFACE_TYPE_THREAD      = 0x04,
};
// Enum for NetworkFaultType
enum class NetworkFaultType : uint8_t
{
    NETWORK_FAULT_TYPE_UNSPECIFIED       = 0x00,
    NETWORK_FAULT_TYPE_HARDWARE_FAILURE  = 0x01,
    NETWORK_FAULT_TYPE_NETWORK_JAMMED    = 0x02,
    NETWORK_FAULT_TYPE_CONNECTION_FAILED = 0x03,
};
// Enum for RadioFaultType
enum class RadioFaultType : uint8_t
{
    RADIO_FAULT_TYPE_UNSPECIFIED    = 0x00,
    RADIO_FAULT_TYPE_WI_FI_FAULT    = 0x01,
    RADIO_FAULT_TYPE_CELLULAR_FAULT = 0x02,
    RADIO_FAULT_TYPE_THREAD_FAULT   = 0x03,
    RADIO_FAULT_TYPE_NFC_FAULT      = 0x04,
    RADIO_FAULT_TYPE_BLE_FAULT      = 0x05,
    RADIO_FAULT_TYPE_ETHERNET_FAULT = 0x06,
};

namespace NetworkInterfaceType {
enum FieldId
{
    kNameFieldId                            = 0,
    kFabricConnectedFieldId                 = 1,
    kOffPremiseServicesReachableIPv4FieldId = 2,
    kOffPremiseServicesReachableIPv6FieldId = 3,
    kHardwareAddressFieldId                 = 4,
    kTypeFieldId                            = 5,
};

struct Type
{
public:
    chip::ByteSpan name;
    bool fabricConnected;
    bool offPremiseServicesReachableIPv4;
    bool offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    InterfaceType type;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NetworkInterfaceType

} // namespace GeneralDiagnostics
namespace GroupKeyManagement {
constexpr ClusterId kClusterId = 0xF004;
// Enum for GroupKeySecurityPolicy
enum class GroupKeySecurityPolicy : uint8_t
{
    GROUP_KEY_SECURITY_POLICY_STANDARD    = 0x00,
    GROUP_KEY_SECURITY_POLICY_LOW_LATENCY = 0x01,
};

namespace GroupKey {
enum FieldId
{
    kVendorIdFieldId               = 0,
    kGroupKeyIndexFieldId          = 1,
    kGroupKeyRootFieldId           = 2,
    kGroupKeyEpochStartTimeFieldId = 3,
    kGroupKeySecurityPolicyFieldId = 4,
};

struct Type
{
public:
    uint16_t vendorId;
    uint16_t groupKeyIndex;
    chip::ByteSpan groupKeyRoot;
    uint64_t groupKeyEpochStartTime;
    GroupKeySecurityPolicy groupKeySecurityPolicy;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace GroupKey
namespace GroupState {
enum FieldId
{
    kVendorIdFieldId         = 0,
    kVendorGroupIdFieldId    = 1,
    kGroupKeySetIndexFieldId = 2,
};

struct Type
{
public:
    uint16_t vendorId;
    uint16_t vendorGroupId;
    uint16_t groupKeySetIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace GroupState

} // namespace GroupKeyManagement
namespace Groups {
constexpr ClusterId kClusterId = 0x04;

} // namespace Groups
namespace Identify {
constexpr ClusterId kClusterId = 0x03;

} // namespace Identify
namespace KeypadInput {
constexpr ClusterId kClusterId = 0x509;
// Enum for KeypadInputCecKeyCode
enum class KeypadInputCecKeyCode : uint8_t
{
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT                       = 0x00,
    KEYPAD_INPUT_CEC_KEY_CODE_UP                           = 0x01,
    KEYPAD_INPUT_CEC_KEY_CODE_DOWN                         = 0x02,
    KEYPAD_INPUT_CEC_KEY_CODE_LEFT                         = 0x03,
    KEYPAD_INPUT_CEC_KEY_CODE_RIGHT                        = 0x04,
    KEYPAD_INPUT_CEC_KEY_CODE_RIGHT_UP                     = 0x05,
    KEYPAD_INPUT_CEC_KEY_CODE_RIGHT_DOWN                   = 0x06,
    KEYPAD_INPUT_CEC_KEY_CODE_LEFT_UP                      = 0x07,
    KEYPAD_INPUT_CEC_KEY_CODE_LEFT_DOWN                    = 0x08,
    KEYPAD_INPUT_CEC_KEY_CODE_ROOT_MENU                    = 0x09,
    KEYPAD_INPUT_CEC_KEY_CODE_SETUP_MENU                   = 0x0A,
    KEYPAD_INPUT_CEC_KEY_CODE_CONTENTS_MENU                = 0x0B,
    KEYPAD_INPUT_CEC_KEY_CODE_FAVORITE_MENU                = 0x0C,
    KEYPAD_INPUT_CEC_KEY_CODE_EXIT                         = 0x0D,
    KEYPAD_INPUT_CEC_KEY_CODE_MEDIA_TOP_MENU               = 0x10,
    KEYPAD_INPUT_CEC_KEY_CODE_MEDIA_CONTEXT_SENSITIVE_MENU = 0x11,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER_ENTRY_MODE            = 0x1D,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER11                     = 0x1E,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER12                     = 0x1F,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBER0_OR_NUMBER10          = 0x20,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS1                     = 0x21,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS2                     = 0x22,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS3                     = 0x23,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS4                     = 0x24,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS5                     = 0x25,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS6                     = 0x26,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS7                     = 0x27,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS8                     = 0x28,
    KEYPAD_INPUT_CEC_KEY_CODE_NUMBERS9                     = 0x29,
    KEYPAD_INPUT_CEC_KEY_CODE_DOT                          = 0x2A,
    KEYPAD_INPUT_CEC_KEY_CODE_ENTER                        = 0x2B,
    KEYPAD_INPUT_CEC_KEY_CODE_CLEAR                        = 0x2C,
    KEYPAD_INPUT_CEC_KEY_CODE_NEXT_FAVORITE                = 0x2F,
    KEYPAD_INPUT_CEC_KEY_CODE_CHANNEL_UP                   = 0x30,
    KEYPAD_INPUT_CEC_KEY_CODE_CHANNEL_DOWN                 = 0x31,
    KEYPAD_INPUT_CEC_KEY_CODE_PREVIOUS_CHANNEL             = 0x32,
    KEYPAD_INPUT_CEC_KEY_CODE_SOUND_SELECT                 = 0x33,
    KEYPAD_INPUT_CEC_KEY_CODE_INPUT_SELECT                 = 0x34,
    KEYPAD_INPUT_CEC_KEY_CODE_DISPLAY_INFORMATION          = 0x35,
    KEYPAD_INPUT_CEC_KEY_CODE_HELP                         = 0x36,
    KEYPAD_INPUT_CEC_KEY_CODE_PAGE_UP                      = 0x37,
    KEYPAD_INPUT_CEC_KEY_CODE_PAGE_DOWN                    = 0x38,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER                        = 0x40,
    KEYPAD_INPUT_CEC_KEY_CODE_VOLUME_UP                    = 0x41,
    KEYPAD_INPUT_CEC_KEY_CODE_VOLUME_DOWN                  = 0x42,
    KEYPAD_INPUT_CEC_KEY_CODE_MUTE                         = 0x43,
    KEYPAD_INPUT_CEC_KEY_CODE_PLAY                         = 0x44,
    KEYPAD_INPUT_CEC_KEY_CODE_STOP                         = 0x45,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE                        = 0x46,
    KEYPAD_INPUT_CEC_KEY_CODE_RECORD                       = 0x47,
    KEYPAD_INPUT_CEC_KEY_CODE_REWIND                       = 0x48,
    KEYPAD_INPUT_CEC_KEY_CODE_FAST_FORWARD                 = 0x49,
    KEYPAD_INPUT_CEC_KEY_CODE_EJECT                        = 0x4A,
    KEYPAD_INPUT_CEC_KEY_CODE_FORWARD                      = 0x4B,
    KEYPAD_INPUT_CEC_KEY_CODE_BACKWARD                     = 0x4C,
    KEYPAD_INPUT_CEC_KEY_CODE_STOP_RECORD                  = 0x4D,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE_RECORD                 = 0x4E,
    KEYPAD_INPUT_CEC_KEY_CODE_RESERVED                     = 0x4F,
    KEYPAD_INPUT_CEC_KEY_CODE_ANGLE                        = 0x50,
    KEYPAD_INPUT_CEC_KEY_CODE_SUB_PICTURE                  = 0x51,
    KEYPAD_INPUT_CEC_KEY_CODE_VIDEO_ON_DEMAND              = 0x52,
    KEYPAD_INPUT_CEC_KEY_CODE_ELECTRONIC_PROGRAM_GUIDE     = 0x53,
    KEYPAD_INPUT_CEC_KEY_CODE_TIMER_PROGRAMMING            = 0x54,
    KEYPAD_INPUT_CEC_KEY_CODE_INITIAL_CONFIGURATION        = 0x55,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_BROADCAST_TYPE        = 0x56,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_SOUND_PRESENTATION    = 0x57,
    KEYPAD_INPUT_CEC_KEY_CODE_PLAY_FUNCTION                = 0x60,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE_PLAY_FUNCTION          = 0x61,
    KEYPAD_INPUT_CEC_KEY_CODE_RECORD_FUNCTION              = 0x62,
    KEYPAD_INPUT_CEC_KEY_CODE_PAUSE_RECORD_FUNCTION        = 0x63,
    KEYPAD_INPUT_CEC_KEY_CODE_STOP_FUNCTION                = 0x64,
    KEYPAD_INPUT_CEC_KEY_CODE_MUTE_FUNCTION                = 0x65,
    KEYPAD_INPUT_CEC_KEY_CODE_RESTORE_VOLUME_FUNCTION      = 0x66,
    KEYPAD_INPUT_CEC_KEY_CODE_TUNE_FUNCTION                = 0x67,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_MEDIA_FUNCTION        = 0x68,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_AV_INPUT_FUNCTION     = 0x69,
    KEYPAD_INPUT_CEC_KEY_CODE_SELECT_AUDIO_INPUT_FUNCTION  = 0x6A,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER_TOGGLE_FUNCTION        = 0x6B,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER_OFF_FUNCTION           = 0x6C,
    KEYPAD_INPUT_CEC_KEY_CODE_POWER_ON_FUNCTION            = 0x6D,
    KEYPAD_INPUT_CEC_KEY_CODE_F1_BLUE                      = 0x71,
    KEYPAD_INPUT_CEC_KEY_CODE_F2_RED                       = 0x72,
    KEYPAD_INPUT_CEC_KEY_CODE_F3_GREEN                     = 0x73,
    KEYPAD_INPUT_CEC_KEY_CODE_F4_YELLOW                    = 0x74,
    KEYPAD_INPUT_CEC_KEY_CODE_F5                           = 0x75,
    KEYPAD_INPUT_CEC_KEY_CODE_DATA                         = 0x76,
};
// Enum for KeypadInputStatus
enum class KeypadInputStatus : uint8_t
{
    KEYPAD_INPUT_STATUS_SUCCESS                      = 0x00,
    KEYPAD_INPUT_STATUS_UNSUPPORTED_KEY              = 0x01,
    KEYPAD_INPUT_STATUS_INVALID_KEY_IN_CURRENT_STATE = 0x02,
};

} // namespace KeypadInput
namespace LevelControl {
constexpr ClusterId kClusterId = 0x08;

} // namespace LevelControl
namespace LowPower {
constexpr ClusterId kClusterId = 0x508;

} // namespace LowPower
namespace MediaInput {
constexpr ClusterId kClusterId = 0x507;
// Enum for MediaInputType
enum class MediaInputType : uint8_t
{
    MEDIA_INPUT_TYPE_INTERNAL  = 0x00,
    MEDIA_INPUT_TYPE_AUX       = 0x01,
    MEDIA_INPUT_TYPE_COAX      = 0x02,
    MEDIA_INPUT_TYPE_COMPOSITE = 0x03,
    MEDIA_INPUT_TYPE_HDMI      = 0x04,
    MEDIA_INPUT_TYPE_INPUT     = 0x05,
    MEDIA_INPUT_TYPE_LINE      = 0x06,
    MEDIA_INPUT_TYPE_OPTICAL   = 0x07,
    MEDIA_INPUT_TYPE_VIDEO     = 0x08,
    MEDIA_INPUT_TYPE_SCART     = 0x09,
    MEDIA_INPUT_TYPE_USB       = 0x0A,
    MEDIA_INPUT_TYPE_OTHER     = 0x0B,
};

namespace MediaInputInfo {
enum FieldId
{
    kIndexFieldId       = 0,
    kInputTypeFieldId   = 1,
    kNameFieldId        = 2,
    kDescriptionFieldId = 3,
};

struct Type
{
public:
    uint8_t index;
    MediaInputType inputType;
    chip::ByteSpan name;
    chip::ByteSpan description;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace MediaInputInfo

} // namespace MediaInput
namespace MediaPlayback {
constexpr ClusterId kClusterId = 0x506;
// Enum for MediaPlaybackState
enum class MediaPlaybackState : uint8_t
{
    MEDIA_PLAYBACK_STATE_PLAYING     = 0x00,
    MEDIA_PLAYBACK_STATE_PAUSED      = 0x01,
    MEDIA_PLAYBACK_STATE_NOT_PLAYING = 0x02,
    MEDIA_PLAYBACK_STATE_BUFFERING   = 0x03,
};
// Enum for MediaPlaybackStatus
enum class MediaPlaybackStatus : uint8_t
{
    MEDIA_PLAYBACK_STATUS_SUCCESS                   = 0x00,
    MEDIA_PLAYBACK_STATUS_INVALID_STATE_FOR_COMMAND = 0x01,
    MEDIA_PLAYBACK_STATUS_NOT_ALLOWED               = 0x02,
    MEDIA_PLAYBACK_STATUS_NOT_ACTIVE                = 0x03,
    MEDIA_PLAYBACK_STATUS_SPEED_OUT_OF_RANGE        = 0x04,
    MEDIA_PLAYBACK_STATUS_SEEK_OUT_OF_RANGE         = 0x05,
};

namespace MediaPlaybackPosition {
enum FieldId
{
    kUpdatedAtFieldId = 0,
    kPositionFieldId  = 1,
};

struct Type
{
public:
    uint64_t updatedAt;
    uint64_t position;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace MediaPlaybackPosition

} // namespace MediaPlayback
namespace NetworkCommissioning {
constexpr ClusterId kClusterId = 0x31;
// Enum for NetworkCommissioningError
enum class NetworkCommissioningError : uint8_t
{
    NETWORK_COMMISSIONING_ERROR_SUCCESS                  = 0x00,
    NETWORK_COMMISSIONING_ERROR_OUT_OF_RANGE             = 0x01,
    NETWORK_COMMISSIONING_ERROR_BOUNDS_EXCEEDED          = 0x02,
    NETWORK_COMMISSIONING_ERROR_NETWORK_ID_NOT_FOUND     = 0x03,
    NETWORK_COMMISSIONING_ERROR_DUPLICATE_NETWORK_ID     = 0x04,
    NETWORK_COMMISSIONING_ERROR_NETWORK_NOT_FOUND        = 0x05,
    NETWORK_COMMISSIONING_ERROR_REGULATORY_ERROR         = 0x06,
    NETWORK_COMMISSIONING_ERROR_AUTH_FAILURE             = 0x07,
    NETWORK_COMMISSIONING_ERROR_UNSUPPORTED_SECURITY     = 0x08,
    NETWORK_COMMISSIONING_ERROR_OTHER_CONNECTION_FAILURE = 0x09,
    NETWORK_COMMISSIONING_ERROR_IPV6_FAILED              = 0x0A,
    NETWORK_COMMISSIONING_ERROR_IP_BIND_FAILED           = 0x0B,
    NETWORK_COMMISSIONING_ERROR_LABEL9                   = 0x0C,
    NETWORK_COMMISSIONING_ERROR_LABEL10                  = 0x0D,
    NETWORK_COMMISSIONING_ERROR_LABEL11                  = 0x0E,
    NETWORK_COMMISSIONING_ERROR_LABEL12                  = 0x0F,
    NETWORK_COMMISSIONING_ERROR_LABEL13                  = 0x10,
    NETWORK_COMMISSIONING_ERROR_LABEL14                  = 0x11,
    NETWORK_COMMISSIONING_ERROR_LABEL15                  = 0x12,
    NETWORK_COMMISSIONING_ERROR_UNKNOWN_ERROR            = 0x13,
};

namespace ThreadInterfaceScanResult {
enum FieldId
{
    kDiscoveryResponseFieldId = 0,
};

struct Type
{
public:
    chip::ByteSpan discoveryResponse;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ThreadInterfaceScanResult
namespace WiFiInterfaceScanResult {
enum FieldId
{
    kSecurityFieldId      = 0,
    kSsidFieldId          = 1,
    kBssidFieldId         = 2,
    kChannelFieldId       = 3,
    kFrequencyBandFieldId = 4,
};

struct Type
{
public:
    uint8_t security;
    chip::ByteSpan ssid;
    chip::ByteSpan bssid;
    uint8_t channel;
    uint32_t frequencyBand;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace WiFiInterfaceScanResult

} // namespace NetworkCommissioning
namespace OtaSoftwareUpdateProvider {
constexpr ClusterId kClusterId = 0x29;
// Enum for OTAApplyUpdateAction
enum class OTAApplyUpdateAction : uint8_t
{
    OTA_APPLY_UPDATE_ACTION_PROCEED           = 0x00,
    OTA_APPLY_UPDATE_ACTION_AWAIT_NEXT_ACTION = 0x01,
    OTA_APPLY_UPDATE_ACTION_DISCONTINUE       = 0x02,
};
// Enum for OTADownloadProtocol
enum class OTADownloadProtocol : uint8_t
{
    OTA_DOWNLOAD_PROTOCOL_BDX_SYNCHRONOUS  = 0x00,
    OTA_DOWNLOAD_PROTOCOL_BDX_ASYNCHRONOUS = 0x01,
    OTA_DOWNLOAD_PROTOCOL_HTTPS            = 0x02,
    OTA_DOWNLOAD_PROTOCOL_VENDOR_SPECIFIC  = 0x03,
};
// Enum for OTAQueryStatus
enum class OTAQueryStatus : uint8_t
{
    OTA_QUERY_STATUS_UPDATE_AVAILABLE = 0x00,
    OTA_QUERY_STATUS_BUSY             = 0x01,
    OTA_QUERY_STATUS_NOT_AVAILABLE    = 0x02,
};

} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
constexpr ClusterId kClusterId = 0x2A;
// Enum for OTAAnnouncementReason
enum class OTAAnnouncementReason : uint8_t
{
    OTA_ANNOUNCEMENT_REASON_SIMPLE_ANNOUNCEMENT       = 0x00,
    OTA_ANNOUNCEMENT_REASON_UPDATE_AVAILABLE          = 0x01,
    OTA_ANNOUNCEMENT_REASON_CRITICAL_UPDATE_AVAILABLE = 0x02,
};

} // namespace OtaSoftwareUpdateRequestor
namespace OccupancySensing {
constexpr ClusterId kClusterId = 0x406;

} // namespace OccupancySensing
namespace OnOff {
constexpr ClusterId kClusterId = 0x06;
// Enum for OnOffDelayedAllOffEffectVariant
enum class OnOffDelayedAllOffEffectVariant : uint8_t
{
    ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_FADE_TO_OFF_IN_0P8_SECONDS                                        = 0x00,
    ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_NO_FADE                                                           = 0x01,
    ON_OFF_DELAYED_ALL_OFF_EFFECT_VARIANT_50_PERCENT_DIM_DOWN_IN_0P8_SECONDS_THEN_FADE_TO_OFF_IN_12_SECONDS = 0x02,
};
// Enum for OnOffDyingLightEffectVariant
enum class OnOffDyingLightEffectVariant : uint8_t
{
    ON_OFF_DYING_LIGHT_EFFECT_VARIANT_20_PERCENTER_DIM_UP_IN_0P5_SECONDS_THEN_FADE_TO_OFF_IN_1_SECOND = 0x00,
};
// Enum for OnOffEffectIdentifier
enum class OnOffEffectIdentifier : uint8_t
{
    ON_OFF_EFFECT_IDENTIFIER_DELAYED_ALL_OFF = 0x00,
    ON_OFF_EFFECT_IDENTIFIER_DYING_LIGHT     = 0x01,
};

} // namespace OnOff
namespace OnOffSwitchConfiguration {
constexpr ClusterId kClusterId = 0x07;

} // namespace OnOffSwitchConfiguration
namespace OperationalCredentials {
constexpr ClusterId kClusterId = 0x3E;
// Enum for NodeOperationalCertStatus
enum class NodeOperationalCertStatus : uint8_t
{
    NODE_OPERATIONAL_CERT_STATUS_SUCCESS                = 0x00,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_PUBLIC_KEY     = 0x01,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_NODE_OP_ID     = 0x02,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_NOC            = 0x03,
    NODE_OPERATIONAL_CERT_STATUS_MISSING_CSR            = 0x04,
    NODE_OPERATIONAL_CERT_STATUS_TABLE_FULL             = 0x05,
    NODE_OPERATIONAL_CERT_STATUS_INSUFFICIENT_PRIVILEGE = 0x08,
    NODE_OPERATIONAL_CERT_STATUS_FABRIC_CONFLICT        = 0x09,
    NODE_OPERATIONAL_CERT_STATUS_LABEL_CONFLICT         = 0x0A,
    NODE_OPERATIONAL_CERT_STATUS_INVALID_FABRIC_INDEX   = 0x0B,
};

namespace FabricDescriptor {
enum FieldId
{
    kFabricIndexFieldId   = 0,
    kRootPublicKeyFieldId = 1,
    kVendorIdFieldId      = 2,
    kFabricIdFieldId      = 3,
    kNodeIdFieldId        = 4,
    kLabelFieldId         = 5,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan rootPublicKey;
    uint16_t vendorId;
    uint64_t fabricId;
    uint64_t nodeId;
    chip::ByteSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace FabricDescriptor
namespace NOCStruct {
enum FieldId
{
    kFabricIndexFieldId = 0,
    kNocFieldId         = 1,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan noc;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NOCStruct

} // namespace OperationalCredentials
namespace PowerSource {
constexpr ClusterId kClusterId = 0x2F;

} // namespace PowerSource
namespace PressureMeasurement {
constexpr ClusterId kClusterId = 0x403;

} // namespace PressureMeasurement
namespace PumpConfigurationAndControl {
constexpr ClusterId kClusterId = 0x200;
// Enum for PumpControlMode
enum class PumpControlMode : uint8_t
{
    PUMP_CONTROL_MODE_CONSTANT_SPEED        = 0x00,
    PUMP_CONTROL_MODE_CONSTANT_PRESSURE     = 0x01,
    PUMP_CONTROL_MODE_PROPORTIONAL_PRESSURE = 0x02,
    PUMP_CONTROL_MODE_CONSTANT_FLOW         = 0x03,
    PUMP_CONTROL_MODE_CONSTANT_TEMPERATURE  = 0x05,
    PUMP_CONTROL_MODE_AUTOMATIC             = 0x07,
};
// Enum for PumpOperationMode
enum class PumpOperationMode : uint8_t
{
    PUMP_OPERATION_MODE_NORMAL  = 0x00,
    PUMP_OPERATION_MODE_MINIMUM = 0x01,
    PUMP_OPERATION_MODE_MAXIMUM = 0x02,
    PUMP_OPERATION_MODE_LOCAL   = 0x03,
};

} // namespace PumpConfigurationAndControl
namespace RelativeHumidityMeasurement {
constexpr ClusterId kClusterId = 0x405;

} // namespace RelativeHumidityMeasurement
namespace Scenes {
constexpr ClusterId kClusterId = 0x05;

} // namespace Scenes
namespace SoftwareDiagnostics {
constexpr ClusterId kClusterId = 0x34;

namespace ThreadMetrics {
enum FieldId
{
    kIdFieldId               = 0,
    kNameFieldId             = 1,
    kStackFreeCurrentFieldId = 2,
    kStackFreeMinimumFieldId = 3,
    kStackSizeFieldId        = 4,
};

struct Type
{
public:
    uint64_t id;
    chip::ByteSpan name;
    uint32_t stackFreeCurrent;
    uint32_t stackFreeMinimum;
    uint32_t stackSize;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ThreadMetrics

} // namespace SoftwareDiagnostics
namespace Switch {
constexpr ClusterId kClusterId = 0x3B;

} // namespace Switch
namespace TvChannel {
constexpr ClusterId kClusterId = 0x504;
// Enum for TvChannelErrorType
enum class TvChannelErrorType : uint8_t
{
    TV_CHANNEL_ERROR_TYPE_MULTIPLE_MATCHES = 0x00,
    TV_CHANNEL_ERROR_TYPE_NO_MATCHES       = 0x01,
};
// Enum for TvChannelLineupInfoType
enum class TvChannelLineupInfoType : uint8_t
{
    TV_CHANNEL_LINEUP_INFO_TYPE_MSO = 0x00,
};

namespace TvChannelInfo {
enum FieldId
{
    kMajorNumberFieldId       = 0,
    kMinorNumberFieldId       = 1,
    kNameFieldId              = 2,
    kCallSignFieldId          = 3,
    kAffiliateCallSignFieldId = 4,
};

struct Type
{
public:
    uint16_t majorNumber;
    uint16_t minorNumber;
    chip::ByteSpan name;
    chip::ByteSpan callSign;
    chip::ByteSpan affiliateCallSign;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace TvChannelInfo
namespace TvChannelLineupInfo {
enum FieldId
{
    kOperatorNameFieldId   = 0,
    kLineupNameFieldId     = 1,
    kPostalCodeFieldId     = 2,
    kLineupInfoTypeFieldId = 3,
};

struct Type
{
public:
    Span<const char> operatorName;
    Span<const char> lineupName;
    Span<const char> postalCode;
    TvChannelLineupInfoType lineupInfoType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace TvChannelLineupInfo

} // namespace TvChannel
namespace TargetNavigator {
constexpr ClusterId kClusterId = 0x505;
// Enum for NavigateTargetStatus
enum class NavigateTargetStatus : uint8_t
{
    NAVIGATE_TARGET_STATUS_SUCCESS           = 0x00,
    NAVIGATE_TARGET_STATUS_APP_NOT_AVAILABLE = 0x01,
    NAVIGATE_TARGET_STATUS_SYSTEM_BUSY       = 0x02,
};

namespace NavigateTargetTargetInfo {
enum FieldId
{
    kIdentifierFieldId = 0,
    kNameFieldId       = 1,
};

struct Type
{
public:
    uint8_t identifier;
    chip::ByteSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NavigateTargetTargetInfo

} // namespace TargetNavigator
namespace TemperatureMeasurement {
constexpr ClusterId kClusterId = 0x402;

} // namespace TemperatureMeasurement
namespace TestCluster {
constexpr ClusterId kClusterId = 0x50F;
// Enum for SimpleEnum
enum class SimpleEnum : uint8_t
{
    SIMPLE_ENUM_UNSPECIFIED = 0x00,
    SIMPLE_ENUM_VALUE_A     = 0x01,
    SIMPLE_ENUM_VALUE_B     = 0x02,
    SIMPLE_ENUM_VALUE_C     = 0x03,
};

namespace SimpleStruct {
enum FieldId
{
    kAFieldId = 0,
    kBFieldId = 1,
    kCFieldId = 2,
    kDFieldId = 3,
    kEFieldId = 4,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleEnum c;
    chip::ByteSpan d;
    Span<const char> e;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace SimpleStruct
namespace NestedStruct {
enum FieldId
{
    kAFieldId = 0,
    kBFieldId = 1,
    kCFieldId = 2,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleStruct::Type c;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NestedStruct
namespace NestedStructList {
enum FieldId
{
    kAFieldId = 0,
    kBFieldId = 1,
    kCFieldId = 2,
    kDFieldId = 3,
    kEFieldId = 4,
    kFFieldId = 5,
    kGFieldId = 6,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleStruct::Type c;
    DataModel::List<SimpleStruct::Type> d;
    DataModel::List<uint32_t> e;
    DataModel::List<chip::ByteSpan> f;
    DataModel::List<uint8_t> g;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

struct DecodableType
{
public:
    uint8_t a;
    bool b;
    SimpleStruct::Type c;
    DataModel::DecodableList<SimpleStruct::Type> d;
    DataModel::DecodableList<uint32_t> e;
    DataModel::DecodableList<chip::ByteSpan> f;
    DataModel::DecodableList<uint8_t> g;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NestedStructList
namespace DoubleNestedStructList {
enum FieldId
{
    kAFieldId = 0,
};

struct Type
{
public:
    DataModel::List<NestedStructList::Type> a;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

struct DecodableType
{
public:
    DataModel::DecodableList<NestedStructList::DecodableType> a;
    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace DoubleNestedStructList
namespace TestListStructOctet {
enum FieldId
{
    kFabricIndexFieldId     = 0,
    kOperationalCertFieldId = 1,
};

struct Type
{
public:
    uint64_t fabricIndex;
    chip::ByteSpan operationalCert;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace TestListStructOctet

} // namespace TestCluster
namespace Thermostat {
constexpr ClusterId kClusterId = 0x201;

} // namespace Thermostat
namespace ThermostatUserInterfaceConfiguration {
constexpr ClusterId kClusterId = 0x204;

} // namespace ThermostatUserInterfaceConfiguration
namespace ThreadNetworkDiagnostics {
constexpr ClusterId kClusterId = 0x35;
// Enum for NetworkFault
enum class NetworkFault : uint8_t
{
    NETWORK_FAULT_UNSPECIFIED      = 0x00,
    NETWORK_FAULT_LINK_DOWN        = 0x01,
    NETWORK_FAULT_HARDWARE_FAILURE = 0x02,
    NETWORK_FAULT_NETWORK_JAMMED   = 0x03,
};
// Enum for RoutingRole
enum class RoutingRole : uint8_t
{
    ROUTING_ROLE_UNSPECIFIED       = 0x00,
    ROUTING_ROLE_UNASSIGNED        = 0x01,
    ROUTING_ROLE_SLEEPY_END_DEVICE = 0x02,
    ROUTING_ROLE_END_DEVICE        = 0x03,
    ROUTING_ROLE_REED              = 0x04,
    ROUTING_ROLE_ROUTER            = 0x05,
    ROUTING_ROLE_LEADER            = 0x06,
};

namespace NeighborTable {
enum FieldId
{
    kExtAddressFieldId       = 0,
    kAgeFieldId              = 1,
    kRloc16FieldId           = 2,
    kLinkFrameCounterFieldId = 3,
    kMleFrameCounterFieldId  = 4,
    kLqiFieldId              = 5,
    kAverageRssiFieldId      = 6,
    kLastRssiFieldId         = 7,
    kFrameErrorRateFieldId   = 8,
    kMessageErrorRateFieldId = 9,
    kRxOnWhenIdleFieldId     = 10,
    kFullThreadDeviceFieldId = 11,
    kFullNetworkDataFieldId  = 12,
    kIsChildFieldId          = 13,
};

struct Type
{
public:
    uint64_t extAddress;
    uint32_t age;
    uint16_t rloc16;
    uint32_t linkFrameCounter;
    uint32_t mleFrameCounter;
    uint8_t lqi;
    int8_t averageRssi;
    int8_t lastRssi;
    uint8_t frameErrorRate;
    uint8_t messageErrorRate;
    bool rxOnWhenIdle;
    bool fullThreadDevice;
    bool fullNetworkData;
    bool isChild;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NeighborTable
namespace OperationalDatasetComponents {
enum FieldId
{
    kActiveTimestampPresentFieldId  = 0,
    kPendingTimestampPresentFieldId = 1,
    kMasterKeyPresentFieldId        = 2,
    kNetworkNamePresentFieldId      = 3,
    kExtendedPanIdPresentFieldId    = 4,
    kMeshLocalPrefixPresentFieldId  = 5,
    kDelayPresentFieldId            = 6,
    kPanIdPresentFieldId            = 7,
    kChannelPresentFieldId          = 8,
    kPskcPresentFieldId             = 9,
    kSecurityPolicyPresentFieldId   = 10,
    kChannelMaskPresentFieldId      = 11,
};

struct Type
{
public:
    bool activeTimestampPresent;
    bool pendingTimestampPresent;
    bool masterKeyPresent;
    bool networkNamePresent;
    bool extendedPanIdPresent;
    bool meshLocalPrefixPresent;
    bool delayPresent;
    bool panIdPresent;
    bool channelPresent;
    bool pskcPresent;
    bool securityPolicyPresent;
    bool channelMaskPresent;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace OperationalDatasetComponents
namespace RouteTable {
enum FieldId
{
    kExtAddressFieldId      = 0,
    kRloc16FieldId          = 1,
    kRouterIdFieldId        = 2,
    kNextHopFieldId         = 3,
    kPathCostFieldId        = 4,
    kLQIInFieldId           = 5,
    kLQIOutFieldId          = 6,
    kAgeFieldId             = 7,
    kAllocatedFieldId       = 8,
    kLinkEstablishedFieldId = 9,
};

struct Type
{
public:
    uint64_t extAddress;
    uint16_t rloc16;
    uint8_t routerId;
    uint8_t nextHop;
    uint8_t pathCost;
    uint8_t lQIIn;
    uint8_t lQIOut;
    uint8_t age;
    bool allocated;
    bool linkEstablished;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace RouteTable
namespace SecurityPolicy {
enum FieldId
{
    kRotationTimeFieldId = 0,
    kFlagsFieldId        = 1,
};

struct Type
{
public:
    uint16_t rotationTime;
    uint16_t flags;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, uint64_t tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace SecurityPolicy

} // namespace ThreadNetworkDiagnostics
namespace WakeOnLan {
constexpr ClusterId kClusterId = 0x503;

} // namespace WakeOnLan
namespace WiFiNetworkDiagnostics {
constexpr ClusterId kClusterId = 0x36;
// Enum for SecurityType
enum class SecurityType : uint8_t
{
    SECURITY_TYPE_UNSPECIFIED = 0x00,
    SECURITY_TYPE_NONE        = 0x01,
    SECURITY_TYPE_WEP         = 0x02,
    SECURITY_TYPE_WPA         = 0x03,
    SECURITY_TYPE_WPA2        = 0x04,
    SECURITY_TYPE_WPA3        = 0x05,
};
// Enum for WiFiVersionType
enum class WiFiVersionType : uint8_t
{
    WI_FI_VERSION_TYPE_802__11A  = 0x00,
    WI_FI_VERSION_TYPE_802__11B  = 0x01,
    WI_FI_VERSION_TYPE_802__11G  = 0x02,
    WI_FI_VERSION_TYPE_802__11N  = 0x03,
    WI_FI_VERSION_TYPE_802__11AC = 0x04,
    WI_FI_VERSION_TYPE_802__11AX = 0x05,
};

} // namespace WiFiNetworkDiagnostics
namespace WindowCovering {
constexpr ClusterId kClusterId = 0x102;
// Enum for WcEndProductType
enum class WcEndProductType : uint8_t
{
    WC_END_PRODUCT_TYPE_ROLLER_SHADE                 = 0x00,
    WC_END_PRODUCT_TYPE_ROMAN_SHADE                  = 0x01,
    WC_END_PRODUCT_TYPE_BALLOON_SHADE                = 0x02,
    WC_END_PRODUCT_TYPE_WOVEN_WOOD                   = 0x03,
    WC_END_PRODUCT_TYPE_PLEATED_SHADE                = 0x04,
    WC_END_PRODUCT_TYPE_CELLULAR_SHADE               = 0x05,
    WC_END_PRODUCT_TYPE_LAYERED_SHADE                = 0x06,
    WC_END_PRODUCT_TYPE_LAYERED_SHADE2_D             = 0x07,
    WC_END_PRODUCT_TYPE_SHEER_SHADE                  = 0x08,
    WC_END_PRODUCT_TYPE_TILT_ONLY_INTERIOR_BLIND     = 0x09,
    WC_END_PRODUCT_TYPE_INTERIOR_BLIND               = 0x0A,
    WC_END_PRODUCT_TYPE_VERTICAL_BLIND_STRIP_CURTAIN = 0x0B,
    WC_END_PRODUCT_TYPE_INTERIOR_VENETIAN_BLIND      = 0x0C,
    WC_END_PRODUCT_TYPE_EXTERIOR_VENETIAN_BLIND      = 0x0D,
    WC_END_PRODUCT_TYPE_LATERAL_LEFT_CURTAIN         = 0x0E,
    WC_END_PRODUCT_TYPE_LATERAL_RIGHT_CURTAIN        = 0x0F,
    WC_END_PRODUCT_TYPE_CENTRAL_CURTAIN              = 0x10,
    WC_END_PRODUCT_TYPE_ROLLER_SHUTTER               = 0x11,
    WC_END_PRODUCT_TYPE_EXTERIOR_VERTICAL_SCREEN     = 0x12,
    WC_END_PRODUCT_TYPE_AWNING_TERRACE_PATIO         = 0x13,
    WC_END_PRODUCT_TYPE_AWNING_VERTICAL_SCREEN       = 0x14,
    WC_END_PRODUCT_TYPE_TILT_ONLY_PERGOLA            = 0x15,
    WC_END_PRODUCT_TYPE_SWINGING_SHUTTER             = 0x16,
    WC_END_PRODUCT_TYPE_SLIDING_SHUTTER              = 0x17,
    WC_END_PRODUCT_TYPE_UNKNOWN                      = 0xFF,
};
// Enum for WcType
enum class WcType : uint8_t
{
    WC_TYPE_ROLLERSHADE                 = 0x00,
    WC_TYPE_ROLLERSHADE2_MOTOR          = 0x01,
    WC_TYPE_ROLLERSHADE_EXTERIOR        = 0x02,
    WC_TYPE_ROLLERSHADE_EXTERIOR2_MOTOR = 0x03,
    WC_TYPE_DRAPERY                     = 0x04,
    WC_TYPE_AWNING                      = 0x05,
    WC_TYPE_SHUTTER                     = 0x06,
    WC_TYPE_TILT_BLIND_TILT_ONLY        = 0x07,
    WC_TYPE_TILT_BLIND_LIFT_AND_TILT    = 0x08,
    WC_TYPE_PROJECTOR_SCREEN            = 0x09,
    WC_TYPE_UNKNOWN                     = 0xFF,
};

} // namespace WindowCovering

} // namespace clusters
} // namespace app
} // namespace chip
