/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#pragma once

#include <app-common/zap-generated/enums.h>
#include <app-common/zap-generated/ids/Attributes.h>
#include <app-common/zap-generated/ids/Clusters.h>
#include <app-common/zap-generated/ids/Commands.h>
#include <app/EventLoggingTypes.h>
#include <app/data-model/DecodableList.h>
#include <app/data-model/Decode.h>
#include <app/data-model/Encode.h>
#include <app/data-model/List.h>
#include <app/data-model/NullObject.h>
#include <app/util/basic-types.h>
#include <lib/support/BitFlags.h>
#include <protocols/interaction_model/Constants.h>

namespace chip {
namespace app {
namespace Clusters {

namespace PowerConfiguration {

namespace Attributes {

namespace MainsVoltage {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainsVoltage
namespace MainsFrequency {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainsFrequency
namespace MainsAlarmMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsAlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainsAlarmMask
namespace MainsVoltageMinThreshold {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainsVoltageMinThreshold
namespace MainsVoltageMaxThreshold {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltageMaxThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainsVoltageMaxThreshold
namespace MainsVoltageDwellTrip {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MainsVoltageDwellTrip::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MainsVoltageDwellTrip
namespace BatteryVoltage {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryVoltage
namespace BatteryPercentageRemaining {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPercentageRemaining
namespace BatteryManufacturer {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryManufacturer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryManufacturer
namespace BatterySize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatterySize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatterySize
namespace BatteryAhrRating {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAhrRating::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryAhrRating
namespace BatteryQuantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryQuantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryQuantity
namespace BatteryRatedVoltage {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryRatedVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryRatedVoltage
namespace BatteryAlarmMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryAlarmMask
namespace BatteryVoltageMinThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryVoltageMinThreshold
namespace BatteryVoltageThreshold1 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageThreshold1::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryVoltageThreshold1
namespace BatteryVoltageThreshold2 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageThreshold2::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryVoltageThreshold2
namespace BatteryVoltageThreshold3 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltageThreshold3::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryVoltageThreshold3
namespace BatteryPercentageMinThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPercentageMinThreshold
namespace BatteryPercentageThreshold1 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageThreshold1::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPercentageThreshold1
namespace BatteryPercentageThreshold2 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageThreshold2::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPercentageThreshold2
namespace BatteryPercentageThreshold3 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentageThreshold3::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPercentageThreshold3
namespace BatteryAlarmState {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryAlarmState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryAlarmState
namespace Battery2Voltage {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Voltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2Voltage
namespace Battery2PercentageRemaining {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2PercentageRemaining
namespace Battery2Manufacturer {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Manufacturer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2Manufacturer
namespace Battery2Size {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Size::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2Size
namespace Battery2AhrRating {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2AhrRating::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2AhrRating
namespace Battery2Quantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2Quantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2Quantity
namespace Battery2RatedVoltage {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2RatedVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2RatedVoltage
namespace Battery2AlarmMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2AlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2AlarmMask
namespace Battery2VoltageMinThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2VoltageMinThreshold
namespace Battery2VoltageThreshold1 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageThreshold1::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2VoltageThreshold1
namespace Battery2VoltageThreshold2 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageThreshold2::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2VoltageThreshold2
namespace Battery2VoltageThreshold3 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2VoltageThreshold3::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2VoltageThreshold3
namespace Battery2PercentageMinThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2PercentageMinThreshold
namespace Battery2PercentageThreshold1 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageThreshold1::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2PercentageThreshold1
namespace Battery2PercentageThreshold2 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageThreshold2::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2PercentageThreshold2
namespace Battery2PercentageThreshold3 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2PercentageThreshold3::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2PercentageThreshold3
namespace Battery2AlarmState {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery2AlarmState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery2AlarmState
namespace Battery3Voltage {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Voltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3Voltage
namespace Battery3PercentageRemaining {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3PercentageRemaining
namespace Battery3Manufacturer {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Manufacturer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3Manufacturer
namespace Battery3Size {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Size::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3Size
namespace Battery3AhrRating {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3AhrRating::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3AhrRating
namespace Battery3Quantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3Quantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3Quantity
namespace Battery3RatedVoltage {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3RatedVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3RatedVoltage
namespace Battery3AlarmMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3AlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3AlarmMask
namespace Battery3VoltageMinThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3VoltageMinThreshold
namespace Battery3VoltageThreshold1 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageThreshold1::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3VoltageThreshold1
namespace Battery3VoltageThreshold2 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageThreshold2::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3VoltageThreshold2
namespace Battery3VoltageThreshold3 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3VoltageThreshold3::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3VoltageThreshold3
namespace Battery3PercentageMinThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageMinThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3PercentageMinThreshold
namespace Battery3PercentageThreshold1 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageThreshold1::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3PercentageThreshold1
namespace Battery3PercentageThreshold2 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageThreshold2::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3PercentageThreshold2
namespace Battery3PercentageThreshold3 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3PercentageThreshold3::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3PercentageThreshold3
namespace Battery3AlarmState {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Battery3AlarmState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Battery3AlarmState
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MainsVoltage::TypeInfo::DecodableType mainsVoltage;
        Attributes::MainsFrequency::TypeInfo::DecodableType mainsFrequency;
        Attributes::MainsAlarmMask::TypeInfo::DecodableType mainsAlarmMask;
        Attributes::MainsVoltageMinThreshold::TypeInfo::DecodableType mainsVoltageMinThreshold;
        Attributes::MainsVoltageMaxThreshold::TypeInfo::DecodableType mainsVoltageMaxThreshold;
        Attributes::MainsVoltageDwellTrip::TypeInfo::DecodableType mainsVoltageDwellTrip;
        Attributes::BatteryVoltage::TypeInfo::DecodableType batteryVoltage;
        Attributes::BatteryPercentageRemaining::TypeInfo::DecodableType batteryPercentageRemaining;
        Attributes::BatteryManufacturer::TypeInfo::DecodableType batteryManufacturer;
        Attributes::BatterySize::TypeInfo::DecodableType batterySize;
        Attributes::BatteryAhrRating::TypeInfo::DecodableType batteryAhrRating;
        Attributes::BatteryQuantity::TypeInfo::DecodableType batteryQuantity;
        Attributes::BatteryRatedVoltage::TypeInfo::DecodableType batteryRatedVoltage;
        Attributes::BatteryAlarmMask::TypeInfo::DecodableType batteryAlarmMask;
        Attributes::BatteryVoltageMinThreshold::TypeInfo::DecodableType batteryVoltageMinThreshold;
        Attributes::BatteryVoltageThreshold1::TypeInfo::DecodableType batteryVoltageThreshold1;
        Attributes::BatteryVoltageThreshold2::TypeInfo::DecodableType batteryVoltageThreshold2;
        Attributes::BatteryVoltageThreshold3::TypeInfo::DecodableType batteryVoltageThreshold3;
        Attributes::BatteryPercentageMinThreshold::TypeInfo::DecodableType batteryPercentageMinThreshold;
        Attributes::BatteryPercentageThreshold1::TypeInfo::DecodableType batteryPercentageThreshold1;
        Attributes::BatteryPercentageThreshold2::TypeInfo::DecodableType batteryPercentageThreshold2;
        Attributes::BatteryPercentageThreshold3::TypeInfo::DecodableType batteryPercentageThreshold3;
        Attributes::BatteryAlarmState::TypeInfo::DecodableType batteryAlarmState;
        Attributes::Battery2Voltage::TypeInfo::DecodableType battery2Voltage;
        Attributes::Battery2PercentageRemaining::TypeInfo::DecodableType battery2PercentageRemaining;
        Attributes::Battery2Manufacturer::TypeInfo::DecodableType battery2Manufacturer;
        Attributes::Battery2Size::TypeInfo::DecodableType battery2Size;
        Attributes::Battery2AhrRating::TypeInfo::DecodableType battery2AhrRating;
        Attributes::Battery2Quantity::TypeInfo::DecodableType battery2Quantity;
        Attributes::Battery2RatedVoltage::TypeInfo::DecodableType battery2RatedVoltage;
        Attributes::Battery2AlarmMask::TypeInfo::DecodableType battery2AlarmMask;
        Attributes::Battery2VoltageMinThreshold::TypeInfo::DecodableType battery2VoltageMinThreshold;
        Attributes::Battery2VoltageThreshold1::TypeInfo::DecodableType battery2VoltageThreshold1;
        Attributes::Battery2VoltageThreshold2::TypeInfo::DecodableType battery2VoltageThreshold2;
        Attributes::Battery2VoltageThreshold3::TypeInfo::DecodableType battery2VoltageThreshold3;
        Attributes::Battery2PercentageMinThreshold::TypeInfo::DecodableType battery2PercentageMinThreshold;
        Attributes::Battery2PercentageThreshold1::TypeInfo::DecodableType battery2PercentageThreshold1;
        Attributes::Battery2PercentageThreshold2::TypeInfo::DecodableType battery2PercentageThreshold2;
        Attributes::Battery2PercentageThreshold3::TypeInfo::DecodableType battery2PercentageThreshold3;
        Attributes::Battery2AlarmState::TypeInfo::DecodableType battery2AlarmState;
        Attributes::Battery3Voltage::TypeInfo::DecodableType battery3Voltage;
        Attributes::Battery3PercentageRemaining::TypeInfo::DecodableType battery3PercentageRemaining;
        Attributes::Battery3Manufacturer::TypeInfo::DecodableType battery3Manufacturer;
        Attributes::Battery3Size::TypeInfo::DecodableType battery3Size;
        Attributes::Battery3AhrRating::TypeInfo::DecodableType battery3AhrRating;
        Attributes::Battery3Quantity::TypeInfo::DecodableType battery3Quantity;
        Attributes::Battery3RatedVoltage::TypeInfo::DecodableType battery3RatedVoltage;
        Attributes::Battery3AlarmMask::TypeInfo::DecodableType battery3AlarmMask;
        Attributes::Battery3VoltageMinThreshold::TypeInfo::DecodableType battery3VoltageMinThreshold;
        Attributes::Battery3VoltageThreshold1::TypeInfo::DecodableType battery3VoltageThreshold1;
        Attributes::Battery3VoltageThreshold2::TypeInfo::DecodableType battery3VoltageThreshold2;
        Attributes::Battery3VoltageThreshold3::TypeInfo::DecodableType battery3VoltageThreshold3;
        Attributes::Battery3PercentageMinThreshold::TypeInfo::DecodableType battery3PercentageMinThreshold;
        Attributes::Battery3PercentageThreshold1::TypeInfo::DecodableType battery3PercentageThreshold1;
        Attributes::Battery3PercentageThreshold2::TypeInfo::DecodableType battery3PercentageThreshold2;
        Attributes::Battery3PercentageThreshold3::TypeInfo::DecodableType battery3PercentageThreshold3;
        Attributes::Battery3AlarmState::TypeInfo::DecodableType battery3AlarmState;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PowerConfiguration
namespace DeviceTemperatureConfiguration {

namespace Attributes {

namespace CurrentTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentTemperature
namespace MinTempExperienced {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinTempExperienced::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinTempExperienced
namespace MaxTempExperienced {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxTempExperienced::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxTempExperienced
namespace OverTempTotalDwell {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverTempTotalDwell::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverTempTotalDwell
namespace DeviceTempAlarmMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceTempAlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceTempAlarmMask
namespace LowTempThreshold {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LowTempThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LowTempThreshold
namespace HighTempThreshold {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HighTempThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HighTempThreshold
namespace LowTempDwellTripPoint {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LowTempDwellTripPoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LowTempDwellTripPoint
namespace HighTempDwellTripPoint {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HighTempDwellTripPoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HighTempDwellTripPoint
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DeviceTemperatureConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentTemperature::TypeInfo::DecodableType currentTemperature;
        Attributes::MinTempExperienced::TypeInfo::DecodableType minTempExperienced;
        Attributes::MaxTempExperienced::TypeInfo::DecodableType maxTempExperienced;
        Attributes::OverTempTotalDwell::TypeInfo::DecodableType overTempTotalDwell;
        Attributes::DeviceTempAlarmMask::TypeInfo::DecodableType deviceTempAlarmMask;
        Attributes::LowTempThreshold::TypeInfo::DecodableType lowTempThreshold;
        Attributes::HighTempThreshold::TypeInfo::DecodableType highTempThreshold;
        Attributes::LowTempDwellTripPoint::TypeInfo::DecodableType lowTempDwellTripPoint;
        Attributes::HighTempDwellTripPoint::TypeInfo::DecodableType highTempDwellTripPoint;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace DeviceTemperatureConfiguration
namespace Identify {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IdentifyEffectIdentifier
enum class IdentifyEffectIdentifier : uint8_t
{
    kBlink         = 0x00,
    kBreathe       = 0x01,
    kOkay          = 0x02,
    kChannelChange = 0x0B,
    kFinishEffect  = 0xFE,
    kStopEffect    = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IdentifyEffectIdentifier        = EmberAfIdentifyEffectIdentifier;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IdentifyEffectVariant
enum class IdentifyEffectVariant : uint8_t
{
    kDefault = 0x00,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IdentifyEffectVariant           = EmberAfIdentifyEffectVariant;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IdentifyIdentifyType
enum class IdentifyIdentifyType : uint8_t
{
    kNone         = 0x00,
    kVisibleLight = 0x01,
    kVisibleLED   = 0x02,
    kAudibleBeep  = 0x03,
    kDisplay      = 0x04,
    kActuator     = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IdentifyIdentifyType            = EmberAfIdentifyIdentifyType;
#endif

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Identify {
struct Type;
struct DecodableType;
} // namespace Identify

namespace IdentifyQueryResponse {
struct Type;
struct DecodableType;
} // namespace IdentifyQueryResponse

namespace IdentifyQuery {
struct Type;
struct DecodableType;
} // namespace IdentifyQuery

namespace TriggerEffect {
struct Type;
struct DecodableType;
} // namespace TriggerEffect

} // namespace Commands

namespace Commands {
namespace Identify {
enum class Fields
{
    kIdentifyTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t identifyTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Identify::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t identifyTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Identify
namespace IdentifyQueryResponse {
enum class Fields
{
    kTimeout = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::IdentifyQueryResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t timeout;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::IdentifyQueryResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    uint16_t timeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace IdentifyQueryResponse
namespace IdentifyQuery {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::IdentifyQuery::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Identify::Commands::IdentifyQueryResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::IdentifyQuery::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace IdentifyQuery
namespace TriggerEffect {
enum class Fields
{
    kEffectIdentifier = 0,
    kEffectVariant    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    IdentifyEffectIdentifier effectIdentifier;
    IdentifyEffectVariant effectVariant;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TriggerEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

    IdentifyEffectIdentifier effectIdentifier;
    IdentifyEffectVariant effectVariant;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TriggerEffect
} // namespace Commands

namespace Attributes {

namespace IdentifyTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdentifyTime
namespace IdentifyType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IdentifyType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IdentifyType
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Identify::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::IdentifyTime::TypeInfo::DecodableType identifyTime;
        Attributes::IdentifyType::TypeInfo::DecodableType identifyType;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Identify
namespace Groups {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddGroup {
struct Type;
struct DecodableType;
} // namespace AddGroup

namespace AddGroupResponse {
struct Type;
struct DecodableType;
} // namespace AddGroupResponse

namespace ViewGroup {
struct Type;
struct DecodableType;
} // namespace ViewGroup

namespace ViewGroupResponse {
struct Type;
struct DecodableType;
} // namespace ViewGroupResponse

namespace GetGroupMembership {
struct Type;
struct DecodableType;
} // namespace GetGroupMembership

namespace GetGroupMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetGroupMembershipResponse

namespace RemoveGroup {
struct Type;
struct DecodableType;
} // namespace RemoveGroup

namespace RemoveGroupResponse {
struct Type;
struct DecodableType;
} // namespace RemoveGroupResponse

namespace RemoveAllGroups {
struct Type;
struct DecodableType;
} // namespace RemoveAllGroups

namespace AddGroupIfIdentifying {
struct Type;
struct DecodableType;
} // namespace AddGroupIfIdentifying

} // namespace Commands

namespace Commands {
namespace AddGroup {
enum class Fields
{
    kGroupId   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Groups::Commands::AddGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroup
namespace AddGroupResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status;
    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupResponse
namespace ViewGroup {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Groups::Commands::ViewGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroup
namespace ViewGroupResponse {
enum class Fields
{
    kStatus    = 0,
    kGroupId   = 1,
    kGroupName = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewGroupResponse
namespace GetGroupMembership {
enum class Fields
{
    kGroupList = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::List<const uint16_t> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Groups::Commands::GetGroupMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    DataModel::DecodableList<uint16_t> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembership
namespace GetGroupMembershipResponse {
enum class Fields
{
    kCapacity  = 0,
    kGroupList = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t capacity;
    DataModel::List<const uint16_t> groupList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetGroupMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t capacity;
    DataModel::DecodableList<uint16_t> groupList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetGroupMembershipResponse
namespace RemoveGroup {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Groups::Commands::RemoveGroupResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroup::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroup
namespace RemoveGroupResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status;
    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveGroupResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint8_t status;
    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveGroupResponse
namespace RemoveAllGroups {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllGroups::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllGroups
namespace AddGroupIfIdentifying {
enum class Fields
{
    kGroupId   = 0,
    kGroupName = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddGroupIfIdentifying::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

    uint16_t groupId;
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddGroupIfIdentifying
} // namespace Commands

namespace Attributes {

namespace NameSupport {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NameSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NameSupport
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Groups::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NameSupport::TypeInfo::DecodableType nameSupport;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Groups
namespace Scenes {

// Bitmap for ScenesCopyMode
enum class ScenesCopyMode : uint8_t
{
    kCopyAllScenes = 0x1,
};

namespace Structs {
namespace SceneExtensionFieldSet {
enum class Fields
{
    kClusterId = 1,
    kLength    = 2,
    kValue     = 3,
};

struct Type
{
public:
    chip::ClusterId clusterId;
    uint8_t length;
    uint8_t value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SceneExtensionFieldSet
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AddScene {
struct Type;
struct DecodableType;
} // namespace AddScene

namespace AddSceneResponse {
struct Type;
struct DecodableType;
} // namespace AddSceneResponse

namespace ViewScene {
struct Type;
struct DecodableType;
} // namespace ViewScene

namespace ViewSceneResponse {
struct Type;
struct DecodableType;
} // namespace ViewSceneResponse

namespace RemoveScene {
struct Type;
struct DecodableType;
} // namespace RemoveScene

namespace RemoveSceneResponse {
struct Type;
struct DecodableType;
} // namespace RemoveSceneResponse

namespace RemoveAllScenes {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenes

namespace RemoveAllScenesResponse {
struct Type;
struct DecodableType;
} // namespace RemoveAllScenesResponse

namespace StoreScene {
struct Type;
struct DecodableType;
} // namespace StoreScene

namespace StoreSceneResponse {
struct Type;
struct DecodableType;
} // namespace StoreSceneResponse

namespace RecallScene {
struct Type;
struct DecodableType;
} // namespace RecallScene

namespace GetSceneMembership {
struct Type;
struct DecodableType;
} // namespace GetSceneMembership

namespace GetSceneMembershipResponse {
struct Type;
struct DecodableType;
} // namespace GetSceneMembershipResponse

namespace EnhancedAddScene {
struct Type;
struct DecodableType;
} // namespace EnhancedAddScene

namespace EnhancedAddSceneResponse {
struct Type;
struct DecodableType;
} // namespace EnhancedAddSceneResponse

namespace EnhancedViewScene {
struct Type;
struct DecodableType;
} // namespace EnhancedViewScene

namespace EnhancedViewSceneResponse {
struct Type;
struct DecodableType;
} // namespace EnhancedViewSceneResponse

namespace CopyScene {
struct Type;
struct DecodableType;
} // namespace CopyScene

namespace CopySceneResponse {
struct Type;
struct DecodableType;
} // namespace CopySceneResponse

} // namespace Commands

namespace Commands {
namespace AddScene {
enum class Fields
{
    kGroupId            = 0,
    kSceneId            = 1,
    kTransitionTime     = 2,
    kSceneName          = 3,
    kExtensionFieldSets = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::List<const Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::AddSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddScene
namespace AddSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddSceneResponse
namespace ViewScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::ViewSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewScene
namespace ViewSceneResponse {
enum class Fields
{
    kStatus             = 0,
    kGroupId            = 1,
    kSceneId            = 2,
    kTransitionTime     = 3,
    kSceneName          = 4,
    kExtensionFieldSets = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::List<const Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ViewSceneResponse
namespace RemoveScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::RemoveSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveScene
namespace RemoveSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveSceneResponse
namespace RemoveAllScenes {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::RemoveAllScenesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenes
namespace RemoveAllScenesResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveAllScenesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveAllScenesResponse
namespace StoreScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::StoreSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreScene
namespace StoreSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StoreSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StoreSceneResponse
namespace RecallScene {
enum class Fields
{
    kGroupId        = 0,
    kSceneId        = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RecallScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RecallScene
namespace GetSceneMembership {
enum class Fields
{
    kGroupId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::GetSceneMembershipResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembership::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembership
namespace GetSceneMembershipResponse {
enum class Fields
{
    kStatus     = 0,
    kCapacity   = 1,
    kGroupId    = 2,
    kSceneCount = 3,
    kSceneList  = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint8_t capacity;
    uint16_t groupId;
    uint8_t sceneCount;
    DataModel::List<const uint8_t> sceneList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSceneMembershipResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint8_t capacity;
    uint16_t groupId;
    uint8_t sceneCount;
    DataModel::DecodableList<uint8_t> sceneList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSceneMembershipResponse
namespace EnhancedAddScene {
enum class Fields
{
    kGroupId            = 0,
    kSceneId            = 1,
    kTransitionTime     = 2,
    kSceneName          = 3,
    kExtensionFieldSets = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedAddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::List<const Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::EnhancedAddSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedAddScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedAddScene
namespace EnhancedAddSceneResponse {
enum class Fields
{
    kStatus  = 0,
    kGroupId = 1,
    kSceneId = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedAddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedAddSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedAddSceneResponse
namespace EnhancedViewScene {
enum class Fields
{
    kGroupId = 0,
    kSceneId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::EnhancedViewSceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedViewScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint16_t groupId;
    uint8_t sceneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedViewScene
namespace EnhancedViewSceneResponse {
enum class Fields
{
    kStatus             = 0,
    kGroupId            = 1,
    kSceneId            = 2,
    kTransitionTime     = 3,
    kSceneName          = 4,
    kExtensionFieldSets = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::List<const Structs::SceneExtensionFieldSet::Type> extensionFieldSets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedViewSceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupId;
    uint8_t sceneId;
    uint16_t transitionTime;
    chip::CharSpan sceneName;
    DataModel::DecodableList<Structs::SceneExtensionFieldSet::DecodableType> extensionFieldSets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedViewSceneResponse
namespace CopyScene {
enum class Fields
{
    kMode        = 0,
    kGroupIdFrom = 1,
    kSceneIdFrom = 2,
    kGroupIdTo   = 3,
    kSceneIdTo   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    chip::BitFlags<ScenesCopyMode> mode;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;
    uint16_t groupIdTo;
    uint8_t sceneIdTo;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Scenes::Commands::CopySceneResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopyScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    chip::BitFlags<ScenesCopyMode> mode;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;
    uint16_t groupIdTo;
    uint8_t sceneIdTo;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopyScene
namespace CopySceneResponse {
enum class Fields
{
    kStatus      = 0,
    kGroupIdFrom = 1,
    kSceneIdFrom = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CopySceneResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

    uint8_t status;
    uint16_t groupIdFrom;
    uint8_t sceneIdFrom;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CopySceneResponse
} // namespace Commands

namespace Attributes {

namespace SceneCount {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SceneCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SceneCount
namespace CurrentScene {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentScene::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentScene
namespace CurrentGroup {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentGroup::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentGroup
namespace SceneValid {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SceneValid::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SceneValid
namespace NameSupport {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NameSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NameSupport
namespace LastConfiguredBy {
struct TypeInfo
{
    using Type             = chip::NodeId;
    using DecodableType    = chip::NodeId;
    using DecodableArgType = chip::NodeId;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConfiguredBy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastConfiguredBy
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Scenes::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SceneCount::TypeInfo::DecodableType sceneCount;
        Attributes::CurrentScene::TypeInfo::DecodableType currentScene;
        Attributes::CurrentGroup::TypeInfo::DecodableType currentGroup;
        Attributes::SceneValid::TypeInfo::DecodableType sceneValid;
        Attributes::NameSupport::TypeInfo::DecodableType nameSupport;
        Attributes::LastConfiguredBy::TypeInfo::DecodableType lastConfiguredBy;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Scenes
namespace OnOff {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OnOffDelayedAllOffEffectVariant
enum class OnOffDelayedAllOffEffectVariant : uint8_t
{
    kFadeToOffIn0p8Seconds                                = 0x00,
    kNoFade                                               = 0x01,
    k50PercentDimDownIn0p8SecondsThenFadeToOffIn12Seconds = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OnOffDelayedAllOffEffectVariant = EmberAfOnOffDelayedAllOffEffectVariant;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OnOffDyingLightEffectVariant
enum class OnOffDyingLightEffectVariant : uint8_t
{
    k20PercenterDimUpIn0p5SecondsThenFadeToOffIn1Second = 0x00,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OnOffDyingLightEffectVariant    = EmberAfOnOffDyingLightEffectVariant;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OnOffEffectIdentifier
enum class OnOffEffectIdentifier : uint8_t
{
    kDelayedAllOff = 0x00,
    kDyingLight    = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OnOffEffectIdentifier           = EmberAfOnOffEffectIdentifier;
#endif

// Bitmap for OnOffControl
enum class OnOffControl : uint8_t
{
    kAcceptOnlyWhenOn = 0x1,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Off {
struct Type;
struct DecodableType;
} // namespace Off

namespace On {
struct Type;
struct DecodableType;
} // namespace On

namespace Toggle {
struct Type;
struct DecodableType;
} // namespace Toggle

namespace OffWithEffect {
struct Type;
struct DecodableType;
} // namespace OffWithEffect

namespace OnWithRecallGlobalScene {
struct Type;
struct DecodableType;
} // namespace OnWithRecallGlobalScene

namespace OnWithTimedOff {
struct Type;
struct DecodableType;
} // namespace OnWithTimedOff

} // namespace Commands

namespace Commands {
namespace Off {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Off::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Off::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Off
namespace On {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::On::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::On::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace On
namespace Toggle {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Toggle::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Toggle
namespace OffWithEffect {
enum class Fields
{
    kEffectId      = 0,
    kEffectVariant = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    OnOffEffectIdentifier effectId;
    OnOffDelayedAllOffEffectVariant effectVariant;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OffWithEffect::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    OnOffEffectIdentifier effectId;
    OnOffDelayedAllOffEffectVariant effectVariant;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OffWithEffect
namespace OnWithRecallGlobalScene {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OnWithRecallGlobalScene::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithRecallGlobalScene
namespace OnWithTimedOff {
enum class Fields
{
    kOnOffControl = 0,
    kOnTime       = 1,
    kOffWaitTime  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    chip::BitFlags<OnOffControl> onOffControl;
    uint16_t onTime;
    uint16_t offWaitTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OnWithTimedOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

    chip::BitFlags<OnOffControl> onOffControl;
    uint16_t onTime;
    uint16_t offWaitTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OnWithTimedOff
} // namespace Commands

namespace Attributes {

namespace OnOff {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnOff
namespace GlobalSceneControl {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GlobalSceneControl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GlobalSceneControl
namespace OnTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnTime
namespace OffWaitTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffWaitTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OffWaitTime
namespace StartUpOnOff {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpOnOff::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpOnOff
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OnOff::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::OnOff::TypeInfo::DecodableType onOff;
        Attributes::GlobalSceneControl::TypeInfo::DecodableType globalSceneControl;
        Attributes::OnTime::TypeInfo::DecodableType onTime;
        Attributes::OffWaitTime::TypeInfo::DecodableType offWaitTime;
        Attributes::StartUpOnOff::TypeInfo::DecodableType startUpOnOff;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OnOff
namespace OnOffSwitchConfiguration {

namespace Attributes {

namespace SwitchType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SwitchType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SwitchType
namespace SwitchActions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SwitchActions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SwitchActions
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OnOffSwitchConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::SwitchType::TypeInfo::DecodableType switchType;
        Attributes::SwitchActions::TypeInfo::DecodableType switchActions;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OnOffSwitchConfiguration
namespace LevelControl {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MoveMode
enum class MoveMode : uint8_t
{
    kUp   = 0x00,
    kDown = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MoveMode                        = EmberAfMoveMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for StepMode
enum class StepMode : uint8_t
{
    kUp   = 0x00,
    kDown = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using StepMode                        = EmberAfStepMode;
#endif

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToLevel {
struct Type;
struct DecodableType;
} // namespace MoveToLevel

namespace Move {
struct Type;
struct DecodableType;
} // namespace Move

namespace Step {
struct Type;
struct DecodableType;
} // namespace Step

namespace Stop {
struct Type;
struct DecodableType;
} // namespace Stop

namespace MoveToLevelWithOnOff {
struct Type;
struct DecodableType;
} // namespace MoveToLevelWithOnOff

namespace MoveWithOnOff {
struct Type;
struct DecodableType;
} // namespace MoveWithOnOff

namespace StepWithOnOff {
struct Type;
struct DecodableType;
} // namespace StepWithOnOff

namespace StopWithOnOff {
struct Type;
struct DecodableType;
} // namespace StopWithOnOff

} // namespace Commands

namespace Commands {
namespace MoveToLevel {
enum class Fields
{
    kLevel          = 0,
    kTransitionTime = 1,
    kOptionMask     = 2,
    kOptionOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevel
namespace Move {
enum class Fields
{
    kMoveMode       = 0,
    kRate           = 1,
    kOptionMask     = 2,
    kOptionOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Move::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;
    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Move::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;
    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Move
namespace Step {
enum class Fields
{
    kStepMode       = 0,
    kStepSize       = 1,
    kTransitionTime = 2,
    kOptionMask     = 3,
    kOptionOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Step::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;
    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Step
namespace Stop {
enum class Fields
{
    kOptionMask     = 0,
    kOptionOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t optionMask;
    uint8_t optionOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Stop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t optionMask;
    uint8_t optionOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Stop
namespace MoveToLevelWithOnOff {
enum class Fields
{
    kLevel          = 0,
    kTransitionTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToLevelWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    uint8_t level;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToLevelWithOnOff
namespace MoveWithOnOff {
enum class Fields
{
    kMoveMode = 0,
    kRate     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    MoveMode moveMode;
    uint8_t rate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveWithOnOff
namespace StepWithOnOff {
enum class Fields
{
    kStepMode       = 0,
    kStepSize       = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    StepMode stepMode;
    uint8_t stepSize;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepWithOnOff
namespace StopWithOnOff {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopWithOnOff::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopWithOnOff
} // namespace Commands

namespace Attributes {

namespace CurrentLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentLevel
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace MinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxLevel
namespace CurrentFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFrequency
namespace MinFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinFrequency
namespace MaxFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxFrequency
namespace Options {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Options::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Options
namespace OnOffTransitionTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnOffTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnOffTransitionTime
namespace OnLevel {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnLevel
namespace OnTransitionTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnTransitionTime
namespace OffTransitionTime {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OffTransitionTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OffTransitionTime
namespace DefaultMoveRate {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultMoveRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultMoveRate
namespace StartUpCurrentLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpCurrentLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpCurrentLevel
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LevelControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentLevel::TypeInfo::DecodableType currentLevel;
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime;
        Attributes::MinLevel::TypeInfo::DecodableType minLevel;
        Attributes::MaxLevel::TypeInfo::DecodableType maxLevel;
        Attributes::CurrentFrequency::TypeInfo::DecodableType currentFrequency;
        Attributes::MinFrequency::TypeInfo::DecodableType minFrequency;
        Attributes::MaxFrequency::TypeInfo::DecodableType maxFrequency;
        Attributes::Options::TypeInfo::DecodableType options;
        Attributes::OnOffTransitionTime::TypeInfo::DecodableType onOffTransitionTime;
        Attributes::OnLevel::TypeInfo::DecodableType onLevel;
        Attributes::OnTransitionTime::TypeInfo::DecodableType onTransitionTime;
        Attributes::OffTransitionTime::TypeInfo::DecodableType offTransitionTime;
        Attributes::DefaultMoveRate::TypeInfo::DecodableType defaultMoveRate;
        Attributes::StartUpCurrentLevel::TypeInfo::DecodableType startUpCurrentLevel;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace LevelControl
namespace Alarms {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetAlarm {
struct Type;
struct DecodableType;
} // namespace ResetAlarm

namespace Alarm {
struct Type;
struct DecodableType;
} // namespace Alarm

namespace ResetAllAlarms {
struct Type;
struct DecodableType;
} // namespace ResetAllAlarms

namespace GetAlarmResponse {
struct Type;
struct DecodableType;
} // namespace GetAlarmResponse

namespace GetAlarm {
struct Type;
struct DecodableType;
} // namespace GetAlarm

namespace ResetAlarmLog {
struct Type;
struct DecodableType;
} // namespace ResetAlarmLog

} // namespace Commands

namespace Commands {
namespace ResetAlarm {
enum class Fields
{
    kAlarmCode = 0,
    kClusterId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetAlarm
namespace Alarm {
enum class Fields
{
    kAlarmCode = 0,
    kClusterId = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Alarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Alarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    uint8_t alarmCode;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Alarm
namespace ResetAllAlarms {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetAllAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetAllAlarms::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetAllAlarms
namespace GetAlarmResponse {
enum class Fields
{
    kStatus    = 0,
    kAlarmCode = 1,
    kClusterId = 2,
    kTimeStamp = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetAlarmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    uint8_t status;
    uint8_t alarmCode;
    chip::ClusterId clusterId;
    uint32_t timeStamp;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetAlarmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    uint8_t status;
    uint8_t alarmCode;
    chip::ClusterId clusterId;
    uint32_t timeStamp;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlarmResponse
namespace GetAlarm {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Alarms::Commands::GetAlarmResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetAlarm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlarm
namespace ResetAlarmLog {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetAlarmLog::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetAlarmLog::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetAlarmLog
} // namespace Commands

namespace Attributes {

namespace AlarmCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmCount
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Alarms::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AlarmCount::TypeInfo::DecodableType alarmCount;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Alarms
namespace Time {

namespace Attributes {

namespace Time {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Time::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Time
namespace TimeStatus {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeStatus
namespace TimeZone {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeZone::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeZone
namespace DstStart {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DstStart::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DstStart
namespace DstEnd {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DstEnd::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DstEnd
namespace DstShift {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DstShift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DstShift
namespace StandardTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StandardTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StandardTime
namespace LocalTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTime
namespace LastSetTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastSetTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastSetTime
namespace ValidUntilTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ValidUntilTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ValidUntilTime
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Time::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Time::TypeInfo::DecodableType time;
        Attributes::TimeStatus::TypeInfo::DecodableType timeStatus;
        Attributes::TimeZone::TypeInfo::DecodableType timeZone;
        Attributes::DstStart::TypeInfo::DecodableType dstStart;
        Attributes::DstEnd::TypeInfo::DecodableType dstEnd;
        Attributes::DstShift::TypeInfo::DecodableType dstShift;
        Attributes::StandardTime::TypeInfo::DecodableType standardTime;
        Attributes::LocalTime::TypeInfo::DecodableType localTime;
        Attributes::LastSetTime::TypeInfo::DecodableType lastSetTime;
        Attributes::ValidUntilTime::TypeInfo::DecodableType validUntilTime;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Time
namespace BinaryInputBasic {

namespace Attributes {

namespace ActiveText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveText
namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Description
namespace InactiveText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InactiveText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InactiveText
namespace OutOfService {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutOfService::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutOfService
namespace Polarity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Polarity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Polarity
namespace PresentValue {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PresentValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PresentValue
namespace Reliability {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reliability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reliability
namespace StatusFlags {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StatusFlags::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StatusFlags
namespace ApplicationType {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationType
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BinaryInputBasic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActiveText::TypeInfo::DecodableType activeText;
        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::InactiveText::TypeInfo::DecodableType inactiveText;
        Attributes::OutOfService::TypeInfo::DecodableType outOfService;
        Attributes::Polarity::TypeInfo::DecodableType polarity;
        Attributes::PresentValue::TypeInfo::DecodableType presentValue;
        Attributes::Reliability::TypeInfo::DecodableType reliability;
        Attributes::StatusFlags::TypeInfo::DecodableType statusFlags;
        Attributes::ApplicationType::TypeInfo::DecodableType applicationType;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BinaryInputBasic
namespace PowerProfile {

namespace Structs {
namespace PowerProfileRecord {
enum class Fields
{
    kPowerProfileId            = 1,
    kEnergyPhaseId             = 2,
    kPowerProfileRemoteControl = 3,
    kPowerProfileState         = 4,
};

struct Type
{
public:
    uint8_t powerProfileId;
    uint8_t energyPhaseId;
    bool powerProfileRemoteControl;
    uint8_t powerProfileState;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace PowerProfileRecord
namespace ScheduledPhase {
enum class Fields
{
    kEnergyPhaseId = 1,
    kScheduledTime = 2,
};

struct Type
{
public:
    uint8_t energyPhaseId;
    uint16_t scheduledTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ScheduledPhase
namespace TransferredPhase {
enum class Fields
{
    kEnergyPhaseId      = 1,
    kMacroPhaseId       = 2,
    kExpectedDuration   = 3,
    kPeakPower          = 4,
    kEnergy             = 5,
    kMaxActivationDelay = 6,
};

struct Type
{
public:
    uint8_t energyPhaseId;
    uint8_t macroPhaseId;
    uint16_t expectedDuration;
    uint16_t peakPower;
    uint16_t energy;
    uint16_t maxActivationDelay;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TransferredPhase
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace PowerProfileRequest {
struct Type;
struct DecodableType;
} // namespace PowerProfileRequest

namespace PowerProfileNotification {
struct Type;
struct DecodableType;
} // namespace PowerProfileNotification

namespace PowerProfileStateRequest {
struct Type;
struct DecodableType;
} // namespace PowerProfileStateRequest

namespace PowerProfileResponse {
struct Type;
struct DecodableType;
} // namespace PowerProfileResponse

namespace GetPowerProfilePriceResponse {
struct Type;
struct DecodableType;
} // namespace GetPowerProfilePriceResponse

namespace PowerProfileStateResponse {
struct Type;
struct DecodableType;
} // namespace PowerProfileStateResponse

namespace GetOverallSchedulePriceResponse {
struct Type;
struct DecodableType;
} // namespace GetOverallSchedulePriceResponse

namespace GetPowerProfilePrice {
struct Type;
struct DecodableType;
} // namespace GetPowerProfilePrice

namespace EnergyPhasesScheduleNotification {
struct Type;
struct DecodableType;
} // namespace EnergyPhasesScheduleNotification

namespace PowerProfilesStateNotification {
struct Type;
struct DecodableType;
} // namespace PowerProfilesStateNotification

namespace EnergyPhasesScheduleResponse {
struct Type;
struct DecodableType;
} // namespace EnergyPhasesScheduleResponse

namespace GetOverallSchedulePrice {
struct Type;
struct DecodableType;
} // namespace GetOverallSchedulePrice

namespace PowerProfileScheduleConstraintsRequest {
struct Type;
struct DecodableType;
} // namespace PowerProfileScheduleConstraintsRequest

namespace EnergyPhasesScheduleRequest {
struct Type;
struct DecodableType;
} // namespace EnergyPhasesScheduleRequest

namespace EnergyPhasesScheduleStateRequest {
struct Type;
struct DecodableType;
} // namespace EnergyPhasesScheduleStateRequest

namespace EnergyPhasesScheduleStateResponse {
struct Type;
struct DecodableType;
} // namespace EnergyPhasesScheduleStateResponse

namespace GetPowerProfilePriceExtendedResponse {
struct Type;
struct DecodableType;
} // namespace GetPowerProfilePriceExtendedResponse

namespace EnergyPhasesScheduleStateNotification {
struct Type;
struct DecodableType;
} // namespace EnergyPhasesScheduleStateNotification

namespace PowerProfileScheduleConstraintsNotification {
struct Type;
struct DecodableType;
} // namespace PowerProfileScheduleConstraintsNotification

namespace PowerProfileScheduleConstraintsResponse {
struct Type;
struct DecodableType;
} // namespace PowerProfileScheduleConstraintsResponse

namespace GetPowerProfilePriceExtended {
struct Type;
struct DecodableType;
} // namespace GetPowerProfilePriceExtended

} // namespace Commands

namespace Commands {
namespace PowerProfileRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::PowerProfileResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileRequest
namespace PowerProfileNotification {
enum class Fields
{
    kTotalProfileNum        = 0,
    kPowerProfileId         = 1,
    kNumOfTransferredPhases = 2,
    kTransferredPhases      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::List<const Structs::TransferredPhase::Type> transferredPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::DecodableList<Structs::TransferredPhase::DecodableType> transferredPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileNotification
namespace PowerProfileStateRequest {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::PowerProfileStateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileStateRequest
namespace PowerProfileResponse {
enum class Fields
{
    kTotalProfileNum        = 0,
    kPowerProfileId         = 1,
    kNumOfTransferredPhases = 2,
    kTransferredPhases      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::List<const Structs::TransferredPhase::Type> transferredPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t totalProfileNum;
    uint8_t powerProfileId;
    uint8_t numOfTransferredPhases;
    DataModel::DecodableList<Structs::TransferredPhase::DecodableType> transferredPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileResponse
namespace GetPowerProfilePriceResponse {
enum class Fields
{
    kPowerProfileId     = 0,
    kCurrency           = 1,
    kPrice              = 2,
    kPriceTrailingDigit = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePriceResponse
namespace PowerProfileStateResponse {
enum class Fields
{
    kPowerProfileCount   = 0,
    kPowerProfileRecords = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::List<const Structs::PowerProfileRecord::Type> powerProfileRecords;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::DecodableList<Structs::PowerProfileRecord::DecodableType> powerProfileRecords;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileStateResponse
namespace GetOverallSchedulePriceResponse {
enum class Fields
{
    kCurrency           = 0,
    kPrice              = 1,
    kPriceTrailingDigit = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetOverallSchedulePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetOverallSchedulePriceResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetOverallSchedulePriceResponse
namespace GetPowerProfilePrice {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePrice::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::GetPowerProfilePriceResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePrice::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePrice
namespace EnergyPhasesScheduleNotification {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<const Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleNotification
namespace PowerProfilesStateNotification {
enum class Fields
{
    kPowerProfileCount   = 0,
    kPowerProfileRecords = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfilesStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::List<const Structs::PowerProfileRecord::Type> powerProfileRecords;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfilesStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileCount;
    DataModel::DecodableList<Structs::PowerProfileRecord::DecodableType> powerProfileRecords;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfilesStateNotification
namespace EnergyPhasesScheduleResponse {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<const Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleResponse
namespace GetOverallSchedulePrice {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetOverallSchedulePrice::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::GetOverallSchedulePriceResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetOverallSchedulePrice::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetOverallSchedulePrice
namespace PowerProfileScheduleConstraintsRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileScheduleConstraintsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::PowerProfileScheduleConstraintsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileScheduleConstraintsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileScheduleConstraintsRequest
namespace EnergyPhasesScheduleRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::EnergyPhasesScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleRequest
namespace EnergyPhasesScheduleStateRequest {
enum class Fields
{
    kPowerProfileId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::EnergyPhasesScheduleStateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleStateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleStateRequest
namespace EnergyPhasesScheduleStateResponse {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<const Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleStateResponse
namespace GetPowerProfilePriceExtendedResponse {
enum class Fields
{
    kPowerProfileId     = 0,
    kCurrency           = 1,
    kPrice              = 2,
    kPriceTrailingDigit = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePriceExtendedResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePriceExtendedResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t currency;
    uint32_t price;
    uint8_t priceTrailingDigit;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePriceExtendedResponse
namespace EnergyPhasesScheduleStateNotification {
enum class Fields
{
    kPowerProfileId       = 0,
    kNumOfScheduledPhases = 1,
    kScheduledPhases      = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::List<const Structs::ScheduledPhase::Type> scheduledPhases;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnergyPhasesScheduleStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint8_t numOfScheduledPhases;
    DataModel::DecodableList<Structs::ScheduledPhase::DecodableType> scheduledPhases;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnergyPhasesScheduleStateNotification
namespace PowerProfileScheduleConstraintsNotification {
enum class Fields
{
    kPowerProfileId = 0,
    kStartAfter     = 1,
    kStopBefore     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileScheduleConstraintsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileScheduleConstraintsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileScheduleConstraintsNotification
namespace PowerProfileScheduleConstraintsResponse {
enum class Fields
{
    kPowerProfileId = 0,
    kStartAfter     = 1,
    kStopBefore     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileScheduleConstraintsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PowerProfileScheduleConstraintsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t powerProfileId;
    uint16_t startAfter;
    uint16_t stopBefore;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PowerProfileScheduleConstraintsResponse
namespace GetPowerProfilePriceExtended {
enum class Fields
{
    kOptions               = 0,
    kPowerProfileId        = 1,
    kPowerProfileStartTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePriceExtended::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t options;
    uint8_t powerProfileId;
    uint16_t powerProfileStartTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PowerProfile::Commands::GetPowerProfilePriceExtendedResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPowerProfilePriceExtended::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

    uint8_t options;
    uint8_t powerProfileId;
    uint16_t powerProfileStartTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPowerProfilePriceExtended
} // namespace Commands

namespace Attributes {

namespace TotalProfileNum {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalProfileNum::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalProfileNum
namespace MultipleScheduling {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MultipleScheduling::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MultipleScheduling
namespace EnergyFormatting {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyFormatting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnergyFormatting
namespace EnergyRemote {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnergyRemote::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnergyRemote
namespace ScheduleMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduleMode
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerProfile::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TotalProfileNum::TypeInfo::DecodableType totalProfileNum;
        Attributes::MultipleScheduling::TypeInfo::DecodableType multipleScheduling;
        Attributes::EnergyFormatting::TypeInfo::DecodableType energyFormatting;
        Attributes::EnergyRemote::TypeInfo::DecodableType energyRemote;
        Attributes::ScheduleMode::TypeInfo::DecodableType scheduleMode;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PowerProfile
namespace ApplianceControl {
// Enum for ApplianceStatus
enum class ApplianceStatus : uint8_t
{
    kOff                      = 0x01,
    kStandBy                  = 0x02,
    kProgrammed               = 0x03,
    kProgrammedWaitingToStart = 0x04,
    kRunning                  = 0x05,
    kPause                    = 0x06,
    kEndProgrammed            = 0x07,
    kFailure                  = 0x08,
    kProgrammeInterrupted     = 0x09,
    kIdle                     = 0x0A,
    kRinseHold                = 0x0B,
    kService                  = 0x0C,
    kSuperfreezing            = 0x0D,
    kSupercooling             = 0x0E,
    kSuperheating             = 0x0F,
};
// Enum for CommandIdentification
enum class CommandIdentification : uint8_t
{
    kStart                = 0x01,
    kStop                 = 0x02,
    kPause                = 0x03,
    kStartSuperfreezing   = 0x04,
    kStopSuperfreezing    = 0x05,
    kStartSupercooling    = 0x06,
    kStopSupercooling     = 0x07,
    kDisableGas           = 0x08,
    kEnableGas            = 0x09,
    kEnableEnergyControl  = 0x0A,
    kDisableEnergyControl = 0x0B,
};
// Enum for WarningEvent
enum class WarningEvent : uint8_t
{
    kWarning1OverallPowerAboveAvailablePowerLevel                                      = 0x00,
    kWarning2OverallPowerAbovePowerThresholdLevel                                      = 0x01,
    kWarning3OverallPowerBackBelowTheAvailablePowerLevel                               = 0x02,
    kWarning4OverallPowerBackBelowThePowerThresholdLevel                               = 0x03,
    kWarning5OverallPowerWillBePotentiallyAboveAvailablePowerLevelIfTheApplianceStarts = 0x04,
};

// Bitmap for RemoteEnableFlagsAndDeviceStatus2
enum class RemoteEnableFlagsAndDeviceStatus2 : uint8_t
{
    kRemoteEnableFlags      = 0xF,
    kDeviceStatus2Structure = 0xF0,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ExecutionOfACommand {
struct Type;
struct DecodableType;
} // namespace ExecutionOfACommand

namespace SignalStateResponse {
struct Type;
struct DecodableType;
} // namespace SignalStateResponse

namespace SignalState {
struct Type;
struct DecodableType;
} // namespace SignalState

namespace SignalStateNotification {
struct Type;
struct DecodableType;
} // namespace SignalStateNotification

namespace WriteFunctions {
struct Type;
struct DecodableType;
} // namespace WriteFunctions

namespace OverloadPauseResume {
struct Type;
struct DecodableType;
} // namespace OverloadPauseResume

namespace OverloadPause {
struct Type;
struct DecodableType;
} // namespace OverloadPause

namespace OverloadWarning {
struct Type;
struct DecodableType;
} // namespace OverloadWarning

} // namespace Commands

namespace Commands {
namespace ExecutionOfACommand {
enum class Fields
{
    kCommandId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ExecutionOfACommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CommandIdentification commandId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ExecutionOfACommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CommandIdentification commandId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ExecutionOfACommand
namespace SignalStateResponse {
enum class Fields
{
    kApplianceStatus                   = 0,
    kRemoteEnableFlagsAndDeviceStatus2 = 1,
    kApplianceStatus2                  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SignalStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    chip::BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SignalStateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    chip::BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignalStateResponse
namespace SignalState {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SignalState::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplianceControl::Commands::SignalStateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SignalState::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignalState
namespace SignalStateNotification {
enum class Fields
{
    kApplianceStatus                   = 0,
    kRemoteEnableFlagsAndDeviceStatus2 = 1,
    kApplianceStatus2                  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SignalStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    chip::BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SignalStateNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    ApplianceStatus applianceStatus;
    chip::BitFlags<RemoteEnableFlagsAndDeviceStatus2> remoteEnableFlagsAndDeviceStatus2;
    ApplianceStatus applianceStatus2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SignalStateNotification
namespace WriteFunctions {
enum class Fields
{
    kFunctionId       = 0,
    kFunctionDataType = 1,
    kFunctionData     = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::WriteFunctions::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    uint16_t functionId;
    uint8_t functionDataType;
    DataModel::List<const uint8_t> functionData;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::WriteFunctions::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    uint16_t functionId;
    uint8_t functionDataType;
    DataModel::DecodableList<uint8_t> functionData;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace WriteFunctions
namespace OverloadPauseResume {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OverloadPauseResume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OverloadPauseResume::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OverloadPauseResume
namespace OverloadPause {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OverloadPause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OverloadPause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OverloadPause
namespace OverloadWarning {
enum class Fields
{
    kWarningEvent = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OverloadWarning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    WarningEvent warningEvent;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OverloadWarning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

    WarningEvent warningEvent;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OverloadWarning
} // namespace Commands

namespace Attributes {

namespace StartTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartTime
namespace FinishTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FinishTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FinishTime
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplianceControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::StartTime::TypeInfo::DecodableType startTime;
        Attributes::FinishTime::TypeInfo::DecodableType finishTime;
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ApplianceControl
namespace PulseWidthModulation {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PulseWidthModulation::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PulseWidthModulation
namespace Descriptor {

namespace Structs {
namespace DeviceType {
enum class Fields
{
    kType     = 1,
    kRevision = 2,
};

struct Type
{
public:
    chip::DeviceTypeId type;
    uint16_t revision;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace DeviceType
} // namespace Structs

namespace Attributes {

namespace DeviceList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Descriptor::Structs::DeviceType::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Descriptor::Structs::DeviceType::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DeviceList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DeviceList
namespace ServerList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ClusterId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ClusterId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ClusterId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ServerList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ServerList
namespace ClientList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ClusterId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ClusterId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ClusterId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClientList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClientList
namespace PartsList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::EndpointId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::EndpointId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::EndpointId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartsList
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Descriptor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DeviceList::TypeInfo::DecodableType deviceList;
        Attributes::ServerList::TypeInfo::DecodableType serverList;
        Attributes::ClientList::TypeInfo::DecodableType clientList;
        Attributes::PartsList::TypeInfo::DecodableType partsList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Descriptor
namespace Binding {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Bind {
struct Type;
struct DecodableType;
} // namespace Bind

namespace Unbind {
struct Type;
struct DecodableType;
} // namespace Unbind

} // namespace Commands

namespace Commands {
namespace Bind {
enum class Fields
{
    kNodeId     = 0,
    kGroupId    = 1,
    kEndpointId = 2,
    kClusterId  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Bind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Bind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Bind
namespace Unbind {
enum class Fields
{
    kNodeId     = 0,
    kGroupId    = 1,
    kEndpointId = 2,
    kClusterId  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Unbind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Unbind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

    chip::NodeId nodeId;
    chip::GroupId groupId;
    chip::EndpointId endpointId;
    chip::ClusterId clusterId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Unbind
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Binding::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Binding
namespace AccessControl {
// Enum for AuthMode
enum class AuthMode : uint8_t
{
    kPase  = 0x01,
    kCase  = 0x02,
    kGroup = 0x03,
};
// Enum for Privilege
enum class Privilege : uint8_t
{
    kView       = 0x01,
    kProxyView  = 0x02,
    kOperate    = 0x03,
    kManage     = 0x04,
    kAdminister = 0x05,
};

namespace Structs {
namespace Target {
enum class Fields
{
    kCluster    = 0,
    kEndpoint   = 1,
    kDeviceType = 2,
};

struct Type
{
public:
    DataModel::Nullable<uint32_t> cluster;
    DataModel::Nullable<uint16_t> endpoint;
    DataModel::Nullable<uint32_t> deviceType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace Target
namespace AccessControlEntry {
enum class Fields
{
    kFabricIndex = 0,
    kPrivilege   = 1,
    kAuthMode    = 2,
    kSubjects    = 3,
    kTargets     = 4,
};

struct Type
{
public:
    chip::FabricIndex fabricIndex;
    Privilege privilege;
    AuthMode authMode;
    DataModel::Nullable<DataModel::List<const uint64_t>> subjects;
    DataModel::Nullable<DataModel::List<const Structs::Target::Type>> targets;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    bool MatchesFabricIndex(FabricIndex fabricIndex_) const { return fabricIndex == fabricIndex_; }
};

struct DecodableType
{
public:
    chip::FabricIndex fabricIndex;
    Privilege privilege;
    AuthMode authMode;
    DataModel::Nullable<DataModel::DecodableList<uint64_t>> subjects;
    DataModel::Nullable<DataModel::DecodableList<Structs::Target::DecodableType>> targets;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace AccessControlEntry
namespace ExtensionEntry {
enum class Fields
{
    kFabricIndex = 0,
    kData        = 1,
};

struct Type
{
public:
    chip::FabricIndex fabricIndex;
    chip::ByteSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
    bool MatchesFabricIndex(FabricIndex fabricIndex_) const { return fabricIndex == fabricIndex_; }
};

using DecodableType = Type;

} // namespace ExtensionEntry
} // namespace Structs

namespace Attributes {

namespace Acl {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::AccessControlEntry::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::AccessControlEntry::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Acl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Acl
namespace Extension {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AccessControl::Structs::ExtensionEntry::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AccessControl::Structs::ExtensionEntry::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Extension::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Extension
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AccessControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Acl::TypeInfo::DecodableType acl;
        Attributes::Extension::TypeInfo::DecodableType extension;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace AccessControl
namespace PollControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace CheckIn {
struct Type;
struct DecodableType;
} // namespace CheckIn

namespace CheckInResponse {
struct Type;
struct DecodableType;
} // namespace CheckInResponse

namespace FastPollStop {
struct Type;
struct DecodableType;
} // namespace FastPollStop

namespace SetLongPollInterval {
struct Type;
struct DecodableType;
} // namespace SetLongPollInterval

namespace SetShortPollInterval {
struct Type;
struct DecodableType;
} // namespace SetShortPollInterval

} // namespace Commands

namespace Commands {
namespace CheckIn {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CheckIn::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::PollControl::Commands::CheckInResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CheckIn::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CheckIn
namespace CheckInResponse {
enum class Fields
{
    kStartFastPolling = 0,
    kFastPollTimeout  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CheckInResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    bool startFastPolling;
    uint16_t fastPollTimeout;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CheckInResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    bool startFastPolling;
    uint16_t fastPollTimeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CheckInResponse
namespace FastPollStop {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::FastPollStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::FastPollStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace FastPollStop
namespace SetLongPollInterval {
enum class Fields
{
    kNewLongPollInterval = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetLongPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    uint32_t newLongPollInterval;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetLongPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    uint32_t newLongPollInterval;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetLongPollInterval
namespace SetShortPollInterval {
enum class Fields
{
    kNewShortPollInterval = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetShortPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    uint16_t newShortPollInterval;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetShortPollInterval::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

    uint16_t newShortPollInterval;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetShortPollInterval
} // namespace Commands

namespace Attributes {

namespace CheckInInterval {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CheckInInterval::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CheckInInterval
namespace LongPollInterval {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongPollInterval::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LongPollInterval
namespace ShortPollInterval {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ShortPollInterval::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ShortPollInterval
namespace FastPollTimeout {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FastPollTimeout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FastPollTimeout
namespace CheckInIntervalMin {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CheckInIntervalMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CheckInIntervalMin
namespace LongPollIntervalMin {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongPollIntervalMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LongPollIntervalMin
namespace FastPollTimeoutMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FastPollTimeoutMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FastPollTimeoutMax
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PollControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CheckInInterval::TypeInfo::DecodableType checkInInterval;
        Attributes::LongPollInterval::TypeInfo::DecodableType longPollInterval;
        Attributes::ShortPollInterval::TypeInfo::DecodableType shortPollInterval;
        Attributes::FastPollTimeout::TypeInfo::DecodableType fastPollTimeout;
        Attributes::CheckInIntervalMin::TypeInfo::DecodableType checkInIntervalMin;
        Attributes::LongPollIntervalMin::TypeInfo::DecodableType longPollIntervalMin;
        Attributes::FastPollTimeoutMax::TypeInfo::DecodableType fastPollTimeoutMax;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PollControl
namespace BridgedActions {
// Enum for ActionErrorEnum
enum class ActionErrorEnum : uint8_t
{
    kUnknown     = 0x00,
    kInterrupted = 0x01,
};
// Enum for ActionStateEnum
enum class ActionStateEnum : uint8_t
{
    kInactive = 0x00,
    kActive   = 0x01,
    kPaused   = 0x02,
    kDisabled = 0x03,
};
// Enum for ActionTypeEnum
enum class ActionTypeEnum : uint8_t
{
    kOther        = 0x00,
    kScene        = 0x01,
    kSequence     = 0x02,
    kAutomation   = 0x03,
    kException    = 0x04,
    kNotification = 0x05,
    kAlarm        = 0x06,
};
// Enum for EndpointListTypeEnum
enum class EndpointListTypeEnum : uint8_t
{
    kOther = 0x00,
    kRoom  = 0x01,
    kZone  = 0x02,
};

// Bitmap for CommandBits
enum class CommandBits : uint16_t
{
    kInstantAction               = 0x1,
    kInstantActionWithTransition = 0x2,
    kStartAction                 = 0x4,
    kStartActionWithDuration     = 0x8,
    kStopAction                  = 0x10,
    kPauseAction                 = 0x20,
    kPauseActionWithDuration     = 0x40,
    kResumeAction                = 0x80,
    kEnableAction                = 0x100,
    kEnableActionWithDuration    = 0x200,
    kDisableAction               = 0x400,
    kDisableActionWithDuration   = 0x800,
};

namespace Structs {
namespace ActionStruct {
enum class Fields
{
    kActionID          = 1,
    kName              = 2,
    kType              = 3,
    kEndpointListID    = 4,
    kSupportedCommands = 5,
    kStatus            = 6,
};

struct Type
{
public:
    uint16_t actionID;
    chip::CharSpan name;
    ActionTypeEnum type;
    uint16_t endpointListID;
    uint16_t supportedCommands;
    ActionStateEnum status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ActionStruct
namespace EndpointListStruct {
enum class Fields
{
    kEndpointListID = 1,
    kName           = 2,
    kType           = 3,
    kEndpoints      = 4,
};

struct Type
{
public:
    uint16_t endpointListID;
    chip::CharSpan name;
    EndpointListTypeEnum type;
    DataModel::List<const chip::EndpointId> endpoints;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    uint16_t endpointListID;
    chip::CharSpan name;
    EndpointListTypeEnum type;
    DataModel::DecodableList<chip::EndpointId> endpoints;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace EndpointListStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace InstantAction {
struct Type;
struct DecodableType;
} // namespace InstantAction

namespace InstantActionWithTransition {
struct Type;
struct DecodableType;
} // namespace InstantActionWithTransition

namespace StartAction {
struct Type;
struct DecodableType;
} // namespace StartAction

namespace StartActionWithDuration {
struct Type;
struct DecodableType;
} // namespace StartActionWithDuration

namespace StopAction {
struct Type;
struct DecodableType;
} // namespace StopAction

namespace PauseAction {
struct Type;
struct DecodableType;
} // namespace PauseAction

namespace PauseActionWithDuration {
struct Type;
struct DecodableType;
} // namespace PauseActionWithDuration

namespace ResumeAction {
struct Type;
struct DecodableType;
} // namespace ResumeAction

namespace EnableAction {
struct Type;
struct DecodableType;
} // namespace EnableAction

namespace EnableActionWithDuration {
struct Type;
struct DecodableType;
} // namespace EnableActionWithDuration

namespace DisableAction {
struct Type;
struct DecodableType;
} // namespace DisableAction

namespace DisableActionWithDuration {
struct Type;
struct DecodableType;
} // namespace DisableActionWithDuration

} // namespace Commands

namespace Commands {
namespace InstantAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InstantAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InstantAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InstantAction
namespace InstantActionWithTransition {
enum class Fields
{
    kActionID       = 0,
    kInvokeID       = 1,
    kTransitionTime = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InstantActionWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint16_t transitionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InstantActionWithTransition::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint16_t transitionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InstantActionWithTransition
namespace StartAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartAction
namespace StartActionWithDuration {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartActionWithDuration
namespace StopAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopAction
namespace PauseAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseAction
namespace PauseActionWithDuration {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PauseActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PauseActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PauseActionWithDuration
namespace ResumeAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResumeAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResumeAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResumeAction
namespace EnableAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableAction
namespace EnableActionWithDuration {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnableActionWithDuration
namespace DisableAction {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisableAction::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableAction
namespace DisableActionWithDuration {
enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
    kDuration = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisableActionWithDuration::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    Optional<uint32_t> invokeID;
    uint32_t duration;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisableActionWithDuration
} // namespace Commands

namespace Attributes {

namespace ActionList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::BridgedActions::Structs::ActionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::ActionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActionList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActionList
namespace EndpointList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::BridgedActions::Structs::EndpointListStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndpointList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndpointList
namespace SetupUrl {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetupUrl::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetupUrl
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ActionList::TypeInfo::DecodableType actionList;
        Attributes::EndpointList::TypeInfo::DecodableType endpointList;
        Attributes::SetupUrl::TypeInfo::DecodableType setupUrl;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace StateChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
    kNewState = 2,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    uint32_t invokeID;
    ActionStateEnum newState;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    uint32_t invokeID;
    ActionStateEnum newState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChanged
namespace ActionFailed {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kActionID = 0,
    kInvokeID = 1,
    kNewState = 2,
    kError    = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    uint32_t invokeID;
    ActionStateEnum newState;
    ActionErrorEnum error;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedActions::Id; }

    uint16_t actionID;
    uint32_t invokeID;
    ActionStateEnum newState;
    ActionErrorEnum error;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ActionFailed
} // namespace Events
} // namespace BridgedActions
namespace Basic {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MfgSpecificPing {
struct Type;
struct DecodableType;
} // namespace MfgSpecificPing

} // namespace Commands

namespace Commands {
namespace MfgSpecificPing {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MfgSpecificPing::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MfgSpecificPing
} // namespace Commands

namespace Attributes {

namespace InteractionModelVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InteractionModelVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InteractionModelVersion
namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductName
namespace ProductID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductID
namespace NodeLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NodeLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NodeLabel
namespace Location {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Location::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Location
namespace HardwareVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SerialNumber
namespace LocalConfigDisabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalConfigDisabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalConfigDisabled
namespace Reachable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reachable
namespace UniqueID {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UniqueID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UniqueID
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::InteractionModelVersion::TypeInfo::DecodableType interactionModelVersion;
        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID;
        Attributes::ProductName::TypeInfo::DecodableType productName;
        Attributes::ProductID::TypeInfo::DecodableType productID;
        Attributes::NodeLabel::TypeInfo::DecodableType nodeLabel;
        Attributes::Location::TypeInfo::DecodableType location;
        Attributes::HardwareVersion::TypeInfo::DecodableType hardwareVersion;
        Attributes::HardwareVersionString::TypeInfo::DecodableType hardwareVersionString;
        Attributes::SoftwareVersion::TypeInfo::DecodableType softwareVersion;
        Attributes::SoftwareVersionString::TypeInfo::DecodableType softwareVersionString;
        Attributes::ManufacturingDate::TypeInfo::DecodableType manufacturingDate;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductURL::TypeInfo::DecodableType productURL;
        Attributes::ProductLabel::TypeInfo::DecodableType productLabel;
        Attributes::SerialNumber::TypeInfo::DecodableType serialNumber;
        Attributes::LocalConfigDisabled::TypeInfo::DecodableType localConfigDisabled;
        Attributes::Reachable::TypeInfo::DecodableType reachable;
        Attributes::UniqueID::TypeInfo::DecodableType uniqueID;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace StartUp {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kSoftwareVersion = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    uint32_t softwareVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    uint32_t softwareVersion;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StartUp
namespace ShutDown {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShutDown
namespace Leave {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leave
namespace ReachableChanged {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000003;

enum class Fields
{
    kReachableNewValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    bool reachableNewValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Basic::Id; }

    bool reachableNewValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ReachableChanged
} // namespace Events
} // namespace Basic
namespace OtaSoftwareUpdateProvider {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTAApplyUpdateAction
enum class OTAApplyUpdateAction : uint8_t
{
    kProceed         = 0x00,
    kAwaitNextAction = 0x01,
    kDiscontinue     = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTAApplyUpdateAction            = EmberAfOTAApplyUpdateAction;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTADownloadProtocol
enum class OTADownloadProtocol : uint8_t
{
    kBDXSynchronous  = 0x00,
    kBDXAsynchronous = 0x01,
    kHttps           = 0x02,
    kVendorSpecific  = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTADownloadProtocol             = EmberAfOTADownloadProtocol;
#endif
// Enum for OTAQueryStatus
enum class OTAQueryStatus : uint8_t
{
    kUpdateAvailable              = 0x00,
    kBusy                         = 0x01,
    kNotAvailable                 = 0x02,
    kDownloadProtocolNotSupported = 0x03,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace QueryImage {
struct Type;
struct DecodableType;
} // namespace QueryImage

namespace QueryImageResponse {
struct Type;
struct DecodableType;
} // namespace QueryImageResponse

namespace ApplyUpdateRequest {
struct Type;
struct DecodableType;
} // namespace ApplyUpdateRequest

namespace ApplyUpdateResponse {
struct Type;
struct DecodableType;
} // namespace ApplyUpdateResponse

namespace NotifyUpdateApplied {
struct Type;
struct DecodableType;
} // namespace NotifyUpdateApplied

} // namespace Commands

namespace Commands {
namespace QueryImage {
enum class Fields
{
    kVendorId            = 0,
    kProductId           = 1,
    kSoftwareVersion     = 2,
    kProtocolsSupported  = 3,
    kHardwareVersion     = 4,
    kLocation            = 5,
    kRequestorCanConsent = 6,
    kMetadataForProvider = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::VendorId vendorId;
    uint16_t productId;
    uint32_t softwareVersion;
    DataModel::List<const OTADownloadProtocol> protocolsSupported;
    Optional<uint16_t> hardwareVersion;
    Optional<chip::CharSpan> location;
    Optional<bool> requestorCanConsent;
    Optional<chip::ByteSpan> metadataForProvider;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OtaSoftwareUpdateProvider::Commands::QueryImageResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryImage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::VendorId vendorId;
    uint16_t productId;
    uint32_t softwareVersion;
    DataModel::DecodableList<OTADownloadProtocol> protocolsSupported;
    Optional<uint16_t> hardwareVersion;
    Optional<chip::CharSpan> location;
    Optional<bool> requestorCanConsent;
    Optional<chip::ByteSpan> metadataForProvider;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImage
namespace QueryImageResponse {
enum class Fields
{
    kStatus                = 0,
    kDelayedActionTime     = 1,
    kImageURI              = 2,
    kSoftwareVersion       = 3,
    kSoftwareVersionString = 4,
    kUpdateToken           = 5,
    kUserConsentNeeded     = 6,
    kMetadataForRequestor  = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    OTAQueryStatus status;
    Optional<uint32_t> delayedActionTime;
    Optional<chip::CharSpan> imageURI;
    Optional<uint32_t> softwareVersion;
    Optional<chip::CharSpan> softwareVersionString;
    Optional<chip::ByteSpan> updateToken;
    Optional<bool> userConsentNeeded;
    Optional<chip::ByteSpan> metadataForRequestor;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::QueryImageResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    OTAQueryStatus status;
    Optional<uint32_t> delayedActionTime;
    Optional<chip::CharSpan> imageURI;
    Optional<uint32_t> softwareVersion;
    Optional<chip::CharSpan> softwareVersionString;
    Optional<chip::ByteSpan> updateToken;
    Optional<bool> userConsentNeeded;
    Optional<chip::ByteSpan> metadataForRequestor;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace QueryImageResponse
namespace ApplyUpdateRequest {
enum class Fields
{
    kUpdateToken = 0,
    kNewVersion  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OtaSoftwareUpdateProvider::Commands::ApplyUpdateResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t newVersion;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateRequest
namespace ApplyUpdateResponse {
enum class Fields
{
    kAction            = 0,
    kDelayedActionTime = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    OTAApplyUpdateAction action;
    uint32_t delayedActionTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ApplyUpdateResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    OTAApplyUpdateAction action;
    uint32_t delayedActionTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ApplyUpdateResponse
namespace NotifyUpdateApplied {
enum class Fields
{
    kUpdateToken     = 0,
    kSoftwareVersion = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NotifyUpdateApplied::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

    chip::ByteSpan updateToken;
    uint32_t softwareVersion;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NotifyUpdateApplied
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateProvider::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OtaSoftwareUpdateProvider
namespace OtaSoftwareUpdateRequestor {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ChangeReasonEnum
enum class ChangeReasonEnum : uint8_t
{
    kUnknown         = 0x00,
    kSuccess         = 0x01,
    kFailure         = 0x02,
    kTimeOut         = 0x03,
    kDelayByProvider = 0x04,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ChangeReasonEnum                = EmberAfChangeReasonEnum;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for OTAAnnouncementReason
enum class OTAAnnouncementReason : uint8_t
{
    kSimpleAnnouncement    = 0x00,
    kUpdateAvailable       = 0x01,
    kUrgentUpdateAvailable = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using OTAAnnouncementReason           = EmberAfOTAAnnouncementReason;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for UpdateStateEnum
enum class UpdateStateEnum : uint8_t
{
    kUnknown              = 0x00,
    kIdle                 = 0x01,
    kQuerying             = 0x02,
    kDelayedOnQuery       = 0x03,
    kDownloading          = 0x04,
    kApplying             = 0x05,
    kDelayedOnApply       = 0x06,
    kRollingBack          = 0x07,
    kDelayedOnUserConsent = 0x08,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using UpdateStateEnum                 = EmberAfUpdateStateEnum;
#endif

namespace Structs {
namespace ProviderLocation {
enum class Fields
{
    kFabricIndex    = 0,
    kProviderNodeID = 1,
    kEndpoint       = 2,
};

struct Type
{
public:
    chip::FabricIndex fabricIndex;
    chip::NodeId providerNodeID;
    chip::EndpointId endpoint;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
    bool MatchesFabricIndex(FabricIndex fabricIndex_) const { return fabricIndex == fabricIndex_; }
};

using DecodableType = Type;

} // namespace ProviderLocation
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AnnounceOtaProvider {
struct Type;
struct DecodableType;
} // namespace AnnounceOtaProvider

} // namespace Commands

namespace Commands {
namespace AnnounceOtaProvider {
enum class Fields
{
    kProviderNodeId     = 0,
    kVendorId           = 1,
    kAnnouncementReason = 2,
    kMetadataForNode    = 3,
    kEndpoint           = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AnnounceOtaProvider::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    chip::NodeId providerNodeId;
    chip::VendorId vendorId;
    OTAAnnouncementReason announcementReason;
    Optional<chip::ByteSpan> metadataForNode;
    chip::EndpointId endpoint;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AnnounceOtaProvider::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    chip::NodeId providerNodeId;
    chip::VendorId vendorId;
    OTAAnnouncementReason announcementReason;
    Optional<chip::ByteSpan> metadataForNode;
    chip::EndpointId endpoint;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AnnounceOtaProvider
} // namespace Commands

namespace Attributes {

namespace DefaultOtaProviders {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OtaSoftwareUpdateRequestor::Structs::ProviderLocation::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultOtaProviders::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultOtaProviders
namespace UpdatePossible {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdatePossible::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdatePossible
namespace UpdateState {
struct TypeInfo
{
    using Type             = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;
    using DecodableType    = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;
    using DecodableArgType = chip::app::Clusters::OtaSoftwareUpdateRequestor::UpdateStateEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdateState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdateState
namespace UpdateStateProgress {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpdateStateProgress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpdateStateProgress
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::DefaultOtaProviders::TypeInfo::DecodableType defaultOtaProviders;
        Attributes::UpdatePossible::TypeInfo::DecodableType updatePossible;
        Attributes::UpdateState::TypeInfo::DecodableType updateState;
        Attributes::UpdateStateProgress::TypeInfo::DecodableType updateStateProgress;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace StateTransition {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kPreviousState         = 0,
    kNewState              = 1,
    kReason                = 2,
    kTargetSoftwareVersion = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    DataModel::Nullable<UpdateStateEnum> previousState;
    UpdateStateEnum newState;
    ChangeReasonEnum reason;
    DataModel::Nullable<uint32_t> targetSoftwareVersion;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    DataModel::Nullable<UpdateStateEnum> previousState;
    UpdateStateEnum newState;
    ChangeReasonEnum reason;
    DataModel::Nullable<uint32_t> targetSoftwareVersion;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateTransition
namespace VersionApplied {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kSoftwareVersion = 0,
    kProductID       = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion;
    uint16_t productID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion;
    uint16_t productID;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace VersionApplied
namespace DownloadError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
    kSoftwareVersion = 0,
    kBytesDownloaded = 1,
    kProgressPercent = 2,
    kPlatformCode    = 3,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion;
    uint64_t bytesDownloaded;
    uint8_t progressPercent;
    DataModel::Nullable<int64_t> platformCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::OtaSoftwareUpdateRequestor::Id; }

    uint32_t softwareVersion;
    uint64_t bytesDownloaded;
    uint8_t progressPercent;
    DataModel::Nullable<int64_t> platformCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DownloadError
} // namespace Events
} // namespace OtaSoftwareUpdateRequestor
namespace LocalizationConfiguration {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LocalizationConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace LocalizationConfiguration
namespace LocalizationTimeFormat {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationTimeFormat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationTimeFormat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationTimeFormat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LocalizationTimeFormat::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace LocalizationTimeFormat
namespace LocalizationUnit {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationUnit::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationUnit::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LocalizationUnit::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LocalizationUnit::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace LocalizationUnit
namespace PowerSourceConfiguration {

namespace Attributes {

namespace Sources {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Sources::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Sources
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerSourceConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Sources::TypeInfo::DecodableType sources;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PowerSourceConfiguration
namespace PowerSource {

// Bitmap for PowerSourceFeature
enum class PowerSourceFeature : uint32_t
{
    kWired        = 0x1,
    kBattery      = 0x2,
    kRechargeable = 0x4,
    kReplaceable  = 0x8,
};

namespace Attributes {

namespace Status {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Status
namespace Order {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Order::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Order
namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Description
namespace WiredAssessedInputVoltage {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedInputVoltage
namespace WiredAssessedInputFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedInputFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedInputFrequency
namespace WiredCurrentType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredCurrentType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredCurrentType
namespace WiredAssessedCurrent {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredAssessedCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredAssessedCurrent
namespace WiredNominalVoltage {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredNominalVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredNominalVoltage
namespace WiredMaximumCurrent {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredMaximumCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredMaximumCurrent
namespace WiredPresent {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiredPresent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiredPresent
namespace ActiveWiredFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveWiredFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveWiredFaults
namespace BatteryVoltage {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryVoltage
namespace BatteryPercentRemaining {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPercentRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPercentRemaining
namespace BatteryTimeRemaining {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryTimeRemaining::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryTimeRemaining
namespace BatteryChargeLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryChargeLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryChargeLevel
namespace BatteryReplacementNeeded {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryReplacementNeeded::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryReplacementNeeded
namespace BatteryReplaceability {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryReplaceability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryReplaceability
namespace BatteryPresent {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryPresent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryPresent
namespace ActiveBatteryFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatteryFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveBatteryFaults
namespace BatteryReplacementDescription {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryReplacementDescription::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryReplacementDescription
namespace BatteryCommonDesignation {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryCommonDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryCommonDesignation
namespace BatteryANSIDesignation {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryANSIDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryANSIDesignation
namespace BatteryIECDesignation {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryIECDesignation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryIECDesignation
namespace BatteryApprovedChemistry {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryApprovedChemistry::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryApprovedChemistry
namespace BatteryCapacity {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryCapacity
namespace BatteryQuantity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryQuantity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryQuantity
namespace BatteryChargeState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryChargeState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryChargeState
namespace BatteryTimeToFullCharge {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryTimeToFullCharge::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryTimeToFullCharge
namespace BatteryFunctionalWhileCharging {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryFunctionalWhileCharging::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryFunctionalWhileCharging
namespace BatteryChargingCurrent {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BatteryChargingCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BatteryChargingCurrent
namespace ActiveBatteryChargeFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveBatteryChargeFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveBatteryChargeFaults
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PowerSource::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Status::TypeInfo::DecodableType status;
        Attributes::Order::TypeInfo::DecodableType order;
        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::WiredAssessedInputVoltage::TypeInfo::DecodableType wiredAssessedInputVoltage;
        Attributes::WiredAssessedInputFrequency::TypeInfo::DecodableType wiredAssessedInputFrequency;
        Attributes::WiredCurrentType::TypeInfo::DecodableType wiredCurrentType;
        Attributes::WiredAssessedCurrent::TypeInfo::DecodableType wiredAssessedCurrent;
        Attributes::WiredNominalVoltage::TypeInfo::DecodableType wiredNominalVoltage;
        Attributes::WiredMaximumCurrent::TypeInfo::DecodableType wiredMaximumCurrent;
        Attributes::WiredPresent::TypeInfo::DecodableType wiredPresent;
        Attributes::ActiveWiredFaults::TypeInfo::DecodableType activeWiredFaults;
        Attributes::BatteryVoltage::TypeInfo::DecodableType batteryVoltage;
        Attributes::BatteryPercentRemaining::TypeInfo::DecodableType batteryPercentRemaining;
        Attributes::BatteryTimeRemaining::TypeInfo::DecodableType batteryTimeRemaining;
        Attributes::BatteryChargeLevel::TypeInfo::DecodableType batteryChargeLevel;
        Attributes::BatteryReplacementNeeded::TypeInfo::DecodableType batteryReplacementNeeded;
        Attributes::BatteryReplaceability::TypeInfo::DecodableType batteryReplaceability;
        Attributes::BatteryPresent::TypeInfo::DecodableType batteryPresent;
        Attributes::ActiveBatteryFaults::TypeInfo::DecodableType activeBatteryFaults;
        Attributes::BatteryReplacementDescription::TypeInfo::DecodableType batteryReplacementDescription;
        Attributes::BatteryCommonDesignation::TypeInfo::DecodableType batteryCommonDesignation;
        Attributes::BatteryANSIDesignation::TypeInfo::DecodableType batteryANSIDesignation;
        Attributes::BatteryIECDesignation::TypeInfo::DecodableType batteryIECDesignation;
        Attributes::BatteryApprovedChemistry::TypeInfo::DecodableType batteryApprovedChemistry;
        Attributes::BatteryCapacity::TypeInfo::DecodableType batteryCapacity;
        Attributes::BatteryQuantity::TypeInfo::DecodableType batteryQuantity;
        Attributes::BatteryChargeState::TypeInfo::DecodableType batteryChargeState;
        Attributes::BatteryTimeToFullCharge::TypeInfo::DecodableType batteryTimeToFullCharge;
        Attributes::BatteryFunctionalWhileCharging::TypeInfo::DecodableType batteryFunctionalWhileCharging;
        Attributes::BatteryChargingCurrent::TypeInfo::DecodableType batteryChargingCurrent;
        Attributes::ActiveBatteryChargeFaults::TypeInfo::DecodableType activeBatteryChargeFaults;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PowerSource
namespace GeneralCommissioning {
// Enum for GeneralCommissioningError
enum class GeneralCommissioningError : uint8_t
{
    kOk                    = 0x00,
    kValueOutsideRange     = 0x01,
    kInvalidAuthentication = 0x02,
    kNotCommissioning      = 0x03,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for RegulatoryLocationType
enum class RegulatoryLocationType : uint8_t
{
    kIndoor        = 0x00,
    kOutdoor       = 0x01,
    kIndoorOutdoor = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using RegulatoryLocationType          = EmberAfRegulatoryLocationType;
#endif

namespace Structs {
namespace BasicCommissioningInfoType {
enum class Fields
{
    kFailSafeExpiryLengthMs = 1,
};

struct Type
{
public:
    uint32_t failSafeExpiryLengthMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace BasicCommissioningInfoType
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ArmFailSafe {
struct Type;
struct DecodableType;
} // namespace ArmFailSafe

namespace ArmFailSafeResponse {
struct Type;
struct DecodableType;
} // namespace ArmFailSafeResponse

namespace SetRegulatoryConfig {
struct Type;
struct DecodableType;
} // namespace SetRegulatoryConfig

namespace SetRegulatoryConfigResponse {
struct Type;
struct DecodableType;
} // namespace SetRegulatoryConfigResponse

namespace CommissioningComplete {
struct Type;
struct DecodableType;
} // namespace CommissioningComplete

namespace CommissioningCompleteResponse {
struct Type;
struct DecodableType;
} // namespace CommissioningCompleteResponse

} // namespace Commands

namespace Commands {
namespace ArmFailSafe {
enum class Fields
{
    kExpiryLengthSeconds = 0,
    kBreadcrumb          = 1,
    kTimeoutMs           = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::ArmFailSafeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafe::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    uint16_t expiryLengthSeconds;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafe
namespace ArmFailSafeResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmFailSafeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmFailSafeResponse
namespace SetRegulatoryConfig {
enum class Fields
{
    kLocation    = 0,
    kCountryCode = 1,
    kBreadcrumb  = 2,
    kTimeoutMs   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    RegulatoryLocationType location;
    chip::CharSpan countryCode;
    uint64_t breadcrumb;
    uint32_t timeoutMs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::SetRegulatoryConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfig::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    RegulatoryLocationType location;
    chip::CharSpan countryCode;
    uint64_t breadcrumb;
    uint32_t timeoutMs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfig
namespace SetRegulatoryConfigResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRegulatoryConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRegulatoryConfigResponse
namespace CommissioningComplete {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::GeneralCommissioning::Commands::CommissioningCompleteResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissioningComplete::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningComplete
namespace CommissioningCompleteResponse {
enum class Fields
{
    kErrorCode = 0,
    kDebugText = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CommissioningCompleteResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

    GeneralCommissioningError errorCode;
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CommissioningCompleteResponse
} // namespace Commands

namespace Attributes {

namespace Breadcrumb {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Breadcrumb::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Breadcrumb
namespace BasicCommissioningInfoList {
struct TypeInfo
{
    using Type =
        chip::app::DataModel::List<const chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralCommissioning::Structs::BasicCommissioningInfoType::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BasicCommissioningInfoList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BasicCommissioningInfoList
namespace RegulatoryConfig {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RegulatoryConfig::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RegulatoryConfig
namespace LocationCapability {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocationCapability::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocationCapability
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GeneralCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Breadcrumb::TypeInfo::DecodableType breadcrumb;
        Attributes::BasicCommissioningInfoList::TypeInfo::DecodableType basicCommissioningInfoList;
        Attributes::RegulatoryConfig::TypeInfo::DecodableType regulatoryConfig;
        Attributes::LocationCapability::TypeInfo::DecodableType locationCapability;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace GeneralCommissioning
namespace NetworkCommissioning {
// Enum for NetworkCommissioningStatus
enum class NetworkCommissioningStatus : uint8_t
{
    kSuccess                = 0x00,
    kOutOfRange             = 0x01,
    kBoundsExceeded         = 0x02,
    kNetworkIDNotFound      = 0x03,
    kDuplicateNetworkID     = 0x04,
    kNetworkNotFound        = 0x05,
    kRegulatoryError        = 0x06,
    kAuthFailure            = 0x07,
    kUnsupportedSecurity    = 0x08,
    kOtherConnectionFailure = 0x09,
    kIPV6Failed             = 0x0A,
    kIPBindFailed           = 0x0B,
    kUnknownError           = 0x0C,
};
// Enum for WiFiBand
enum class WiFiBand : uint8_t
{
    k2g4  = 0x00,
    k3g65 = 0x01,
    k5g   = 0x02,
    k6g   = 0x03,
    k60g  = 0x04,
};

namespace Structs {
namespace NetworkInfo {
enum class Fields
{
    kNetworkID = 1,
    kConnected = 2,
};

struct Type
{
public:
    chip::ByteSpan networkID;
    bool connected;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NetworkInfo
namespace ThreadInterfaceScanResult {
enum class Fields
{
    kPanId           = 1,
    kExtendedPanId   = 2,
    kNetworkName     = 3,
    kChannel         = 4,
    kVersion         = 5,
    kExtendedAddress = 6,
    kRssi            = 7,
    kLqi             = 8,
};

struct Type
{
public:
    uint64_t panId;
    uint64_t extendedPanId;
    chip::CharSpan networkName;
    uint16_t channel;
    uint8_t version;
    uint64_t extendedAddress;
    int8_t rssi;
    uint8_t lqi;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ThreadInterfaceScanResult
namespace WiFiInterfaceScanResult {
enum class Fields
{
    kSecurity = 1,
    kSsid     = 2,
    kBssid    = 3,
    kChannel  = 4,
    kWiFiBand = 5,
    kRssi     = 6,
};

struct Type
{
public:
    uint8_t security;
    chip::ByteSpan ssid;
    chip::ByteSpan bssid;
    uint16_t channel;
    WiFiBand wiFiBand;
    int8_t rssi;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace WiFiInterfaceScanResult
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ScanNetworks {
struct Type;
struct DecodableType;
} // namespace ScanNetworks

namespace ScanNetworksResponse {
struct Type;
struct DecodableType;
} // namespace ScanNetworksResponse

namespace AddOrUpdateWiFiNetwork {
struct Type;
struct DecodableType;
} // namespace AddOrUpdateWiFiNetwork

namespace AddOrUpdateThreadNetwork {
struct Type;
struct DecodableType;
} // namespace AddOrUpdateThreadNetwork

namespace RemoveNetwork {
struct Type;
struct DecodableType;
} // namespace RemoveNetwork

namespace NetworkConfigResponse {
struct Type;
struct DecodableType;
} // namespace NetworkConfigResponse

namespace ConnectNetwork {
struct Type;
struct DecodableType;
} // namespace ConnectNetwork

namespace ConnectNetworkResponse {
struct Type;
struct DecodableType;
} // namespace ConnectNetworkResponse

namespace ReorderNetwork {
struct Type;
struct DecodableType;
} // namespace ReorderNetwork

} // namespace Commands

namespace Commands {
namespace ScanNetworks {
enum class Fields
{
    kSsid       = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    uint64_t breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::ScanNetworksResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    uint64_t breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworks
namespace ScanNetworksResponse {
enum class Fields
{
    kNetworkingStatus  = 0,
    kDebugText         = 1,
    kWiFiScanResults   = 2,
    kThreadScanResults = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatus networkingStatus;
    chip::CharSpan debugText;
    DataModel::List<const Structs::WiFiInterfaceScanResult::Type> wiFiScanResults;
    DataModel::List<const Structs::ThreadInterfaceScanResult::Type> threadScanResults;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ScanNetworksResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatus networkingStatus;
    chip::CharSpan debugText;
    DataModel::DecodableList<Structs::WiFiInterfaceScanResult::DecodableType> wiFiScanResults;
    DataModel::DecodableList<Structs::ThreadInterfaceScanResult::DecodableType> threadScanResults;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ScanNetworksResponse
namespace AddOrUpdateWiFiNetwork {
enum class Fields
{
    kSsid        = 0,
    kCredentials = 1,
    kBreadcrumb  = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    uint64_t breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateWiFiNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan ssid;
    chip::ByteSpan credentials;
    uint64_t breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddOrUpdateWiFiNetwork
namespace AddOrUpdateThreadNetwork {
enum class Fields
{
    kOperationalDataset = 0,
    kBreadcrumb         = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    uint64_t breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddOrUpdateThreadNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan operationalDataset;
    uint64_t breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddOrUpdateThreadNetwork
namespace RemoveNetwork {
enum class Fields
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveNetwork
namespace NetworkConfigResponse {
enum class Fields
{
    kNetworkingStatus = 0,
    kDebugText        = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NetworkConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatus networkingStatus;
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NetworkConfigResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatus networkingStatus;
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NetworkConfigResponse
namespace ConnectNetwork {
enum class Fields
{
    kNetworkID  = 0,
    kBreadcrumb = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::ConnectNetworkResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint64_t breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConnectNetwork
namespace ConnectNetworkResponse {
enum class Fields
{
    kNetworkingStatus = 0,
    kDebugText        = 1,
    kErrorValue       = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatus networkingStatus;
    chip::CharSpan debugText;
    int32_t errorValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ConnectNetworkResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    NetworkCommissioningStatus networkingStatus;
    chip::CharSpan debugText;
    int32_t errorValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ConnectNetworkResponse
namespace ReorderNetwork {
enum class Fields
{
    kNetworkID    = 0,
    kNetworkIndex = 1,
    kBreadcrumb   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReorderNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint8_t networkIndex;
    uint64_t breadcrumb;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::NetworkCommissioning::Commands::NetworkConfigResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReorderNetwork::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

    chip::ByteSpan networkID;
    uint8_t networkIndex;
    uint64_t breadcrumb;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReorderNetwork
} // namespace Commands

namespace Attributes {

namespace MaxNetworks {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxNetworks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxNetworks
namespace Networks {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::NetworkCommissioning::Structs::NetworkInfo::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Networks::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Networks
namespace ScanMaxTimeSeconds {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScanMaxTimeSeconds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScanMaxTimeSeconds
namespace ConnectMaxTimeSeconds {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConnectMaxTimeSeconds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ConnectMaxTimeSeconds
namespace InterfaceEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InterfaceEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InterfaceEnabled
namespace LastNetworkingStatus {
struct TypeInfo
{
    using Type             = chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus;
    using DecodableType    = chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus;
    using DecodableArgType = chip::app::Clusters::NetworkCommissioning::NetworkCommissioningStatus;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastNetworkingStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastNetworkingStatus
namespace LastNetworkID {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastNetworkID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastNetworkID
namespace LastConnectErrorValue {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LastConnectErrorValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LastConnectErrorValue
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NetworkCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxNetworks::TypeInfo::DecodableType maxNetworks;
        Attributes::Networks::TypeInfo::DecodableType networks;
        Attributes::ScanMaxTimeSeconds::TypeInfo::DecodableType scanMaxTimeSeconds;
        Attributes::ConnectMaxTimeSeconds::TypeInfo::DecodableType connectMaxTimeSeconds;
        Attributes::InterfaceEnabled::TypeInfo::DecodableType interfaceEnabled;
        Attributes::LastNetworkingStatus::TypeInfo::DecodableType lastNetworkingStatus;
        Attributes::LastNetworkID::TypeInfo::DecodableType lastNetworkID;
        Attributes::LastConnectErrorValue::TypeInfo::DecodableType lastConnectErrorValue;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace NetworkCommissioning
namespace DiagnosticLogs {
// Enum for LogsIntent
enum class LogsIntent : uint8_t
{
    kEndUserSupport = 0x00,
    kNetworkDiag    = 0x01,
    kCrashLogs      = 0x02,
};
// Enum for LogsStatus
enum class LogsStatus : uint8_t
{
    kSuccess   = 0x00,
    kExhausted = 0x01,
    kNoLogs    = 0x02,
    kBusy      = 0x03,
    kDenied    = 0x04,
};
// Enum for LogsTransferProtocol
enum class LogsTransferProtocol : uint8_t
{
    kResponsePayload = 0x00,
    kBdx             = 0x01,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace RetrieveLogsRequest {
struct Type;
struct DecodableType;
} // namespace RetrieveLogsRequest

namespace RetrieveLogsResponse {
struct Type;
struct DecodableType;
} // namespace RetrieveLogsResponse

} // namespace Commands

namespace Commands {
namespace RetrieveLogsRequest {
enum class Fields
{
    kIntent                 = 0,
    kRequestedProtocol      = 1,
    kTransferFileDesignator = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    LogsIntent intent;
    LogsTransferProtocol requestedProtocol;
    chip::ByteSpan transferFileDesignator;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DiagnosticLogs::Commands::RetrieveLogsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    LogsIntent intent;
    LogsTransferProtocol requestedProtocol;
    chip::ByteSpan transferFileDesignator;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsRequest
namespace RetrieveLogsResponse {
enum class Fields
{
    kStatus        = 0,
    kContent       = 1,
    kTimeStamp     = 2,
    kTimeSinceBoot = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    LogsStatus status;
    chip::ByteSpan content;
    uint32_t timeStamp;
    uint32_t timeSinceBoot;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RetrieveLogsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

    LogsStatus status;
    chip::ByteSpan content;
    uint32_t timeStamp;
    uint32_t timeSinceBoot;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RetrieveLogsResponse
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DiagnosticLogs::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace DiagnosticLogs
namespace GeneralDiagnostics {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for BootReasonType
enum class BootReasonType : uint8_t
{
    kUnspecified             = 0x00,
    kPowerOnReboot           = 0x01,
    kBrownOutReset           = 0x02,
    kSoftwareWatchdogReset   = 0x03,
    kHardwareWatchdogReset   = 0x04,
    kSoftwareUpdateCompleted = 0x05,
    kSoftwareReset           = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using BootReasonType                  = EmberAfBootReasonType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HardwareFaultType
enum class HardwareFaultType : uint8_t
{
    kUnspecified            = 0x00,
    kRadio                  = 0x01,
    kSensor                 = 0x02,
    kResettableOverTemp     = 0x03,
    kNonResettableOverTemp  = 0x04,
    kPowerSource            = 0x05,
    kVisualDisplayFault     = 0x06,
    kAudioOutputFault       = 0x07,
    kUserInterfaceFault     = 0x08,
    kNonVolatileMemoryError = 0x09,
    kTamperDetected         = 0x0A,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HardwareFaultType               = EmberAfHardwareFaultType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for InterfaceType
enum class InterfaceType : uint8_t
{
    kUnspecified = 0x00,
    kWiFi        = 0x01,
    kEthernet    = 0x02,
    kCellular    = 0x03,
    kThread      = 0x04,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using InterfaceType                   = EmberAfInterfaceType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NetworkFaultType
enum class NetworkFaultType : uint8_t
{
    kUnspecified      = 0x00,
    kHardwareFailure  = 0x01,
    kNetworkJammed    = 0x02,
    kConnectionFailed = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NetworkFaultType                = EmberAfNetworkFaultType;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for RadioFaultType
enum class RadioFaultType : uint8_t
{
    kUnspecified   = 0x00,
    kWiFiFault     = 0x01,
    kCellularFault = 0x02,
    kThreadFault   = 0x03,
    kNFCFault      = 0x04,
    kBLEFault      = 0x05,
    kEthernetFault = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using RadioFaultType                  = EmberAfRadioFaultType;
#endif

namespace Structs {
namespace NetworkInterfaceType {
enum class Fields
{
    kName                            = 1,
    kFabricConnected                 = 2,
    kOffPremiseServicesReachableIPv4 = 3,
    kOffPremiseServicesReachableIPv6 = 4,
    kHardwareAddress                 = 5,
    kType                            = 6,
};

struct Type
{
public:
    chip::CharSpan name;
    bool fabricConnected;
    bool offPremiseServicesReachableIPv4;
    bool offPremiseServicesReachableIPv6;
    chip::ByteSpan hardwareAddress;
    InterfaceType type;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NetworkInterfaceType
} // namespace Structs

namespace Attributes {

namespace NetworkInterfaces {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::GeneralDiagnostics::Structs::NetworkInterfaceType::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkInterfaces::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NetworkInterfaces
namespace RebootCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RebootCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RebootCount
namespace UpTime {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UpTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UpTime
namespace TotalOperationalHours {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalOperationalHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalOperationalHours
namespace BootReasons {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BootReasons::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BootReasons
namespace ActiveHardwareFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveHardwareFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveHardwareFaults
namespace ActiveRadioFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveRadioFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveRadioFaults
namespace ActiveNetworkFaults {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaults::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveNetworkFaults
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NetworkInterfaces::TypeInfo::DecodableType networkInterfaces;
        Attributes::RebootCount::TypeInfo::DecodableType rebootCount;
        Attributes::UpTime::TypeInfo::DecodableType upTime;
        Attributes::TotalOperationalHours::TypeInfo::DecodableType totalOperationalHours;
        Attributes::BootReasons::TypeInfo::DecodableType bootReasons;
        Attributes::ActiveHardwareFaults::TypeInfo::DecodableType activeHardwareFaults;
        Attributes::ActiveRadioFaults::TypeInfo::DecodableType activeRadioFaults;
        Attributes::ActiveNetworkFaults::TypeInfo::DecodableType activeNetworkFaults;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace HardwareFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::List<const HardwareFaultType> current;
    DataModel::List<const HardwareFaultType> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<HardwareFaultType> current;
    DataModel::DecodableList<HardwareFaultType> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace HardwareFaultChange
namespace RadioFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::List<const RadioFaultType> current;
    DataModel::List<const RadioFaultType> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<RadioFaultType> current;
    DataModel::DecodableList<RadioFaultType> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace RadioFaultChange
namespace NetworkFaultChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
    kCurrent  = 0,
    kPrevious = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::List<const NetworkFaultType> current;
    DataModel::List<const NetworkFaultType> previous;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    DataModel::DecodableList<NetworkFaultType> current;
    DataModel::DecodableList<NetworkFaultType> previous;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace NetworkFaultChange
namespace BootReason {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000003;

enum class Fields
{
    kBootReason = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    BootReasonType bootReason;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::GeneralDiagnostics::Id; }

    BootReasonType bootReason;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace BootReason
} // namespace Events
} // namespace GeneralDiagnostics
namespace SoftwareDiagnostics {

namespace Structs {
namespace SoftwareFault {
enum class Fields
{
    kId             = 1,
    kName           = 2,
    kFaultRecording = 3,
};

struct Type
{
public:
    uint64_t id;
    chip::CharSpan name;
    chip::ByteSpan faultRecording;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SoftwareFault
namespace ThreadMetrics {
enum class Fields
{
    kId               = 1,
    kName             = 2,
    kStackFreeCurrent = 3,
    kStackFreeMinimum = 4,
    kStackSize        = 5,
};

struct Type
{
public:
    uint64_t id;
    chip::CharSpan name;
    uint32_t stackFreeCurrent;
    uint32_t stackFreeMinimum;
    uint32_t stackSize;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ThreadMetrics
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetWatermarks {
struct Type;
struct DecodableType;
} // namespace ResetWatermarks

} // namespace Commands

namespace Commands {
namespace ResetWatermarks {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetWatermarks::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetWatermarks
} // namespace Commands

namespace Attributes {

namespace ThreadMetrics {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::SoftwareDiagnostics::Structs::ThreadMetrics::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThreadMetrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThreadMetrics
namespace CurrentHeapFree {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapFree::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapFree
namespace CurrentHeapUsed {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapUsed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapUsed
namespace CurrentHeapHighWatermark {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHeapHighWatermark::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHeapHighWatermark
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ThreadMetrics::TypeInfo::DecodableType threadMetrics;
        Attributes::CurrentHeapFree::TypeInfo::DecodableType currentHeapFree;
        Attributes::CurrentHeapUsed::TypeInfo::DecodableType currentHeapUsed;
        Attributes::CurrentHeapHighWatermark::TypeInfo::DecodableType currentHeapHighWatermark;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace SoftwareFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kSoftwareFault = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    Structs::SoftwareFault::Type softwareFault;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::SoftwareDiagnostics::Id; }

    Structs::SoftwareFault::DecodableType softwareFault;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SoftwareFault
} // namespace Events
} // namespace SoftwareDiagnostics
namespace ThreadNetworkDiagnostics {
// Enum for NetworkFault
enum class NetworkFault : uint8_t
{
    kUnspecified     = 0x00,
    kLinkDown        = 0x01,
    kHardwareFailure = 0x02,
    kNetworkJammed   = 0x03,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for RoutingRole
enum class RoutingRole : uint8_t
{
    kUnspecified     = 0x00,
    kUnassigned      = 0x01,
    kSleepyEndDevice = 0x02,
    kEndDevice       = 0x03,
    kReed            = 0x04,
    kRouter          = 0x05,
    kLeader          = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using RoutingRole                     = EmberAfRoutingRole;
#endif
// Enum for ThreadConnectionStatus
enum class ThreadConnectionStatus : uint8_t
{
    kConnected    = 0x00,
    kNotConnected = 0x01,
};

namespace Structs {
namespace NeighborTable {
enum class Fields
{
    kExtAddress       = 1,
    kAge              = 2,
    kRloc16           = 3,
    kLinkFrameCounter = 4,
    kMleFrameCounter  = 5,
    kLqi              = 6,
    kAverageRssi      = 7,
    kLastRssi         = 8,
    kFrameErrorRate   = 9,
    kMessageErrorRate = 10,
    kRxOnWhenIdle     = 11,
    kFullThreadDevice = 12,
    kFullNetworkData  = 13,
    kIsChild          = 14,
};

struct Type
{
public:
    uint64_t extAddress;
    uint32_t age;
    uint16_t rloc16;
    uint32_t linkFrameCounter;
    uint32_t mleFrameCounter;
    uint8_t lqi;
    int8_t averageRssi;
    int8_t lastRssi;
    uint8_t frameErrorRate;
    uint8_t messageErrorRate;
    bool rxOnWhenIdle;
    bool fullThreadDevice;
    bool fullNetworkData;
    bool isChild;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NeighborTable
namespace OperationalDatasetComponents {
enum class Fields
{
    kActiveTimestampPresent  = 1,
    kPendingTimestampPresent = 2,
    kMasterKeyPresent        = 3,
    kNetworkNamePresent      = 4,
    kExtendedPanIdPresent    = 5,
    kMeshLocalPrefixPresent  = 6,
    kDelayPresent            = 7,
    kPanIdPresent            = 8,
    kChannelPresent          = 9,
    kPskcPresent             = 10,
    kSecurityPolicyPresent   = 11,
    kChannelMaskPresent      = 12,
};

struct Type
{
public:
    bool activeTimestampPresent;
    bool pendingTimestampPresent;
    bool masterKeyPresent;
    bool networkNamePresent;
    bool extendedPanIdPresent;
    bool meshLocalPrefixPresent;
    bool delayPresent;
    bool panIdPresent;
    bool channelPresent;
    bool pskcPresent;
    bool securityPolicyPresent;
    bool channelMaskPresent;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace OperationalDatasetComponents
namespace RouteTable {
enum class Fields
{
    kExtAddress      = 1,
    kRloc16          = 2,
    kRouterId        = 3,
    kNextHop         = 4,
    kPathCost        = 5,
    kLQIIn           = 6,
    kLQIOut          = 7,
    kAge             = 8,
    kAllocated       = 9,
    kLinkEstablished = 10,
};

struct Type
{
public:
    uint64_t extAddress;
    uint16_t rloc16;
    uint8_t routerId;
    uint8_t nextHop;
    uint8_t pathCost;
    uint8_t LQIIn;
    uint8_t LQIOut;
    uint8_t age;
    bool allocated;
    bool linkEstablished;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace RouteTable
namespace SecurityPolicy {
enum class Fields
{
    kRotationTime = 1,
    kFlags        = 2,
};

struct Type
{
public:
    uint16_t rotationTime;
    uint16_t flags;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SecurityPolicy
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace Channel {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Channel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Channel
namespace RoutingRole {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RoutingRole::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RoutingRole
namespace NetworkName {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NetworkName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NetworkName
namespace PanId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PanId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PanId
namespace ExtendedPanId {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExtendedPanId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExtendedPanId
namespace MeshLocalPrefix {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeshLocalPrefix::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeshLocalPrefix
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace NeighborTableList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::NeighborTable::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeighborTableList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeighborTableList
namespace RouteTableList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::RouteTable::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouteTableList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RouteTableList
namespace PartitionId {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartitionId
namespace Weighting {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Weighting::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Weighting
namespace DataVersion {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DataVersion
namespace StableDataVersion {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StableDataVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StableDataVersion
namespace LeaderRouterId {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRouterId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LeaderRouterId
namespace DetachedRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DetachedRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DetachedRoleCount
namespace ChildRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChildRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChildRoleCount
namespace RouterRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RouterRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RouterRoleCount
namespace LeaderRoleCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LeaderRoleCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LeaderRoleCount
namespace AttachAttemptCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttachAttemptCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttachAttemptCount
namespace PartitionIdChangeCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartitionIdChangeCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartitionIdChangeCount
namespace BetterPartitionAttachAttemptCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BetterPartitionAttachAttemptCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BetterPartitionAttachAttemptCount
namespace ParentChangeCount {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ParentChangeCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ParentChangeCount
namespace TxTotalCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxTotalCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxTotalCount
namespace TxUnicastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxUnicastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxUnicastCount
namespace TxBroadcastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBroadcastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBroadcastCount
namespace TxAckRequestedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckRequestedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxAckRequestedCount
namespace TxAckedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxAckedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxAckedCount
namespace TxNoAckRequestedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxNoAckRequestedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxNoAckRequestedCount
namespace TxDataCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDataCount
namespace TxDataPollCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDataPollCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDataPollCount
namespace TxBeaconCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBeaconCount
namespace TxBeaconRequestCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxBeaconRequestCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxBeaconRequestCount
namespace TxOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxOtherCount
namespace TxRetryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxRetryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxRetryCount
namespace TxDirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxDirectMaxRetryExpiryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxDirectMaxRetryExpiryCount
namespace TxIndirectMaxRetryExpiryCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxIndirectMaxRetryExpiryCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxIndirectMaxRetryExpiryCount
namespace TxErrCcaCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCcaCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrCcaCount
namespace TxErrAbortCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrAbortCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrAbortCount
namespace TxErrBusyChannelCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrBusyChannelCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrBusyChannelCount
namespace RxTotalCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxTotalCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxTotalCount
namespace RxUnicastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxUnicastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxUnicastCount
namespace RxBroadcastCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBroadcastCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBroadcastCount
namespace RxDataCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDataCount
namespace RxDataPollCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDataPollCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDataPollCount
namespace RxBeaconCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBeaconCount
namespace RxBeaconRequestCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxBeaconRequestCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxBeaconRequestCount
namespace RxOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxOtherCount
namespace RxAddressFilteredCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxAddressFilteredCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxAddressFilteredCount
namespace RxDestAddrFilteredCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDestAddrFilteredCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDestAddrFilteredCount
namespace RxDuplicatedCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxDuplicatedCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxDuplicatedCount
namespace RxErrNoFrameCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrNoFrameCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrNoFrameCount
namespace RxErrUnknownNeighborCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrUnknownNeighborCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrUnknownNeighborCount
namespace RxErrInvalidSrcAddrCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrInvalidSrcAddrCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrInvalidSrcAddrCount
namespace RxErrSecCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrSecCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrSecCount
namespace RxErrFcsCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrFcsCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrFcsCount
namespace RxErrOtherCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RxErrOtherCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RxErrOtherCount
namespace ActiveTimestamp {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveTimestamp
namespace PendingTimestamp {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PendingTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PendingTimestamp
namespace Delay {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Delay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Delay
namespace SecurityPolicy {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::SecurityPolicy::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityPolicy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SecurityPolicy
namespace ChannelMask {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelMask
namespace OperationalDatasetComponents {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<
        const chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::ThreadNetworkDiagnostics::Structs::OperationalDatasetComponents::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalDatasetComponents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalDatasetComponents
namespace ActiveNetworkFaultsList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ThreadNetworkDiagnostics::NetworkFault> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveNetworkFaultsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveNetworkFaultsList
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Channel::TypeInfo::DecodableType channel;
        Attributes::RoutingRole::TypeInfo::DecodableType routingRole;
        Attributes::NetworkName::TypeInfo::DecodableType networkName;
        Attributes::PanId::TypeInfo::DecodableType panId;
        Attributes::ExtendedPanId::TypeInfo::DecodableType extendedPanId;
        Attributes::MeshLocalPrefix::TypeInfo::DecodableType meshLocalPrefix;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount;
        Attributes::NeighborTableList::TypeInfo::DecodableType neighborTableList;
        Attributes::RouteTableList::TypeInfo::DecodableType routeTableList;
        Attributes::PartitionId::TypeInfo::DecodableType partitionId;
        Attributes::Weighting::TypeInfo::DecodableType weighting;
        Attributes::DataVersion::TypeInfo::DecodableType dataVersion;
        Attributes::StableDataVersion::TypeInfo::DecodableType stableDataVersion;
        Attributes::LeaderRouterId::TypeInfo::DecodableType leaderRouterId;
        Attributes::DetachedRoleCount::TypeInfo::DecodableType detachedRoleCount;
        Attributes::ChildRoleCount::TypeInfo::DecodableType childRoleCount;
        Attributes::RouterRoleCount::TypeInfo::DecodableType routerRoleCount;
        Attributes::LeaderRoleCount::TypeInfo::DecodableType leaderRoleCount;
        Attributes::AttachAttemptCount::TypeInfo::DecodableType attachAttemptCount;
        Attributes::PartitionIdChangeCount::TypeInfo::DecodableType partitionIdChangeCount;
        Attributes::BetterPartitionAttachAttemptCount::TypeInfo::DecodableType betterPartitionAttachAttemptCount;
        Attributes::ParentChangeCount::TypeInfo::DecodableType parentChangeCount;
        Attributes::TxTotalCount::TypeInfo::DecodableType txTotalCount;
        Attributes::TxUnicastCount::TypeInfo::DecodableType txUnicastCount;
        Attributes::TxBroadcastCount::TypeInfo::DecodableType txBroadcastCount;
        Attributes::TxAckRequestedCount::TypeInfo::DecodableType txAckRequestedCount;
        Attributes::TxAckedCount::TypeInfo::DecodableType txAckedCount;
        Attributes::TxNoAckRequestedCount::TypeInfo::DecodableType txNoAckRequestedCount;
        Attributes::TxDataCount::TypeInfo::DecodableType txDataCount;
        Attributes::TxDataPollCount::TypeInfo::DecodableType txDataPollCount;
        Attributes::TxBeaconCount::TypeInfo::DecodableType txBeaconCount;
        Attributes::TxBeaconRequestCount::TypeInfo::DecodableType txBeaconRequestCount;
        Attributes::TxOtherCount::TypeInfo::DecodableType txOtherCount;
        Attributes::TxRetryCount::TypeInfo::DecodableType txRetryCount;
        Attributes::TxDirectMaxRetryExpiryCount::TypeInfo::DecodableType txDirectMaxRetryExpiryCount;
        Attributes::TxIndirectMaxRetryExpiryCount::TypeInfo::DecodableType txIndirectMaxRetryExpiryCount;
        Attributes::TxErrCcaCount::TypeInfo::DecodableType txErrCcaCount;
        Attributes::TxErrAbortCount::TypeInfo::DecodableType txErrAbortCount;
        Attributes::TxErrBusyChannelCount::TypeInfo::DecodableType txErrBusyChannelCount;
        Attributes::RxTotalCount::TypeInfo::DecodableType rxTotalCount;
        Attributes::RxUnicastCount::TypeInfo::DecodableType rxUnicastCount;
        Attributes::RxBroadcastCount::TypeInfo::DecodableType rxBroadcastCount;
        Attributes::RxDataCount::TypeInfo::DecodableType rxDataCount;
        Attributes::RxDataPollCount::TypeInfo::DecodableType rxDataPollCount;
        Attributes::RxBeaconCount::TypeInfo::DecodableType rxBeaconCount;
        Attributes::RxBeaconRequestCount::TypeInfo::DecodableType rxBeaconRequestCount;
        Attributes::RxOtherCount::TypeInfo::DecodableType rxOtherCount;
        Attributes::RxAddressFilteredCount::TypeInfo::DecodableType rxAddressFilteredCount;
        Attributes::RxDestAddrFilteredCount::TypeInfo::DecodableType rxDestAddrFilteredCount;
        Attributes::RxDuplicatedCount::TypeInfo::DecodableType rxDuplicatedCount;
        Attributes::RxErrNoFrameCount::TypeInfo::DecodableType rxErrNoFrameCount;
        Attributes::RxErrUnknownNeighborCount::TypeInfo::DecodableType rxErrUnknownNeighborCount;
        Attributes::RxErrInvalidSrcAddrCount::TypeInfo::DecodableType rxErrInvalidSrcAddrCount;
        Attributes::RxErrSecCount::TypeInfo::DecodableType rxErrSecCount;
        Attributes::RxErrFcsCount::TypeInfo::DecodableType rxErrFcsCount;
        Attributes::RxErrOtherCount::TypeInfo::DecodableType rxErrOtherCount;
        Attributes::ActiveTimestamp::TypeInfo::DecodableType activeTimestamp;
        Attributes::PendingTimestamp::TypeInfo::DecodableType pendingTimestamp;
        Attributes::Delay::TypeInfo::DecodableType delay;
        Attributes::SecurityPolicy::TypeInfo::DecodableType securityPolicy;
        Attributes::ChannelMask::TypeInfo::DecodableType channelMask;
        Attributes::OperationalDatasetComponents::TypeInfo::DecodableType operationalDatasetComponents;
        Attributes::ActiveNetworkFaultsList::TypeInfo::DecodableType activeNetworkFaultsList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace ConnectionStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kConnectionStatus = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    ThreadConnectionStatus connectionStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::ThreadNetworkDiagnostics::Id; }

    ThreadConnectionStatus connectionStatus;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ConnectionStatus
} // namespace Events
} // namespace ThreadNetworkDiagnostics
namespace WiFiNetworkDiagnostics {
// Enum for AssociationFailureCause
enum class AssociationFailureCause : uint8_t
{
    kUnknown              = 0x00,
    kAssociationFailed    = 0x01,
    kAuthenticationFailed = 0x02,
    kSsidNotFound         = 0x03,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SecurityType
enum class SecurityType : uint8_t
{
    kUnspecified = 0x00,
    kNone        = 0x01,
    kWep         = 0x02,
    kWpa         = 0x03,
    kWpa2        = 0x04,
    kWpa3        = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SecurityType                    = EmberAfSecurityType;
#endif
// Enum for WiFiConnectionStatus
enum class WiFiConnectionStatus : uint8_t
{
    kConnected    = 0x00,
    kNotConnected = 0x01,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for WiFiVersionType
enum class WiFiVersionType : uint8_t
{
    k80211a  = 0x00,
    k80211b  = 0x01,
    k80211g  = 0x02,
    k80211n  = 0x03,
    k80211ac = 0x04,
    k80211ax = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using WiFiVersionType                 = EmberAfWiFiVersionType;
#endif

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace Bssid {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bssid::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bssid
namespace SecurityType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SecurityType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SecurityType
namespace WiFiVersion {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WiFiVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WiFiVersion
namespace ChannelNumber {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelNumber
namespace Rssi {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Rssi::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Rssi
namespace BeaconLostCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconLostCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BeaconLostCount
namespace BeaconRxCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BeaconRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BeaconRxCount
namespace PacketMulticastRxCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketMulticastRxCount
namespace PacketMulticastTxCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketMulticastTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketMulticastTxCount
namespace PacketUnicastRxCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketUnicastRxCount
namespace PacketUnicastTxCount {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketUnicastTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketUnicastTxCount
namespace CurrentMaxRate {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMaxRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMaxRate
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Bssid::TypeInfo::DecodableType bssid;
        Attributes::SecurityType::TypeInfo::DecodableType securityType;
        Attributes::WiFiVersion::TypeInfo::DecodableType wiFiVersion;
        Attributes::ChannelNumber::TypeInfo::DecodableType channelNumber;
        Attributes::Rssi::TypeInfo::DecodableType rssi;
        Attributes::BeaconLostCount::TypeInfo::DecodableType beaconLostCount;
        Attributes::BeaconRxCount::TypeInfo::DecodableType beaconRxCount;
        Attributes::PacketMulticastRxCount::TypeInfo::DecodableType packetMulticastRxCount;
        Attributes::PacketMulticastTxCount::TypeInfo::DecodableType packetMulticastTxCount;
        Attributes::PacketUnicastRxCount::TypeInfo::DecodableType packetUnicastRxCount;
        Attributes::PacketUnicastTxCount::TypeInfo::DecodableType packetUnicastTxCount;
        Attributes::CurrentMaxRate::TypeInfo::DecodableType currentMaxRate;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace Disconnection {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kReasonCode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    uint16_t reasonCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    uint16_t reasonCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Disconnection
namespace AssociationFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kAssociationFailure = 0,
    kStatus             = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    AssociationFailureCause associationFailure;
    uint16_t status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    AssociationFailureCause associationFailure;
    uint16_t status;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AssociationFailure
namespace ConnectionStatus {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
    kConnectionStatus = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    WiFiConnectionStatus connectionStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::WiFiNetworkDiagnostics::Id; }

    WiFiConnectionStatus connectionStatus;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ConnectionStatus
} // namespace Events
} // namespace WiFiNetworkDiagnostics
namespace EthernetNetworkDiagnostics {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for PHYRateType
enum class PHYRateType : uint8_t
{
    k10m   = 0x00,
    k100m  = 0x01,
    k1000m = 0x02,
    k25g   = 0x03,
    k5g    = 0x04,
    k10g   = 0x05,
    k40g   = 0x06,
    k100g  = 0x07,
    k200g  = 0x08,
    k400g  = 0x09,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using PHYRateType                     = EmberAfPHYRateType;
#endif

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ResetCounts {
struct Type;
struct DecodableType;
} // namespace ResetCounts

} // namespace Commands

namespace Commands {
namespace ResetCounts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ResetCounts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ResetCounts
} // namespace Commands

namespace Attributes {

namespace PHYRate {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PHYRate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PHYRate
namespace FullDuplex {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FullDuplex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FullDuplex
namespace PacketRxCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketRxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketRxCount
namespace PacketTxCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PacketTxCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PacketTxCount
namespace TxErrCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TxErrCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TxErrCount
namespace CollisionCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CollisionCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CollisionCount
namespace OverrunCount {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverrunCount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverrunCount
namespace CarrierDetect {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CarrierDetect::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CarrierDetect
namespace TimeSinceReset {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimeSinceReset::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TimeSinceReset
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EthernetNetworkDiagnostics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PHYRate::TypeInfo::DecodableType PHYRate;
        Attributes::FullDuplex::TypeInfo::DecodableType fullDuplex;
        Attributes::PacketRxCount::TypeInfo::DecodableType packetRxCount;
        Attributes::PacketTxCount::TypeInfo::DecodableType packetTxCount;
        Attributes::TxErrCount::TypeInfo::DecodableType txErrCount;
        Attributes::CollisionCount::TypeInfo::DecodableType collisionCount;
        Attributes::OverrunCount::TypeInfo::DecodableType overrunCount;
        Attributes::CarrierDetect::TypeInfo::DecodableType carrierDetect;
        Attributes::TimeSinceReset::TypeInfo::DecodableType timeSinceReset;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace EthernetNetworkDiagnostics
namespace TimeSynchronization {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TimeSynchronization::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace TimeSynchronization
namespace BridgedDeviceBasic {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace StartUp {
struct Type;
struct DecodableType;
} // namespace StartUp

namespace ShutDown {
struct Type;
struct DecodableType;
} // namespace ShutDown

namespace Leave {
struct Type;
struct DecodableType;
} // namespace Leave

namespace ReachableChanged {
struct Type;
struct DecodableType;
} // namespace ReachableChanged

} // namespace Commands

namespace Commands {
namespace StartUp {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartUp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartUp
namespace ShutDown {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ShutDown::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShutDown
namespace Leave {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Leave::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Leave
namespace ReachableChanged {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ReachableChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ReachableChanged
} // namespace Commands

namespace Attributes {

namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorName
namespace VendorID {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorID
namespace ProductName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductName
namespace NodeLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NodeLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NodeLabel
namespace HardwareVersion {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersion
namespace HardwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HardwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HardwareVersionString
namespace SoftwareVersion {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersion
namespace SoftwareVersionString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareVersionString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareVersionString
namespace ManufacturingDate {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManufacturingDate::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ManufacturingDate
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartNumber
namespace ProductURL {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductURL::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductURL
namespace ProductLabel {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductLabel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductLabel
namespace SerialNumber {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SerialNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SerialNumber
namespace Reachable {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Reachable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Reachable
namespace UniqueID {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UniqueID::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UniqueID
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BridgedDeviceBasic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorID::TypeInfo::DecodableType vendorID;
        Attributes::ProductName::TypeInfo::DecodableType productName;
        Attributes::NodeLabel::TypeInfo::DecodableType nodeLabel;
        Attributes::HardwareVersion::TypeInfo::DecodableType hardwareVersion;
        Attributes::HardwareVersionString::TypeInfo::DecodableType hardwareVersionString;
        Attributes::SoftwareVersion::TypeInfo::DecodableType softwareVersion;
        Attributes::SoftwareVersionString::TypeInfo::DecodableType softwareVersionString;
        Attributes::ManufacturingDate::TypeInfo::DecodableType manufacturingDate;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductURL::TypeInfo::DecodableType productURL;
        Attributes::ProductLabel::TypeInfo::DecodableType productLabel;
        Attributes::SerialNumber::TypeInfo::DecodableType serialNumber;
        Attributes::Reachable::TypeInfo::DecodableType reachable;
        Attributes::UniqueID::TypeInfo::DecodableType uniqueID;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BridgedDeviceBasic
namespace Switch {

namespace Attributes {

namespace NumberOfPositions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPositions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPositions
namespace CurrentPosition {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPosition
namespace MultiPressMax {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MultiPressMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MultiPressMax
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::NumberOfPositions::TypeInfo::DecodableType numberOfPositions;
        Attributes::CurrentPosition::TypeInfo::DecodableType currentPosition;
        Attributes::MultiPressMax::TypeInfo::DecodableType multiPressMax;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace SwitchLatched {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SwitchLatched
namespace InitialPress {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace InitialPress
namespace LongPress {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
    kNewPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LongPress
namespace ShortRelease {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000003;

enum class Fields
{
    kPreviousPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ShortRelease
namespace LongRelease {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000004;

enum class Fields
{
    kPreviousPosition = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t previousPosition;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LongRelease
namespace MultiPressOngoing {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000005;

enum class Fields
{
    kNewPosition                   = 0,
    kCurrentNumberOfPressesCounted = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;
    uint8_t currentNumberOfPressesCounted;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;
    uint8_t currentNumberOfPressesCounted;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MultiPressOngoing
namespace MultiPressComplete {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000006;

enum class Fields
{
    kNewPosition                 = 0,
    kTotalNumberOfPressesCounted = 1,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;
    uint8_t totalNumberOfPressesCounted;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::Switch::Id; }

    uint8_t newPosition;
    uint8_t totalNumberOfPressesCounted;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MultiPressComplete
} // namespace Events
} // namespace Switch
namespace AdministratorCommissioning {
// Enum for CommissioningWindowStatus
enum class CommissioningWindowStatus : uint8_t
{
    kWindowNotOpen      = 0x00,
    kEnhancedWindowOpen = 0x01,
    kBasicWindowOpen    = 0x02,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for StatusCode
enum class StatusCode : uint8_t
{
    kBusy               = 0x01,
    kPAKEParameterError = 0x02,
    kWindowNotOpen      = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using StatusCode                      = EmberAfStatusCode;
#endif

namespace Commands {
// Forward-declarations so we can reference these later.

namespace OpenCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace OpenCommissioningWindow

namespace OpenBasicCommissioningWindow {
struct Type;
struct DecodableType;
} // namespace OpenBasicCommissioningWindow

namespace RevokeCommissioning {
struct Type;
struct DecodableType;
} // namespace RevokeCommissioning

} // namespace Commands

namespace Commands {
namespace OpenCommissioningWindow {
enum class Fields
{
    kCommissioningTimeout = 0,
    kPAKEVerifier         = 1,
    kDiscriminator        = 2,
    kIterations           = 3,
    kSalt                 = 4,
    kPasscodeID           = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;
    chip::ByteSpan PAKEVerifier;
    uint16_t discriminator;
    uint32_t iterations;
    chip::ByteSpan salt;
    uint16_t passcodeID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpenCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;
    chip::ByteSpan PAKEVerifier;
    uint16_t discriminator;
    uint32_t iterations;
    chip::ByteSpan salt;
    uint16_t passcodeID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenCommissioningWindow
namespace OpenBasicCommissioningWindow {
enum class Fields
{
    kCommissioningTimeout = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpenBasicCommissioningWindow::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    uint16_t commissioningTimeout;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpenBasicCommissioningWindow
namespace RevokeCommissioning {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RevokeCommissioning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RevokeCommissioning
} // namespace Commands

namespace Attributes {

namespace WindowStatus {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WindowStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WindowStatus
namespace AdminFabricIndex {
struct TypeInfo
{
    using Type             = chip::FabricIndex;
    using DecodableType    = chip::FabricIndex;
    using DecodableArgType = chip::FabricIndex;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AdminFabricIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AdminFabricIndex
namespace AdminVendorId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AdminVendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AdminVendorId
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AdministratorCommissioning::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::WindowStatus::TypeInfo::DecodableType windowStatus;
        Attributes::AdminFabricIndex::TypeInfo::DecodableType adminFabricIndex;
        Attributes::AdminVendorId::TypeInfo::DecodableType adminVendorId;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace AdministratorCommissioning
namespace OperationalCredentials {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for NodeOperationalCertStatus
enum class NodeOperationalCertStatus : uint8_t
{
    kSuccess               = 0x00,
    kInvalidPublicKey      = 0x01,
    kInvalidNodeOpId       = 0x02,
    kInvalidNOC            = 0x03,
    kMissingCsr            = 0x04,
    kTableFull             = 0x05,
    kInsufficientPrivilege = 0x08,
    kFabricConflict        = 0x09,
    kLabelConflict         = 0x0A,
    kInvalidFabricIndex    = 0x0B,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using NodeOperationalCertStatus       = EmberAfNodeOperationalCertStatus;
#endif

namespace Structs {
namespace FabricDescriptor {
enum class Fields
{
    kFabricIndex   = 1,
    kRootPublicKey = 2,
    kVendorId      = 3,
    kFabricId      = 4,
    kNodeId        = 5,
    kLabel         = 6,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan rootPublicKey;
    uint16_t vendorId;
    chip::FabricId fabricId;
    chip::NodeId nodeId;
    chip::CharSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace FabricDescriptor
namespace NOCStruct {
enum class Fields
{
    kFabricIndex = 1,
    kNoc         = 2,
};

struct Type
{
public:
    uint8_t fabricIndex;
    chip::ByteSpan noc;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NOCStruct
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace AttestationRequest {
struct Type;
struct DecodableType;
} // namespace AttestationRequest

namespace AttestationResponse {
struct Type;
struct DecodableType;
} // namespace AttestationResponse

namespace CertificateChainRequest {
struct Type;
struct DecodableType;
} // namespace CertificateChainRequest

namespace CertificateChainResponse {
struct Type;
struct DecodableType;
} // namespace CertificateChainResponse

namespace OpCSRRequest {
struct Type;
struct DecodableType;
} // namespace OpCSRRequest

namespace OpCSRResponse {
struct Type;
struct DecodableType;
} // namespace OpCSRResponse

namespace AddNOC {
struct Type;
struct DecodableType;
} // namespace AddNOC

namespace UpdateNOC {
struct Type;
struct DecodableType;
} // namespace UpdateNOC

namespace NOCResponse {
struct Type;
struct DecodableType;
} // namespace NOCResponse

namespace UpdateFabricLabel {
struct Type;
struct DecodableType;
} // namespace UpdateFabricLabel

namespace RemoveFabric {
struct Type;
struct DecodableType;
} // namespace RemoveFabric

namespace AddTrustedRootCertificate {
struct Type;
struct DecodableType;
} // namespace AddTrustedRootCertificate

namespace RemoveTrustedRootCertificate {
struct Type;
struct DecodableType;
} // namespace RemoveTrustedRootCertificate

} // namespace Commands

namespace Commands {
namespace AttestationRequest {
enum class Fields
{
    kAttestationNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::AttestationResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AttestationRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationRequest
namespace AttestationResponse {
enum class Fields
{
    kAttestationElements = 0,
    kSignature           = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan signature;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AttestationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan attestationElements;
    chip::ByteSpan signature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AttestationResponse
namespace CertificateChainRequest {
enum class Fields
{
    kCertificateType = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    uint8_t certificateType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::CertificateChainResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    uint8_t certificateType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainRequest
namespace CertificateChainResponse {
enum class Fields
{
    kCertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan certificate;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CertificateChainResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan certificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CertificateChainResponse
namespace OpCSRRequest {
enum class Fields
{
    kCSRNonce = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpCSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::OpCSRResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpCSRRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan CSRNonce;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpCSRRequest
namespace OpCSRResponse {
enum class Fields
{
    kNOCSRElements        = 0,
    kAttestationSignature = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OpCSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OpCSRResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCSRElements;
    chip::ByteSpan attestationSignature;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OpCSRResponse
namespace AddNOC {
enum class Fields
{
    kNOCValue      = 0,
    kICACValue     = 1,
    kIPKValue      = 2,
    kCaseAdminNode = 3,
    kAdminVendorId = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    chip::ByteSpan IPKValue;
    chip::NodeId caseAdminNode;
    uint16_t adminVendorId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    chip::ByteSpan IPKValue;
    chip::NodeId caseAdminNode;
    uint16_t adminVendorId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddNOC
namespace UpdateNOC {
enum class Fields
{
    kNOCValue  = 0,
    kICACValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateNOC::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan NOCValue;
    Optional<chip::ByteSpan> ICACValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateNOC
namespace NOCResponse {
enum class Fields
{
    kStatusCode  = 0,
    kFabricIndex = 1,
    kDebugText   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    uint8_t statusCode;
    uint8_t fabricIndex;
    chip::CharSpan debugText;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NOCResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    uint8_t statusCode;
    uint8_t fabricIndex;
    chip::CharSpan debugText;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NOCResponse
namespace UpdateFabricLabel {
enum class Fields
{
    kLabel = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::CharSpan label;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpdateFabricLabel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::CharSpan label;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpdateFabricLabel
namespace RemoveFabric {
enum class Fields
{
    kFabricIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    uint8_t fabricIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::OperationalCredentials::Commands::NOCResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveFabric::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    uint8_t fabricIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveFabric
namespace AddTrustedRootCertificate {
enum class Fields
{
    kRootCertificate = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan rootCertificate;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AddTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan rootCertificate;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AddTrustedRootCertificate
namespace RemoveTrustedRootCertificate {
enum class Fields
{
    kTrustedRootIdentifier = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RemoveTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan trustedRootIdentifier;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RemoveTrustedRootCertificate::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

    chip::ByteSpan trustedRootIdentifier;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RemoveTrustedRootCertificate
} // namespace Commands

namespace Attributes {

namespace FabricsList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::OperationalCredentials::Structs::FabricDescriptor::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FabricsList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FabricsList
namespace SupportedFabrics {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedFabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedFabrics
namespace CommissionedFabrics {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CommissionedFabrics::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CommissionedFabrics
namespace TrustedRootCertificates {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TrustedRootCertificates::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TrustedRootCertificates
namespace CurrentFabricIndex {
struct TypeInfo
{
    using Type             = chip::FabricIndex;
    using DecodableType    = chip::FabricIndex;
    using DecodableArgType = chip::FabricIndex;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentFabricIndex::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentFabricIndex
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OperationalCredentials::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::FabricsList::TypeInfo::DecodableType fabricsList;
        Attributes::SupportedFabrics::TypeInfo::DecodableType supportedFabrics;
        Attributes::CommissionedFabrics::TypeInfo::DecodableType commissionedFabrics;
        Attributes::TrustedRootCertificates::TypeInfo::DecodableType trustedRootCertificates;
        Attributes::CurrentFabricIndex::TypeInfo::DecodableType currentFabricIndex;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OperationalCredentials
namespace GroupKeyManagement {
// Enum for GroupKeySecurityPolicy
enum class GroupKeySecurityPolicy : uint8_t
{
    kStandard   = 0x00,
    kLowLatency = 0x01,
};

namespace Structs {
namespace GroupInfo {
enum class Fields
{
    kFabricIndex = 0,
    kGroupId     = 1,
    kEndpoints   = 2,
    kGroupName   = 3,
};

struct Type
{
public:
    uint16_t fabricIndex;
    uint16_t groupId;
    DataModel::List<const uint16_t> endpoints;
    chip::CharSpan groupName;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    uint16_t fabricIndex;
    uint16_t groupId;
    DataModel::DecodableList<uint16_t> endpoints;
    chip::CharSpan groupName;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace GroupInfo
namespace GroupKey {
enum class Fields
{
    kFabricIndex   = 0,
    kGroupId       = 1,
    kGroupKeySetID = 2,
};

struct Type
{
public:
    uint16_t fabricIndex;
    uint16_t groupId;
    uint16_t groupKeySetID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace GroupKey
namespace GroupKeySet {
enum class Fields
{
    kGroupKeySetID   = 0,
    kSecurityPolicy  = 1,
    kEpochKey0       = 2,
    kEpochStartTime0 = 3,
    kEpochKey1       = 4,
    kEpochStartTime1 = 5,
    kEpochKey2       = 6,
    kEpochStartTime2 = 7,
};

struct Type
{
public:
    uint16_t groupKeySetID;
    GroupKeySecurityPolicy securityPolicy;
    chip::ByteSpan epochKey0;
    uint64_t epochStartTime0;
    chip::ByteSpan epochKey1;
    uint64_t epochStartTime1;
    chip::ByteSpan epochKey2;
    uint64_t epochStartTime2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace GroupKeySet
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace KeySetWrite {
struct Type;
struct DecodableType;
} // namespace KeySetWrite

namespace KeySetRead {
struct Type;
struct DecodableType;
} // namespace KeySetRead

namespace KeySetReadResponse {
struct Type;
struct DecodableType;
} // namespace KeySetReadResponse

namespace KeySetRemove {
struct Type;
struct DecodableType;
} // namespace KeySetRemove

namespace KeySetReadAllIndices {
struct Type;
struct DecodableType;
} // namespace KeySetReadAllIndices

namespace KeySetReadAllIndicesResponse {
struct Type;
struct DecodableType;
} // namespace KeySetReadAllIndicesResponse

} // namespace Commands

namespace Commands {
namespace KeySetWrite {
enum class Fields
{
    kGroupKeySet = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetWrite::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySet::Type groupKeySet;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetWrite::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySet::DecodableType groupKeySet;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetWrite
namespace KeySetRead {
enum class Fields
{
    kGroupKeySetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetRead::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::GroupKeyManagement::Commands::KeySetReadResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetRead::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetRead
namespace KeySetReadResponse {
enum class Fields
{
    kGroupKeySet = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySet::Type groupKeySet;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    Structs::GroupKeySet::DecodableType groupKeySet;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadResponse
namespace KeySetRemove {
enum class Fields
{
    kGroupKeySetID = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetRemove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetRemove::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    uint16_t groupKeySetID;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetRemove
namespace KeySetReadAllIndices {
enum class Fields
{
    kGroupKeySetIDs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndices::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::List<const uint16_t> groupKeySetIDs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::GroupKeyManagement::Commands::KeySetReadAllIndicesResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndices::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::DecodableList<uint16_t> groupKeySetIDs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadAllIndices
namespace KeySetReadAllIndicesResponse {
enum class Fields
{
    kGroupKeySetIDs = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndicesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::List<const uint16_t> groupKeySetIDs;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::KeySetReadAllIndicesResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

    DataModel::DecodableList<uint16_t> groupKeySetIDs;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace KeySetReadAllIndicesResponse
} // namespace Commands

namespace Attributes {

namespace GroupKeyMap {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupKey::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupKeyMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GroupKeyMap
namespace GroupTable {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::GroupKeyManagement::Structs::GroupInfo::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::GroupTable::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace GroupTable
namespace MaxGroupsPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxGroupsPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxGroupsPerFabric
namespace MaxGroupKeysPerFabric {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxGroupKeysPerFabric::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxGroupKeysPerFabric
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::GroupKeyManagement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::GroupKeyMap::TypeInfo::DecodableType groupKeyMap;
        Attributes::GroupTable::TypeInfo::DecodableType groupTable;
        Attributes::MaxGroupsPerFabric::TypeInfo::DecodableType maxGroupsPerFabric;
        Attributes::MaxGroupKeysPerFabric::TypeInfo::DecodableType maxGroupKeysPerFabric;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace GroupKeyManagement
namespace FixedLabel {

namespace Structs {
namespace LabelStruct {
enum class Fields
{
    kLabel = 1,
    kValue = 2,
};

struct Type
{
public:
    chip::CharSpan label;
    chip::CharSpan value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace LabelStruct
} // namespace Structs

namespace Attributes {

namespace LabelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::FixedLabel::Structs::LabelStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::FixedLabel::Structs::LabelStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LabelList
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FixedLabel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LabelList::TypeInfo::DecodableType labelList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace FixedLabel
namespace UserLabel {

namespace Structs {
namespace LabelStruct {
enum class Fields
{
    kLabel = 1,
    kValue = 2,
};

struct Type
{
public:
    chip::CharSpan label;
    chip::CharSpan value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace LabelStruct
} // namespace Structs

namespace Attributes {

namespace LabelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::UserLabel::Structs::LabelStruct::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::UserLabel::Structs::LabelStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LabelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LabelList
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::UserLabel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LabelList::TypeInfo::DecodableType labelList;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace UserLabel
namespace ProxyConfiguration {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ProxyConfiguration
namespace ProxyDiscovery {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyDiscovery::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ProxyDiscovery
namespace ProxyValid {

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ProxyValid::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ProxyValid
namespace BooleanState {

namespace Attributes {

namespace StateValue {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StateValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StateValue
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::StateValue::TypeInfo::DecodableType stateValue;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace StateChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kStateValue = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

    bool stateValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::BooleanState::Id; }

    bool stateValue;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace StateChange
} // namespace Events
} // namespace BooleanState
namespace ModeSelect {

namespace Structs {
namespace ModeOptionStruct {
enum class Fields
{
    kLabel       = 1,
    kMode        = 2,
    kSemanticTag = 3,
};

struct Type
{
public:
    chip::CharSpan label;
    uint8_t mode;
    uint32_t semanticTag;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ModeOptionStruct
namespace SemanticTag {
enum class Fields
{
    kMfgCode = 1,
    kValue   = 2,
};

struct Type
{
public:
    uint16_t mfgCode;
    uint16_t value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SemanticTag
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeToMode {
struct Type;
struct DecodableType;
} // namespace ChangeToMode

} // namespace Commands

namespace Commands {
namespace ChangeToMode {
enum class Fields
{
    kNewMode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

    uint8_t newMode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeToMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

    uint8_t newMode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeToMode
} // namespace Commands

namespace Attributes {

namespace CurrentMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMode
namespace SupportedModes {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::ModeSelect::Structs::ModeOptionStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedModes
namespace OnMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OnMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OnMode
namespace StartUpMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpMode
namespace Description {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Description::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Description
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ModeSelect::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentMode::TypeInfo::DecodableType currentMode;
        Attributes::SupportedModes::TypeInfo::DecodableType supportedModes;
        Attributes::OnMode::TypeInfo::DecodableType onMode;
        Attributes::StartUpMode::TypeInfo::DecodableType startUpMode;
        Attributes::Description::TypeInfo::DecodableType description;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ModeSelect
namespace ShadeConfiguration {

namespace Attributes {

namespace PhysicalClosedLimit {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimit
namespace MotorStepSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MotorStepSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MotorStepSize
namespace Status {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Status::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Status
namespace ClosedLimit {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClosedLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClosedLimit
namespace Mode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mode
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ShadeConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhysicalClosedLimit::TypeInfo::DecodableType physicalClosedLimit;
        Attributes::MotorStepSize::TypeInfo::DecodableType motorStepSize;
        Attributes::Status::TypeInfo::DecodableType status;
        Attributes::ClosedLimit::TypeInfo::DecodableType closedLimit;
        Attributes::Mode::TypeInfo::DecodableType mode;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ShadeConfiguration
namespace DoorLock {
// Enum for DlAlarmCode
enum class DlAlarmCode : uint8_t
{
    kLockJammed              = 0x00,
    kLockFactoryReset        = 0x01,
    kLockRadioPowerCycled    = 0x03,
    kWrongCodeEntryLimit     = 0x04,
    kFrontEsceutcheonRemoved = 0x05,
    kDoorForcedOpen          = 0x06,
    kDoorAjar                = 0x07,
    kForcedUser              = 0x08,
};
// Enum for DlCredentialRule
enum class DlCredentialRule : uint8_t
{
    kSingle = 0x00,
    kDouble = 0x01,
    kTri    = 0x02,
};
// Enum for DlCredentialType
enum class DlCredentialType : uint8_t
{
    kProgrammingPIN = 0x00,
    kPin            = 0x01,
    kRfid           = 0x02,
    kFingerprint    = 0x03,
    kFingerVein     = 0x04,
    kFace           = 0x05,
};
// Enum for DlDataOperationType
enum class DlDataOperationType : uint8_t
{
    kAdd    = 0x00,
    kClear  = 0x01,
    kModify = 0x02,
};
// Enum for DlDoorLockStatus
enum class DlDoorLockStatus : uint8_t
{
    kDuplicate = 0x02,
    kOccupied  = 0x03,
};
// Enum for DlDoorState
enum class DlDoorState : uint8_t
{
    kDoorOpen             = 0x00,
    kDoorClosed           = 0x01,
    kDoorJammed           = 0x02,
    kDoorForcedOpen       = 0x03,
    kDoorUnspecifiedError = 0x04,
    kDoorAjar             = 0x05,
};
// Enum for DlLockDataType
enum class DlLockDataType : uint8_t
{
    kUnspecified     = 0x00,
    kProgrammingCode = 0x01,
    kUserIndex       = 0x02,
    kWeekDaySchedule = 0x03,
    kYearDaySchedule = 0x04,
    kHolidaySchedule = 0x05,
    kPin             = 0x06,
    kRfid            = 0x07,
    kFingerprint     = 0x08,
};
// Enum for DlLockOperationType
enum class DlLockOperationType : uint8_t
{
    kLock               = 0x00,
    kUnlock             = 0x01,
    kNonAccessUserEvent = 0x02,
    kForcedUserEvent    = 0x03,
};
// Enum for DlLockState
enum class DlLockState : uint8_t
{
    kNotFullyLocked = 0x00,
    kLocked         = 0x01,
    kUnlocked       = 0x02,
};
// Enum for DlLockType
enum class DlLockType : uint8_t
{
    kDeadBolt           = 0x00,
    kMagnetic           = 0x01,
    kOther              = 0x02,
    kMortise            = 0x03,
    kRim                = 0x04,
    kLatchBolt          = 0x05,
    kCylindricalLock    = 0x06,
    kTubularLock        = 0x07,
    kInterconnectedLock = 0x08,
    kDeadLatch          = 0x09,
    kDoorFurniture      = 0x0A,
};
// Enum for DlOperatingMode
enum class DlOperatingMode : uint8_t
{
    kNormal             = 0x00,
    kVacation           = 0x01,
    kPrivacy            = 0x02,
    kNoRemoteLockUnlock = 0x03,
    kPassage            = 0x04,
};
// Enum for DlOperationError
enum class DlOperationError : uint8_t
{
    kUnspecified         = 0x00,
    kInvalidCredential   = 0x01,
    kDisabledUserDenied  = 0x02,
    kRestricted          = 0x03,
    kInsufficientBattery = 0x04,
};
// Enum for DlOperationSource
enum class DlOperationSource : uint8_t
{
    kUnspecified       = 0x00,
    kManual            = 0x01,
    kProprietaryRemote = 0x02,
    kKeypad            = 0x03,
    kAuto              = 0x04,
    kButton            = 0x05,
    kSchedule          = 0x06,
    kRemote            = 0x07,
    kRfid              = 0x08,
    kBiometric         = 0x09,
};
// Enum for DlStatus
enum class DlStatus : uint8_t
{
    kSuccess      = 0x00,
    kFailure      = 0x01,
    kDuplicate    = 0x02,
    kOccupied     = 0x03,
    kInvalidField = 0x85,
    kNotFound     = 0x8B,
};
// Enum for DlUserStatus
enum class DlUserStatus : uint8_t
{
    kAvailable        = 0x00,
    kOccupiedEnabled  = 0x01,
    kOccupiedDisabled = 0x03,
};
// Enum for DlUserType
enum class DlUserType : uint8_t
{
    kUnrestrictedUser       = 0x00,
    kYearDayScheduleUser    = 0x01,
    kWeekDayScheduleUser    = 0x02,
    kProgrammingUser        = 0x03,
    kNonAccessUser          = 0x04,
    kForcedUser             = 0x05,
    kDisposableUser         = 0x06,
    kExpiringUser           = 0x07,
    kScheduleRestrictedUser = 0x08,
    kRemoteOnlyUser         = 0x09,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockOperationEventCode
enum class DoorLockOperationEventCode : uint8_t
{
    kUnknownOrMfgSpecific  = 0x00,
    kLock                  = 0x01,
    kUnlock                = 0x02,
    kLockInvalidPinOrId    = 0x03,
    kLockInvalidSchedule   = 0x04,
    kUnlockInvalidPinOrId  = 0x05,
    kUnlockInvalidSchedule = 0x06,
    kOneTouchLock          = 0x07,
    kKeyLock               = 0x08,
    kKeyUnlock             = 0x09,
    kAutoLock              = 0x0A,
    kScheduleLock          = 0x0B,
    kScheduleUnlock        = 0x0C,
    kManualLock            = 0x0D,
    kManualUnlock          = 0x0E,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockOperationEventCode      = EmberAfDoorLockOperationEventCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockProgrammingEventCode
enum class DoorLockProgrammingEventCode : uint8_t
{
    kUnknownOrMfgSpecific = 0x00,
    kMasterCodeChanged    = 0x01,
    kPinAdded             = 0x02,
    kPinDeleted           = 0x03,
    kPinChanged           = 0x04,
    kIdAdded              = 0x05,
    kIdDeleted            = 0x06,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockProgrammingEventCode    = EmberAfDoorLockProgrammingEventCode;
#endif
// Enum for DoorLockSetPinOrIdStatus
enum class DoorLockSetPinOrIdStatus : uint8_t
{
    kSuccess            = 0x00,
    kGeneralFailure     = 0x01,
    kMemoryFull         = 0x02,
    kDuplicateCodeError = 0x03,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockUserStatus
enum class DoorLockUserStatus : uint8_t
{
    kAvailable        = 0x00,
    kOccupiedEnabled  = 0x01,
    kOccupiedDisabled = 0x03,
    kNotSupported     = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockUserStatus              = EmberAfDoorLockUserStatus;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for DoorLockUserType
enum class DoorLockUserType : uint8_t
{
    kUnrestricted        = 0x00,
    kYearDayScheduleUser = 0x01,
    kWeekDayScheduleUser = 0x02,
    kMasterUser          = 0x03,
    kNonAccessUser       = 0x04,
    kNotSupported        = 0xFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using DoorLockUserType                = EmberAfDoorLockUserType;
#endif

// Bitmap for DlAlarmMask
enum class DlAlarmMask : uint16_t
{
    kLockingMechanismJammed                 = 0x1,
    kLockResetToFactoryDefaults             = 0x2,
    kReserved                               = 0x4,
    kRFModulePowerCycled                    = 0x8,
    kWrongCodeEntryLimit                    = 0x10,
    kFrontEscutcheonRemovedFromMain         = 0x20,
    kForcedDoorOpenUnderDoorLockedCondition = 0x40,
};

// Bitmap for DlCredentialRulesSupport
enum class DlCredentialRulesSupport : uint8_t
{
    kSingle = 0x1,
    kDual   = 0x2,
    kTri    = 0x4,
};

// Bitmap for DlDaysMaskMap
enum class DlDaysMaskMap : uint8_t
{
    kSunday    = 0x1,
    kMonday    = 0x2,
    kTuesday   = 0x4,
    kWednesday = 0x8,
    kThursday  = 0x10,
    kFriday    = 0x20,
    kSaturday  = 0x40,
};

// Bitmap for DlDefaultConfigurationRegister
enum class DlDefaultConfigurationRegister : uint16_t
{
    kEnableLocalProgrammingEnabled         = 0x1,
    kKeypadInterfaceDefaultAccessEnabled   = 0x2,
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4,
    kSoundEnabled                          = 0x20,
    kAutoRelockTimeSet                     = 0x40,
    kLEDSettingsSet                        = 0x80,
};

// Bitmap for DlKeypadOperationEventMask
enum class DlKeypadOperationEventMask : uint16_t
{
    kUnknown               = 0x1,
    kLock                  = 0x2,
    kUnlock                = 0x4,
    kLockInvalidPIN        = 0x8,
    kLockInvalidSchedule   = 0x10,
    kUnlockInvalidCode     = 0x20,
    kUnlockInvalidSchedule = 0x40,
    kNonAccessUserOpEvent  = 0x80,
};

// Bitmap for DlKeypadProgrammingEventMask
enum class DlKeypadProgrammingEventMask : uint16_t
{
    kUnknown               = 0x1,
    kProgrammingPINChanged = 0x2,
    kPINAdded              = 0x4,
    kPINCleared            = 0x8,
    kPINChanged            = 0x10,
};

// Bitmap for DlLocalProgrammingFeatures
enum class DlLocalProgrammingFeatures : uint8_t
{
    kAddUsersCredentialsSchedulesLocally    = 0x1,
    kModifyUsersCredentialsSchedulesLocally = 0x2,
    kClearUsersCredentialsSchedulesLocally  = 0x4,
    kAdjustLockSettingsLocally              = 0x8,
};

// Bitmap for DlManualOperationEventMask
enum class DlManualOperationEventMask : uint16_t
{
    kUnknown         = 0x1,
    kThumbturnLock   = 0x2,
    kThumbturnUnlock = 0x4,
    kOneTouchLock    = 0x8,
    kKeyLock         = 0x10,
    kKeyUnlock       = 0x20,
    kAutoLock        = 0x40,
    kScheduleLock    = 0x80,
    kScheduleUnlock  = 0x100,
    kManualLock      = 0x200,
    kManualUnlock    = 0x400,
};

// Bitmap for DlRFIDOperationEventMask
enum class DlRFIDOperationEventMask : uint16_t
{
    kUnknown               = 0x1,
    kLock                  = 0x2,
    kUnlock                = 0x4,
    kLockInvalidRFID       = 0x8,
    kLockInvalidSchedule   = 0x10,
    kUnlockInvalidRFID     = 0x20,
    kUnlockInvalidSchedule = 0x40,
};

// Bitmap for DlRFIDProgrammingEventMask
enum class DlRFIDProgrammingEventMask : uint16_t
{
    kUnknown         = 0x1,
    kRFIDCodeAdded   = 0x20,
    kRFIDCodeCleared = 0x40,
};

// Bitmap for DlRemoteOperationEventMask
enum class DlRemoteOperationEventMask : uint16_t
{
    kUnknown               = 0x1,
    kLock                  = 0x2,
    kUnlock                = 0x4,
    kLockInvalidCode       = 0x8,
    kLockInvalidSchedule   = 0x10,
    kUnlockInvalidCode     = 0x20,
    kUnlockInvalidSchedule = 0x40,
};

// Bitmap for DlRemoteProgrammingEventMask
enum class DlRemoteProgrammingEventMask : uint16_t
{
    kUnknown               = 0x1,
    kProgrammingPINChanged = 0x2,
    kPINAdded              = 0x4,
    kPINCleared            = 0x8,
    kPINChanged            = 0x10,
    kRFIDCodeAdded         = 0x20,
    kRFIDCodeCleared       = 0x40,
};

// Bitmap for DlSupportedOperatingModes
enum class DlSupportedOperatingModes : uint16_t
{
    kNormal             = 0x1,
    kVacation           = 0x2,
    kPrivacy            = 0x4,
    kNoRemoteLockUnlock = 0x8,
    kPassage            = 0x10,
};

// Bitmap for DoorLockDayOfWeek
enum class DoorLockDayOfWeek : uint8_t
{
    kSunday    = 0x1,
    kMonday    = 0x2,
    kTuesday   = 0x4,
    kWednesday = 0x8,
    kThursday  = 0x10,
    kFriday    = 0x20,
    kSaturday  = 0x40,
};

namespace Structs {
namespace DlCredential {
enum class Fields
{
    kCredentialType  = 1,
    kCredentialIndex = 2,
};

struct Type
{
public:
    DlCredentialType credentialType;
    uint16_t credentialIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace DlCredential
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LockDoor {
struct Type;
struct DecodableType;
} // namespace LockDoor

namespace UnlockDoor {
struct Type;
struct DecodableType;
} // namespace UnlockDoor

namespace UnlockWithTimeout {
struct Type;
struct DecodableType;
} // namespace UnlockWithTimeout

namespace GetLogRecord {
struct Type;
struct DecodableType;
} // namespace GetLogRecord

namespace GetLogRecordResponse {
struct Type;
struct DecodableType;
} // namespace GetLogRecordResponse

namespace SetPINCode {
struct Type;
struct DecodableType;
} // namespace SetPINCode

namespace GetPINCode {
struct Type;
struct DecodableType;
} // namespace GetPINCode

namespace GetPINCodeResponse {
struct Type;
struct DecodableType;
} // namespace GetPINCodeResponse

namespace ClearPINCode {
struct Type;
struct DecodableType;
} // namespace ClearPINCode

namespace ClearAllPINCodes {
struct Type;
struct DecodableType;
} // namespace ClearAllPINCodes

namespace SetUserStatus {
struct Type;
struct DecodableType;
} // namespace SetUserStatus

namespace GetUserStatus {
struct Type;
struct DecodableType;
} // namespace GetUserStatus

namespace GetUserStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetUserStatusResponse

namespace SetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeekDaySchedule

namespace GetWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeekDaySchedule

namespace GetWeekDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeekDayScheduleResponse

namespace ClearWeekDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeekDaySchedule

namespace SetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace SetYearDaySchedule

namespace GetYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace GetYearDaySchedule

namespace GetYearDayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetYearDayScheduleResponse

namespace ClearYearDaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearYearDaySchedule

namespace SetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace SetHolidaySchedule

namespace GetHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace GetHolidaySchedule

namespace GetHolidayScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetHolidayScheduleResponse

namespace ClearHolidaySchedule {
struct Type;
struct DecodableType;
} // namespace ClearHolidaySchedule

namespace SetUserType {
struct Type;
struct DecodableType;
} // namespace SetUserType

namespace GetUserType {
struct Type;
struct DecodableType;
} // namespace GetUserType

namespace GetUserTypeResponse {
struct Type;
struct DecodableType;
} // namespace GetUserTypeResponse

namespace SetRFIDCode {
struct Type;
struct DecodableType;
} // namespace SetRFIDCode

namespace GetRFIDCode {
struct Type;
struct DecodableType;
} // namespace GetRFIDCode

namespace GetRFIDCodeResponse {
struct Type;
struct DecodableType;
} // namespace GetRFIDCodeResponse

namespace ClearRFIDCode {
struct Type;
struct DecodableType;
} // namespace ClearRFIDCode

namespace ClearAllRFIDCodes {
struct Type;
struct DecodableType;
} // namespace ClearAllRFIDCodes

namespace SetUser {
struct Type;
struct DecodableType;
} // namespace SetUser

namespace GetUser {
struct Type;
struct DecodableType;
} // namespace GetUser

namespace GetUserResponse {
struct Type;
struct DecodableType;
} // namespace GetUserResponse

namespace ClearUser {
struct Type;
struct DecodableType;
} // namespace ClearUser

namespace OperatingEventNotification {
struct Type;
struct DecodableType;
} // namespace OperatingEventNotification

namespace ProgrammingEventNotification {
struct Type;
struct DecodableType;
} // namespace ProgrammingEventNotification

namespace SetCredential {
struct Type;
struct DecodableType;
} // namespace SetCredential

namespace SetCredentialResponse {
struct Type;
struct DecodableType;
} // namespace SetCredentialResponse

namespace GetCredentialStatus {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatus

namespace GetCredentialStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetCredentialStatusResponse

namespace ClearCredential {
struct Type;
struct DecodableType;
} // namespace ClearCredential

} // namespace Commands

namespace Commands {
namespace LockDoor {
enum class Fields
{
    kPinCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> pinCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> pinCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LockDoor
namespace UnlockDoor {
enum class Fields
{
    kPinCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> pinCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockDoor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Optional<chip::ByteSpan> pinCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockDoor
namespace UnlockWithTimeout {
enum class Fields
{
    kTimeout = 0,
    kPinCode = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout;
    Optional<chip::ByteSpan> pinCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UnlockWithTimeout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t timeout;
    Optional<chip::ByteSpan> pinCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UnlockWithTimeout
namespace GetLogRecord {
enum class Fields
{
    kLogIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetLogRecord::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t logIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetLogRecordResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetLogRecord::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t logIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLogRecord
namespace GetLogRecordResponse {
enum class Fields
{
    kLogEntryId         = 0,
    kTimestamp          = 1,
    kEventType          = 2,
    kSource             = 3,
    kEventIdOrAlarmCode = 4,
    kUserId             = 5,
    kPin                = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetLogRecordResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t logEntryId;
    uint32_t timestamp;
    uint8_t eventType;
    uint8_t source;
    uint8_t eventIdOrAlarmCode;
    uint16_t userId;
    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetLogRecordResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t logEntryId;
    uint32_t timestamp;
    uint8_t eventType;
    uint8_t source;
    uint8_t eventIdOrAlarmCode;
    uint16_t userId;
    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLogRecordResponse
namespace SetPINCode {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kPin        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetPINCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;
    DlUserType userType;
    chip::ByteSpan pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetPINCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;
    DlUserType userType;
    chip::ByteSpan pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetPINCode
namespace GetPINCode {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPINCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetPINCodeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPINCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPINCode
namespace GetPINCodeResponse {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kPin        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPINCodeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DataModel::Nullable<DlUserStatus> userStatus;
    DataModel::Nullable<DlUserType> userType;
    DataModel::Nullable<chip::ByteSpan> pin;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPINCodeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DataModel::Nullable<DlUserStatus> userStatus;
    DataModel::Nullable<DlUserType> userType;
    DataModel::Nullable<chip::ByteSpan> pin;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPINCodeResponse
namespace ClearPINCode {
enum class Fields
{
    kPinSlotIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearPINCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t pinSlotIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearPINCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t pinSlotIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearPINCode
namespace ClearAllPINCodes {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearAllPINCodes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearAllPINCodes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAllPINCodes
namespace SetUserStatus {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUserStatus
namespace GetUserStatus {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetUserStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserStatus
namespace GetUserStatusResponse {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserStatusResponse
namespace SetWeekDaySchedule {
enum class Fields
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kDaysMask     = 2,
    kStartHour    = 3,
    kStartMinute  = 4,
    kEndHour      = 5,
    kEndMinute    = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;
    chip::BitFlags<DlDaysMaskMap> daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;
    chip::BitFlags<DlDaysMaskMap> daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeekDaySchedule
namespace GetWeekDaySchedule {
enum class Fields
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetWeekDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDaySchedule
namespace GetWeekDayScheduleResponse {
enum class Fields
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
    kStatus       = 2,
    kDaysMask     = 3,
    kStartHour    = 4,
    kStartMinute  = 5,
    kEndHour      = 6,
    kEndMinute    = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;
    DlStatus status;
    chip::BitFlags<DlDaysMaskMap> daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeekDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;
    DlStatus status;
    chip::BitFlags<DlDaysMaskMap> daysMask;
    uint8_t startHour;
    uint8_t startMinute;
    uint8_t endHour;
    uint8_t endMinute;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeekDayScheduleResponse
namespace ClearWeekDaySchedule {
enum class Fields
{
    kWeekDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeekDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t weekDayIndex;
    uint16_t userIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeekDaySchedule
namespace SetYearDaySchedule {
enum class Fields
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;
    uint32_t localStartTime;
    uint32_t localEndTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;
    uint32_t localStartTime;
    uint32_t localEndTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetYearDaySchedule
namespace GetYearDaySchedule {
enum class Fields
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetYearDayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDaySchedule
namespace GetYearDayScheduleResponse {
enum class Fields
{
    kYearDayIndex   = 0,
    kUserIndex      = 1,
    kStatus         = 2,
    kLocalStartTime = 3,
    kLocalEndTime   = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;
    DlStatus status;
    uint32_t localStartTime;
    uint32_t localEndTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetYearDayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;
    DlStatus status;
    uint32_t localStartTime;
    uint32_t localEndTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetYearDayScheduleResponse
namespace ClearYearDaySchedule {
enum class Fields
{
    kYearDayIndex = 0,
    kUserIndex    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearYearDaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t yearDayIndex;
    uint16_t userIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearYearDaySchedule
namespace SetHolidaySchedule {
enum class Fields
{
    kHolidayIndex   = 0,
    kLocalStartTime = 1,
    kLocalEndTime   = 2,
    kOperatingMode  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;
    uint32_t localStartTime;
    uint32_t localEndTime;
    DlOperatingMode operatingMode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;
    uint32_t localStartTime;
    uint32_t localEndTime;
    DlOperatingMode operatingMode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetHolidaySchedule
namespace GetHolidaySchedule {
enum class Fields
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetHolidayScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidaySchedule
namespace GetHolidayScheduleResponse {
enum class Fields
{
    kHolidayIndex   = 0,
    kStatus         = 1,
    kLocalStartTime = 2,
    kLocalEndTime   = 3,
    kOperatingMode  = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;
    DlStatus status;
    uint32_t localStartTime;
    uint32_t localEndTime;
    DlOperatingMode operatingMode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetHolidayScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;
    DlStatus status;
    uint32_t localStartTime;
    uint32_t localEndTime;
    DlOperatingMode operatingMode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetHolidayScheduleResponse
namespace ClearHolidaySchedule {
enum class Fields
{
    kHolidayIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearHolidaySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t holidayIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearHolidaySchedule
namespace SetUserType {
enum class Fields
{
    kUserId   = 0,
    kUserType = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserType userType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserType userType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUserType
namespace GetUserType {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetUserTypeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserType::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserType
namespace GetUserTypeResponse {
enum class Fields
{
    kUserId   = 0,
    kUserType = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserTypeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserType userType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserTypeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserType userType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserTypeResponse
namespace SetRFIDCode {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kRfidCode   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetRFIDCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;
    DlUserType userType;
    chip::ByteSpan rfidCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetRFIDCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DlUserStatus userStatus;
    DlUserType userType;
    chip::ByteSpan rfidCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetRFIDCode
namespace GetRFIDCode {
enum class Fields
{
    kUserId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetRFIDCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetRFIDCodeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetRFIDCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRFIDCode
namespace GetRFIDCodeResponse {
enum class Fields
{
    kUserId     = 0,
    kUserStatus = 1,
    kUserType   = 2,
    kRfidCode   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetRFIDCodeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DataModel::Nullable<DlUserStatus> userStatus;
    DataModel::Nullable<DlUserType> userType;
    DataModel::Nullable<chip::ByteSpan> rfidCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetRFIDCodeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userId;
    DataModel::Nullable<DlUserStatus> userStatus;
    DataModel::Nullable<DlUserType> userType;
    DataModel::Nullable<chip::ByteSpan> rfidCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRFIDCodeResponse
namespace ClearRFIDCode {
enum class Fields
{
    kRfidSlotIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearRFIDCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t rfidSlotIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearRFIDCode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t rfidSlotIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearRFIDCode
namespace ClearAllRFIDCodes {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearAllRFIDCodes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearAllRFIDCodes::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearAllRFIDCodes
namespace SetUser {
enum class Fields
{
    kOperationType  = 0,
    kUserIndex      = 1,
    kUserName       = 2,
    kUserUniqueId   = 3,
    kUserStatus     = 4,
    kUserType       = 5,
    kCredentialRule = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlDataOperationType operationType;
    uint16_t userIndex;
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueId;
    DlUserStatus userStatus;
    DlUserType userType;
    DlCredentialRule credentialRule;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlDataOperationType operationType;
    uint16_t userIndex;
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueId;
    DlUserStatus userStatus;
    DlUserType userType;
    DlCredentialRule credentialRule;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetUser
namespace GetUser {
enum class Fields
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetUserResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUser
namespace GetUserResponse {
enum class Fields
{
    kUserIndex               = 0,
    kUserName                = 1,
    kUserUniqueId            = 2,
    kUserStatus              = 3,
    kUserType                = 4,
    kCredentialRule          = 5,
    kCredentials             = 6,
    kCreatorFabricIndex      = 7,
    kLastModifiedFabricIndex = 8,
    kNextUserIndex           = 9,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex;
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueId;
    DataModel::Nullable<DlUserStatus> userStatus;
    DataModel::Nullable<DlUserType> userType;
    DataModel::Nullable<DlCredentialRule> credentialRule;
    DataModel::Nullable<DataModel::List<const Structs::DlCredential::Type>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    uint16_t nextUserIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetUserResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex;
    DataModel::Nullable<chip::CharSpan> userName;
    DataModel::Nullable<uint32_t> userUniqueId;
    DataModel::Nullable<DlUserStatus> userStatus;
    DataModel::Nullable<DlUserType> userType;
    DataModel::Nullable<DlCredentialRule> credentialRule;
    DataModel::Nullable<DataModel::DecodableList<Structs::DlCredential::DecodableType>> credentials;
    DataModel::Nullable<chip::FabricIndex> creatorFabricIndex;
    DataModel::Nullable<chip::FabricIndex> lastModifiedFabricIndex;
    uint16_t nextUserIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetUserResponse
namespace ClearUser {
enum class Fields
{
    kUserIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearUser::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint16_t userIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearUser
namespace OperatingEventNotification {
enum class Fields
{
    kOperationEventSource = 0,
    kOperationEventCode   = 1,
    kUserId               = 2,
    kPin                  = 3,
    kLocalTime            = 4,
    kData                 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::OperatingEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t operationEventSource;
    uint8_t operationEventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    uint32_t localTime;
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::OperatingEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t operationEventSource;
    uint8_t operationEventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    uint32_t localTime;
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace OperatingEventNotification
namespace ProgrammingEventNotification {
enum class Fields
{
    kProgramEventSource = 0,
    kProgramEventCode   = 1,
    kUserId             = 2,
    kPin                = 3,
    kUserType           = 4,
    kUserStatus         = 5,
    kLocalTime          = 6,
    kData               = 7,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ProgrammingEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t programEventSource;
    uint8_t programEventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    DlUserType userType;
    DlUserStatus userStatus;
    uint32_t localTime;
    Optional<chip::CharSpan> data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ProgrammingEventNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    uint8_t programEventSource;
    uint8_t programEventCode;
    uint16_t userId;
    chip::ByteSpan pin;
    DlUserType userType;
    DlUserStatus userStatus;
    uint32_t localTime;
    Optional<chip::CharSpan> data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ProgrammingEventNotification
namespace SetCredential {
enum class Fields
{
    kOperationType  = 0,
    kCredential     = 1,
    kCredentialData = 2,
    kUserIndex      = 3,
    kUserStatus     = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlDataOperationType operationType;
    Structs::DlCredential::Type credential;
    chip::ByteSpan credentialData;
    uint16_t userIndex;
    DlUserStatus userStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::SetCredentialResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlDataOperationType operationType;
    Structs::DlCredential::DecodableType credential;
    chip::ByteSpan credentialData;
    uint16_t userIndex;
    DlUserStatus userStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredential
namespace SetCredentialResponse {
enum class Fields
{
    kStatus              = 0,
    kUserIndex           = 1,
    kNextCredentialIndex = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetCredentialResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlStatus status;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetCredentialResponse
namespace GetCredentialStatus {
enum class Fields
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::DlCredential::Type credential;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::DoorLock::Commands::GetCredentialStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::DlCredential::DecodableType credential;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatus
namespace GetCredentialStatusResponse {
enum class Fields
{
    kCredentialExists    = 0,
    kUserIndex           = 1,
    kNextCredentialIndex = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetCredentialStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    bool credentialExists;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<uint16_t> nextCredentialIndex;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetCredentialStatusResponse
namespace ClearCredential {
enum class Fields
{
    kCredential = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::DlCredential::Type credential;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearCredential::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    Structs::DlCredential::DecodableType credential;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearCredential
} // namespace Commands

namespace Attributes {

namespace LockState {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlLockState> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LockState
namespace LockType {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DoorLock::DlLockType;
    using DecodableType    = chip::app::Clusters::DoorLock::DlLockType;
    using DecodableArgType = chip::app::Clusters::DoorLock::DlLockType;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LockType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LockType
namespace ActuatorEnabled {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActuatorEnabled::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActuatorEnabled
namespace DoorState {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDoorState>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDoorState>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::DoorLock::DlDoorState> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorState
namespace DoorOpenEvents {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorOpenEvents
namespace DoorClosedEvents {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DoorClosedEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DoorClosedEvents
namespace OpenPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OpenPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OpenPeriod
namespace NumberOfLogRecordsSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfLogRecordsSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfLogRecordsSupported
namespace NumberOfTotalUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfTotalUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfTotalUsersSupported
namespace NumberOfPINUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPINUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPINUsersSupported
namespace NumberOfRFIDUsersSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfRFIDUsersSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfRFIDUsersSupported
namespace NumberOfWeekDaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeekDaySchedulesSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfWeekDaySchedulesSupportedPerUser
namespace NumberOfYearDaySchedulesSupportedPerUser {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfYearDaySchedulesSupportedPerUser::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfYearDaySchedulesSupportedPerUser
namespace NumberOfHolidaySchedulesSupported {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfHolidaySchedulesSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfHolidaySchedulesSupported
namespace MaxPINCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPINCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPINCodeLength
namespace MinPINCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinPINCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinPINCodeLength
namespace MaxRFIDCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxRFIDCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxRFIDCodeLength
namespace MinRFIDCodeLength {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinRFIDCodeLength::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinRFIDCodeLength
namespace CredentialRulesSupport {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CredentialRulesSupport::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CredentialRulesSupport
namespace EnableLogging {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableLogging::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableLogging
namespace Language {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Language::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Language
namespace LEDSettings {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LEDSettings::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LEDSettings
namespace AutoRelockTime {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AutoRelockTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AutoRelockTime
namespace SoundVolume {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoundVolume::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoundVolume
namespace OperatingMode {
struct TypeInfo
{
    using Type             = chip::app::Clusters::DoorLock::DlOperatingMode;
    using DecodableType    = chip::app::Clusters::DoorLock::DlOperatingMode;
    using DecodableArgType = chip::app::Clusters::DoorLock::DlOperatingMode;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperatingMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperatingMode
namespace SupportedOperatingModes {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedOperatingModes::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedOperatingModes
namespace DefaultConfigurationRegister {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DefaultConfigurationRegister::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DefaultConfigurationRegister
namespace EnableLocalProgramming {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableLocalProgramming::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableLocalProgramming
namespace EnableOneTouchLocking {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableOneTouchLocking::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableOneTouchLocking
namespace EnableInsideStatusLED {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnableInsideStatusLED::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnableInsideStatusLED
namespace EnablePrivacyModeButton {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnablePrivacyModeButton::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnablePrivacyModeButton
namespace LocalProgrammingFeatures {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalProgrammingFeatures::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalProgrammingFeatures
namespace WrongCodeEntryLimit {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WrongCodeEntryLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WrongCodeEntryLimit
namespace UserCodeTemporaryDisableTime {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UserCodeTemporaryDisableTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UserCodeTemporaryDisableTime
namespace SendPINOverTheAir {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SendPINOverTheAir::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SendPINOverTheAir
namespace RequirePINforRemoteOperation {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RequirePINforRemoteOperation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RequirePINforRemoteOperation
namespace ExpiringUserTimeout {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ExpiringUserTimeout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ExpiringUserTimeout
namespace AlarmMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmMask
namespace KeypadOperationEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadOperationEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace KeypadOperationEventMask
namespace RemoteOperationEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemoteOperationEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemoteOperationEventMask
namespace ManualOperationEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ManualOperationEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ManualOperationEventMask
namespace RFIDOperationEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RFIDOperationEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RFIDOperationEventMask
namespace KeypadProgrammingEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadProgrammingEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace KeypadProgrammingEventMask
namespace RemoteProgrammingEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemoteProgrammingEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemoteProgrammingEventMask
namespace RFIDProgrammingEventMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RFIDProgrammingEventMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RFIDProgrammingEventMask
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LockState::TypeInfo::DecodableType lockState;
        Attributes::LockType::TypeInfo::DecodableType lockType;
        Attributes::ActuatorEnabled::TypeInfo::DecodableType actuatorEnabled;
        Attributes::DoorState::TypeInfo::DecodableType doorState;
        Attributes::DoorOpenEvents::TypeInfo::DecodableType doorOpenEvents;
        Attributes::DoorClosedEvents::TypeInfo::DecodableType doorClosedEvents;
        Attributes::OpenPeriod::TypeInfo::DecodableType openPeriod;
        Attributes::NumberOfLogRecordsSupported::TypeInfo::DecodableType numberOfLogRecordsSupported;
        Attributes::NumberOfTotalUsersSupported::TypeInfo::DecodableType numberOfTotalUsersSupported;
        Attributes::NumberOfPINUsersSupported::TypeInfo::DecodableType numberOfPINUsersSupported;
        Attributes::NumberOfRFIDUsersSupported::TypeInfo::DecodableType numberOfRFIDUsersSupported;
        Attributes::NumberOfWeekDaySchedulesSupportedPerUser::TypeInfo::DecodableType numberOfWeekDaySchedulesSupportedPerUser;
        Attributes::NumberOfYearDaySchedulesSupportedPerUser::TypeInfo::DecodableType numberOfYearDaySchedulesSupportedPerUser;
        Attributes::NumberOfHolidaySchedulesSupported::TypeInfo::DecodableType numberOfHolidaySchedulesSupported;
        Attributes::MaxPINCodeLength::TypeInfo::DecodableType maxPINCodeLength;
        Attributes::MinPINCodeLength::TypeInfo::DecodableType minPINCodeLength;
        Attributes::MaxRFIDCodeLength::TypeInfo::DecodableType maxRFIDCodeLength;
        Attributes::MinRFIDCodeLength::TypeInfo::DecodableType minRFIDCodeLength;
        Attributes::CredentialRulesSupport::TypeInfo::DecodableType credentialRulesSupport;
        Attributes::EnableLogging::TypeInfo::DecodableType enableLogging;
        Attributes::Language::TypeInfo::DecodableType language;
        Attributes::LEDSettings::TypeInfo::DecodableType LEDSettings;
        Attributes::AutoRelockTime::TypeInfo::DecodableType autoRelockTime;
        Attributes::SoundVolume::TypeInfo::DecodableType soundVolume;
        Attributes::OperatingMode::TypeInfo::DecodableType operatingMode;
        Attributes::SupportedOperatingModes::TypeInfo::DecodableType supportedOperatingModes;
        Attributes::DefaultConfigurationRegister::TypeInfo::DecodableType defaultConfigurationRegister;
        Attributes::EnableLocalProgramming::TypeInfo::DecodableType enableLocalProgramming;
        Attributes::EnableOneTouchLocking::TypeInfo::DecodableType enableOneTouchLocking;
        Attributes::EnableInsideStatusLED::TypeInfo::DecodableType enableInsideStatusLED;
        Attributes::EnablePrivacyModeButton::TypeInfo::DecodableType enablePrivacyModeButton;
        Attributes::LocalProgrammingFeatures::TypeInfo::DecodableType localProgrammingFeatures;
        Attributes::WrongCodeEntryLimit::TypeInfo::DecodableType wrongCodeEntryLimit;
        Attributes::UserCodeTemporaryDisableTime::TypeInfo::DecodableType userCodeTemporaryDisableTime;
        Attributes::SendPINOverTheAir::TypeInfo::DecodableType sendPINOverTheAir;
        Attributes::RequirePINforRemoteOperation::TypeInfo::DecodableType requirePINforRemoteOperation;
        Attributes::ExpiringUserTimeout::TypeInfo::DecodableType expiringUserTimeout;
        Attributes::AlarmMask::TypeInfo::DecodableType alarmMask;
        Attributes::KeypadOperationEventMask::TypeInfo::DecodableType keypadOperationEventMask;
        Attributes::RemoteOperationEventMask::TypeInfo::DecodableType remoteOperationEventMask;
        Attributes::ManualOperationEventMask::TypeInfo::DecodableType manualOperationEventMask;
        Attributes::RFIDOperationEventMask::TypeInfo::DecodableType RFIDOperationEventMask;
        Attributes::KeypadProgrammingEventMask::TypeInfo::DecodableType keypadProgrammingEventMask;
        Attributes::RemoteProgrammingEventMask::TypeInfo::DecodableType remoteProgrammingEventMask;
        Attributes::RFIDProgrammingEventMask::TypeInfo::DecodableType RFIDProgrammingEventMask;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace DoorLockAlarm {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
    kAlarmCode = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlAlarmCode alarmCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlAlarmCode alarmCode;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DoorLockAlarm
namespace DoorStateChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kDoorState = 0,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlDoorState doorState;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlDoorState doorState;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DoorStateChange
namespace LockOperation {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
    kLockOperationType = 0,
    kOperationSource   = 1,
    kUserIndex         = 2,
    kFabricIndex       = 3,
    kSourceNode        = 4,
    kCredentials       = 5,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlLockOperationType lockOperationType;
    DlOperationSource operationSource;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::List<const Structs::DlCredential::Type>>> credentials;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlLockOperationType lockOperationType;
    DlOperationSource operationSource;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::DlCredential::DecodableType>>> credentials;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockOperation
namespace LockOperationError {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000003;

enum class Fields
{
    kLockOperationType = 0,
    kOperationSource   = 1,
    kOperationError    = 2,
    kUserIndex         = 3,
    kFabricIndex       = 4,
    kSourceNode        = 5,
    kCredentials       = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlLockOperationType lockOperationType;
    DlOperationSource operationSource;
    DlOperationError operationError;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::List<const Structs::DlCredential::Type>>> credentials;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlLockOperationType lockOperationType;
    DlOperationSource operationSource;
    DlOperationError operationError;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    Optional<DataModel::Nullable<DataModel::DecodableList<Structs::DlCredential::DecodableType>>> credentials;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockOperationError
namespace LockUserChange {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000004;

enum class Fields
{
    kLockDataType      = 0,
    kDataOperationType = 1,
    kOperationSource   = 2,
    kUserIndex         = 3,
    kFabricIndex       = 4,
    kSourceNode        = 5,
    kDataIndex         = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlLockDataType lockDataType;
    DlDataOperationType dataOperationType;
    DlOperationSource operationSource;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    DataModel::Nullable<uint16_t> dataIndex;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::DoorLock::Id; }

    DlLockDataType lockDataType;
    DlDataOperationType dataOperationType;
    DlOperationSource operationSource;
    DataModel::Nullable<uint16_t> userIndex;
    DataModel::Nullable<chip::FabricIndex> fabricIndex;
    DataModel::Nullable<chip::NodeId> sourceNode;
    DataModel::Nullable<uint16_t> dataIndex;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace LockUserChange
} // namespace Events
} // namespace DoorLock
namespace WindowCovering {

// Bitmap for WcConfigStatus
enum class WcConfigStatus : uint8_t
{
    kOperational               = 0x1,
    kOnline                    = 0x2,
    kOpenAndUpCommandsReversed = 0x4,
    kLiftPositionAware         = 0x8,
    kTiltPositionAware         = 0x10,
    kLiftEncoderControlled     = 0x20,
    kTiltEncoderControlled     = 0x40,
};

// Bitmap for WcFeature
enum class WcFeature : uint32_t
{
    kLift              = 0x1,
    kTilt              = 0x2,
    kPositionAwareLift = 0x4,
    kAbsolutePosition  = 0x8,
    kPositionAwareTilt = 0x10,
};

// Bitmap for WcMode
enum class WcMode : uint8_t
{
    kMotorDirectionReversed = 0x1,
    kCalibrationMode        = 0x2,
    kMaintenanceMode        = 0x4,
    kLEDFeedback            = 0x8,
};

// Bitmap for WcOperationalStatus
enum class WcOperationalStatus : uint8_t
{
    kGlobal = 0x3,
    kLift   = 0xC,
    kTilt   = 0x30,
};

// Bitmap for WcSafetyStatus
enum class WcSafetyStatus : uint16_t
{
    kRemoteLockout       = 0x1,
    kTamperDetection     = 0x2,
    kFailedCommunication = 0x4,
    kPositionFailure     = 0x8,
    kThermalProtection   = 0x10,
    kObstacleDetected    = 0x20,
    kPower               = 0x40,
    kStopInput           = 0x80,
    kMotorJammed         = 0x100,
    kHardwareFailure     = 0x200,
    kManualOperation     = 0x400,
    kProtection          = 0x800,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace UpOrOpen {
struct Type;
struct DecodableType;
} // namespace UpOrOpen

namespace DownOrClose {
struct Type;
struct DecodableType;
} // namespace DownOrClose

namespace StopMotion {
struct Type;
struct DecodableType;
} // namespace StopMotion

namespace GoToLiftValue {
struct Type;
struct DecodableType;
} // namespace GoToLiftValue

namespace GoToLiftPercentage {
struct Type;
struct DecodableType;
} // namespace GoToLiftPercentage

namespace GoToTiltValue {
struct Type;
struct DecodableType;
} // namespace GoToTiltValue

namespace GoToTiltPercentage {
struct Type;
struct DecodableType;
} // namespace GoToTiltPercentage

} // namespace Commands

namespace Commands {
namespace UpOrOpen {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::UpOrOpen::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace UpOrOpen
namespace DownOrClose {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DownOrClose::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DownOrClose
namespace StopMotion {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMotion::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMotion
namespace GoToLiftValue {
enum class Fields
{
    kLiftValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t liftValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t liftValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftValue
namespace GoToLiftPercentage {
enum class Fields
{
    kLiftPercentageValue    = 0,
    kLiftPercent100thsValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent liftPercentageValue;
    chip::Percent100ths liftPercent100thsValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToLiftPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent liftPercentageValue;
    chip::Percent100ths liftPercent100thsValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToLiftPercentage
namespace GoToTiltValue {
enum class Fields
{
    kTiltValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t tiltValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltValue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    uint16_t tiltValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltValue
namespace GoToTiltPercentage {
enum class Fields
{
    kTiltPercentageValue    = 0,
    kTiltPercent100thsValue = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent tiltPercentageValue;
    chip::Percent100ths tiltPercent100thsValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GoToTiltPercentage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

    chip::Percent tiltPercentageValue;
    chip::Percent100ths tiltPercent100thsValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GoToTiltPercentage
} // namespace Commands

namespace Attributes {

namespace Type {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Type::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Type
namespace PhysicalClosedLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimitLift
namespace PhysicalClosedLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalClosedLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalClosedLimitTilt
namespace CurrentPositionLift {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLift
namespace CurrentPositionTilt {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTilt
namespace NumberOfActuationsLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfActuationsLift
namespace NumberOfActuationsTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfActuationsTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfActuationsTilt
namespace ConfigStatus {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ConfigStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ConfigStatus
namespace CurrentPositionLiftPercentage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLiftPercentage
namespace CurrentPositionTiltPercentage {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercentage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTiltPercentage
namespace OperationalStatus {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationalStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationalStatus
namespace TargetPositionLiftPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionLiftPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetPositionLiftPercent100ths
namespace TargetPositionTiltPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetPositionTiltPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetPositionTiltPercent100ths
namespace EndProductType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EndProductType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EndProductType
namespace CurrentPositionLiftPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionLiftPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionLiftPercent100ths
namespace CurrentPositionTiltPercent100ths {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::Percent100ths>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::Percent100ths> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentPositionTiltPercent100ths::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentPositionTiltPercent100ths
namespace InstalledOpenLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledOpenLimitLift
namespace InstalledClosedLimitLift {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitLift::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledClosedLimitLift
namespace InstalledOpenLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledOpenLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledOpenLimitTilt
namespace InstalledClosedLimitTilt {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstalledClosedLimitTilt::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstalledClosedLimitTilt
namespace Mode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Mode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Mode
namespace SafetyStatus {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SafetyStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SafetyStatus
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WindowCovering::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Type::TypeInfo::DecodableType type;
        Attributes::PhysicalClosedLimitLift::TypeInfo::DecodableType physicalClosedLimitLift;
        Attributes::PhysicalClosedLimitTilt::TypeInfo::DecodableType physicalClosedLimitTilt;
        Attributes::CurrentPositionLift::TypeInfo::DecodableType currentPositionLift;
        Attributes::CurrentPositionTilt::TypeInfo::DecodableType currentPositionTilt;
        Attributes::NumberOfActuationsLift::TypeInfo::DecodableType numberOfActuationsLift;
        Attributes::NumberOfActuationsTilt::TypeInfo::DecodableType numberOfActuationsTilt;
        Attributes::ConfigStatus::TypeInfo::DecodableType configStatus;
        Attributes::CurrentPositionLiftPercentage::TypeInfo::DecodableType currentPositionLiftPercentage;
        Attributes::CurrentPositionTiltPercentage::TypeInfo::DecodableType currentPositionTiltPercentage;
        Attributes::OperationalStatus::TypeInfo::DecodableType operationalStatus;
        Attributes::TargetPositionLiftPercent100ths::TypeInfo::DecodableType targetPositionLiftPercent100ths;
        Attributes::TargetPositionTiltPercent100ths::TypeInfo::DecodableType targetPositionTiltPercent100ths;
        Attributes::EndProductType::TypeInfo::DecodableType endProductType;
        Attributes::CurrentPositionLiftPercent100ths::TypeInfo::DecodableType currentPositionLiftPercent100ths;
        Attributes::CurrentPositionTiltPercent100ths::TypeInfo::DecodableType currentPositionTiltPercent100ths;
        Attributes::InstalledOpenLimitLift::TypeInfo::DecodableType installedOpenLimitLift;
        Attributes::InstalledClosedLimitLift::TypeInfo::DecodableType installedClosedLimitLift;
        Attributes::InstalledOpenLimitTilt::TypeInfo::DecodableType installedOpenLimitTilt;
        Attributes::InstalledClosedLimitTilt::TypeInfo::DecodableType installedClosedLimitTilt;
        Attributes::Mode::TypeInfo::DecodableType mode;
        Attributes::SafetyStatus::TypeInfo::DecodableType safetyStatus;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace WindowCovering
namespace BarrierControl {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace BarrierControlGoToPercent {
struct Type;
struct DecodableType;
} // namespace BarrierControlGoToPercent

namespace BarrierControlStop {
struct Type;
struct DecodableType;
} // namespace BarrierControlStop

} // namespace Commands

namespace Commands {
namespace BarrierControlGoToPercent {
enum class Fields
{
    kPercentOpen = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlGoToPercent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    uint8_t percentOpen;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlGoToPercent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    uint8_t percentOpen;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BarrierControlGoToPercent
namespace BarrierControlStop {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BarrierControlStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BarrierControlStop
} // namespace Commands

namespace Attributes {

namespace BarrierMovingState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierMovingState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierMovingState
namespace BarrierSafetyStatus {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierSafetyStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierSafetyStatus
namespace BarrierCapabilities {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCapabilities
namespace BarrierOpenEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierOpenEvents
namespace BarrierCloseEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCloseEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCloseEvents
namespace BarrierCommandOpenEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCommandOpenEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCommandOpenEvents
namespace BarrierCommandCloseEvents {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierCommandCloseEvents::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierCommandCloseEvents
namespace BarrierOpenPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierOpenPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierOpenPeriod
namespace BarrierClosePeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierClosePeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierClosePeriod
namespace BarrierPosition {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BarrierPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BarrierPosition
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BarrierControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::BarrierMovingState::TypeInfo::DecodableType barrierMovingState;
        Attributes::BarrierSafetyStatus::TypeInfo::DecodableType barrierSafetyStatus;
        Attributes::BarrierCapabilities::TypeInfo::DecodableType barrierCapabilities;
        Attributes::BarrierOpenEvents::TypeInfo::DecodableType barrierOpenEvents;
        Attributes::BarrierCloseEvents::TypeInfo::DecodableType barrierCloseEvents;
        Attributes::BarrierCommandOpenEvents::TypeInfo::DecodableType barrierCommandOpenEvents;
        Attributes::BarrierCommandCloseEvents::TypeInfo::DecodableType barrierCommandCloseEvents;
        Attributes::BarrierOpenPeriod::TypeInfo::DecodableType barrierOpenPeriod;
        Attributes::BarrierClosePeriod::TypeInfo::DecodableType barrierClosePeriod;
        Attributes::BarrierPosition::TypeInfo::DecodableType barrierPosition;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BarrierControl
namespace PumpConfigurationAndControl {
// Enum for PumpControlMode
enum class PumpControlMode : uint8_t
{
    kConstantSpeed        = 0x00,
    kConstantPressure     = 0x01,
    kProportionalPressure = 0x02,
    kConstantFlow         = 0x03,
    kConstantTemperature  = 0x05,
    kAutomatic            = 0x07,
};
// Enum for PumpOperationMode
enum class PumpOperationMode : uint8_t
{
    kNormal  = 0x00,
    kMinimum = 0x01,
    kMaximum = 0x02,
    kLocal   = 0x03,
};

// Bitmap for PumpStatus
enum class PumpStatus : uint16_t
{
    kDeviceFault       = 0x1,
    kSupplyfault       = 0x2,
    kSpeedLow          = 0x4,
    kSpeedHigh         = 0x8,
    kLocalOverride     = 0x10,
    kRunning           = 0x20,
    kRemotePressure    = 0x40,
    kRemoteFlow        = 0x80,
    kRemoteTemperature = 0x100,
};

namespace Attributes {

namespace MaxPressure {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxPressure
namespace MaxSpeed {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxSpeed
namespace MaxFlow {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxFlow
namespace MinConstPressure {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstPressure
namespace MaxConstPressure {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstPressure
namespace MinCompPressure {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCompPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinCompPressure
namespace MaxCompPressure {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCompPressure::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCompPressure
namespace MinConstSpeed {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstSpeed
namespace MaxConstSpeed {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstSpeed
namespace MinConstFlow {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstFlow
namespace MaxConstFlow {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstFlow::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstFlow
namespace MinConstTemp {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinConstTemp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinConstTemp
namespace MaxConstTemp {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxConstTemp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxConstTemp
namespace PumpStatus {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PumpStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PumpStatus
namespace EffectiveOperationMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveOperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EffectiveOperationMode
namespace EffectiveControlMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EffectiveControlMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EffectiveControlMode
namespace Capacity {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Capacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Capacity
namespace Speed {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Speed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Speed
namespace LifetimeRunningHours {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeRunningHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LifetimeRunningHours
namespace Power {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Power::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Power
namespace LifetimeEnergyConsumed {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LifetimeEnergyConsumed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LifetimeEnergyConsumed
namespace OperationMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OperationMode
namespace ControlMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ControlMode
namespace AlarmMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmMask
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxPressure::TypeInfo::DecodableType maxPressure;
        Attributes::MaxSpeed::TypeInfo::DecodableType maxSpeed;
        Attributes::MaxFlow::TypeInfo::DecodableType maxFlow;
        Attributes::MinConstPressure::TypeInfo::DecodableType minConstPressure;
        Attributes::MaxConstPressure::TypeInfo::DecodableType maxConstPressure;
        Attributes::MinCompPressure::TypeInfo::DecodableType minCompPressure;
        Attributes::MaxCompPressure::TypeInfo::DecodableType maxCompPressure;
        Attributes::MinConstSpeed::TypeInfo::DecodableType minConstSpeed;
        Attributes::MaxConstSpeed::TypeInfo::DecodableType maxConstSpeed;
        Attributes::MinConstFlow::TypeInfo::DecodableType minConstFlow;
        Attributes::MaxConstFlow::TypeInfo::DecodableType maxConstFlow;
        Attributes::MinConstTemp::TypeInfo::DecodableType minConstTemp;
        Attributes::MaxConstTemp::TypeInfo::DecodableType maxConstTemp;
        Attributes::PumpStatus::TypeInfo::DecodableType pumpStatus;
        Attributes::EffectiveOperationMode::TypeInfo::DecodableType effectiveOperationMode;
        Attributes::EffectiveControlMode::TypeInfo::DecodableType effectiveControlMode;
        Attributes::Capacity::TypeInfo::DecodableType capacity;
        Attributes::Speed::TypeInfo::DecodableType speed;
        Attributes::LifetimeRunningHours::TypeInfo::DecodableType lifetimeRunningHours;
        Attributes::Power::TypeInfo::DecodableType power;
        Attributes::LifetimeEnergyConsumed::TypeInfo::DecodableType lifetimeEnergyConsumed;
        Attributes::OperationMode::TypeInfo::DecodableType operationMode;
        Attributes::ControlMode::TypeInfo::DecodableType controlMode;
        Attributes::AlarmMask::TypeInfo::DecodableType alarmMask;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace SupplyVoltageLow {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000000;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SupplyVoltageLow
namespace SupplyVoltageHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SupplyVoltageHigh
namespace PowerMissingPhase {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000002;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PowerMissingPhase
namespace SystemPressureLow {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000003;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SystemPressureLow
namespace SystemPressureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000004;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SystemPressureHigh
namespace DryRunning {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000005;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace DryRunning
namespace MotorTemperatureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000006;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace MotorTemperatureHigh
namespace PumpMotorFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000007;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PumpMotorFatalFailure
namespace ElectronicTemperatureHigh {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000008;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicTemperatureHigh
namespace PumpBlocked {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x00000009;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace PumpBlocked
namespace SensorFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x0000000A;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace SensorFailure
namespace ElectronicNonFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x0000000B;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicNonFatalFailure
namespace ElectronicFatalFailure {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Critical;
static constexpr EventId kEventId             = 0x0000000C;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace ElectronicFatalFailure
namespace GeneralFault {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x0000000D;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace GeneralFault
namespace Leakage {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x0000000E;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace Leakage
namespace AirDetection {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x0000000F;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace AirDetection
namespace TurbineOperation {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000010;

enum class Fields
{
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::PumpConfigurationAndControl::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TurbineOperation
} // namespace Events
} // namespace PumpConfigurationAndControl
namespace Thermostat {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SetpointAdjustMode
enum class SetpointAdjustMode : uint8_t
{
    kHeatSetpoint         = 0x00,
    kCoolSetpoint         = 0x01,
    kHeatAndCoolSetpoints = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SetpointAdjustMode              = EmberAfSetpointAdjustMode;
#endif

// Bitmap for DayOfWeek
enum class DayOfWeek : uint8_t
{
    kSunday         = 0x1,
    kMonday         = 0x2,
    kTuesday        = 0x4,
    kWednesday      = 0x8,
    kThursday       = 0x10,
    kFriday         = 0x20,
    kSaturday       = 0x40,
    kAwayOrVacation = 0x80,
};

// Bitmap for ModeForSequence
enum class ModeForSequence : uint8_t
{
    kHeatSetpointFieldPresent = 0x1,
    kCoolSetpointFieldPresent = 0x2,
};

// Bitmap for ThermostatFeature
enum class ThermostatFeature : uint32_t
{
    kHeating   = 0x1,
    kCooling   = 0x2,
    kOccupancy = 0x4,
    kSchedule  = 0x8,
    kSetback   = 0x10,
    kAutomode  = 0x20,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SetpointRaiseLower {
struct Type;
struct DecodableType;
} // namespace SetpointRaiseLower

namespace GetWeeklyScheduleResponse {
struct Type;
struct DecodableType;
} // namespace GetWeeklyScheduleResponse

namespace SetWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace SetWeeklySchedule

namespace GetRelayStatusLogResponse {
struct Type;
struct DecodableType;
} // namespace GetRelayStatusLogResponse

namespace GetWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace GetWeeklySchedule

namespace ClearWeeklySchedule {
struct Type;
struct DecodableType;
} // namespace ClearWeeklySchedule

namespace GetRelayStatusLog {
struct Type;
struct DecodableType;
} // namespace GetRelayStatusLog

} // namespace Commands

namespace Commands {
namespace SetpointRaiseLower {
enum class Fields
{
    kMode   = 0,
    kAmount = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    SetpointAdjustMode mode;
    int8_t amount;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetpointRaiseLower::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    SetpointAdjustMode mode;
    int8_t amount;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetpointRaiseLower
namespace GetWeeklyScheduleResponse {
enum class Fields
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kPayload                        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklyScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    chip::BitFlags<DayOfWeek> dayOfWeekForSequence;
    chip::BitFlags<ModeForSequence> modeForSequence;
    DataModel::List<const uint8_t> payload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklyScheduleResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    chip::BitFlags<DayOfWeek> dayOfWeekForSequence;
    chip::BitFlags<ModeForSequence> modeForSequence;
    DataModel::DecodableList<uint8_t> payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklyScheduleResponse
namespace SetWeeklySchedule {
enum class Fields
{
    kNumberOfTransitionsForSequence = 0,
    kDayOfWeekForSequence           = 1,
    kModeForSequence                = 2,
    kPayload                        = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    chip::BitFlags<DayOfWeek> dayOfWeekForSequence;
    chip::BitFlags<ModeForSequence> modeForSequence;
    DataModel::List<const uint8_t> payload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint8_t numberOfTransitionsForSequence;
    chip::BitFlags<DayOfWeek> dayOfWeekForSequence;
    chip::BitFlags<ModeForSequence> modeForSequence;
    DataModel::DecodableList<uint8_t> payload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetWeeklySchedule
namespace GetRelayStatusLogResponse {
enum class Fields
{
    kTimeOfDay            = 0,
    kRelayStatus          = 1,
    kLocalTemperature     = 2,
    kHumidityInPercentage = 3,
    kSetpoint             = 4,
    kUnreadEntries        = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetRelayStatusLogResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint16_t timeOfDay;
    uint16_t relayStatus;
    int16_t localTemperature;
    uint8_t humidityInPercentage;
    int16_t setpoint;
    uint16_t unreadEntries;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetRelayStatusLogResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    uint16_t timeOfDay;
    uint16_t relayStatus;
    int16_t localTemperature;
    uint8_t humidityInPercentage;
    int16_t setpoint;
    uint16_t unreadEntries;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRelayStatusLogResponse
namespace GetWeeklySchedule {
enum class Fields
{
    kDaysToReturn = 0,
    kModeToReturn = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitFlags<DayOfWeek> daysToReturn;
    chip::BitFlags<ModeForSequence> modeToReturn;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Thermostat::Commands::GetWeeklyScheduleResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    chip::BitFlags<DayOfWeek> daysToReturn;
    chip::BitFlags<ModeForSequence> modeToReturn;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetWeeklySchedule
namespace ClearWeeklySchedule {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ClearWeeklySchedule::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ClearWeeklySchedule
namespace GetRelayStatusLog {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetRelayStatusLog::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Thermostat::Commands::GetRelayStatusLogResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetRelayStatusLog::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetRelayStatusLog
} // namespace Commands

namespace Attributes {

namespace LocalTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTemperature
namespace OutdoorTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OutdoorTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OutdoorTemperature
namespace Occupancy {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Occupancy
namespace AbsMinHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinHeatSetpointLimit
namespace AbsMaxHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxHeatSetpointLimit
namespace AbsMinCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMinCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMinCoolSetpointLimit
namespace AbsMaxCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AbsMaxCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AbsMaxCoolSetpointLimit
namespace PiCoolingDemand {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PiCoolingDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PiCoolingDemand
namespace PiHeatingDemand {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PiHeatingDemand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PiHeatingDemand
namespace HvacSystemTypeConfiguration {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HvacSystemTypeConfiguration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HvacSystemTypeConfiguration
namespace LocalTemperatureCalibration {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LocalTemperatureCalibration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LocalTemperatureCalibration
namespace OccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedCoolingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedCoolingSetpoint
namespace OccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupiedHeatingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupiedHeatingSetpoint
namespace UnoccupiedCoolingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedCoolingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedCoolingSetpoint
namespace UnoccupiedHeatingSetpoint {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UnoccupiedHeatingSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UnoccupiedHeatingSetpoint
namespace MinHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinHeatSetpointLimit
namespace MaxHeatSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxHeatSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxHeatSetpointLimit
namespace MinCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinCoolSetpointLimit
namespace MaxCoolSetpointLimit {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxCoolSetpointLimit::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxCoolSetpointLimit
namespace MinSetpointDeadBand {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinSetpointDeadBand::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinSetpointDeadBand
namespace RemoteSensing {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemoteSensing::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemoteSensing
namespace ControlSequenceOfOperation {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ControlSequenceOfOperation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ControlSequenceOfOperation
namespace SystemMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SystemMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SystemMode
namespace AlarmMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AlarmMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AlarmMask
namespace ThermostatRunningMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatRunningMode
namespace StartOfWeek {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartOfWeek::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartOfWeek
namespace NumberOfWeeklyTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfWeeklyTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfWeeklyTransitions
namespace NumberOfDailyTransitions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfDailyTransitions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfDailyTransitions
namespace TemperatureSetpointHold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHold
namespace TemperatureSetpointHoldDuration {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureSetpointHoldDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureSetpointHoldDuration
namespace ThermostatProgrammingOperationMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatProgrammingOperationMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatProgrammingOperationMode
namespace ThermostatRunningState {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ThermostatRunningState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ThermostatRunningState
namespace SetpointChangeSource {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSource::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeSource
namespace SetpointChangeAmount {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeAmount::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeAmount
namespace SetpointChangeSourceTimestamp {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SetpointChangeSourceTimestamp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SetpointChangeSourceTimestamp
namespace AcType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcType
namespace AcCapacity {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCapacity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCapacity
namespace AcRefrigerantType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcRefrigerantType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcRefrigerantType
namespace AcCompressor {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCompressor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCompressor
namespace AcErrorCode {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcErrorCode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcErrorCode
namespace AcLouverPosition {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcLouverPosition::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcLouverPosition
namespace AcCoilTemperature {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCoilTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCoilTemperature
namespace AcCapacityFormat {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCapacityFormat::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCapacityFormat
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Thermostat::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LocalTemperature::TypeInfo::DecodableType localTemperature;
        Attributes::OutdoorTemperature::TypeInfo::DecodableType outdoorTemperature;
        Attributes::Occupancy::TypeInfo::DecodableType occupancy;
        Attributes::AbsMinHeatSetpointLimit::TypeInfo::DecodableType absMinHeatSetpointLimit;
        Attributes::AbsMaxHeatSetpointLimit::TypeInfo::DecodableType absMaxHeatSetpointLimit;
        Attributes::AbsMinCoolSetpointLimit::TypeInfo::DecodableType absMinCoolSetpointLimit;
        Attributes::AbsMaxCoolSetpointLimit::TypeInfo::DecodableType absMaxCoolSetpointLimit;
        Attributes::PiCoolingDemand::TypeInfo::DecodableType piCoolingDemand;
        Attributes::PiHeatingDemand::TypeInfo::DecodableType piHeatingDemand;
        Attributes::HvacSystemTypeConfiguration::TypeInfo::DecodableType hvacSystemTypeConfiguration;
        Attributes::LocalTemperatureCalibration::TypeInfo::DecodableType localTemperatureCalibration;
        Attributes::OccupiedCoolingSetpoint::TypeInfo::DecodableType occupiedCoolingSetpoint;
        Attributes::OccupiedHeatingSetpoint::TypeInfo::DecodableType occupiedHeatingSetpoint;
        Attributes::UnoccupiedCoolingSetpoint::TypeInfo::DecodableType unoccupiedCoolingSetpoint;
        Attributes::UnoccupiedHeatingSetpoint::TypeInfo::DecodableType unoccupiedHeatingSetpoint;
        Attributes::MinHeatSetpointLimit::TypeInfo::DecodableType minHeatSetpointLimit;
        Attributes::MaxHeatSetpointLimit::TypeInfo::DecodableType maxHeatSetpointLimit;
        Attributes::MinCoolSetpointLimit::TypeInfo::DecodableType minCoolSetpointLimit;
        Attributes::MaxCoolSetpointLimit::TypeInfo::DecodableType maxCoolSetpointLimit;
        Attributes::MinSetpointDeadBand::TypeInfo::DecodableType minSetpointDeadBand;
        Attributes::RemoteSensing::TypeInfo::DecodableType remoteSensing;
        Attributes::ControlSequenceOfOperation::TypeInfo::DecodableType controlSequenceOfOperation;
        Attributes::SystemMode::TypeInfo::DecodableType systemMode;
        Attributes::AlarmMask::TypeInfo::DecodableType alarmMask;
        Attributes::ThermostatRunningMode::TypeInfo::DecodableType thermostatRunningMode;
        Attributes::StartOfWeek::TypeInfo::DecodableType startOfWeek;
        Attributes::NumberOfWeeklyTransitions::TypeInfo::DecodableType numberOfWeeklyTransitions;
        Attributes::NumberOfDailyTransitions::TypeInfo::DecodableType numberOfDailyTransitions;
        Attributes::TemperatureSetpointHold::TypeInfo::DecodableType temperatureSetpointHold;
        Attributes::TemperatureSetpointHoldDuration::TypeInfo::DecodableType temperatureSetpointHoldDuration;
        Attributes::ThermostatProgrammingOperationMode::TypeInfo::DecodableType thermostatProgrammingOperationMode;
        Attributes::ThermostatRunningState::TypeInfo::DecodableType thermostatRunningState;
        Attributes::SetpointChangeSource::TypeInfo::DecodableType setpointChangeSource;
        Attributes::SetpointChangeAmount::TypeInfo::DecodableType setpointChangeAmount;
        Attributes::SetpointChangeSourceTimestamp::TypeInfo::DecodableType setpointChangeSourceTimestamp;
        Attributes::AcType::TypeInfo::DecodableType acType;
        Attributes::AcCapacity::TypeInfo::DecodableType acCapacity;
        Attributes::AcRefrigerantType::TypeInfo::DecodableType acRefrigerantType;
        Attributes::AcCompressor::TypeInfo::DecodableType acCompressor;
        Attributes::AcErrorCode::TypeInfo::DecodableType acErrorCode;
        Attributes::AcLouverPosition::TypeInfo::DecodableType acLouverPosition;
        Attributes::AcCoilTemperature::TypeInfo::DecodableType acCoilTemperature;
        Attributes::AcCapacityFormat::TypeInfo::DecodableType acCapacityFormat;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Thermostat
namespace FanControl {

namespace Attributes {

namespace FanMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FanMode
namespace FanModeSequence {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FanModeSequence::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FanModeSequence
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FanControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::FanMode::TypeInfo::DecodableType fanMode;
        Attributes::FanModeSequence::TypeInfo::DecodableType fanModeSequence;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace FanControl
namespace DehumidificationControl {

namespace Attributes {

namespace RelativeHumidity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RelativeHumidity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RelativeHumidity
namespace DehumidificationCooling {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationCooling::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DehumidificationCooling
namespace RhDehumidificationSetpoint {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RhDehumidificationSetpoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RhDehumidificationSetpoint
namespace RelativeHumidityMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RelativeHumidityMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RelativeHumidityMode
namespace DehumidificationLockout {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationLockout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DehumidificationLockout
namespace DehumidificationHysteresis {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationHysteresis::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DehumidificationHysteresis
namespace DehumidificationMaxCool {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DehumidificationMaxCool::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DehumidificationMaxCool
namespace RelativeHumidityDisplay {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RelativeHumidityDisplay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RelativeHumidityDisplay
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DehumidificationControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::RelativeHumidity::TypeInfo::DecodableType relativeHumidity;
        Attributes::DehumidificationCooling::TypeInfo::DecodableType dehumidificationCooling;
        Attributes::RhDehumidificationSetpoint::TypeInfo::DecodableType rhDehumidificationSetpoint;
        Attributes::RelativeHumidityMode::TypeInfo::DecodableType relativeHumidityMode;
        Attributes::DehumidificationLockout::TypeInfo::DecodableType dehumidificationLockout;
        Attributes::DehumidificationHysteresis::TypeInfo::DecodableType dehumidificationHysteresis;
        Attributes::DehumidificationMaxCool::TypeInfo::DecodableType dehumidificationMaxCool;
        Attributes::RelativeHumidityDisplay::TypeInfo::DecodableType relativeHumidityDisplay;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace DehumidificationControl
namespace ThermostatUserInterfaceConfiguration {

namespace Attributes {

namespace TemperatureDisplayMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TemperatureDisplayMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TemperatureDisplayMode
namespace KeypadLockout {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::KeypadLockout::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace KeypadLockout
namespace ScheduleProgrammingVisibility {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScheduleProgrammingVisibility::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScheduleProgrammingVisibility
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ThermostatUserInterfaceConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TemperatureDisplayMode::TypeInfo::DecodableType temperatureDisplayMode;
        Attributes::KeypadLockout::TypeInfo::DecodableType keypadLockout;
        Attributes::ScheduleProgrammingVisibility::TypeInfo::DecodableType scheduleProgrammingVisibility;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ThermostatUserInterfaceConfiguration
namespace ColorControl {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ColorLoopAction
enum class ColorLoopAction : uint8_t
{
    kDeactivate                            = 0x00,
    kActivateFromColorLoopStartEnhancedHue = 0x01,
    kActivateFromEnhancedCurrentHue        = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ColorLoopAction                 = EmberAfColorLoopAction;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ColorLoopDirection
enum class ColorLoopDirection : uint8_t
{
    kDecrementHue = 0x00,
    kIncrementHue = 0x01,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ColorLoopDirection              = EmberAfColorLoopDirection;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ColorMode
enum class ColorMode : uint8_t
{
    kCurrentHueAndCurrentSaturation = 0x00,
    kCurrentXAndCurrentY            = 0x01,
    kColorTemperature               = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ColorMode                       = EmberAfColorMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HueDirection
enum class HueDirection : uint8_t
{
    kShortestDistance = 0x00,
    kLongestDistance  = 0x01,
    kUp               = 0x02,
    kDown             = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HueDirection                    = EmberAfHueDirection;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HueMoveMode
enum class HueMoveMode : uint8_t
{
    kStop = 0x00,
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HueMoveMode                     = EmberAfHueMoveMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for HueStepMode
enum class HueStepMode : uint8_t
{
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using HueStepMode                     = EmberAfHueStepMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SaturationMoveMode
enum class SaturationMoveMode : uint8_t
{
    kStop = 0x00,
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SaturationMoveMode              = EmberAfSaturationMoveMode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for SaturationStepMode
enum class SaturationStepMode : uint8_t
{
    kUp   = 0x01,
    kDown = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using SaturationStepMode              = EmberAfSaturationStepMode;
#endif

// Bitmap for ColorCapabilities
enum class ColorCapabilities : uint16_t
{
    kHueSaturationSupported    = 0x1,
    kEnhancedHueSupported      = 0x2,
    kColorLoopSupported        = 0x4,
    kXYAttributesSupported     = 0x8,
    kColorTemperatureSupported = 0x10,
};

// Bitmap for ColorLoopUpdateFlags
enum class ColorLoopUpdateFlags : uint8_t
{
    kUpdateAction    = 0x1,
    kUpdateDirection = 0x2,
    kUpdateTime      = 0x4,
    kUpdateStartHue  = 0x8,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MoveToHue {
struct Type;
struct DecodableType;
} // namespace MoveToHue

namespace MoveHue {
struct Type;
struct DecodableType;
} // namespace MoveHue

namespace StepHue {
struct Type;
struct DecodableType;
} // namespace StepHue

namespace MoveToSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToSaturation

namespace MoveSaturation {
struct Type;
struct DecodableType;
} // namespace MoveSaturation

namespace StepSaturation {
struct Type;
struct DecodableType;
} // namespace StepSaturation

namespace MoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace MoveToHueAndSaturation

namespace MoveToColor {
struct Type;
struct DecodableType;
} // namespace MoveToColor

namespace MoveColor {
struct Type;
struct DecodableType;
} // namespace MoveColor

namespace StepColor {
struct Type;
struct DecodableType;
} // namespace StepColor

namespace MoveToColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveToColorTemperature

namespace EnhancedMoveToHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHue

namespace EnhancedMoveHue {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveHue

namespace EnhancedStepHue {
struct Type;
struct DecodableType;
} // namespace EnhancedStepHue

namespace EnhancedMoveToHueAndSaturation {
struct Type;
struct DecodableType;
} // namespace EnhancedMoveToHueAndSaturation

namespace ColorLoopSet {
struct Type;
struct DecodableType;
} // namespace ColorLoopSet

namespace StopMoveStep {
struct Type;
struct DecodableType;
} // namespace StopMoveStep

namespace MoveColorTemperature {
struct Type;
struct DecodableType;
} // namespace MoveColorTemperature

namespace StepColorTemperature {
struct Type;
struct DecodableType;
} // namespace StepColorTemperature

} // namespace Commands

namespace Commands {
namespace MoveToHue {
enum class Fields
{
    kHue             = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHue
namespace MoveHue {
enum class Fields
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveHue
namespace StepHue {
enum class Fields
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepHue
namespace MoveToSaturation {
enum class Fields
{
    kSaturation      = 0,
    kTransitionTime  = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToSaturation
namespace MoveSaturation {
enum class Fields
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationMoveMode moveMode;
    uint8_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveSaturation
namespace StepSaturation {
enum class Fields
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    SaturationStepMode stepMode;
    uint8_t stepSize;
    uint8_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepSaturation
namespace MoveToHueAndSaturation {
enum class Fields
{
    kHue             = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t hue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToHueAndSaturation
namespace MoveToColor {
enum class Fields
{
    kColorX          = 0,
    kColorY          = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX;
    uint16_t colorY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorX;
    uint16_t colorY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColor
namespace MoveColor {
enum class Fields
{
    kRateX           = 0,
    kRateY           = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX;
    int16_t rateY;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t rateX;
    int16_t rateY;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColor
namespace StepColor {
enum class Fields
{
    kStepX           = 0,
    kStepY           = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX;
    int16_t stepY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColor::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    int16_t stepX;
    int16_t stepY;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColor
namespace MoveToColorTemperature {
enum class Fields
{
    kColorTemperature = 0,
    kTransitionTime   = 1,
    kOptionsMask      = 2,
    kOptionsOverride  = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperature;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveToColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t colorTemperature;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveToColorTemperature
namespace EnhancedMoveToHue {
enum class Fields
{
    kEnhancedHue     = 0,
    kDirection       = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue;
    HueDirection direction;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHue
namespace EnhancedMoveHue {
enum class Fields
{
    kMoveMode        = 0,
    kRate            = 1,
    kOptionsMask     = 2,
    kOptionsOverride = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveHue
namespace EnhancedStepHue {
enum class Fields
{
    kStepMode        = 0,
    kStepSize        = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedStepHue::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedStepHue
namespace EnhancedMoveToHueAndSaturation {
enum class Fields
{
    kEnhancedHue     = 0,
    kSaturation      = 1,
    kTransitionTime  = 2,
    kOptionsMask     = 3,
    kOptionsOverride = 4,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EnhancedMoveToHueAndSaturation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint16_t enhancedHue;
    uint8_t saturation;
    uint16_t transitionTime;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EnhancedMoveToHueAndSaturation
namespace ColorLoopSet {
enum class Fields
{
    kUpdateFlags     = 0,
    kAction          = 1,
    kDirection       = 2,
    kTime            = 3,
    kStartHue        = 4,
    kOptionsMask     = 5,
    kOptionsOverride = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitFlags<ColorLoopUpdateFlags> updateFlags;
    ColorLoopAction action;
    ColorLoopDirection direction;
    uint16_t time;
    uint16_t startHue;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ColorLoopSet::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    chip::BitFlags<ColorLoopUpdateFlags> updateFlags;
    ColorLoopAction action;
    ColorLoopDirection direction;
    uint16_t time;
    uint16_t startHue;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ColorLoopSet
namespace StopMoveStep {
enum class Fields
{
    kOptionsMask     = 0,
    kOptionsOverride = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopMoveStep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopMoveStep
namespace MoveColorTemperature {
enum class Fields
{
    kMoveMode                = 0,
    kRate                    = 1,
    kColorTemperatureMinimum = 2,
    kColorTemperatureMaximum = 3,
    kOptionsMask             = 4,
    kOptionsOverride         = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MoveColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueMoveMode moveMode;
    uint16_t rate;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MoveColorTemperature
namespace StepColorTemperature {
enum class Fields
{
    kStepMode                = 0,
    kStepSize                = 1,
    kTransitionTime          = 2,
    kColorTemperatureMinimum = 3,
    kColorTemperatureMaximum = 4,
    kOptionsMask             = 5,
    kOptionsOverride         = 6,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StepColorTemperature::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

    HueStepMode stepMode;
    uint16_t stepSize;
    uint16_t transitionTime;
    uint16_t colorTemperatureMinimum;
    uint16_t colorTemperatureMaximum;
    uint8_t optionsMask;
    uint8_t optionsOverride;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StepColorTemperature
} // namespace Commands

namespace Attributes {

namespace CurrentHue {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentHue
namespace CurrentSaturation {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentSaturation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentSaturation
namespace RemainingTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RemainingTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RemainingTime
namespace CurrentX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentX
namespace CurrentY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentY
namespace DriftCompensation {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DriftCompensation::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DriftCompensation
namespace CompensationText {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompensationText::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CompensationText
namespace ColorTemperature {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTemperature::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTemperature
namespace ColorMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorMode
namespace ColorControlOptions {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorControlOptions::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorControlOptions
namespace NumberOfPrimaries {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfPrimaries::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfPrimaries
namespace Primary1X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1X
namespace Primary1Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1Y
namespace Primary1Intensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary1Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary1Intensity
namespace Primary2X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2X
namespace Primary2Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2Y
namespace Primary2Intensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary2Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary2Intensity
namespace Primary3X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3X
namespace Primary3Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3Y
namespace Primary3Intensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary3Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary3Intensity
namespace Primary4X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4X
namespace Primary4Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4Y
namespace Primary4Intensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary4Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary4Intensity
namespace Primary5X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5X
namespace Primary5Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5Y
namespace Primary5Intensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary5Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary5Intensity
namespace Primary6X {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6X::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6X
namespace Primary6Y {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Y::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6Y
namespace Primary6Intensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Primary6Intensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Primary6Intensity
namespace WhitePointX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WhitePointX
namespace WhitePointY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WhitePointY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WhitePointY
namespace ColorPointRX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRX
namespace ColorPointRY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRY
namespace ColorPointRIntensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointRIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointRIntensity
namespace ColorPointGX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGX
namespace ColorPointGY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGY
namespace ColorPointGIntensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointGIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointGIntensity
namespace ColorPointBX {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBX::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBX
namespace ColorPointBY {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBY::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBY
namespace ColorPointBIntensity {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorPointBIntensity::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorPointBIntensity
namespace EnhancedCurrentHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedCurrentHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnhancedCurrentHue
namespace EnhancedColorMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnhancedColorMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnhancedColorMode
namespace ColorLoopActive {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopActive::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopActive
namespace ColorLoopDirection {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopDirection::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopDirection
namespace ColorLoopTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopTime
namespace ColorLoopStartEnhancedHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStartEnhancedHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopStartEnhancedHue
namespace ColorLoopStoredEnhancedHue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorLoopStoredEnhancedHue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorLoopStoredEnhancedHue
namespace ColorCapabilities {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorCapabilities::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorCapabilities
namespace ColorTempPhysicalMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTempPhysicalMin
namespace ColorTempPhysicalMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ColorTempPhysicalMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ColorTempPhysicalMax
namespace CoupleColorTempToLevelMinMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CoupleColorTempToLevelMinMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CoupleColorTempToLevelMinMireds
namespace StartUpColorTemperatureMireds {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartUpColorTemperatureMireds::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartUpColorTemperatureMireds
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ColorControl::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CurrentHue::TypeInfo::DecodableType currentHue;
        Attributes::CurrentSaturation::TypeInfo::DecodableType currentSaturation;
        Attributes::RemainingTime::TypeInfo::DecodableType remainingTime;
        Attributes::CurrentX::TypeInfo::DecodableType currentX;
        Attributes::CurrentY::TypeInfo::DecodableType currentY;
        Attributes::DriftCompensation::TypeInfo::DecodableType driftCompensation;
        Attributes::CompensationText::TypeInfo::DecodableType compensationText;
        Attributes::ColorTemperature::TypeInfo::DecodableType colorTemperature;
        Attributes::ColorMode::TypeInfo::DecodableType colorMode;
        Attributes::ColorControlOptions::TypeInfo::DecodableType colorControlOptions;
        Attributes::NumberOfPrimaries::TypeInfo::DecodableType numberOfPrimaries;
        Attributes::Primary1X::TypeInfo::DecodableType primary1X;
        Attributes::Primary1Y::TypeInfo::DecodableType primary1Y;
        Attributes::Primary1Intensity::TypeInfo::DecodableType primary1Intensity;
        Attributes::Primary2X::TypeInfo::DecodableType primary2X;
        Attributes::Primary2Y::TypeInfo::DecodableType primary2Y;
        Attributes::Primary2Intensity::TypeInfo::DecodableType primary2Intensity;
        Attributes::Primary3X::TypeInfo::DecodableType primary3X;
        Attributes::Primary3Y::TypeInfo::DecodableType primary3Y;
        Attributes::Primary3Intensity::TypeInfo::DecodableType primary3Intensity;
        Attributes::Primary4X::TypeInfo::DecodableType primary4X;
        Attributes::Primary4Y::TypeInfo::DecodableType primary4Y;
        Attributes::Primary4Intensity::TypeInfo::DecodableType primary4Intensity;
        Attributes::Primary5X::TypeInfo::DecodableType primary5X;
        Attributes::Primary5Y::TypeInfo::DecodableType primary5Y;
        Attributes::Primary5Intensity::TypeInfo::DecodableType primary5Intensity;
        Attributes::Primary6X::TypeInfo::DecodableType primary6X;
        Attributes::Primary6Y::TypeInfo::DecodableType primary6Y;
        Attributes::Primary6Intensity::TypeInfo::DecodableType primary6Intensity;
        Attributes::WhitePointX::TypeInfo::DecodableType whitePointX;
        Attributes::WhitePointY::TypeInfo::DecodableType whitePointY;
        Attributes::ColorPointRX::TypeInfo::DecodableType colorPointRX;
        Attributes::ColorPointRY::TypeInfo::DecodableType colorPointRY;
        Attributes::ColorPointRIntensity::TypeInfo::DecodableType colorPointRIntensity;
        Attributes::ColorPointGX::TypeInfo::DecodableType colorPointGX;
        Attributes::ColorPointGY::TypeInfo::DecodableType colorPointGY;
        Attributes::ColorPointGIntensity::TypeInfo::DecodableType colorPointGIntensity;
        Attributes::ColorPointBX::TypeInfo::DecodableType colorPointBX;
        Attributes::ColorPointBY::TypeInfo::DecodableType colorPointBY;
        Attributes::ColorPointBIntensity::TypeInfo::DecodableType colorPointBIntensity;
        Attributes::EnhancedCurrentHue::TypeInfo::DecodableType enhancedCurrentHue;
        Attributes::EnhancedColorMode::TypeInfo::DecodableType enhancedColorMode;
        Attributes::ColorLoopActive::TypeInfo::DecodableType colorLoopActive;
        Attributes::ColorLoopDirection::TypeInfo::DecodableType colorLoopDirection;
        Attributes::ColorLoopTime::TypeInfo::DecodableType colorLoopTime;
        Attributes::ColorLoopStartEnhancedHue::TypeInfo::DecodableType colorLoopStartEnhancedHue;
        Attributes::ColorLoopStoredEnhancedHue::TypeInfo::DecodableType colorLoopStoredEnhancedHue;
        Attributes::ColorCapabilities::TypeInfo::DecodableType colorCapabilities;
        Attributes::ColorTempPhysicalMin::TypeInfo::DecodableType colorTempPhysicalMin;
        Attributes::ColorTempPhysicalMax::TypeInfo::DecodableType colorTempPhysicalMax;
        Attributes::CoupleColorTempToLevelMinMireds::TypeInfo::DecodableType coupleColorTempToLevelMinMireds;
        Attributes::StartUpColorTemperatureMireds::TypeInfo::DecodableType startUpColorTemperatureMireds;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ColorControl
namespace BallastConfiguration {

namespace Attributes {

namespace PhysicalMinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalMinLevel
namespace PhysicalMaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalMaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalMaxLevel
namespace BallastStatus {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BallastStatus
namespace MinLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinLevel
namespace MaxLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxLevel
namespace PowerOnLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerOnLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerOnLevel
namespace PowerOnFadeTime {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerOnFadeTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerOnFadeTime
namespace IntrinsicBallastFactor {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IntrinsicBallastFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IntrinsicBallastFactor
namespace BallastFactorAdjustment {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BallastFactorAdjustment::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BallastFactorAdjustment
namespace LampQuality {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampQuality::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampQuality
namespace LampType {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampType
namespace LampManufacturer {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampManufacturer::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampManufacturer
namespace LampRatedHours {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampRatedHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampRatedHours
namespace LampBurnHours {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHours::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampBurnHours
namespace LampAlarmMode {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampAlarmMode::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampAlarmMode
namespace LampBurnHoursTripPoint {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LampBurnHoursTripPoint::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LampBurnHoursTripPoint
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BallastConfiguration::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PhysicalMinLevel::TypeInfo::DecodableType physicalMinLevel;
        Attributes::PhysicalMaxLevel::TypeInfo::DecodableType physicalMaxLevel;
        Attributes::BallastStatus::TypeInfo::DecodableType ballastStatus;
        Attributes::MinLevel::TypeInfo::DecodableType minLevel;
        Attributes::MaxLevel::TypeInfo::DecodableType maxLevel;
        Attributes::PowerOnLevel::TypeInfo::DecodableType powerOnLevel;
        Attributes::PowerOnFadeTime::TypeInfo::DecodableType powerOnFadeTime;
        Attributes::IntrinsicBallastFactor::TypeInfo::DecodableType intrinsicBallastFactor;
        Attributes::BallastFactorAdjustment::TypeInfo::DecodableType ballastFactorAdjustment;
        Attributes::LampQuality::TypeInfo::DecodableType lampQuality;
        Attributes::LampType::TypeInfo::DecodableType lampType;
        Attributes::LampManufacturer::TypeInfo::DecodableType lampManufacturer;
        Attributes::LampRatedHours::TypeInfo::DecodableType lampRatedHours;
        Attributes::LampBurnHours::TypeInfo::DecodableType lampBurnHours;
        Attributes::LampAlarmMode::TypeInfo::DecodableType lampAlarmMode;
        Attributes::LampBurnHoursTripPoint::TypeInfo::DecodableType lampBurnHoursTripPoint;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BallastConfiguration
namespace IlluminanceMeasurement {
// Enum for LightSensorType
enum class LightSensorType : uint8_t
{
    kPhotodiode = 0x00,
    kCmos       = 0x01,
};

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace LightSensorType {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LightSensorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LightSensorType
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IlluminanceMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::LightSensorType::TypeInfo::DecodableType lightSensorType;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace IlluminanceMeasurement
namespace TemperatureMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TemperatureMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace TemperatureMeasurement
namespace PressureMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace ScaledValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScaledValue
namespace MinScaledValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinScaledValue
namespace MaxScaledValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxScaledValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxScaledValue
namespace ScaledTolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ScaledTolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ScaledTolerance
namespace Scale {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Scale::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Scale
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::PressureMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::ScaledValue::TypeInfo::DecodableType scaledValue;
        Attributes::MinScaledValue::TypeInfo::DecodableType minScaledValue;
        Attributes::MaxScaledValue::TypeInfo::DecodableType maxScaledValue;
        Attributes::ScaledTolerance::TypeInfo::DecodableType scaledTolerance;
        Attributes::Scale::TypeInfo::DecodableType scale;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace PressureMeasurement
namespace FlowMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FlowMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace FlowMeasurement
namespace RelativeHumidityMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::RelativeHumidityMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace RelativeHumidityMeasurement
namespace OccupancySensing {

namespace Attributes {

namespace Occupancy {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Occupancy::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Occupancy
namespace OccupancySensorType {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupancySensorType
namespace OccupancySensorTypeBitmap {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OccupancySensorTypeBitmap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OccupancySensorTypeBitmap
namespace PirOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PirOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PirOccupiedToUnoccupiedDelay
namespace PirUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PirUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PirUnoccupiedToOccupiedDelay
namespace PirUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PirUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PirUnoccupiedToOccupiedThreshold
namespace UltrasonicOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicOccupiedToUnoccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicUnoccupiedToOccupiedDelay
namespace UltrasonicUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UltrasonicUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UltrasonicUnoccupiedToOccupiedThreshold
namespace PhysicalContactOccupiedToUnoccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactOccupiedToUnoccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactOccupiedToUnoccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedDelay {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedDelay::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedDelay
namespace PhysicalContactUnoccupiedToOccupiedThreshold {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhysicalContactUnoccupiedToOccupiedThreshold
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OccupancySensing::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Occupancy::TypeInfo::DecodableType occupancy;
        Attributes::OccupancySensorType::TypeInfo::DecodableType occupancySensorType;
        Attributes::OccupancySensorTypeBitmap::TypeInfo::DecodableType occupancySensorTypeBitmap;
        Attributes::PirOccupiedToUnoccupiedDelay::TypeInfo::DecodableType pirOccupiedToUnoccupiedDelay;
        Attributes::PirUnoccupiedToOccupiedDelay::TypeInfo::DecodableType pirUnoccupiedToOccupiedDelay;
        Attributes::PirUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType pirUnoccupiedToOccupiedThreshold;
        Attributes::UltrasonicOccupiedToUnoccupiedDelay::TypeInfo::DecodableType ultrasonicOccupiedToUnoccupiedDelay;
        Attributes::UltrasonicUnoccupiedToOccupiedDelay::TypeInfo::DecodableType ultrasonicUnoccupiedToOccupiedDelay;
        Attributes::UltrasonicUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType ultrasonicUnoccupiedToOccupiedThreshold;
        Attributes::PhysicalContactOccupiedToUnoccupiedDelay::TypeInfo::DecodableType physicalContactOccupiedToUnoccupiedDelay;
        Attributes::PhysicalContactUnoccupiedToOccupiedDelay::TypeInfo::DecodableType physicalContactUnoccupiedToOccupiedDelay;
        Attributes::PhysicalContactUnoccupiedToOccupiedThreshold::TypeInfo::DecodableType
            physicalContactUnoccupiedToOccupiedThreshold;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OccupancySensing
namespace CarbonMonoxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CarbonMonoxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace CarbonMonoxideConcentrationMeasurement
namespace CarbonDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CarbonDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace CarbonDioxideConcentrationMeasurement
namespace EthyleneConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EthyleneConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace EthyleneConcentrationMeasurement
namespace EthyleneOxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::EthyleneOxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace EthyleneOxideConcentrationMeasurement
namespace HydrogenConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::HydrogenConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace HydrogenConcentrationMeasurement
namespace HydrogenSulphideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::HydrogenSulphideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace HydrogenSulphideConcentrationMeasurement
namespace NitricOxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NitricOxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace NitricOxideConcentrationMeasurement
namespace NitrogenDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::NitrogenDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace NitrogenDioxideConcentrationMeasurement
namespace OxygenConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OxygenConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OxygenConcentrationMeasurement
namespace OzoneConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::OzoneConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace OzoneConcentrationMeasurement
namespace SulfurDioxideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SulfurDioxideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace SulfurDioxideConcentrationMeasurement
namespace DissolvedOxygenConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::DissolvedOxygenConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace DissolvedOxygenConcentrationMeasurement
namespace BromateConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BromateConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BromateConcentrationMeasurement
namespace ChloraminesConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ChloraminesConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ChloraminesConcentrationMeasurement
namespace ChlorineConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ChlorineConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ChlorineConcentrationMeasurement
namespace FecalColiformAndEColiConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FecalColiformAndEColiConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace FecalColiformAndEColiConcentrationMeasurement
namespace FluorideConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::FluorideConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace FluorideConcentrationMeasurement
namespace HaloaceticAcidsConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::HaloaceticAcidsConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace HaloaceticAcidsConcentrationMeasurement
namespace TotalTrihalomethanesConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TotalTrihalomethanesConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace TotalTrihalomethanesConcentrationMeasurement
namespace TotalColiformBacteriaConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TotalColiformBacteriaConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace TotalColiformBacteriaConcentrationMeasurement
namespace TurbidityConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TurbidityConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace TurbidityConcentrationMeasurement
namespace CopperConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::CopperConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace CopperConcentrationMeasurement
namespace LeadConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LeadConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace LeadConcentrationMeasurement
namespace ManganeseConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ManganeseConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ManganeseConcentrationMeasurement
namespace SulfateConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SulfateConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace SulfateConcentrationMeasurement
namespace BromodichloromethaneConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BromodichloromethaneConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BromodichloromethaneConcentrationMeasurement
namespace BromoformConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::BromoformConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace BromoformConcentrationMeasurement
namespace ChlorodibromomethaneConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ChlorodibromomethaneConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ChlorodibromomethaneConcentrationMeasurement
namespace ChloroformConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ChloroformConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ChloroformConcentrationMeasurement
namespace SodiumConcentrationMeasurement {

namespace Attributes {

namespace MeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredValue
namespace MinMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MinMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MinMeasuredValue
namespace MaxMeasuredValue {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxMeasuredValue::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxMeasuredValue
namespace Tolerance {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Tolerance::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Tolerance
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::SodiumConcentrationMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasuredValue::TypeInfo::DecodableType measuredValue;
        Attributes::MinMeasuredValue::TypeInfo::DecodableType minMeasuredValue;
        Attributes::MaxMeasuredValue::TypeInfo::DecodableType maxMeasuredValue;
        Attributes::Tolerance::TypeInfo::DecodableType tolerance;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace SodiumConcentrationMeasurement
namespace IasZone {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasEnrollResponseCode
enum class IasEnrollResponseCode : uint8_t
{
    kSuccess        = 0x00,
    kNotSupported   = 0x01,
    kNoEnrollPermit = 0x02,
    kTooManyZones   = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasEnrollResponseCode           = EmberAfIasEnrollResponseCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasZoneType
enum class IasZoneType : uint16_t
{
    kStandardCie             = 0x00,
    kMotionSensor            = 0x0D,
    kContactSwitch           = 0x15,
    kFireSensor              = 0x28,
    kWaterSensor             = 0x2A,
    kGasSensor               = 0x2B,
    kPersonalEmergencyDevice = 0x2C,
    kVibrationMovementSensor = 0x2D,
    kRemoteControl           = 0x10F,
    kKeyFob                  = 0x115,
    kKeypad                  = 0x21D,
    kStandardWarningDevice   = 0x225,
    kGlassBreakSensor        = 0x226,
    kCarbonMonoxideSensor    = 0x227,
    kSecurityRepeater        = 0x229,
    kInvalidZoneType         = 0xFFFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasZoneType                     = EmberAfIasZoneType;
#endif

// Bitmap for IasZoneStatus
enum class IasZoneStatus : uint16_t
{
    kAlarm1             = 0x1,
    kAlarm2             = 0x2,
    kTamper             = 0x4,
    kBattery            = 0x8,
    kSupervisionReports = 0x10,
    kRestoreReports     = 0x20,
    kTrouble            = 0x40,
    kAc                 = 0x80,
    kTest               = 0x100,
    kBatteryDefect      = 0x200,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ZoneEnrollResponse {
struct Type;
struct DecodableType;
} // namespace ZoneEnrollResponse

namespace ZoneStatusChangeNotification {
struct Type;
struct DecodableType;
} // namespace ZoneStatusChangeNotification

namespace InitiateNormalOperationMode {
struct Type;
struct DecodableType;
} // namespace InitiateNormalOperationMode

namespace ZoneEnrollRequest {
struct Type;
struct DecodableType;
} // namespace ZoneEnrollRequest

namespace InitiateTestMode {
struct Type;
struct DecodableType;
} // namespace InitiateTestMode

namespace InitiateNormalOperationModeResponse {
struct Type;
struct DecodableType;
} // namespace InitiateNormalOperationModeResponse

namespace InitiateTestModeResponse {
struct Type;
struct DecodableType;
} // namespace InitiateTestModeResponse

} // namespace Commands

namespace Commands {
namespace ZoneEnrollResponse {
enum class Fields
{
    kEnrollResponseCode = 0,
    kZoneId             = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ZoneEnrollResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    IasEnrollResponseCode enrollResponseCode;
    uint8_t zoneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ZoneEnrollResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    IasEnrollResponseCode enrollResponseCode;
    uint8_t zoneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneEnrollResponse
namespace ZoneStatusChangeNotification {
enum class Fields
{
    kZoneStatus     = 0,
    kExtendedStatus = 1,
    kZoneId         = 2,
    kDelay          = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ZoneStatusChangeNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    chip::BitFlags<IasZoneStatus> zoneStatus;
    uint8_t extendedStatus;
    uint8_t zoneId;
    uint16_t delay;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ZoneStatusChangeNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    chip::BitFlags<IasZoneStatus> zoneStatus;
    uint8_t extendedStatus;
    uint8_t zoneId;
    uint16_t delay;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneStatusChangeNotification
namespace InitiateNormalOperationMode {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InitiateNormalOperationMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasZone::Commands::InitiateNormalOperationModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InitiateNormalOperationMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateNormalOperationMode
namespace ZoneEnrollRequest {
enum class Fields
{
    kZoneType         = 0,
    kManufacturerCode = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ZoneEnrollRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    IasZoneType zoneType;
    uint16_t manufacturerCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasZone::Commands::ZoneEnrollResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ZoneEnrollRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    IasZoneType zoneType;
    uint16_t manufacturerCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneEnrollRequest
namespace InitiateTestMode {
enum class Fields
{
    kTestModeDuration            = 0,
    kCurrentZoneSensitivityLevel = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InitiateTestMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    uint8_t testModeDuration;
    uint8_t currentZoneSensitivityLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasZone::Commands::InitiateTestModeResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InitiateTestMode::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    uint8_t testModeDuration;
    uint8_t currentZoneSensitivityLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateTestMode
namespace InitiateNormalOperationModeResponse {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InitiateNormalOperationModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InitiateNormalOperationModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateNormalOperationModeResponse
namespace InitiateTestModeResponse {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::InitiateTestModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::InitiateTestModeResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace InitiateTestModeResponse
} // namespace Commands

namespace Attributes {

namespace ZoneState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ZoneState
namespace ZoneType {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ZoneType
namespace ZoneStatus {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ZoneStatus
namespace IasCieAddress {
struct TypeInfo
{
    using Type             = chip::NodeId;
    using DecodableType    = chip::NodeId;
    using DecodableArgType = chip::NodeId;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::IasCieAddress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace IasCieAddress
namespace ZoneId {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ZoneId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ZoneId
namespace NumberOfZoneSensitivityLevelsSupported {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NumberOfZoneSensitivityLevelsSupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NumberOfZoneSensitivityLevelsSupported
namespace CurrentZoneSensitivityLevel {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentZoneSensitivityLevel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentZoneSensitivityLevel
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IasZone::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ZoneState::TypeInfo::DecodableType zoneState;
        Attributes::ZoneType::TypeInfo::DecodableType zoneType;
        Attributes::ZoneStatus::TypeInfo::DecodableType zoneStatus;
        Attributes::IasCieAddress::TypeInfo::DecodableType iasCieAddress;
        Attributes::ZoneId::TypeInfo::DecodableType zoneId;
        Attributes::NumberOfZoneSensitivityLevelsSupported::TypeInfo::DecodableType numberOfZoneSensitivityLevelsSupported;
        Attributes::CurrentZoneSensitivityLevel::TypeInfo::DecodableType currentZoneSensitivityLevel;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace IasZone
namespace IasAce {
// Enum for IasAceAlarmStatus
enum class IasAceAlarmStatus : uint8_t
{
    kNoAlarm        = 0x00,
    kBurglar        = 0x01,
    kFire           = 0x02,
    kEmergency      = 0x03,
    kPolicePanic    = 0x04,
    kFirePanic      = 0x05,
    kEmergencyPanic = 0x06,
};
// Enum for IasAceArmMode
enum class IasAceArmMode : uint8_t
{
    kDisarm                 = 0x00,
    kArmDayHomeZonesOnly    = 0x01,
    kArmNightSleepZonesOnly = 0x02,
    kArmAllZones            = 0x03,
};
// Enum for IasAceArmNotification
enum class IasAceArmNotification : uint8_t
{
    kAllZonesDisarmed         = 0x00,
    kOnlyDayHomeZonesArmed    = 0x01,
    kOnlyNightSleepZonesArmed = 0x02,
    kAllZonesArmed            = 0x03,
    kInvalidArmDisarmCode     = 0x04,
    kNotReadyToArm            = 0x05,
    kAlreadyDisarmed          = 0x06,
};
// Enum for IasAceAudibleNotification
enum class IasAceAudibleNotification : uint8_t
{
    kMute         = 0x00,
    kDefaultSound = 0x01,
};
// Enum for IasAceBypassResult
enum class IasAceBypassResult : uint8_t
{
    kZoneBypassed         = 0x00,
    kZoneNotBypassed      = 0x01,
    kNotAllowed           = 0x02,
    kInvalidZoneId        = 0x03,
    kUnknownZoneId        = 0x04,
    kInvalidArmDisarmCode = 0x05,
};
// Enum for IasAcePanelStatus
enum class IasAcePanelStatus : uint8_t
{
    kPanelDisarmed = 0x00,
    kArmedStay     = 0x01,
    kArmedNight    = 0x02,
    kArmedAway     = 0x03,
    kExitDelay     = 0x04,
    kEntryDelay    = 0x05,
    kNotReadyToArm = 0x06,
    kInAlarm       = 0x07,
    kArmingStay    = 0x08,
    kArmingNight   = 0x09,
    kArmingAway    = 0x0A,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for IasZoneType
enum class IasZoneType : uint16_t
{
    kStandardCie             = 0x00,
    kMotionSensor            = 0x0D,
    kContactSwitch           = 0x15,
    kFireSensor              = 0x28,
    kWaterSensor             = 0x2A,
    kGasSensor               = 0x2B,
    kPersonalEmergencyDevice = 0x2C,
    kVibrationMovementSensor = 0x2D,
    kRemoteControl           = 0x10F,
    kKeyFob                  = 0x115,
    kKeypad                  = 0x21D,
    kStandardWarningDevice   = 0x225,
    kGlassBreakSensor        = 0x226,
    kCarbonMonoxideSensor    = 0x227,
    kSecurityRepeater        = 0x229,
    kInvalidZoneType         = 0xFFFF,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using IasZoneType                     = EmberAfIasZoneType;
#endif

// Bitmap for IasZoneStatus
enum class IasZoneStatus : uint16_t
{
    kAlarm1             = 0x1,
    kAlarm2             = 0x2,
    kTamper             = 0x4,
    kBattery            = 0x8,
    kSupervisionReports = 0x10,
    kRestoreReports     = 0x20,
    kTrouble            = 0x40,
    kAc                 = 0x80,
    kTest               = 0x100,
    kBatteryDefect      = 0x200,
};

namespace Structs {
namespace IasAceZoneStatusResult {
enum class Fields
{
    kZoneId     = 1,
    kZoneStatus = 2,
};

struct Type
{
public:
    uint8_t zoneId;
    chip::BitFlags<IasZoneStatus> zoneStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace IasAceZoneStatusResult
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Arm {
struct Type;
struct DecodableType;
} // namespace Arm

namespace ArmResponse {
struct Type;
struct DecodableType;
} // namespace ArmResponse

namespace Bypass {
struct Type;
struct DecodableType;
} // namespace Bypass

namespace GetZoneIdMapResponse {
struct Type;
struct DecodableType;
} // namespace GetZoneIdMapResponse

namespace Emergency {
struct Type;
struct DecodableType;
} // namespace Emergency

namespace GetZoneInformationResponse {
struct Type;
struct DecodableType;
} // namespace GetZoneInformationResponse

namespace Fire {
struct Type;
struct DecodableType;
} // namespace Fire

namespace ZoneStatusChanged {
struct Type;
struct DecodableType;
} // namespace ZoneStatusChanged

namespace Panic {
struct Type;
struct DecodableType;
} // namespace Panic

namespace PanelStatusChanged {
struct Type;
struct DecodableType;
} // namespace PanelStatusChanged

namespace GetZoneIdMap {
struct Type;
struct DecodableType;
} // namespace GetZoneIdMap

namespace GetPanelStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetPanelStatusResponse

namespace GetZoneInformation {
struct Type;
struct DecodableType;
} // namespace GetZoneInformation

namespace SetBypassedZoneList {
struct Type;
struct DecodableType;
} // namespace SetBypassedZoneList

namespace GetPanelStatus {
struct Type;
struct DecodableType;
} // namespace GetPanelStatus

namespace BypassResponse {
struct Type;
struct DecodableType;
} // namespace BypassResponse

namespace GetBypassedZoneList {
struct Type;
struct DecodableType;
} // namespace GetBypassedZoneList

namespace GetZoneStatusResponse {
struct Type;
struct DecodableType;
} // namespace GetZoneStatusResponse

namespace GetZoneStatus {
struct Type;
struct DecodableType;
} // namespace GetZoneStatus

} // namespace Commands

namespace Commands {
namespace Arm {
enum class Fields
{
    kArmMode       = 0,
    kArmDisarmCode = 1,
    kZoneId        = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Arm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAceArmMode armMode;
    chip::CharSpan armDisarmCode;
    uint8_t zoneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasAce::Commands::ArmResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Arm::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAceArmMode armMode;
    chip::CharSpan armDisarmCode;
    uint8_t zoneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Arm
namespace ArmResponse {
enum class Fields
{
    kArmNotification = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ArmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAceArmNotification armNotification;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ArmResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAceArmNotification armNotification;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ArmResponse
namespace Bypass {
enum class Fields
{
    kNumberOfZones = 0,
    kZoneIds       = 1,
    kArmDisarmCode = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Bypass::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::List<const uint8_t> zoneIds;
    chip::CharSpan armDisarmCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasAce::Commands::BypassResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Bypass::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::DecodableList<uint8_t> zoneIds;
    chip::CharSpan armDisarmCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Bypass
namespace GetZoneIdMapResponse {
enum class Fields
{
    kSection0  = 0,
    kSection1  = 1,
    kSection2  = 2,
    kSection3  = 3,
    kSection4  = 4,
    kSection5  = 5,
    kSection6  = 6,
    kSection7  = 7,
    kSection8  = 8,
    kSection9  = 9,
    kSection10 = 10,
    kSection11 = 11,
    kSection12 = 12,
    kSection13 = 13,
    kSection14 = 14,
    kSection15 = 15,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetZoneIdMapResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint16_t section0;
    uint16_t section1;
    uint16_t section2;
    uint16_t section3;
    uint16_t section4;
    uint16_t section5;
    uint16_t section6;
    uint16_t section7;
    uint16_t section8;
    uint16_t section9;
    uint16_t section10;
    uint16_t section11;
    uint16_t section12;
    uint16_t section13;
    uint16_t section14;
    uint16_t section15;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetZoneIdMapResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint16_t section0;
    uint16_t section1;
    uint16_t section2;
    uint16_t section3;
    uint16_t section4;
    uint16_t section5;
    uint16_t section6;
    uint16_t section7;
    uint16_t section8;
    uint16_t section9;
    uint16_t section10;
    uint16_t section11;
    uint16_t section12;
    uint16_t section13;
    uint16_t section14;
    uint16_t section15;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneIdMapResponse
namespace Emergency {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Emergency::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Emergency::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Emergency
namespace GetZoneInformationResponse {
enum class Fields
{
    kZoneId      = 0,
    kZoneType    = 1,
    kIeeeAddress = 2,
    kZoneLabel   = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetZoneInformationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t zoneId;
    IasZoneType zoneType;
    chip::NodeId ieeeAddress;
    chip::CharSpan zoneLabel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetZoneInformationResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t zoneId;
    IasZoneType zoneType;
    chip::NodeId ieeeAddress;
    chip::CharSpan zoneLabel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneInformationResponse
namespace Fire {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Fire::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Fire::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Fire
namespace ZoneStatusChanged {
enum class Fields
{
    kZoneId              = 0,
    kZoneStatus          = 1,
    kAudibleNotification = 2,
    kZoneLabel           = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ZoneStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t zoneId;
    uint16_t zoneStatus;
    IasAceAudibleNotification audibleNotification;
    chip::CharSpan zoneLabel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ZoneStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t zoneId;
    uint16_t zoneStatus;
    IasAceAudibleNotification audibleNotification;
    chip::CharSpan zoneLabel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ZoneStatusChanged
namespace Panic {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Panic::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Panic::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Panic
namespace PanelStatusChanged {
enum class Fields
{
    kPanelStatus         = 0,
    kSecondsRemaining    = 1,
    kAudibleNotification = 2,
    kAlarmStatus         = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::PanelStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::PanelStatusChanged::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace PanelStatusChanged
namespace GetZoneIdMap {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetZoneIdMap::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasAce::Commands::GetZoneIdMapResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetZoneIdMap::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneIdMap
namespace GetPanelStatusResponse {
enum class Fields
{
    kPanelStatus         = 0,
    kSecondsRemaining    = 1,
    kAudibleNotification = 2,
    kAlarmStatus         = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPanelStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPanelStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    IasAcePanelStatus panelStatus;
    uint8_t secondsRemaining;
    IasAceAudibleNotification audibleNotification;
    IasAceAlarmStatus alarmStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPanelStatusResponse
namespace GetZoneInformation {
enum class Fields
{
    kZoneId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetZoneInformation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t zoneId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasAce::Commands::GetZoneInformationResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetZoneInformation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t zoneId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneInformation
namespace SetBypassedZoneList {
enum class Fields
{
    kNumberOfZones = 0,
    kZoneIds       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::List<const uint8_t> zoneIds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::DecodableList<uint8_t> zoneIds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SetBypassedZoneList
namespace GetPanelStatus {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetPanelStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasAce::Commands::GetPanelStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetPanelStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetPanelStatus
namespace BypassResponse {
enum class Fields
{
    kNumberOfZones = 0,
    kBypassResult  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BypassResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::List<const IasAceBypassResult> bypassResult;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BypassResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t numberOfZones;
    DataModel::DecodableList<IasAceBypassResult> bypassResult;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BypassResponse
namespace GetBypassedZoneList {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetBypassedZoneList::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetBypassedZoneList
namespace GetZoneStatusResponse {
enum class Fields
{
    kZoneStatusComplete = 0,
    kNumberOfZones      = 1,
    kZoneStatusResult   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetZoneStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    bool zoneStatusComplete;
    uint8_t numberOfZones;
    DataModel::List<const Structs::IasAceZoneStatusResult::Type> zoneStatusResult;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetZoneStatusResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    bool zoneStatusComplete;
    uint8_t numberOfZones;
    DataModel::DecodableList<Structs::IasAceZoneStatusResult::DecodableType> zoneStatusResult;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneStatusResponse
namespace GetZoneStatus {
enum class Fields
{
    kStartingZoneId     = 0,
    kMaxNumberOfZoneIds = 1,
    kZoneStatusMaskFlag = 2,
    kZoneStatusMask     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t startingZoneId;
    uint8_t maxNumberOfZoneIds;
    bool zoneStatusMaskFlag;
    uint16_t zoneStatusMask;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::IasAce::Commands::GetZoneStatusResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetZoneStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

    uint8_t startingZoneId;
    uint8_t maxNumberOfZoneIds;
    bool zoneStatusMaskFlag;
    uint16_t zoneStatusMask;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetZoneStatus
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IasAce::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace IasAce
namespace IasWd {

// Bitmap for SquawkInfo
enum class SquawkInfo : uint8_t
{
    kMode   = 0xF0,
    kStrobe = 0x8,
    kLevel  = 0x3,
};

// Bitmap for WarningInfo
enum class WarningInfo : uint8_t
{
    kMode       = 0xF0,
    kStrobe     = 0xC,
    kSirenLevel = 0x3,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace StartWarning {
struct Type;
struct DecodableType;
} // namespace StartWarning

namespace Squawk {
struct Type;
struct DecodableType;
} // namespace Squawk

} // namespace Commands

namespace Commands {
namespace StartWarning {
enum class Fields
{
    kWarningInfo     = 0,
    kWarningDuration = 1,
    kStrobeDutyCycle = 2,
    kStrobeLevel     = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StartWarning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }

    chip::BitFlags<WarningInfo> warningInfo;
    uint16_t warningDuration;
    uint8_t strobeDutyCycle;
    uint8_t strobeLevel;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StartWarning::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }

    chip::BitFlags<WarningInfo> warningInfo;
    uint16_t warningDuration;
    uint8_t strobeDutyCycle;
    uint8_t strobeLevel;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StartWarning
namespace Squawk {
enum class Fields
{
    kSquawkInfo = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Squawk::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }

    chip::BitFlags<SquawkInfo> squawkInfo;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Squawk::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }

    chip::BitFlags<SquawkInfo> squawkInfo;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Squawk
} // namespace Commands

namespace Attributes {

namespace MaxDuration {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MaxDuration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MaxDuration
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::IasWd::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MaxDuration::TypeInfo::DecodableType maxDuration;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace IasWd
namespace WakeOnLan {

namespace Attributes {

namespace WakeOnLanMacAddress {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::WakeOnLanMacAddress::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace WakeOnLanMacAddress
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::WakeOnLan::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::WakeOnLanMacAddress::TypeInfo::DecodableType wakeOnLanMacAddress;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace WakeOnLan
namespace Channel {
// Enum for ChannelErrorType
enum class ChannelErrorType : uint8_t
{
    kMultipleMatches = 0x00,
    kNoMatches       = 0x01,
};
// Enum for ChannelLineupInfoType
enum class ChannelLineupInfoType : uint8_t
{
    kMso = 0x00,
};

namespace Structs {
namespace ChannelInfo {
enum class Fields
{
    kMajorNumber       = 1,
    kMinorNumber       = 2,
    kName              = 3,
    kCallSign          = 4,
    kAffiliateCallSign = 5,
};

struct Type
{
public:
    uint16_t majorNumber;
    uint16_t minorNumber;
    chip::CharSpan name;
    chip::CharSpan callSign;
    chip::CharSpan affiliateCallSign;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ChannelInfo
namespace ChannelLineupInfo {
enum class Fields
{
    kOperatorName   = 1,
    kLineupName     = 2,
    kPostalCode     = 3,
    kLineupInfoType = 4,
};

struct Type
{
public:
    chip::CharSpan operatorName;
    chip::CharSpan lineupName;
    chip::CharSpan postalCode;
    ChannelLineupInfoType lineupInfoType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ChannelLineupInfo
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeChannel {
struct Type;
struct DecodableType;
} // namespace ChangeChannel

namespace ChangeChannelResponse {
struct Type;
struct DecodableType;
} // namespace ChangeChannelResponse

namespace ChangeChannelByNumber {
struct Type;
struct DecodableType;
} // namespace ChangeChannelByNumber

namespace SkipChannel {
struct Type;
struct DecodableType;
} // namespace SkipChannel

} // namespace Commands

namespace Commands {
namespace ChangeChannel {
enum class Fields
{
    kMatch = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan match;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::Channel::Commands::ChangeChannelResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    chip::CharSpan match;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannel
namespace ChangeChannelResponse {
enum class Fields
{
    kChannelMatch = 0,
    kErrorType    = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Structs::ChannelInfo::Type channelMatch;
    ChannelErrorType errorType;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    Structs::ChannelInfo::DecodableType channelMatch;
    ChannelErrorType errorType;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelResponse
namespace ChangeChannelByNumber {
enum class Fields
{
    kMajorNumber = 0,
    kMinorNumber = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t majorNumber;
    uint16_t minorNumber;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeChannelByNumber::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t majorNumber;
    uint16_t minorNumber;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeChannelByNumber
namespace SkipChannel {
enum class Fields
{
    kCount = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t count;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SkipChannel::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

    uint16_t count;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SkipChannel
} // namespace Commands

namespace Attributes {

namespace ChannelList {
struct TypeInfo
{
    using Type          = chip::app::DataModel::List<const chip::app::Clusters::Channel::Structs::ChannelInfo::Type>;
    using DecodableType = chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelList
namespace ChannelLineup {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Channel::Structs::ChannelLineupInfo::Type;
    using DecodableType    = chip::app::Clusters::Channel::Structs::ChannelLineupInfo::DecodableType;
    using DecodableArgType = const chip::app::Clusters::Channel::Structs::ChannelLineupInfo::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ChannelLineup::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ChannelLineup
namespace CurrentChannel {
struct TypeInfo
{
    using Type             = chip::app::Clusters::Channel::Structs::ChannelInfo::Type;
    using DecodableType    = chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType;
    using DecodableArgType = const chip::app::Clusters::Channel::Structs::ChannelInfo::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentChannel::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentChannel
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Channel::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ChannelList::TypeInfo::DecodableType channelList;
        Attributes::ChannelLineup::TypeInfo::DecodableType channelLineup;
        Attributes::CurrentChannel::TypeInfo::DecodableType currentChannel;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Channel
namespace TargetNavigator {
// Enum for NavigateTargetStatus
enum class NavigateTargetStatus : uint8_t
{
    kSuccess         = 0x00,
    kAppNotAvailable = 0x01,
    kSystemBusy      = 0x02,
};

namespace Structs {
namespace NavigateTargetTargetInfo {
enum class Fields
{
    kIdentifier = 1,
    kName       = 2,
};

struct Type
{
public:
    uint8_t identifier;
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NavigateTargetTargetInfo
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace NavigateTarget {
struct Type;
struct DecodableType;
} // namespace NavigateTarget

namespace NavigateTargetResponse {
struct Type;
struct DecodableType;
} // namespace NavigateTargetResponse

} // namespace Commands

namespace Commands {
namespace NavigateTarget {
enum class Fields
{
    kTarget = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    uint8_t target;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TargetNavigator::Commands::NavigateTargetResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NavigateTarget::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    uint8_t target;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTarget
namespace NavigateTargetResponse {
enum class Fields
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    NavigateTargetStatus status;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::NavigateTargetResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

    NavigateTargetStatus status;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace NavigateTargetResponse
} // namespace Commands

namespace Attributes {

namespace TargetNavigatorList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TargetNavigator::Structs::NavigateTargetTargetInfo::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TargetNavigatorList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TargetNavigatorList
namespace CurrentNavigatorTarget {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentNavigatorTarget::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentNavigatorTarget
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TargetNavigator::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::TargetNavigatorList::TypeInfo::DecodableType targetNavigatorList;
        Attributes::CurrentNavigatorTarget::TypeInfo::DecodableType currentNavigatorTarget;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace TargetNavigator
namespace MediaPlayback {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MediaPlaybackState
enum class MediaPlaybackState : uint8_t
{
    kPlaying    = 0x00,
    kPaused     = 0x01,
    kNotPlaying = 0x02,
    kBuffering  = 0x03,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MediaPlaybackState              = EmberAfMediaPlaybackState;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MediaPlaybackStatus
enum class MediaPlaybackStatus : uint8_t
{
    kSuccess                = 0x00,
    kInvalidStateForCommand = 0x01,
    kNotAllowed             = 0x02,
    kNotActive              = 0x03,
    kSpeedOutOfRange        = 0x04,
    kSeekOutOfRange         = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MediaPlaybackStatus             = EmberAfMediaPlaybackStatus;
#endif

namespace Structs {
namespace MediaPlaybackPosition {
enum class Fields
{
    kUpdatedAt = 1,
    kPosition  = 2,
};

struct Type
{
public:
    uint64_t updatedAt;
    uint64_t position;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace MediaPlaybackPosition
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace MediaPlay {
struct Type;
struct DecodableType;
} // namespace MediaPlay

namespace MediaPlayResponse {
struct Type;
struct DecodableType;
} // namespace MediaPlayResponse

namespace MediaPause {
struct Type;
struct DecodableType;
} // namespace MediaPause

namespace MediaPauseResponse {
struct Type;
struct DecodableType;
} // namespace MediaPauseResponse

namespace MediaStop {
struct Type;
struct DecodableType;
} // namespace MediaStop

namespace MediaStopResponse {
struct Type;
struct DecodableType;
} // namespace MediaStopResponse

namespace MediaStartOver {
struct Type;
struct DecodableType;
} // namespace MediaStartOver

namespace MediaStartOverResponse {
struct Type;
struct DecodableType;
} // namespace MediaStartOverResponse

namespace MediaPrevious {
struct Type;
struct DecodableType;
} // namespace MediaPrevious

namespace MediaPreviousResponse {
struct Type;
struct DecodableType;
} // namespace MediaPreviousResponse

namespace MediaNext {
struct Type;
struct DecodableType;
} // namespace MediaNext

namespace MediaNextResponse {
struct Type;
struct DecodableType;
} // namespace MediaNextResponse

namespace MediaRewind {
struct Type;
struct DecodableType;
} // namespace MediaRewind

namespace MediaRewindResponse {
struct Type;
struct DecodableType;
} // namespace MediaRewindResponse

namespace MediaFastForward {
struct Type;
struct DecodableType;
} // namespace MediaFastForward

namespace MediaFastForwardResponse {
struct Type;
struct DecodableType;
} // namespace MediaFastForwardResponse

namespace MediaSkipForward {
struct Type;
struct DecodableType;
} // namespace MediaSkipForward

namespace MediaSkipForwardResponse {
struct Type;
struct DecodableType;
} // namespace MediaSkipForwardResponse

namespace MediaSkipBackward {
struct Type;
struct DecodableType;
} // namespace MediaSkipBackward

namespace MediaSkipBackwardResponse {
struct Type;
struct DecodableType;
} // namespace MediaSkipBackwardResponse

namespace MediaSeek {
struct Type;
struct DecodableType;
} // namespace MediaSeek

namespace MediaSeekResponse {
struct Type;
struct DecodableType;
} // namespace MediaSeekResponse

} // namespace Commands

namespace Commands {
namespace MediaPlay {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaPlay::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaPlayResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaPlay::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPlay
namespace MediaPlayResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaPlayResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaPlayResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPlayResponse
namespace MediaPause {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaPause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaPauseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaPause::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPause
namespace MediaPauseResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaPauseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaPauseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPauseResponse
namespace MediaStop {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaStopResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaStop::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStop
namespace MediaStopResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaStopResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaStopResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStopResponse
namespace MediaStartOver {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaStartOver::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaStartOverResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaStartOver::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStartOver
namespace MediaStartOverResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaStartOverResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaStartOverResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaStartOverResponse
namespace MediaPrevious {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaPrevious::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaPreviousResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaPrevious::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPrevious
namespace MediaPreviousResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaPreviousResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaPreviousResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaPreviousResponse
namespace MediaNext {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaNext::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaNextResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaNext::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaNext
namespace MediaNextResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaNextResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaNextResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaNextResponse
namespace MediaRewind {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaRewind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaRewindResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaRewind::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaRewind
namespace MediaRewindResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaRewindResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaRewindResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaRewindResponse
namespace MediaFastForward {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaFastForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaFastForwardResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaFastForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaFastForward
namespace MediaFastForwardResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaFastForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaFastForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaFastForwardResponse
namespace MediaSkipForward {
enum class Fields
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaSkipForwardResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipForward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipForward
namespace MediaSkipForwardResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipForwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipForwardResponse
namespace MediaSkipBackward {
enum class Fields
{
    kDeltaPositionMilliseconds = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaSkipBackwardResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipBackward::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t deltaPositionMilliseconds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipBackward
namespace MediaSkipBackwardResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipBackwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaSkipBackwardResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSkipBackwardResponse
namespace MediaSeek {
enum class Fields
{
    kPosition = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaSeek::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t position;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::MediaPlayback::Commands::MediaSeekResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaSeek::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    uint64_t position;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSeek
namespace MediaSeekResponse {
enum class Fields
{
    kMediaPlaybackStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MediaSeekResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MediaSeekResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

    MediaPlaybackStatus mediaPlaybackStatus;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MediaSeekResponse
} // namespace Commands

namespace Attributes {

namespace PlaybackState {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PlaybackState::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PlaybackState
namespace StartTime {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StartTime::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StartTime
namespace Duration {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Duration::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Duration
namespace Position {
struct TypeInfo
{
    using Type             = chip::app::Clusters::MediaPlayback::Structs::MediaPlaybackPosition::Type;
    using DecodableType    = chip::app::Clusters::MediaPlayback::Structs::MediaPlaybackPosition::DecodableType;
    using DecodableArgType = const chip::app::Clusters::MediaPlayback::Structs::MediaPlaybackPosition::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Position::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Position
namespace PlaybackSpeed {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PlaybackSpeed::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PlaybackSpeed
namespace SeekRangeEnd {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeEnd::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SeekRangeEnd
namespace SeekRangeStart {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SeekRangeStart::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SeekRangeStart
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MediaPlayback::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::PlaybackState::TypeInfo::DecodableType playbackState;
        Attributes::StartTime::TypeInfo::DecodableType startTime;
        Attributes::Duration::TypeInfo::DecodableType duration;
        Attributes::Position::TypeInfo::DecodableType position;
        Attributes::PlaybackSpeed::TypeInfo::DecodableType playbackSpeed;
        Attributes::SeekRangeEnd::TypeInfo::DecodableType seekRangeEnd;
        Attributes::SeekRangeStart::TypeInfo::DecodableType seekRangeStart;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace MediaPlayback
namespace MediaInput {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for MediaInputType
enum class MediaInputType : uint8_t
{
    kInternal  = 0x00,
    kAux       = 0x01,
    kCoax      = 0x02,
    kComposite = 0x03,
    kHdmi      = 0x04,
    kInput     = 0x05,
    kLine      = 0x06,
    kOptical   = 0x07,
    kVideo     = 0x08,
    kScart     = 0x09,
    kUsb       = 0x0A,
    kOther     = 0x0B,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using MediaInputType                  = EmberAfMediaInputType;
#endif

namespace Structs {
namespace MediaInputInfo {
enum class Fields
{
    kIndex       = 1,
    kInputType   = 2,
    kName        = 3,
    kDescription = 4,
};

struct Type
{
public:
    uint8_t index;
    MediaInputType inputType;
    chip::CharSpan name;
    chip::CharSpan description;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace MediaInputInfo
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectInput {
struct Type;
struct DecodableType;
} // namespace SelectInput

namespace ShowInputStatus {
struct Type;
struct DecodableType;
} // namespace ShowInputStatus

namespace HideInputStatus {
struct Type;
struct DecodableType;
} // namespace HideInputStatus

namespace RenameInput {
struct Type;
struct DecodableType;
} // namespace RenameInput

} // namespace Commands

namespace Commands {
namespace SelectInput {
enum class Fields
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectInput
namespace ShowInputStatus {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ShowInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ShowInputStatus
namespace HideInputStatus {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideInputStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideInputStatus
namespace RenameInput {
enum class Fields
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index;
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RenameInput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

    uint8_t index;
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameInput
} // namespace Commands

namespace Attributes {

namespace MediaInputList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::MediaInput::Structs::MediaInputInfo::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::MediaInput::Structs::MediaInputInfo::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MediaInputList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MediaInputList
namespace CurrentMediaInput {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentMediaInput::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentMediaInput
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MediaInput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MediaInputList::TypeInfo::DecodableType mediaInputList;
        Attributes::CurrentMediaInput::TypeInfo::DecodableType currentMediaInput;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace MediaInput
namespace LowPower {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Sleep {
struct Type;
struct DecodableType;
} // namespace Sleep

} // namespace Commands

namespace Commands {
namespace Sleep {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Sleep::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Sleep
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::LowPower::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace LowPower
namespace KeypadInput {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for KeypadInputCecKeyCode
enum class KeypadInputCecKeyCode : uint8_t
{
    kSelect                    = 0x00,
    kUp                        = 0x01,
    kDown                      = 0x02,
    kLeft                      = 0x03,
    kRight                     = 0x04,
    kRightUp                   = 0x05,
    kRightDown                 = 0x06,
    kLeftUp                    = 0x07,
    kLeftDown                  = 0x08,
    kRootMenu                  = 0x09,
    kSetupMenu                 = 0x0A,
    kContentsMenu              = 0x0B,
    kFavoriteMenu              = 0x0C,
    kExit                      = 0x0D,
    kMediaTopMenu              = 0x10,
    kMediaContextSensitiveMenu = 0x11,
    kNumberEntryMode           = 0x1D,
    kNumber11                  = 0x1E,
    kNumber12                  = 0x1F,
    kNumber0OrNumber10         = 0x20,
    kNumbers1                  = 0x21,
    kNumbers2                  = 0x22,
    kNumbers3                  = 0x23,
    kNumbers4                  = 0x24,
    kNumbers5                  = 0x25,
    kNumbers6                  = 0x26,
    kNumbers7                  = 0x27,
    kNumbers8                  = 0x28,
    kNumbers9                  = 0x29,
    kDot                       = 0x2A,
    kEnter                     = 0x2B,
    kClear                     = 0x2C,
    kNextFavorite              = 0x2F,
    kChannelUp                 = 0x30,
    kChannelDown               = 0x31,
    kPreviousChannel           = 0x32,
    kSoundSelect               = 0x33,
    kInputSelect               = 0x34,
    kDisplayInformation        = 0x35,
    kHelp                      = 0x36,
    kPageUp                    = 0x37,
    kPageDown                  = 0x38,
    kPower                     = 0x40,
    kVolumeUp                  = 0x41,
    kVolumeDown                = 0x42,
    kMute                      = 0x43,
    kPlay                      = 0x44,
    kStop                      = 0x45,
    kPause                     = 0x46,
    kRecord                    = 0x47,
    kRewind                    = 0x48,
    kFastForward               = 0x49,
    kEject                     = 0x4A,
    kForward                   = 0x4B,
    kBackward                  = 0x4C,
    kStopRecord                = 0x4D,
    kPauseRecord               = 0x4E,
    kReserved                  = 0x4F,
    kAngle                     = 0x50,
    kSubPicture                = 0x51,
    kVideoOnDemand             = 0x52,
    kElectronicProgramGuide    = 0x53,
    kTimerProgramming          = 0x54,
    kInitialConfiguration      = 0x55,
    kSelectBroadcastType       = 0x56,
    kSelectSoundPresentation   = 0x57,
    kPlayFunction              = 0x60,
    kPausePlayFunction         = 0x61,
    kRecordFunction            = 0x62,
    kPauseRecordFunction       = 0x63,
    kStopFunction              = 0x64,
    kMuteFunction              = 0x65,
    kRestoreVolumeFunction     = 0x66,
    kTuneFunction              = 0x67,
    kSelectMediaFunction       = 0x68,
    kSelectAvInputFunction     = 0x69,
    kSelectAudioInputFunction  = 0x6A,
    kPowerToggleFunction       = 0x6B,
    kPowerOffFunction          = 0x6C,
    kPowerOnFunction           = 0x6D,
    kF1Blue                    = 0x71,
    kF2Red                     = 0x72,
    kF3Green                   = 0x73,
    kF4Yellow                  = 0x74,
    kF5                        = 0x75,
    kData                      = 0x76,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using KeypadInputCecKeyCode           = EmberAfKeypadInputCecKeyCode;
#endif
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for KeypadInputStatus
enum class KeypadInputStatus : uint8_t
{
    kSuccess                  = 0x00,
    kUnsupportedKey           = 0x01,
    kInvalidKeyInCurrentState = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using KeypadInputStatus               = EmberAfKeypadInputStatus;
#endif

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SendKey {
struct Type;
struct DecodableType;
} // namespace SendKey

namespace SendKeyResponse {
struct Type;
struct DecodableType;
} // namespace SendKeyResponse

} // namespace Commands

namespace Commands {
namespace SendKey {
enum class Fields
{
    kKeyCode = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    KeypadInputCecKeyCode keyCode;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::KeypadInput::Commands::SendKeyResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SendKey::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    KeypadInputCecKeyCode keyCode;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKey
namespace SendKeyResponse {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    KeypadInputStatus status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SendKeyResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

    KeypadInputStatus status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SendKeyResponse
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::KeypadInput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace KeypadInput
namespace ContentLauncher {
// Enum for ContentLaunchMetricType
enum class ContentLaunchMetricType : uint8_t
{
    kPixels     = 0x00,
    kPercentage = 0x01,
};
// Enum for ContentLaunchParameterEnum
enum class ContentLaunchParameterEnum : uint8_t
{
    kActor      = 0x00,
    kChannel    = 0x01,
    kCharacter  = 0x02,
    kDirector   = 0x03,
    kEvent      = 0x04,
    kFranchise  = 0x05,
    kGenre      = 0x06,
    kLeague     = 0x07,
    kPopularity = 0x08,
    kProvider   = 0x09,
    kSport      = 0x0A,
    kSportsTeam = 0x0B,
    kType       = 0x0C,
};
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ContentLaunchStatus
enum class ContentLaunchStatus : uint8_t
{
    kSuccess         = 0x00,
    kUrlNotAvailable = 0x01,
    kAuthFailed      = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ContentLaunchStatus             = EmberAfContentLaunchStatus;
#endif

// Bitmap for SupportedStreamingProtocol
enum class SupportedStreamingProtocol : uint32_t
{
    kDash = 0x1,
    kHls  = 0x2,
};

namespace Structs {
namespace ContentLaunchDimension {
enum class Fields
{
    kWidth  = 1,
    kHeight = 2,
    kMetric = 3,
};

struct Type
{
public:
    double width;
    double height;
    ContentLaunchMetricType metric;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchDimension
namespace ContentLaunchAdditionalInfo {
enum class Fields
{
    kName  = 1,
    kValue = 2,
};

struct Type
{
public:
    chip::CharSpan name;
    chip::CharSpan value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchAdditionalInfo
namespace ContentLaunchParamater {
enum class Fields
{
    kType           = 1,
    kValue          = 2,
    kExternalIDList = 3,
};

struct Type
{
public:
    ContentLaunchParameterEnum type;
    chip::CharSpan value;
    DataModel::List<const Structs::ContentLaunchAdditionalInfo::Type> externalIDList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    ContentLaunchParameterEnum type;
    chip::CharSpan value;
    DataModel::DecodableList<Structs::ContentLaunchAdditionalInfo::DecodableType> externalIDList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace ContentLaunchParamater
namespace ContentLaunchStyleInformation {
enum class Fields
{
    kImageUrl = 1,
    kColor    = 2,
    kSize     = 3,
};

struct Type
{
public:
    chip::CharSpan imageUrl;
    chip::CharSpan color;
    Structs::ContentLaunchDimension::Type size;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchStyleInformation
namespace ContentLaunchBrandingInformation {
enum class Fields
{
    kProviderName = 1,
    kBackground   = 2,
    kLogo         = 3,
    kProgressBar  = 4,
    kSplash       = 5,
    kWaterMark    = 6,
};

struct Type
{
public:
    chip::CharSpan providerName;
    Structs::ContentLaunchStyleInformation::Type background;
    Structs::ContentLaunchStyleInformation::Type logo;
    Structs::ContentLaunchStyleInformation::Type progressBar;
    Structs::ContentLaunchStyleInformation::Type splash;
    Structs::ContentLaunchStyleInformation::Type waterMark;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ContentLaunchBrandingInformation
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LaunchContent {
struct Type;
struct DecodableType;
} // namespace LaunchContent

namespace LaunchContentResponse {
struct Type;
struct DecodableType;
} // namespace LaunchContentResponse

namespace LaunchURL {
struct Type;
struct DecodableType;
} // namespace LaunchURL

namespace LaunchURLResponse {
struct Type;
struct DecodableType;
} // namespace LaunchURLResponse

} // namespace Commands

namespace Commands {
namespace LaunchContent {
enum class Fields
{
    kAutoPlay = 0,
    kData     = 1,
    kSearch   = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    bool autoPlay;
    chip::CharSpan data;
    DataModel::List<const Structs::ContentLaunchParamater::Type> search;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ContentLauncher::Commands::LaunchContentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchContent::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    bool autoPlay;
    chip::CharSpan data;
    DataModel::DecodableList<Structs::ContentLaunchParamater::DecodableType> search;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchContent
namespace LaunchContentResponse {
enum class Fields
{
    kContentLaunchStatus = 0,
    kData                = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchContentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    ContentLaunchStatus contentLaunchStatus;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchContentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    ContentLaunchStatus contentLaunchStatus;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchContentResponse
namespace LaunchURL {
enum class Fields
{
    kContentURL          = 0,
    kDisplayString       = 1,
    kBrandingInformation = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    chip::CharSpan contentURL;
    chip::CharSpan displayString;
    DataModel::List<const Structs::ContentLaunchBrandingInformation::Type> brandingInformation;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ContentLauncher::Commands::LaunchURLResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchURL::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    chip::CharSpan contentURL;
    chip::CharSpan displayString;
    DataModel::DecodableList<Structs::ContentLaunchBrandingInformation::DecodableType> brandingInformation;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchURL
namespace LaunchURLResponse {
enum class Fields
{
    kContentLaunchStatus = 0,
    kData                = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchURLResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    ContentLaunchStatus contentLaunchStatus;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchURLResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

    ContentLaunchStatus contentLaunchStatus;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchURLResponse
} // namespace Commands

namespace Attributes {

namespace AcceptHeaderList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcceptHeaderList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcceptHeaderList
namespace SupportedStreamingProtocols {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SupportedStreamingProtocols::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SupportedStreamingProtocols
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ContentLauncher::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AcceptHeaderList::TypeInfo::DecodableType acceptHeaderList;
        Attributes::SupportedStreamingProtocols::TypeInfo::DecodableType supportedStreamingProtocols;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ContentLauncher
namespace AudioOutput {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for AudioOutputType
enum class AudioOutputType : uint8_t
{
    kHdmi      = 0x00,
    kBt        = 0x01,
    kOptical   = 0x02,
    kHeadphone = 0x03,
    kInternal  = 0x04,
    kOther     = 0x05,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using AudioOutputType                 = EmberAfAudioOutputType;
#endif

namespace Structs {
namespace AudioOutputInfo {
enum class Fields
{
    kIndex      = 1,
    kOutputType = 2,
    kName       = 3,
};

struct Type
{
public:
    uint8_t index;
    AudioOutputType outputType;
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace AudioOutputInfo
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace SelectOutput {
struct Type;
struct DecodableType;
} // namespace SelectOutput

namespace RenameOutput {
struct Type;
struct DecodableType;
} // namespace RenameOutput

} // namespace Commands

namespace Commands {
namespace SelectOutput {
enum class Fields
{
    kIndex = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SelectOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SelectOutput
namespace RenameOutput {
enum class Fields
{
    kIndex = 0,
    kName  = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index;
    chip::CharSpan name;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::RenameOutput::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

    uint8_t index;
    chip::CharSpan name;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace RenameOutput
} // namespace Commands

namespace Attributes {

namespace AudioOutputList {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::AudioOutput::Structs::AudioOutputInfo::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AudioOutputList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AudioOutputList
namespace CurrentAudioOutput {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentAudioOutput::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentAudioOutput
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AudioOutput::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AudioOutputList::TypeInfo::DecodableType audioOutputList;
        Attributes::CurrentAudioOutput::TypeInfo::DecodableType currentAudioOutput;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace AudioOutput
namespace ApplicationLauncher {
// Need to convert consumers to using the new enum classes, so we
// don't just have casts all over.
#ifdef CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
// Enum for ApplicationLauncherStatus
enum class ApplicationLauncherStatus : uint8_t
{
    kSuccess         = 0x00,
    kAppNotAvailable = 0x01,
    kSystemBusy      = 0x02,
};
#else // CHIP_USE_ENUM_CLASS_FOR_IM_ENUM
using ApplicationLauncherStatus       = EmberAfApplicationLauncherStatus;
#endif

namespace Structs {
namespace ApplicationLauncherApp {
enum class Fields
{
    kCatalogVendorId = 1,
    kApplicationId   = 2,
};

struct Type
{
public:
    uint16_t catalogVendorId;
    chip::CharSpan applicationId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ApplicationLauncherApp
namespace ApplicationLauncherEndpoint {
enum class Fields
{
    kApplication = 1,
    kEndpoint    = 2,
};

struct Type
{
public:
    Structs::ApplicationLauncherApp::Type application;
    chip::CharSpan endpoint;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ApplicationLauncherEndpoint
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LaunchApp {
struct Type;
struct DecodableType;
} // namespace LaunchApp

namespace LaunchAppResponse {
struct Type;
struct DecodableType;
} // namespace LaunchAppResponse

namespace StopApp {
struct Type;
struct DecodableType;
} // namespace StopApp

namespace StopAppResponse {
struct Type;
struct DecodableType;
} // namespace StopAppResponse

namespace HideApp {
struct Type;
struct DecodableType;
} // namespace HideApp

namespace HideAppResponse {
struct Type;
struct DecodableType;
} // namespace HideAppResponse

} // namespace Commands

namespace Commands {
namespace LaunchApp {
enum class Fields
{
    kData        = 0,
    kApplication = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    chip::CharSpan data;
    Structs::ApplicationLauncherApp::Type application;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::LaunchAppResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    chip::CharSpan data;
    Structs::ApplicationLauncherApp::DecodableType application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchApp
namespace LaunchAppResponse {
enum class Fields
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LaunchAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LaunchAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LaunchAppResponse
namespace StopApp {
enum class Fields
{
    kApplication = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Structs::ApplicationLauncherApp::Type application;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::StopAppResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Structs::ApplicationLauncherApp::DecodableType application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopApp
namespace StopAppResponse {
enum class Fields
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StopAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StopAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StopAppResponse
namespace HideApp {
enum class Fields
{
    kApplication = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Structs::ApplicationLauncherApp::Type application;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplicationLauncher::Commands::HideAppResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideApp::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    Structs::ApplicationLauncherApp::DecodableType application;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideApp
namespace HideAppResponse {
enum class Fields
{
    kStatus = 0,
    kData   = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::HideAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::CharSpan data;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::HideAppResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

    ApplicationLauncherStatus status;
    chip::CharSpan data;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace HideAppResponse
} // namespace Commands

namespace Attributes {

namespace ApplicationLauncherList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint16_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationLauncherList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationLauncherList
namespace ApplicationLauncherApp {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherEndpoint::Type;
    using DecodableType    = chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherEndpoint::DecodableType;
    using DecodableArgType = const chip::app::Clusters::ApplicationLauncher::Structs::ApplicationLauncherEndpoint::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationLauncherApp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationLauncherApp
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplicationLauncher::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::ApplicationLauncherList::TypeInfo::DecodableType applicationLauncherList;
        Attributes::ApplicationLauncherApp::TypeInfo::DecodableType applicationLauncherApp;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ApplicationLauncher
namespace ApplicationBasic {
// Enum for ApplicationBasicStatus
enum class ApplicationBasicStatus : uint8_t
{
    kStopped               = 0x00,
    kActiveVisibleFocus    = 0x01,
    kActiveHidden          = 0x02,
    kActiveVisibleNotFocus = 0x03,
};

namespace Structs {
namespace ApplicationBasicApp {
enum class Fields
{
    kCatalogVendorId = 1,
    kApplicationId   = 2,
};

struct Type
{
public:
    uint16_t catalogVendorId;
    chip::CharSpan applicationId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace ApplicationBasicApp
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace ChangeStatus {
struct Type;
struct DecodableType;
} // namespace ChangeStatus

} // namespace Commands

namespace Commands {
namespace ChangeStatus {
enum class Fields
{
    kStatus = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::ChangeStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }

    ApplicationBasicStatus status;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::ChangeStatus::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }

    ApplicationBasicStatus status;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace ChangeStatus
} // namespace Commands

namespace Attributes {

namespace VendorName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorName
namespace VendorId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorId
namespace ApplicationName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationName
namespace ProductId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductId
namespace ApplicationApp {
struct TypeInfo
{
    using Type             = chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApp::Type;
    using DecodableType    = chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApp::DecodableType;
    using DecodableArgType = const chip::app::Clusters::ApplicationBasic::Structs::ApplicationBasicApp::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationApp::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationApp
namespace ApplicationStatus {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationStatus::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationStatus
namespace ApplicationVersion {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApplicationVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApplicationVersion
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplicationBasic::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::VendorName::TypeInfo::DecodableType vendorName;
        Attributes::VendorId::TypeInfo::DecodableType vendorId;
        Attributes::ApplicationName::TypeInfo::DecodableType applicationName;
        Attributes::ProductId::TypeInfo::DecodableType productId;
        Attributes::ApplicationApp::TypeInfo::DecodableType applicationApp;
        Attributes::ApplicationStatus::TypeInfo::DecodableType applicationStatus;
        Attributes::ApplicationVersion::TypeInfo::DecodableType applicationVersion;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ApplicationBasic
namespace AccountLogin {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetSetupPIN {
struct Type;
struct DecodableType;
} // namespace GetSetupPIN

namespace GetSetupPINResponse {
struct Type;
struct DecodableType;
} // namespace GetSetupPINResponse

namespace Login {
struct Type;
struct DecodableType;
} // namespace Login

namespace Logout {
struct Type;
struct DecodableType;
} // namespace Logout

} // namespace Commands

namespace Commands {
namespace GetSetupPIN {
enum class Fields
{
    kTempAccountIdentifier = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::AccountLogin::Commands::GetSetupPINResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPIN::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPIN
namespace GetSetupPINResponse {
enum class Fields
{
    kSetupPIN = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan setupPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetSetupPINResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan setupPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetSetupPINResponse
namespace Login {
enum class Fields
{
    kTempAccountIdentifier = 0,
    kSetupPIN              = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Login::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    chip::CharSpan setupPIN;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Login::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    chip::CharSpan tempAccountIdentifier;
    chip::CharSpan setupPIN;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Login
namespace Logout {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Logout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Logout::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Logout
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::AccountLogin::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace AccountLogin
namespace TestCluster {
// Enum for SimpleEnum
enum class SimpleEnum : uint8_t
{
    kUnspecified = 0x00,
    kValueA      = 0x01,
    kValueB      = 0x02,
    kValueC      = 0x03,
};

// Bitmap for SimpleBitmap
enum class SimpleBitmap : uint8_t
{
    kValueA = 0x1,
    kValueB = 0x2,
    kValueC = 0x4,
};

namespace Structs {
namespace SimpleStruct {
enum class Fields
{
    kA = 1,
    kB = 2,
    kC = 3,
    kD = 4,
    kE = 5,
    kF = 6,
    kG = 7,
    kH = 8,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    SimpleEnum c;
    chip::ByteSpan d;
    chip::CharSpan e;
    chip::BitFlags<SimpleBitmap> f;
    float g;
    double h;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace SimpleStruct
namespace NullablesAndOptionalsStruct {
enum class Fields
{
    kNullableInt            = 1,
    kOptionalInt            = 2,
    kNullableOptionalInt    = 3,
    kNullableString         = 4,
    kOptionalString         = 5,
    kNullableOptionalString = 6,
    kNullableStruct         = 7,
    kOptionalStruct         = 8,
    kNullableOptionalStruct = 9,
    kNullableList           = 10,
    kOptionalList           = 11,
    kNullableOptionalList   = 12,
};

struct Type
{
public:
    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NullablesAndOptionalsStruct
namespace NestedStruct {
enum class Fields
{
    kA = 1,
    kB = 2,
    kC = 3,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    Structs::SimpleStruct::Type c;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace NestedStruct
namespace NestedStructList {
enum class Fields
{
    kA = 1,
    kB = 2,
    kC = 3,
    kD = 4,
    kE = 5,
    kF = 6,
    kG = 7,
};

struct Type
{
public:
    uint8_t a;
    bool b;
    Structs::SimpleStruct::Type c;
    DataModel::List<const Structs::SimpleStruct::Type> d;
    DataModel::List<const uint32_t> e;
    DataModel::List<const chip::ByteSpan> f;
    DataModel::List<const uint8_t> g;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    uint8_t a;
    bool b;
    Structs::SimpleStruct::DecodableType c;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> d;
    DataModel::DecodableList<uint32_t> e;
    DataModel::DecodableList<chip::ByteSpan> f;
    DataModel::DecodableList<uint8_t> g;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace NestedStructList
namespace DoubleNestedStructList {
enum class Fields
{
    kA = 1,
};

struct Type
{
public:
    DataModel::List<const Structs::NestedStructList::Type> a;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    DataModel::DecodableList<Structs::NestedStructList::DecodableType> a;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

} // namespace DoubleNestedStructList
namespace TestListStructOctet {
enum class Fields
{
    kFabricIndex     = 1,
    kOperationalCert = 2,
};

struct Type
{
public:
    uint64_t fabricIndex;
    chip::ByteSpan operationalCert;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};

using DecodableType = Type;

} // namespace TestListStructOctet
} // namespace Structs

namespace Commands {
// Forward-declarations so we can reference these later.

namespace Test {
struct Type;
struct DecodableType;
} // namespace Test

namespace TestSpecificResponse {
struct Type;
struct DecodableType;
} // namespace TestSpecificResponse

namespace TestNotHandled {
struct Type;
struct DecodableType;
} // namespace TestNotHandled

namespace TestAddArgumentsResponse {
struct Type;
struct DecodableType;
} // namespace TestAddArgumentsResponse

namespace TestSpecific {
struct Type;
struct DecodableType;
} // namespace TestSpecific

namespace TestSimpleArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentResponse

namespace TestUnknownCommand {
struct Type;
struct DecodableType;
} // namespace TestUnknownCommand

namespace TestStructArrayArgumentResponse {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentResponse

namespace TestAddArguments {
struct Type;
struct DecodableType;
} // namespace TestAddArguments

namespace TestListInt8UReverseResponse {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseResponse

namespace TestSimpleArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleArgumentRequest

namespace TestEnumsResponse {
struct Type;
struct DecodableType;
} // namespace TestEnumsResponse

namespace TestStructArrayArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArrayArgumentRequest

namespace TestNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalResponse

namespace TestStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestStructArgumentRequest

namespace TestComplexNullableOptionalResponse {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalResponse

namespace TestNestedStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructArgumentRequest

namespace BooleanResponse {
struct Type;
struct DecodableType;
} // namespace BooleanResponse

namespace TestListStructArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListStructArgumentRequest

namespace SimpleStructResponse {
struct Type;
struct DecodableType;
} // namespace SimpleStructResponse

namespace TestListInt8UArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UArgumentRequest

namespace TestEmitTestEventResponse {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventResponse

namespace TestNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestNestedStructListArgumentRequest

namespace TestListNestedStructListArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestListNestedStructListArgumentRequest

namespace TestListInt8UReverseRequest {
struct Type;
struct DecodableType;
} // namespace TestListInt8UReverseRequest

namespace TestEnumsRequest {
struct Type;
struct DecodableType;
} // namespace TestEnumsRequest

namespace TestNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestNullableOptionalRequest

namespace TestComplexNullableOptionalRequest {
struct Type;
struct DecodableType;
} // namespace TestComplexNullableOptionalRequest

namespace SimpleStructEchoRequest {
struct Type;
struct DecodableType;
} // namespace SimpleStructEchoRequest

namespace TimedInvokeRequest {
struct Type;
struct DecodableType;
} // namespace TimedInvokeRequest

namespace TestSimpleOptionalArgumentRequest {
struct Type;
struct DecodableType;
} // namespace TestSimpleOptionalArgumentRequest

namespace TestEmitTestEventRequest {
struct Type;
struct DecodableType;
} // namespace TestEmitTestEventRequest

} // namespace Commands

namespace Commands {
namespace Test {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::Test::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace Test
namespace TestSpecificResponse {
enum class Fields
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t returnValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecificResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t returnValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecificResponse
namespace TestNotHandled {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNotHandled::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNotHandled
namespace TestAddArgumentsResponse {
enum class Fields
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t returnValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArgumentsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t returnValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArgumentsResponse
namespace TestSpecific {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestSpecificResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSpecific::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSpecific
namespace TestSimpleArgumentResponse {
enum class Fields
{
    kReturnValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool returnValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool returnValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentResponse
namespace TestUnknownCommand {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestUnknownCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestUnknownCommand
namespace TestStructArrayArgumentResponse {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5;
    bool arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5;
    bool arg6;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentResponse
namespace TestAddArguments {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t arg1;
    uint8_t arg2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestAddArgumentsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestAddArguments::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t arg1;
    uint8_t arg2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestAddArguments
namespace TestListInt8UReverseResponse {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseResponse
namespace TestSimpleArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestSimpleArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleArgumentRequest
namespace TestEnumsResponse {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    chip::VendorId arg1;
    SimpleEnum arg2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    chip::VendorId arg1;
    SimpleEnum arg2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsResponse
namespace TestStructArrayArgumentRequest {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
    kArg4 = 3,
    kArg5 = 4,
    kArg6 = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;
    DataModel::List<const Structs::SimpleStruct::Type> arg2;
    DataModel::List<const SimpleEnum> arg3;
    DataModel::List<const bool> arg4;
    SimpleEnum arg5;
    bool arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestStructArrayArgumentResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArrayArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg2;
    DataModel::DecodableList<SimpleEnum> arg3;
    DataModel::DecodableList<bool> arg4;
    SimpleEnum arg5;
    bool arg6;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArrayArgumentRequest
namespace TestNullableOptionalResponse {
enum class Fields
{
    kWasPresent    = 0,
    kWasNull       = 1,
    kValue         = 2,
    kOriginalValue = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool wasPresent;
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool wasPresent;
    Optional<bool> wasNull;
    Optional<uint8_t> value;
    Optional<DataModel::Nullable<uint8_t>> originalValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalResponse
namespace TestStructArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestStructArgumentRequest
namespace TestComplexNullableOptionalResponse {
enum class Fields
{
    kNullableIntWasNull               = 0,
    kNullableIntValue                 = 1,
    kOptionalIntWasPresent            = 2,
    kOptionalIntValue                 = 3,
    kNullableOptionalIntWasPresent    = 4,
    kNullableOptionalIntWasNull       = 5,
    kNullableOptionalIntValue         = 6,
    kNullableStringWasNull            = 7,
    kNullableStringValue              = 8,
    kOptionalStringWasPresent         = 9,
    kOptionalStringValue              = 10,
    kNullableOptionalStringWasPresent = 11,
    kNullableOptionalStringWasNull    = 12,
    kNullableOptionalStringValue      = 13,
    kNullableStructWasNull            = 14,
    kNullableStructValue              = 15,
    kOptionalStructWasPresent         = 16,
    kOptionalStructValue              = 17,
    kNullableOptionalStructWasPresent = 18,
    kNullableOptionalStructWasNull    = 19,
    kNullableOptionalStructValue      = 20,
    kNullableListWasNull              = 21,
    kNullableListValue                = 22,
    kOptionalListWasPresent           = 23,
    kOptionalListValue                = 24,
    kNullableOptionalListWasPresent   = 25,
    kNullableOptionalListWasNull      = 26,
    kNullableOptionalListValue        = 27,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool nullableIntWasNull;
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent;
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent;
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull;
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent;
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent;
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull;
    Optional<Structs::SimpleStruct::Type> nullableStructValue;
    bool optionalStructWasPresent;
    Optional<Structs::SimpleStruct::Type> optionalStructValue;
    bool nullableOptionalStructWasPresent;
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::Type> nullableOptionalStructValue;
    bool nullableListWasNull;
    Optional<DataModel::List<const SimpleEnum>> nullableListValue;
    bool optionalListWasPresent;
    Optional<DataModel::List<const SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent;
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::List<const SimpleEnum>> nullableOptionalListValue;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool nullableIntWasNull;
    Optional<uint16_t> nullableIntValue;
    bool optionalIntWasPresent;
    Optional<uint16_t> optionalIntValue;
    bool nullableOptionalIntWasPresent;
    Optional<bool> nullableOptionalIntWasNull;
    Optional<uint16_t> nullableOptionalIntValue;
    bool nullableStringWasNull;
    Optional<chip::CharSpan> nullableStringValue;
    bool optionalStringWasPresent;
    Optional<chip::CharSpan> optionalStringValue;
    bool nullableOptionalStringWasPresent;
    Optional<bool> nullableOptionalStringWasNull;
    Optional<chip::CharSpan> nullableOptionalStringValue;
    bool nullableStructWasNull;
    Optional<Structs::SimpleStruct::DecodableType> nullableStructValue;
    bool optionalStructWasPresent;
    Optional<Structs::SimpleStruct::DecodableType> optionalStructValue;
    bool nullableOptionalStructWasPresent;
    Optional<bool> nullableOptionalStructWasNull;
    Optional<Structs::SimpleStruct::DecodableType> nullableOptionalStructValue;
    bool nullableListWasNull;
    Optional<DataModel::DecodableList<SimpleEnum>> nullableListValue;
    bool optionalListWasPresent;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalListValue;
    bool nullableOptionalListWasPresent;
    Optional<bool> nullableOptionalListWasNull;
    Optional<DataModel::DecodableList<SimpleEnum>> nullableOptionalListValue;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalResponse
namespace TestNestedStructArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::NestedStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::NestedStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructArgumentRequest
namespace BooleanResponse {
enum class Fields
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::BooleanResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    bool value;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace BooleanResponse
namespace TestListStructArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const Structs::SimpleStruct::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListStructArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListStructArgumentRequest
namespace SimpleStructResponse {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructResponse
namespace TestListInt8UArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UArgumentRequest
namespace TestEmitTestEventResponse {
enum class Fields
{
    kValue = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint64_t value;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint64_t value;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventResponse
namespace TestNestedStructListArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::NestedStructList::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::NestedStructList::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNestedStructListArgumentRequest
namespace TestListNestedStructListArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const Structs::NestedStructList::Type> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::BooleanResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListNestedStructListArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<Structs::NestedStructList::DecodableType> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListNestedStructListArgumentRequest
namespace TestListInt8UReverseRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::List<const uint8_t> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestListInt8UReverseResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestListInt8UReverseRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::DecodableList<uint8_t> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestListInt8UReverseRequest
namespace TestEnumsRequest {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    chip::VendorId arg1;
    SimpleEnum arg2;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestEnumsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEnumsRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    chip::VendorId arg1;
    SimpleEnum arg2;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEnumsRequest
namespace TestNullableOptionalRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Optional<DataModel::Nullable<uint8_t>> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestNullableOptionalRequest
namespace TestComplexNullableOptionalRequest {
enum class Fields
{
    kNullableInt            = 0,
    kOptionalInt            = 1,
    kNullableOptionalInt    = 2,
    kNullableString         = 3,
    kOptionalString         = 4,
    kNullableOptionalString = 5,
    kNullableStruct         = 6,
    kOptionalStruct         = 7,
    kNullableOptionalStruct = 8,
    kNullableList           = 9,
    kOptionalList           = 10,
    kNullableOptionalList   = 11,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::Type> nullableStruct;
    Optional<Structs::SimpleStruct::Type> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::Type>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::List<const SimpleEnum>> nullableList;
    Optional<DataModel::List<const SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::List<const SimpleEnum>>> nullableOptionalList;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestComplexNullableOptionalResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestComplexNullableOptionalRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    DataModel::Nullable<uint16_t> nullableInt;
    Optional<uint16_t> optionalInt;
    Optional<DataModel::Nullable<uint16_t>> nullableOptionalInt;
    DataModel::Nullable<chip::CharSpan> nullableString;
    Optional<chip::CharSpan> optionalString;
    Optional<DataModel::Nullable<chip::CharSpan>> nullableOptionalString;
    DataModel::Nullable<Structs::SimpleStruct::DecodableType> nullableStruct;
    Optional<Structs::SimpleStruct::DecodableType> optionalStruct;
    Optional<DataModel::Nullable<Structs::SimpleStruct::DecodableType>> nullableOptionalStruct;
    DataModel::Nullable<DataModel::DecodableList<SimpleEnum>> nullableList;
    Optional<DataModel::DecodableList<SimpleEnum>> optionalList;
    Optional<DataModel::Nullable<DataModel::DecodableList<SimpleEnum>>> nullableOptionalList;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestComplexNullableOptionalRequest
namespace SimpleStructEchoRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::SimpleStruct::Type arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::SimpleStructResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::SimpleStructEchoRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Structs::SimpleStruct::DecodableType arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace SimpleStructEchoRequest
namespace TimedInvokeRequest {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return true; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TimedInvokeRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TimedInvokeRequest
namespace TestSimpleOptionalArgumentRequest {
enum class Fields
{
    kArg1 = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Optional<bool> arg1;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestSimpleOptionalArgumentRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    Optional<bool> arg1;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestSimpleOptionalArgumentRequest
namespace TestEmitTestEventRequest {
enum class Fields
{
    kArg1 = 0,
    kArg2 = 1,
    kArg3 = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t arg1;
    SimpleEnum arg2;
    bool arg3;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::TestCluster::Commands::TestEmitTestEventResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::TestEmitTestEventRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t arg1;
    SimpleEnum arg2;
    bool arg3;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace TestEmitTestEventRequest
} // namespace Commands

namespace Attributes {

namespace Boolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Boolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Boolean
namespace Bitmap8 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap8
namespace Bitmap16 {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap16
namespace Bitmap32 {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap32::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap32
namespace Bitmap64 {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Bitmap64::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Bitmap64
namespace Int8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int8u
namespace Int16u {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int16u
namespace Int24u {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int24u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int24u
namespace Int32u {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int32u
namespace Int40u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int40u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int40u
namespace Int48u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int48u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int48u
namespace Int56u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int56u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int56u
namespace Int64u {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int64u
namespace Int8s {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int8s
namespace Int16s {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int16s
namespace Int24s {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int24s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int24s
namespace Int32s {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int32s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int32s
namespace Int40s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int40s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int40s
namespace Int48s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int48s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int48s
namespace Int56s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int56s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int56s
namespace Int64s {
struct TypeInfo
{
    using Type             = int64_t;
    using DecodableType    = int64_t;
    using DecodableArgType = int64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Int64s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Int64s
namespace Enum8 {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enum8
namespace Enum16 {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Enum16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Enum16
namespace FloatSingle {
struct TypeInfo
{
    using Type             = float;
    using DecodableType    = float;
    using DecodableArgType = float;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FloatSingle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FloatSingle
namespace FloatDouble {
struct TypeInfo
{
    using Type             = double;
    using DecodableType    = double;
    using DecodableArgType = double;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FloatDouble::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FloatDouble
namespace OctetString {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OctetString
namespace ListInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const uint8_t>;
    using DecodableType    = chip::app::DataModel::DecodableList<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListInt8u
namespace ListOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListOctetString
namespace ListStructOctetString {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::TestListStructOctet::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::TestListStructOctet::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListStructOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListStructOctetString
namespace LongOctetString {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LongOctetString
namespace CharString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CharString
namespace LongCharString {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LongCharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LongCharString
namespace EpochUs {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochUs::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EpochUs
namespace EpochS {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EpochS::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EpochS
namespace VendorId {
struct TypeInfo
{
    using Type             = chip::VendorId;
    using DecodableType    = chip::VendorId;
    using DecodableArgType = chip::VendorId;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VendorId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VendorId
namespace ListNullablesAndOptionalsStruct {
struct TypeInfo
{
    using Type = chip::app::DataModel::List<const chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::Type>;
    using DecodableType =
        chip::app::DataModel::DecodableList<chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<
        chip::app::Clusters::TestCluster::Structs::NullablesAndOptionalsStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListNullablesAndOptionalsStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListNullablesAndOptionalsStruct
namespace EnumAttr {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TestCluster::SimpleEnum;
    using DecodableType    = chip::app::Clusters::TestCluster::SimpleEnum;
    using DecodableArgType = chip::app::Clusters::TestCluster::SimpleEnum;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::EnumAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace EnumAttr
namespace StructAttr {
struct TypeInfo
{
    using Type             = chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type;
    using DecodableType    = chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType;
    using DecodableArgType = const chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::StructAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace StructAttr
namespace RangeRestrictedInt8u {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt8u
namespace RangeRestrictedInt8s {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt8s
namespace RangeRestrictedInt16u {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt16u
namespace RangeRestrictedInt16s {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RangeRestrictedInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RangeRestrictedInt16s
namespace ListLongOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ListLongOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ListLongOctetString
namespace TimedWriteBoolean {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TimedWriteBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return true; }
};
} // namespace TimedWriteBoolean
namespace Unsupported {
struct TypeInfo
{
    using Type             = bool;
    using DecodableType    = bool;
    using DecodableArgType = bool;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Unsupported::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Unsupported
namespace NullableBoolean {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<bool>;
    using DecodableType    = chip::app::DataModel::Nullable<bool>;
    using DecodableArgType = const chip::app::DataModel::Nullable<bool> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBoolean::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBoolean
namespace NullableBitmap8 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap8
namespace NullableBitmap16 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap16
namespace NullableBitmap32 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap32::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap32
namespace NullableBitmap64 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableBitmap64::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableBitmap64
namespace NullableInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt8u
namespace NullableInt16u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt16u
namespace NullableInt24u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt24u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt24u
namespace NullableInt32u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt32u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt32u
namespace NullableInt40u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt40u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt40u
namespace NullableInt48u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt48u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt48u
namespace NullableInt56u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt56u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt56u
namespace NullableInt64u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt64u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt64u
namespace NullableInt8s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt8s
namespace NullableInt16s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt16s
namespace NullableInt24s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt24s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt24s
namespace NullableInt32s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int32_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int32_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int32_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt32s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt32s
namespace NullableInt40s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt40s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt40s
namespace NullableInt48s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt48s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt48s
namespace NullableInt56s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt56s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt56s
namespace NullableInt64s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int64_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int64_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int64_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableInt64s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableInt64s
namespace NullableEnum8 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnum8::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnum8
namespace NullableEnum16 {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnum16::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnum16
namespace NullableFloatSingle {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<float>;
    using DecodableType    = chip::app::DataModel::Nullable<float>;
    using DecodableArgType = const chip::app::DataModel::Nullable<float> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableFloatSingle::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableFloatSingle
namespace NullableFloatDouble {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<double>;
    using DecodableType    = chip::app::DataModel::Nullable<double>;
    using DecodableArgType = const chip::app::DataModel::Nullable<double> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableFloatDouble::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableFloatDouble
namespace NullableOctetString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::ByteSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::ByteSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableOctetString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableOctetString
namespace NullableCharString {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::CharSpan>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::CharSpan> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableCharString::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableCharString
namespace NullableEnumAttr {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum>;
    using DecodableType    = chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum>;
    using DecodableArgType = const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::SimpleEnum> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableEnumAttr::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableEnumAttr
namespace NullableStruct {
struct TypeInfo
{
    using Type          = chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::Structs::SimpleStruct::Type>;
    using DecodableType = chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType>;
    using DecodableArgType =
        const chip::app::DataModel::Nullable<chip::app::Clusters::TestCluster::Structs::SimpleStruct::DecodableType> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableStruct::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableStruct
namespace NullableRangeRestrictedInt8u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt8u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt8u
namespace NullableRangeRestrictedInt8s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int8_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int8_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int8_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt8s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt8s
namespace NullableRangeRestrictedInt16u {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<uint16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<uint16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt16u::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt16u
namespace NullableRangeRestrictedInt16s {
struct TypeInfo
{
    using Type             = chip::app::DataModel::Nullable<int16_t>;
    using DecodableType    = chip::app::DataModel::Nullable<int16_t>;
    using DecodableArgType = const chip::app::DataModel::Nullable<int16_t> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NullableRangeRestrictedInt16s::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NullableRangeRestrictedInt16s
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::Boolean::TypeInfo::DecodableType boolean;
        Attributes::Bitmap8::TypeInfo::DecodableType bitmap8;
        Attributes::Bitmap16::TypeInfo::DecodableType bitmap16;
        Attributes::Bitmap32::TypeInfo::DecodableType bitmap32;
        Attributes::Bitmap64::TypeInfo::DecodableType bitmap64;
        Attributes::Int8u::TypeInfo::DecodableType int8u;
        Attributes::Int16u::TypeInfo::DecodableType int16u;
        Attributes::Int24u::TypeInfo::DecodableType int24u;
        Attributes::Int32u::TypeInfo::DecodableType int32u;
        Attributes::Int40u::TypeInfo::DecodableType int40u;
        Attributes::Int48u::TypeInfo::DecodableType int48u;
        Attributes::Int56u::TypeInfo::DecodableType int56u;
        Attributes::Int64u::TypeInfo::DecodableType int64u;
        Attributes::Int8s::TypeInfo::DecodableType int8s;
        Attributes::Int16s::TypeInfo::DecodableType int16s;
        Attributes::Int24s::TypeInfo::DecodableType int24s;
        Attributes::Int32s::TypeInfo::DecodableType int32s;
        Attributes::Int40s::TypeInfo::DecodableType int40s;
        Attributes::Int48s::TypeInfo::DecodableType int48s;
        Attributes::Int56s::TypeInfo::DecodableType int56s;
        Attributes::Int64s::TypeInfo::DecodableType int64s;
        Attributes::Enum8::TypeInfo::DecodableType enum8;
        Attributes::Enum16::TypeInfo::DecodableType enum16;
        Attributes::FloatSingle::TypeInfo::DecodableType floatSingle;
        Attributes::FloatDouble::TypeInfo::DecodableType floatDouble;
        Attributes::OctetString::TypeInfo::DecodableType octetString;
        Attributes::ListInt8u::TypeInfo::DecodableType listInt8u;
        Attributes::ListOctetString::TypeInfo::DecodableType listOctetString;
        Attributes::ListStructOctetString::TypeInfo::DecodableType listStructOctetString;
        Attributes::LongOctetString::TypeInfo::DecodableType longOctetString;
        Attributes::CharString::TypeInfo::DecodableType charString;
        Attributes::LongCharString::TypeInfo::DecodableType longCharString;
        Attributes::EpochUs::TypeInfo::DecodableType epochUs;
        Attributes::EpochS::TypeInfo::DecodableType epochS;
        Attributes::VendorId::TypeInfo::DecodableType vendorId;
        Attributes::ListNullablesAndOptionalsStruct::TypeInfo::DecodableType listNullablesAndOptionalsStruct;
        Attributes::EnumAttr::TypeInfo::DecodableType enumAttr;
        Attributes::StructAttr::TypeInfo::DecodableType structAttr;
        Attributes::RangeRestrictedInt8u::TypeInfo::DecodableType rangeRestrictedInt8u;
        Attributes::RangeRestrictedInt8s::TypeInfo::DecodableType rangeRestrictedInt8s;
        Attributes::RangeRestrictedInt16u::TypeInfo::DecodableType rangeRestrictedInt16u;
        Attributes::RangeRestrictedInt16s::TypeInfo::DecodableType rangeRestrictedInt16s;
        Attributes::ListLongOctetString::TypeInfo::DecodableType listLongOctetString;
        Attributes::TimedWriteBoolean::TypeInfo::DecodableType timedWriteBoolean;
        Attributes::Unsupported::TypeInfo::DecodableType unsupported;
        Attributes::NullableBoolean::TypeInfo::DecodableType nullableBoolean;
        Attributes::NullableBitmap8::TypeInfo::DecodableType nullableBitmap8;
        Attributes::NullableBitmap16::TypeInfo::DecodableType nullableBitmap16;
        Attributes::NullableBitmap32::TypeInfo::DecodableType nullableBitmap32;
        Attributes::NullableBitmap64::TypeInfo::DecodableType nullableBitmap64;
        Attributes::NullableInt8u::TypeInfo::DecodableType nullableInt8u;
        Attributes::NullableInt16u::TypeInfo::DecodableType nullableInt16u;
        Attributes::NullableInt24u::TypeInfo::DecodableType nullableInt24u;
        Attributes::NullableInt32u::TypeInfo::DecodableType nullableInt32u;
        Attributes::NullableInt40u::TypeInfo::DecodableType nullableInt40u;
        Attributes::NullableInt48u::TypeInfo::DecodableType nullableInt48u;
        Attributes::NullableInt56u::TypeInfo::DecodableType nullableInt56u;
        Attributes::NullableInt64u::TypeInfo::DecodableType nullableInt64u;
        Attributes::NullableInt8s::TypeInfo::DecodableType nullableInt8s;
        Attributes::NullableInt16s::TypeInfo::DecodableType nullableInt16s;
        Attributes::NullableInt24s::TypeInfo::DecodableType nullableInt24s;
        Attributes::NullableInt32s::TypeInfo::DecodableType nullableInt32s;
        Attributes::NullableInt40s::TypeInfo::DecodableType nullableInt40s;
        Attributes::NullableInt48s::TypeInfo::DecodableType nullableInt48s;
        Attributes::NullableInt56s::TypeInfo::DecodableType nullableInt56s;
        Attributes::NullableInt64s::TypeInfo::DecodableType nullableInt64s;
        Attributes::NullableEnum8::TypeInfo::DecodableType nullableEnum8;
        Attributes::NullableEnum16::TypeInfo::DecodableType nullableEnum16;
        Attributes::NullableFloatSingle::TypeInfo::DecodableType nullableFloatSingle;
        Attributes::NullableFloatDouble::TypeInfo::DecodableType nullableFloatDouble;
        Attributes::NullableOctetString::TypeInfo::DecodableType nullableOctetString;
        Attributes::NullableCharString::TypeInfo::DecodableType nullableCharString;
        Attributes::NullableEnumAttr::TypeInfo::DecodableType nullableEnumAttr;
        Attributes::NullableStruct::TypeInfo::DecodableType nullableStruct;
        Attributes::NullableRangeRestrictedInt8u::TypeInfo::DecodableType nullableRangeRestrictedInt8u;
        Attributes::NullableRangeRestrictedInt8s::TypeInfo::DecodableType nullableRangeRestrictedInt8s;
        Attributes::NullableRangeRestrictedInt16u::TypeInfo::DecodableType nullableRangeRestrictedInt16u;
        Attributes::NullableRangeRestrictedInt16s::TypeInfo::DecodableType nullableRangeRestrictedInt16s;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
namespace Events {
namespace TestEvent {
static constexpr PriorityLevel kPriorityLevel = PriorityLevel::Info;
static constexpr EventId kEventId             = 0x00000001;

enum class Fields
{
    kArg1 = 1,
    kArg2 = 2,
    kArg3 = 3,
    kArg4 = 4,
    kArg5 = 5,
    kArg6 = 6,
};

struct Type
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t arg1;
    SimpleEnum arg2;
    bool arg3;
    Structs::SimpleStruct::Type arg4;
    DataModel::List<const Structs::SimpleStruct::Type> arg5;
    DataModel::List<const SimpleEnum> arg6;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;
};

struct DecodableType
{
public:
    static constexpr PriorityLevel GetPriorityLevel() { return kPriorityLevel; }
    static constexpr EventId GetEventId() { return kEventId; }
    static constexpr ClusterId GetClusterId() { return Clusters::TestCluster::Id; }

    uint8_t arg1;
    SimpleEnum arg2;
    bool arg3;
    Structs::SimpleStruct::DecodableType arg4;
    DataModel::DecodableList<Structs::SimpleStruct::DecodableType> arg5;
    DataModel::DecodableList<SimpleEnum> arg6;

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
} // namespace TestEvent
} // namespace Events
} // namespace TestCluster
namespace Messaging {
// Enum for EventId
enum class EventId : uint8_t
{
    kMeterCoverRemoved                  = 0x00,
    kMeterCoverClosed                   = 0x01,
    kStrongMagneticField                = 0x02,
    kNoStrongMagneticField              = 0x03,
    kBatteryFailure                     = 0x04,
    kLowBattery                         = 0x05,
    kProgramMemoryError                 = 0x06,
    kRamError                           = 0x07,
    kNvMemoryError                      = 0x08,
    kMeasurementSystemError             = 0x09,
    kWatchdogError                      = 0x0A,
    kSupplyDisconnectFailure            = 0x0B,
    kSupplyConnectFailure               = 0x0C,
    kMeasurmentSoftwareChanged          = 0x0D,
    kDstEnabled                         = 0x0E,
    kDstDisabled                        = 0x0F,
    kClockAdjBackward                   = 0x10,
    kClockAdjForward                    = 0x11,
    kClockInvalid                       = 0x12,
    kCommsErrorHan                      = 0x13,
    kCommsOkHan                         = 0x14,
    kFraudAttempt                       = 0x15,
    kPowerLoss                          = 0x16,
    kIncorrectProtocol                  = 0x17,
    kUnusualHanTraffic                  = 0x18,
    kUnexpectedClockChange              = 0x19,
    kCommsUsingUnauthenticatedComponent = 0x1A,
    kErrorRegClear                      = 0x1B,
    kAlarmRegClear                      = 0x1C,
    kUnexpectedHwReset                  = 0x1D,
    kUnexpectedProgramExecution         = 0x1E,
    kEventLogCleared                    = 0x1F,
    kManualDisconnect                   = 0x20,
    kManualConnect                      = 0x21,
    kRemoteDisconnection                = 0x22,
    kLocalDisconnection                 = 0x23,
    kLimitThresholdExceeded             = 0x24,
    kLimitThresholdOk                   = 0x25,
    kLimitThresholdChanged              = 0x26,
    kMaximumDemandExceeded              = 0x27,
    kProfileCleared                     = 0x28,
    kFirmwareReadyForActivation         = 0x29,
    kFirmwareActivated                  = 0x2A,
    kPatchFailure                       = 0x2B,
    kTouTariffActivation                = 0x2C,
    k8x8Tariffactivated                 = 0x2D,
    kSingleTariffRateActivated          = 0x2E,
    kAsynchronousBillingOccurred        = 0x2F,
    kSynchronousBillingOccurred         = 0x30,
    kIncorrectPolarity                  = 0x80,
    kCurrentNoVoltage                   = 0x81,
    kUnderVoltage                       = 0x82,
    kOverVoltage                        = 0x83,
    kNormalVoltage                      = 0x84,
    kPfBelowThreshold                   = 0x85,
    kPfAboveThreshold                   = 0x86,
    kTerminalCoverRemoved               = 0x87,
    kTerminalCoverClosed                = 0x88,
    kReverseFlow                        = 0xA0,
    kTiltTamper                         = 0xA1,
    kBatteryCoverRemoved                = 0xA2,
    kBatteryCoverClosed                 = 0xA3,
    kExcessFlow                         = 0xA4,
    kCreditOk                           = 0xC0,
    kLowCredit                          = 0xC1,
    kEmergencyCreditInUse               = 0xC0,
    kEmergencyCreditExhausted           = 0xC1,
    kZeroCreditEcNotSelected            = 0xC2,
    kSupplyOn                           = 0xC3,
    kSupplyOffAarmed                    = 0xC4,
    kSupplyOff                          = 0xC5,
    kDiscountApplied                    = 0xC6,
    kManufacturerSpecificA              = 0xE0,
    kManufacturerSpecificB              = 0xE1,
    kManufacturerSpecificC              = 0xE2,
    kManufacturerSpecificD              = 0xE3,
    kManufacturerSpecificE              = 0xE4,
    kManufacturerSpecificF              = 0xE5,
    kManufacturerSpecificG              = 0xE6,
    kManufacturerSpecificH              = 0xE7,
    kManufacturerSpecificI              = 0xE8,
};
// Enum for MessagingControlConfirmation
enum class MessagingControlConfirmation : uint8_t
{
    kNotRequired = 0x00,
    kRequired    = 0x80,
};
// Enum for MessagingControlEnhancedConfirmation
enum class MessagingControlEnhancedConfirmation : uint8_t
{
    kNotRequired = 0x00,
    kRequired    = 0x20,
};
// Enum for MessagingControlImportance
enum class MessagingControlImportance : uint8_t
{
    kLow      = 0x00,
    kMedium   = 0x04,
    kHigh     = 0x08,
    kCritical = 0x0C,
};
// Enum for MessagingControlTransmission
enum class MessagingControlTransmission : uint8_t
{
    kNormal             = 0x00,
    kNormalAndAnonymous = 0x01,
    kAnonymous          = 0x02,
    kReserved           = 0x03,
};

// Bitmap for MessagingConfirmationControl
enum class MessagingConfirmationControl : uint8_t
{
    kNoReturned  = 0x1,
    kYesReturned = 0x2,
};

// Bitmap for MessagingControlMask
enum class MessagingControlMask : uint8_t
{
    kTransMechanism              = 0x3,
    kMessageUrgency              = 0xC,
    kEnhancedConfirmationRequest = 0x20,
    kMessageConfirmation         = 0x80,
};

// Bitmap for MessagingExtendedControlMask
enum class MessagingExtendedControlMask : uint8_t
{
    kMessageConfirmationStatus = 0x1,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace DisplayMessage {
struct Type;
struct DecodableType;
} // namespace DisplayMessage

namespace GetLastMessage {
struct Type;
struct DecodableType;
} // namespace GetLastMessage

namespace CancelMessage {
struct Type;
struct DecodableType;
} // namespace CancelMessage

namespace MessageConfirmation {
struct Type;
struct DecodableType;
} // namespace MessageConfirmation

namespace DisplayProtectedMessage {
struct Type;
struct DecodableType;
} // namespace DisplayProtectedMessage

namespace GetMessageCancellation {
struct Type;
struct DecodableType;
} // namespace GetMessageCancellation

namespace CancelAllMessages {
struct Type;
struct DecodableType;
} // namespace CancelAllMessages

} // namespace Commands

namespace Commands {
namespace DisplayMessage {
enum class Fields
{
    kMessageId                      = 0,
    kMessageControl                 = 1,
    kStartTime                      = 2,
    kDurationInMinutes              = 3,
    kMessage                        = 4,
    kOptionalExtendedMessageControl = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisplayMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    chip::BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::CharSpan message;
    chip::BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisplayMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    chip::BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::CharSpan message;
    chip::BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisplayMessage
namespace GetLastMessage {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetLastMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetLastMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetLastMessage
namespace CancelMessage {
enum class Fields
{
    kMessageId      = 0,
    kMessageControl = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    chip::BitFlags<MessagingControlMask> messageControl;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    chip::BitFlags<MessagingControlMask> messageControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelMessage
namespace MessageConfirmation {
enum class Fields
{
    kMessageId                  = 0,
    kConfirmationTime           = 1,
    kMessageConfirmationControl = 2,
    kMessageResponse            = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::MessageConfirmation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    uint32_t confirmationTime;
    uint8_t messageConfirmationControl;
    chip::ByteSpan messageResponse;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::MessageConfirmation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    uint32_t confirmationTime;
    uint8_t messageConfirmationControl;
    chip::ByteSpan messageResponse;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace MessageConfirmation
namespace DisplayProtectedMessage {
enum class Fields
{
    kMessageId                      = 0,
    kMessageControl                 = 1,
    kStartTime                      = 2,
    kDurationInMinutes              = 3,
    kMessage                        = 4,
    kOptionalExtendedMessageControl = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::DisplayProtectedMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    chip::BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::CharSpan message;
    chip::BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::DisplayProtectedMessage::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t messageId;
    chip::BitFlags<MessagingControlMask> messageControl;
    uint32_t startTime;
    uint16_t durationInMinutes;
    chip::CharSpan message;
    chip::BitFlags<MessagingExtendedControlMask> optionalExtendedMessageControl;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace DisplayProtectedMessage
namespace GetMessageCancellation {
enum class Fields
{
    kEarliestImplementationTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetMessageCancellation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t earliestImplementationTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetMessageCancellation::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t earliestImplementationTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMessageCancellation
namespace CancelAllMessages {
enum class Fields
{
    kImplementationDateTime = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::CancelAllMessages::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t implementationDateTime;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::CancelAllMessages::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

    uint32_t implementationDateTime;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace CancelAllMessages
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::Messaging::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace Messaging
namespace ApplianceIdentification {

namespace Attributes {

namespace BasicIdentification {
struct TypeInfo
{
    using Type             = uint64_t;
    using DecodableType    = uint64_t;
    using DecodableArgType = uint64_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BasicIdentification::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BasicIdentification
namespace CompanyName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompanyName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CompanyName
namespace CompanyId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompanyId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CompanyId
namespace BrandName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BrandName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BrandName
namespace BrandId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::BrandId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace BrandId
namespace Model {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Model::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Model
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartNumber
namespace ProductRevision {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductRevision
namespace SoftwareRevision {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareRevision
namespace ProductTypeName {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductTypeName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductTypeName
namespace ProductTypeId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductTypeId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductTypeId
namespace CecedSpecificationVersion {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CecedSpecificationVersion::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CecedSpecificationVersion
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplianceIdentification::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::BasicIdentification::TypeInfo::DecodableType basicIdentification;
        Attributes::CompanyName::TypeInfo::DecodableType companyName;
        Attributes::CompanyId::TypeInfo::DecodableType companyId;
        Attributes::BrandName::TypeInfo::DecodableType brandName;
        Attributes::BrandId::TypeInfo::DecodableType brandId;
        Attributes::Model::TypeInfo::DecodableType model;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductRevision::TypeInfo::DecodableType productRevision;
        Attributes::SoftwareRevision::TypeInfo::DecodableType softwareRevision;
        Attributes::ProductTypeName::TypeInfo::DecodableType productTypeName;
        Attributes::ProductTypeId::TypeInfo::DecodableType productTypeId;
        Attributes::CecedSpecificationVersion::TypeInfo::DecodableType cecedSpecificationVersion;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ApplianceIdentification
namespace MeterIdentification {

namespace Attributes {

namespace CompanyName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CompanyName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CompanyName
namespace MeterTypeId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeterTypeId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeterTypeId
namespace DataQualityId {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DataQualityId::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DataQualityId
namespace CustomerName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CustomerName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CustomerName
namespace Model {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Model::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Model
namespace PartNumber {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PartNumber::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PartNumber
namespace ProductRevision {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ProductRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ProductRevision
namespace SoftwareRevision {
struct TypeInfo
{
    using Type             = chip::ByteSpan;
    using DecodableType    = chip::ByteSpan;
    using DecodableArgType = chip::ByteSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::SoftwareRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace SoftwareRevision
namespace UtilityName {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::UtilityName::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace UtilityName
namespace Pod {
struct TypeInfo
{
    using Type             = chip::CharSpan;
    using DecodableType    = chip::CharSpan;
    using DecodableArgType = chip::CharSpan;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Pod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Pod
namespace AvailablePower {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AvailablePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AvailablePower
namespace PowerThreshold {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerThreshold::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerThreshold
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::MeterIdentification::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::CompanyName::TypeInfo::DecodableType companyName;
        Attributes::MeterTypeId::TypeInfo::DecodableType meterTypeId;
        Attributes::DataQualityId::TypeInfo::DecodableType dataQualityId;
        Attributes::CustomerName::TypeInfo::DecodableType customerName;
        Attributes::Model::TypeInfo::DecodableType model;
        Attributes::PartNumber::TypeInfo::DecodableType partNumber;
        Attributes::ProductRevision::TypeInfo::DecodableType productRevision;
        Attributes::SoftwareRevision::TypeInfo::DecodableType softwareRevision;
        Attributes::UtilityName::TypeInfo::DecodableType utilityName;
        Attributes::Pod::TypeInfo::DecodableType pod;
        Attributes::AvailablePower::TypeInfo::DecodableType availablePower;
        Attributes::PowerThreshold::TypeInfo::DecodableType powerThreshold;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace MeterIdentification
namespace ApplianceEventsAndAlert {
// Enum for EventIdentification
enum class EventIdentification : uint8_t
{
    kEndOfCycle         = 0x01,
    kTemperatureReached = 0x04,
    kEndOfCooking       = 0x05,
    kSwitchingOff       = 0x06,
    kWrongData          = 0x07,
};

// Bitmap for AlertCount
enum class AlertCount : uint8_t
{
    kNumberOfAlerts = 0xF,
    kTypeOfAlert    = 0xF0,
};

// Bitmap for AlertStructure
enum class AlertStructure : uint32_t
{
    kAlertId          = 0xFF,
    kCategory         = 0xF00,
    kPresenceRecovery = 0x3000,
};

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetAlerts {
struct Type;
struct DecodableType;
} // namespace GetAlerts

namespace GetAlertsResponse {
struct Type;
struct DecodableType;
} // namespace GetAlertsResponse

namespace AlertsNotification {
struct Type;
struct DecodableType;
} // namespace AlertsNotification

namespace EventsNotification {
struct Type;
struct DecodableType;
} // namespace EventsNotification

} // namespace Commands

namespace Commands {
namespace GetAlerts {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetAlerts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplianceEventsAndAlert::Commands::GetAlertsResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetAlerts::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlerts
namespace GetAlertsResponse {
enum class Fields
{
    kAlertsCount     = 0,
    kAlertStructures = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetAlertsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    chip::BitFlags<AlertCount> alertsCount;
    DataModel::List<const chip::BitFlags<AlertStructure>> alertStructures;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetAlertsResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    chip::BitFlags<AlertCount> alertsCount;
    DataModel::DecodableList<chip::BitFlags<AlertStructure>> alertStructures;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetAlertsResponse
namespace AlertsNotification {
enum class Fields
{
    kAlertsCount     = 0,
    kAlertStructures = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::AlertsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    chip::BitFlags<AlertCount> alertsCount;
    DataModel::List<const chip::BitFlags<AlertStructure>> alertStructures;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::AlertsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    chip::BitFlags<AlertCount> alertsCount;
    DataModel::DecodableList<chip::BitFlags<AlertStructure>> alertStructures;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace AlertsNotification
namespace EventsNotification {
enum class Fields
{
    kEventHeader = 0,
    kEventId     = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::EventsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    uint8_t eventHeader;
    EventIdentification eventId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::EventsNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

    uint8_t eventHeader;
    EventIdentification eventId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace EventsNotification
} // namespace Commands

namespace Attributes {

namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplianceEventsAndAlert::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ApplianceEventsAndAlert
namespace ApplianceStatistics {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace LogNotification {
struct Type;
struct DecodableType;
} // namespace LogNotification

namespace LogRequest {
struct Type;
struct DecodableType;
} // namespace LogRequest

namespace LogResponse {
struct Type;
struct DecodableType;
} // namespace LogResponse

namespace LogQueueRequest {
struct Type;
struct DecodableType;
} // namespace LogQueueRequest

namespace LogQueueResponse {
struct Type;
struct DecodableType;
} // namespace LogQueueResponse

namespace StatisticsAvailable {
struct Type;
struct DecodableType;
} // namespace StatisticsAvailable

} // namespace Commands

namespace Commands {
namespace LogNotification {
enum class Fields
{
    kTimeStamp  = 0,
    kLogId      = 1,
    kLogLength  = 2,
    kLogPayload = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LogNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::List<const uint8_t> logPayload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LogNotification::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::DecodableList<uint8_t> logPayload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogNotification
namespace LogRequest {
enum class Fields
{
    kLogId = 0,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LogRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint32_t logId;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplianceStatistics::Commands::LogResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LogRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint32_t logId;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogRequest
namespace LogResponse {
enum class Fields
{
    kTimeStamp  = 0,
    kLogId      = 1,
    kLogLength  = 2,
    kLogPayload = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LogResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::List<const uint8_t> logPayload;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LogResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint32_t timeStamp;
    uint32_t logId;
    uint32_t logLength;
    DataModel::DecodableList<uint8_t> logPayload;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogResponse
namespace LogQueueRequest {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LogQueueRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = Clusters::ApplianceStatistics::Commands::LogQueueResponse::DecodableType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LogQueueRequest::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogQueueRequest
namespace LogQueueResponse {
enum class Fields
{
    kLogQueueSize = 0,
    kLogIds       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::LogQueueResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::List<const uint32_t> logIds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::LogQueueResponse::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::DecodableList<uint32_t> logIds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace LogQueueResponse
namespace StatisticsAvailable {
enum class Fields
{
    kLogQueueSize = 0,
    kLogIds       = 1,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::StatisticsAvailable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::List<const uint32_t> logIds;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::StatisticsAvailable::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

    uint8_t logQueueSize;
    DataModel::DecodableList<uint32_t> logIds;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace StatisticsAvailable
} // namespace Commands

namespace Attributes {

namespace LogMaxSize {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LogMaxSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LogMaxSize
namespace LogQueueMaxSize {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LogQueueMaxSize::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LogQueueMaxSize
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ApplianceStatistics::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::LogMaxSize::TypeInfo::DecodableType logMaxSize;
        Attributes::LogQueueMaxSize::TypeInfo::DecodableType logQueueMaxSize;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ApplianceStatistics
namespace ElectricalMeasurement {

namespace Commands {
// Forward-declarations so we can reference these later.

namespace GetProfileInfoResponseCommand {
struct Type;
struct DecodableType;
} // namespace GetProfileInfoResponseCommand

namespace GetProfileInfoCommand {
struct Type;
struct DecodableType;
} // namespace GetProfileInfoCommand

namespace GetMeasurementProfileResponseCommand {
struct Type;
struct DecodableType;
} // namespace GetMeasurementProfileResponseCommand

namespace GetMeasurementProfileCommand {
struct Type;
struct DecodableType;
} // namespace GetMeasurementProfileCommand

} // namespace Commands

namespace Commands {
namespace GetProfileInfoResponseCommand {
enum class Fields
{
    kProfileCount          = 0,
    kProfileIntervalPeriod = 1,
    kMaxNumberOfIntervals  = 2,
    kListOfAttributes      = 3,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint8_t profileCount;
    uint8_t profileIntervalPeriod;
    uint8_t maxNumberOfIntervals;
    DataModel::List<const uint16_t> listOfAttributes;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint8_t profileCount;
    uint8_t profileIntervalPeriod;
    uint8_t maxNumberOfIntervals;
    DataModel::DecodableList<uint16_t> listOfAttributes;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProfileInfoResponseCommand
namespace GetProfileInfoCommand {
enum class Fields
{
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetProfileInfoCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetProfileInfoCommand
namespace GetMeasurementProfileResponseCommand {
enum class Fields
{
    kStartTime                  = 0,
    kStatus                     = 1,
    kProfileIntervalPeriod      = 2,
    kNumberOfIntervalsDelivered = 3,
    kAttributeId                = 4,
    kIntervals                  = 5,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint32_t startTime;
    uint8_t status;
    uint8_t profileIntervalPeriod;
    uint8_t numberOfIntervalsDelivered;
    uint16_t attributeId;
    DataModel::List<const uint8_t> intervals;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileResponseCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint32_t startTime;
    uint8_t status;
    uint8_t profileIntervalPeriod;
    uint8_t numberOfIntervalsDelivered;
    uint16_t attributeId;
    DataModel::DecodableList<uint8_t> intervals;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMeasurementProfileResponseCommand
namespace GetMeasurementProfileCommand {
enum class Fields
{
    kAttributeId       = 0,
    kStartTime         = 1,
    kNumberOfIntervals = 2,
};

struct Type
{
public:
    // Use GetCommandId instead of commandId directly to avoid naming conflict with CommandIdentification in ExecutionOfACommand
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint16_t attributeId;
    uint32_t startTime;
    uint8_t numberOfIntervals;

    CHIP_ERROR Encode(TLV::TLVWriter & writer, TLV::Tag tag) const;

    using ResponseType = DataModel::NullObjectType;

    static constexpr bool MustUseTimedInvoke() { return false; }
};

struct DecodableType
{
public:
    static constexpr CommandId GetCommandId() { return Commands::GetMeasurementProfileCommand::Id; }
    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

    uint16_t attributeId;
    uint32_t startTime;
    uint8_t numberOfIntervals;
    CHIP_ERROR Decode(TLV::TLVReader & reader);
};
}; // namespace GetMeasurementProfileCommand
} // namespace Commands

namespace Attributes {

namespace MeasurementType {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasurementType::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasurementType
namespace DcVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltage
namespace DcVoltageMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageMin
namespace DcVoltageMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageMax
namespace DcCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrent
namespace DcCurrentMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentMin
namespace DcCurrentMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentMax
namespace DcPower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPower
namespace DcPowerMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerMin
namespace DcPowerMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerMax
namespace DcVoltageMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageMultiplier
namespace DcVoltageDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcVoltageDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcVoltageDivisor
namespace DcCurrentMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentMultiplier
namespace DcCurrentDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcCurrentDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcCurrentDivisor
namespace DcPowerMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerMultiplier
namespace DcPowerDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::DcPowerDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace DcPowerDivisor
namespace AcFrequency {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequency::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequency
namespace AcFrequencyMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyMin
namespace AcFrequencyMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyMax
namespace NeutralCurrent {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::NeutralCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace NeutralCurrent
namespace TotalActivePower {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalActivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalActivePower
namespace TotalReactivePower {
struct TypeInfo
{
    using Type             = int32_t;
    using DecodableType    = int32_t;
    using DecodableArgType = int32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalReactivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalReactivePower
namespace TotalApparentPower {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::TotalApparentPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace TotalApparentPower
namespace Measured1stHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured1stHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured1stHarmonicCurrent
namespace Measured3rdHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured3rdHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured3rdHarmonicCurrent
namespace Measured5thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured5thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured5thHarmonicCurrent
namespace Measured7thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured7thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured7thHarmonicCurrent
namespace Measured9thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured9thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured9thHarmonicCurrent
namespace Measured11thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::Measured11thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace Measured11thHarmonicCurrent
namespace MeasuredPhase1stHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase1stHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase1stHarmonicCurrent
namespace MeasuredPhase3rdHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase3rdHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase3rdHarmonicCurrent
namespace MeasuredPhase5thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase5thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase5thHarmonicCurrent
namespace MeasuredPhase7thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase7thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase7thHarmonicCurrent
namespace MeasuredPhase9thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase9thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase9thHarmonicCurrent
namespace MeasuredPhase11thHarmonicCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::MeasuredPhase11thHarmonicCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace MeasuredPhase11thHarmonicCurrent
namespace AcFrequencyMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyMultiplier
namespace AcFrequencyDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcFrequencyDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcFrequencyDivisor
namespace PowerMultiplier {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerMultiplier
namespace PowerDivisor {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerDivisor
namespace HarmonicCurrentMultiplier {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::HarmonicCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace HarmonicCurrentMultiplier
namespace PhaseHarmonicCurrentMultiplier {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PhaseHarmonicCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PhaseHarmonicCurrentMultiplier
namespace InstantaneousVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousVoltage
namespace InstantaneousLineCurrent {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousLineCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousLineCurrent
namespace InstantaneousActiveCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousActiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousActiveCurrent
namespace InstantaneousReactiveCurrent {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousReactiveCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousReactiveCurrent
namespace InstantaneousPower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::InstantaneousPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace InstantaneousPower
namespace RmsVoltage {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltage
namespace RmsVoltageMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMin
namespace RmsVoltageMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMax
namespace RmsCurrent {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrent::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrent
namespace RmsCurrentMin {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMin
namespace RmsCurrentMax {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMax
namespace ActivePower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePower
namespace ActivePowerMin {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMin::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMin
namespace ActivePowerMax {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMax::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMax
namespace ReactivePower {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePower
namespace ApparentPower {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPower::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPower
namespace PowerFactor {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactor
namespace AverageRmsVoltageMeasurementPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsVoltageMeasurementPeriod
namespace AverageRmsUnderVoltageCounter {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounter::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltageCounter
namespace RmsExtremeOverVoltagePeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltagePeriod
namespace RmsExtremeUnderVoltagePeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltagePeriod
namespace RmsVoltageSagPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSagPeriod
namespace RmsVoltageSwellPeriod {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriod::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwellPeriod
namespace AcVoltageMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcVoltageMultiplier
namespace AcVoltageDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcVoltageDivisor
namespace AcCurrentMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCurrentMultiplier
namespace AcCurrentDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCurrentDivisor
namespace AcPowerMultiplier {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcPowerMultiplier::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcPowerMultiplier
namespace AcPowerDivisor {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcPowerDivisor::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcPowerDivisor
namespace OverloadAlarmsMask {
struct TypeInfo
{
    using Type             = uint8_t;
    using DecodableType    = uint8_t;
    using DecodableArgType = uint8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::OverloadAlarmsMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace OverloadAlarmsMask
namespace VoltageOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::VoltageOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace VoltageOverload
namespace CurrentOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::CurrentOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace CurrentOverload
namespace AcOverloadAlarmsMask {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcOverloadAlarmsMask::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcOverloadAlarmsMask
namespace AcVoltageOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcVoltageOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcVoltageOverload
namespace AcCurrentOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcCurrentOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcCurrentOverload
namespace AcActivePowerOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcActivePowerOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcActivePowerOverload
namespace AcReactivePowerOverload {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AcReactivePowerOverload::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AcReactivePowerOverload
namespace AverageRmsOverVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsOverVoltage
namespace AverageRmsUnderVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltage
namespace RmsExtremeOverVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltage
namespace RmsExtremeUnderVoltage {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltage::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltage
namespace RmsVoltageSag {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSag::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSag
namespace RmsVoltageSwell {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwell::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwell
namespace LineCurrentPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LineCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LineCurrentPhaseB
namespace ActiveCurrentPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCurrentPhaseB
namespace ReactiveCurrentPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactiveCurrentPhaseB
namespace RmsVoltagePhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltagePhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltagePhaseB
namespace RmsVoltageMinPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMinPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMinPhaseB
namespace RmsVoltageMaxPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMaxPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMaxPhaseB
namespace RmsCurrentPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentPhaseB
namespace RmsCurrentMinPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMinPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMinPhaseB
namespace RmsCurrentMaxPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMaxPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMaxPhaseB
namespace ActivePowerPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerPhaseB
namespace ActivePowerMinPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMinPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMinPhaseB
namespace ActivePowerMaxPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMaxPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMaxPhaseB
namespace ReactivePowerPhaseB {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePowerPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePowerPhaseB
namespace ApparentPowerPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPowerPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPowerPhaseB
namespace PowerFactorPhaseB {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactorPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactorPhaseB
namespace AverageRmsVoltageMeasurementPeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsVoltageMeasurementPeriodPhaseB
namespace AverageRmsOverVoltageCounterPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltageCounterPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsOverVoltageCounterPhaseB
namespace AverageRmsUnderVoltageCounterPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounterPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltageCounterPhaseB
namespace RmsExtremeOverVoltagePeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltagePeriodPhaseB
namespace RmsExtremeUnderVoltagePeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltagePeriodPhaseB
namespace RmsVoltageSagPeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSagPeriodPhaseB
namespace RmsVoltageSwellPeriodPhaseB {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriodPhaseB::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwellPeriodPhaseB
namespace LineCurrentPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::LineCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace LineCurrentPhaseC
namespace ActiveCurrentPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActiveCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActiveCurrentPhaseC
namespace ReactiveCurrentPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactiveCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactiveCurrentPhaseC
namespace RmsVoltagePhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltagePhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltagePhaseC
namespace RmsVoltageMinPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMinPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMinPhaseC
namespace RmsVoltageMaxPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageMaxPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageMaxPhaseC
namespace RmsCurrentPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentPhaseC
namespace RmsCurrentMinPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMinPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMinPhaseC
namespace RmsCurrentMaxPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsCurrentMaxPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsCurrentMaxPhaseC
namespace ActivePowerPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerPhaseC
namespace ActivePowerMinPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMinPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMinPhaseC
namespace ActivePowerMaxPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ActivePowerMaxPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ActivePowerMaxPhaseC
namespace ReactivePowerPhaseC {
struct TypeInfo
{
    using Type             = int16_t;
    using DecodableType    = int16_t;
    using DecodableArgType = int16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ReactivePowerPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ReactivePowerPhaseC
namespace ApparentPowerPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ApparentPowerPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ApparentPowerPhaseC
namespace PowerFactorPhaseC {
struct TypeInfo
{
    using Type             = int8_t;
    using DecodableType    = int8_t;
    using DecodableArgType = int8_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::PowerFactorPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace PowerFactorPhaseC
namespace AverageRmsVoltageMeasurementPeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsVoltageMeasurementPeriodPhaseC
namespace AverageRmsOverVoltageCounterPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsOverVoltageCounterPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsOverVoltageCounterPhaseC
namespace AverageRmsUnderVoltageCounterPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AverageRmsUnderVoltageCounterPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AverageRmsUnderVoltageCounterPhaseC
namespace RmsExtremeOverVoltagePeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeOverVoltagePeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeOverVoltagePeriodPhaseC
namespace RmsExtremeUnderVoltagePeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsExtremeUnderVoltagePeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsExtremeUnderVoltagePeriodPhaseC
namespace RmsVoltageSagPeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSagPeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSagPeriodPhaseC
namespace RmsVoltageSwellPeriodPhaseC {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::RmsVoltageSwellPeriodPhaseC::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace RmsVoltageSwellPeriodPhaseC
namespace AttributeList {
struct TypeInfo
{
    using Type             = chip::app::DataModel::List<const chip::AttributeId>;
    using DecodableType    = chip::app::DataModel::DecodableList<chip::AttributeId>;
    using DecodableArgType = const chip::app::DataModel::DecodableList<chip::AttributeId> &;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::AttributeList::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace AttributeList
namespace FeatureMap {
struct TypeInfo
{
    using Type             = uint32_t;
    using DecodableType    = uint32_t;
    using DecodableArgType = uint32_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::FeatureMap::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace FeatureMap
namespace ClusterRevision {
struct TypeInfo
{
    using Type             = uint16_t;
    using DecodableType    = uint16_t;
    using DecodableArgType = uint16_t;

    static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }
    static constexpr AttributeId GetAttributeId() { return Attributes::ClusterRevision::Id; }
    static constexpr bool MustUseTimedWrite() { return false; }
};
} // namespace ClusterRevision

struct TypeInfo
{
    struct DecodableType
    {
        static constexpr ClusterId GetClusterId() { return Clusters::ElectricalMeasurement::Id; }

        CHIP_ERROR Decode(TLV::TLVReader & reader, const ConcreteAttributePath & path);

        Attributes::MeasurementType::TypeInfo::DecodableType measurementType;
        Attributes::DcVoltage::TypeInfo::DecodableType dcVoltage;
        Attributes::DcVoltageMin::TypeInfo::DecodableType dcVoltageMin;
        Attributes::DcVoltageMax::TypeInfo::DecodableType dcVoltageMax;
        Attributes::DcCurrent::TypeInfo::DecodableType dcCurrent;
        Attributes::DcCurrentMin::TypeInfo::DecodableType dcCurrentMin;
        Attributes::DcCurrentMax::TypeInfo::DecodableType dcCurrentMax;
        Attributes::DcPower::TypeInfo::DecodableType dcPower;
        Attributes::DcPowerMin::TypeInfo::DecodableType dcPowerMin;
        Attributes::DcPowerMax::TypeInfo::DecodableType dcPowerMax;
        Attributes::DcVoltageMultiplier::TypeInfo::DecodableType dcVoltageMultiplier;
        Attributes::DcVoltageDivisor::TypeInfo::DecodableType dcVoltageDivisor;
        Attributes::DcCurrentMultiplier::TypeInfo::DecodableType dcCurrentMultiplier;
        Attributes::DcCurrentDivisor::TypeInfo::DecodableType dcCurrentDivisor;
        Attributes::DcPowerMultiplier::TypeInfo::DecodableType dcPowerMultiplier;
        Attributes::DcPowerDivisor::TypeInfo::DecodableType dcPowerDivisor;
        Attributes::AcFrequency::TypeInfo::DecodableType acFrequency;
        Attributes::AcFrequencyMin::TypeInfo::DecodableType acFrequencyMin;
        Attributes::AcFrequencyMax::TypeInfo::DecodableType acFrequencyMax;
        Attributes::NeutralCurrent::TypeInfo::DecodableType neutralCurrent;
        Attributes::TotalActivePower::TypeInfo::DecodableType totalActivePower;
        Attributes::TotalReactivePower::TypeInfo::DecodableType totalReactivePower;
        Attributes::TotalApparentPower::TypeInfo::DecodableType totalApparentPower;
        Attributes::Measured1stHarmonicCurrent::TypeInfo::DecodableType measured1stHarmonicCurrent;
        Attributes::Measured3rdHarmonicCurrent::TypeInfo::DecodableType measured3rdHarmonicCurrent;
        Attributes::Measured5thHarmonicCurrent::TypeInfo::DecodableType measured5thHarmonicCurrent;
        Attributes::Measured7thHarmonicCurrent::TypeInfo::DecodableType measured7thHarmonicCurrent;
        Attributes::Measured9thHarmonicCurrent::TypeInfo::DecodableType measured9thHarmonicCurrent;
        Attributes::Measured11thHarmonicCurrent::TypeInfo::DecodableType measured11thHarmonicCurrent;
        Attributes::MeasuredPhase1stHarmonicCurrent::TypeInfo::DecodableType measuredPhase1stHarmonicCurrent;
        Attributes::MeasuredPhase3rdHarmonicCurrent::TypeInfo::DecodableType measuredPhase3rdHarmonicCurrent;
        Attributes::MeasuredPhase5thHarmonicCurrent::TypeInfo::DecodableType measuredPhase5thHarmonicCurrent;
        Attributes::MeasuredPhase7thHarmonicCurrent::TypeInfo::DecodableType measuredPhase7thHarmonicCurrent;
        Attributes::MeasuredPhase9thHarmonicCurrent::TypeInfo::DecodableType measuredPhase9thHarmonicCurrent;
        Attributes::MeasuredPhase11thHarmonicCurrent::TypeInfo::DecodableType measuredPhase11thHarmonicCurrent;
        Attributes::AcFrequencyMultiplier::TypeInfo::DecodableType acFrequencyMultiplier;
        Attributes::AcFrequencyDivisor::TypeInfo::DecodableType acFrequencyDivisor;
        Attributes::PowerMultiplier::TypeInfo::DecodableType powerMultiplier;
        Attributes::PowerDivisor::TypeInfo::DecodableType powerDivisor;
        Attributes::HarmonicCurrentMultiplier::TypeInfo::DecodableType harmonicCurrentMultiplier;
        Attributes::PhaseHarmonicCurrentMultiplier::TypeInfo::DecodableType phaseHarmonicCurrentMultiplier;
        Attributes::InstantaneousVoltage::TypeInfo::DecodableType instantaneousVoltage;
        Attributes::InstantaneousLineCurrent::TypeInfo::DecodableType instantaneousLineCurrent;
        Attributes::InstantaneousActiveCurrent::TypeInfo::DecodableType instantaneousActiveCurrent;
        Attributes::InstantaneousReactiveCurrent::TypeInfo::DecodableType instantaneousReactiveCurrent;
        Attributes::InstantaneousPower::TypeInfo::DecodableType instantaneousPower;
        Attributes::RmsVoltage::TypeInfo::DecodableType rmsVoltage;
        Attributes::RmsVoltageMin::TypeInfo::DecodableType rmsVoltageMin;
        Attributes::RmsVoltageMax::TypeInfo::DecodableType rmsVoltageMax;
        Attributes::RmsCurrent::TypeInfo::DecodableType rmsCurrent;
        Attributes::RmsCurrentMin::TypeInfo::DecodableType rmsCurrentMin;
        Attributes::RmsCurrentMax::TypeInfo::DecodableType rmsCurrentMax;
        Attributes::ActivePower::TypeInfo::DecodableType activePower;
        Attributes::ActivePowerMin::TypeInfo::DecodableType activePowerMin;
        Attributes::ActivePowerMax::TypeInfo::DecodableType activePowerMax;
        Attributes::ReactivePower::TypeInfo::DecodableType reactivePower;
        Attributes::ApparentPower::TypeInfo::DecodableType apparentPower;
        Attributes::PowerFactor::TypeInfo::DecodableType powerFactor;
        Attributes::AverageRmsVoltageMeasurementPeriod::TypeInfo::DecodableType averageRmsVoltageMeasurementPeriod;
        Attributes::AverageRmsUnderVoltageCounter::TypeInfo::DecodableType averageRmsUnderVoltageCounter;
        Attributes::RmsExtremeOverVoltagePeriod::TypeInfo::DecodableType rmsExtremeOverVoltagePeriod;
        Attributes::RmsExtremeUnderVoltagePeriod::TypeInfo::DecodableType rmsExtremeUnderVoltagePeriod;
        Attributes::RmsVoltageSagPeriod::TypeInfo::DecodableType rmsVoltageSagPeriod;
        Attributes::RmsVoltageSwellPeriod::TypeInfo::DecodableType rmsVoltageSwellPeriod;
        Attributes::AcVoltageMultiplier::TypeInfo::DecodableType acVoltageMultiplier;
        Attributes::AcVoltageDivisor::TypeInfo::DecodableType acVoltageDivisor;
        Attributes::AcCurrentMultiplier::TypeInfo::DecodableType acCurrentMultiplier;
        Attributes::AcCurrentDivisor::TypeInfo::DecodableType acCurrentDivisor;
        Attributes::AcPowerMultiplier::TypeInfo::DecodableType acPowerMultiplier;
        Attributes::AcPowerDivisor::TypeInfo::DecodableType acPowerDivisor;
        Attributes::OverloadAlarmsMask::TypeInfo::DecodableType overloadAlarmsMask;
        Attributes::VoltageOverload::TypeInfo::DecodableType voltageOverload;
        Attributes::CurrentOverload::TypeInfo::DecodableType currentOverload;
        Attributes::AcOverloadAlarmsMask::TypeInfo::DecodableType acOverloadAlarmsMask;
        Attributes::AcVoltageOverload::TypeInfo::DecodableType acVoltageOverload;
        Attributes::AcCurrentOverload::TypeInfo::DecodableType acCurrentOverload;
        Attributes::AcActivePowerOverload::TypeInfo::DecodableType acActivePowerOverload;
        Attributes::AcReactivePowerOverload::TypeInfo::DecodableType acReactivePowerOverload;
        Attributes::AverageRmsOverVoltage::TypeInfo::DecodableType averageRmsOverVoltage;
        Attributes::AverageRmsUnderVoltage::TypeInfo::DecodableType averageRmsUnderVoltage;
        Attributes::RmsExtremeOverVoltage::TypeInfo::DecodableType rmsExtremeOverVoltage;
        Attributes::RmsExtremeUnderVoltage::TypeInfo::DecodableType rmsExtremeUnderVoltage;
        Attributes::RmsVoltageSag::TypeInfo::DecodableType rmsVoltageSag;
        Attributes::RmsVoltageSwell::TypeInfo::DecodableType rmsVoltageSwell;
        Attributes::LineCurrentPhaseB::TypeInfo::DecodableType lineCurrentPhaseB;
        Attributes::ActiveCurrentPhaseB::TypeInfo::DecodableType activeCurrentPhaseB;
        Attributes::ReactiveCurrentPhaseB::TypeInfo::DecodableType reactiveCurrentPhaseB;
        Attributes::RmsVoltagePhaseB::TypeInfo::DecodableType rmsVoltagePhaseB;
        Attributes::RmsVoltageMinPhaseB::TypeInfo::DecodableType rmsVoltageMinPhaseB;
        Attributes::RmsVoltageMaxPhaseB::TypeInfo::DecodableType rmsVoltageMaxPhaseB;
        Attributes::RmsCurrentPhaseB::TypeInfo::DecodableType rmsCurrentPhaseB;
        Attributes::RmsCurrentMinPhaseB::TypeInfo::DecodableType rmsCurrentMinPhaseB;
        Attributes::RmsCurrentMaxPhaseB::TypeInfo::DecodableType rmsCurrentMaxPhaseB;
        Attributes::ActivePowerPhaseB::TypeInfo::DecodableType activePowerPhaseB;
        Attributes::ActivePowerMinPhaseB::TypeInfo::DecodableType activePowerMinPhaseB;
        Attributes::ActivePowerMaxPhaseB::TypeInfo::DecodableType activePowerMaxPhaseB;
        Attributes::ReactivePowerPhaseB::TypeInfo::DecodableType reactivePowerPhaseB;
        Attributes::ApparentPowerPhaseB::TypeInfo::DecodableType apparentPowerPhaseB;
        Attributes::PowerFactorPhaseB::TypeInfo::DecodableType powerFactorPhaseB;
        Attributes::AverageRmsVoltageMeasurementPeriodPhaseB::TypeInfo::DecodableType averageRmsVoltageMeasurementPeriodPhaseB;
        Attributes::AverageRmsOverVoltageCounterPhaseB::TypeInfo::DecodableType averageRmsOverVoltageCounterPhaseB;
        Attributes::AverageRmsUnderVoltageCounterPhaseB::TypeInfo::DecodableType averageRmsUnderVoltageCounterPhaseB;
        Attributes::RmsExtremeOverVoltagePeriodPhaseB::TypeInfo::DecodableType rmsExtremeOverVoltagePeriodPhaseB;
        Attributes::RmsExtremeUnderVoltagePeriodPhaseB::TypeInfo::DecodableType rmsExtremeUnderVoltagePeriodPhaseB;
        Attributes::RmsVoltageSagPeriodPhaseB::TypeInfo::DecodableType rmsVoltageSagPeriodPhaseB;
        Attributes::RmsVoltageSwellPeriodPhaseB::TypeInfo::DecodableType rmsVoltageSwellPeriodPhaseB;
        Attributes::LineCurrentPhaseC::TypeInfo::DecodableType lineCurrentPhaseC;
        Attributes::ActiveCurrentPhaseC::TypeInfo::DecodableType activeCurrentPhaseC;
        Attributes::ReactiveCurrentPhaseC::TypeInfo::DecodableType reactiveCurrentPhaseC;
        Attributes::RmsVoltagePhaseC::TypeInfo::DecodableType rmsVoltagePhaseC;
        Attributes::RmsVoltageMinPhaseC::TypeInfo::DecodableType rmsVoltageMinPhaseC;
        Attributes::RmsVoltageMaxPhaseC::TypeInfo::DecodableType rmsVoltageMaxPhaseC;
        Attributes::RmsCurrentPhaseC::TypeInfo::DecodableType rmsCurrentPhaseC;
        Attributes::RmsCurrentMinPhaseC::TypeInfo::DecodableType rmsCurrentMinPhaseC;
        Attributes::RmsCurrentMaxPhaseC::TypeInfo::DecodableType rmsCurrentMaxPhaseC;
        Attributes::ActivePowerPhaseC::TypeInfo::DecodableType activePowerPhaseC;
        Attributes::ActivePowerMinPhaseC::TypeInfo::DecodableType activePowerMinPhaseC;
        Attributes::ActivePowerMaxPhaseC::TypeInfo::DecodableType activePowerMaxPhaseC;
        Attributes::ReactivePowerPhaseC::TypeInfo::DecodableType reactivePowerPhaseC;
        Attributes::ApparentPowerPhaseC::TypeInfo::DecodableType apparentPowerPhaseC;
        Attributes::PowerFactorPhaseC::TypeInfo::DecodableType powerFactorPhaseC;
        Attributes::AverageRmsVoltageMeasurementPeriodPhaseC::TypeInfo::DecodableType averageRmsVoltageMeasurementPeriodPhaseC;
        Attributes::AverageRmsOverVoltageCounterPhaseC::TypeInfo::DecodableType averageRmsOverVoltageCounterPhaseC;
        Attributes::AverageRmsUnderVoltageCounterPhaseC::TypeInfo::DecodableType averageRmsUnderVoltageCounterPhaseC;
        Attributes::RmsExtremeOverVoltagePeriodPhaseC::TypeInfo::DecodableType rmsExtremeOverVoltagePeriodPhaseC;
        Attributes::RmsExtremeUnderVoltagePeriodPhaseC::TypeInfo::DecodableType rmsExtremeUnderVoltagePeriodPhaseC;
        Attributes::RmsVoltageSagPeriodPhaseC::TypeInfo::DecodableType rmsVoltageSagPeriodPhaseC;
        Attributes::RmsVoltageSwellPeriodPhaseC::TypeInfo::DecodableType rmsVoltageSwellPeriodPhaseC;
        Attributes::AttributeList::TypeInfo::DecodableType attributeList;
        Attributes::FeatureMap::TypeInfo::DecodableType featureMap;
        Attributes::ClusterRevision::TypeInfo::DecodableType clusterRevision;
    };
};
} // namespace Attributes
} // namespace ElectricalMeasurement

} // namespace Clusters
} // namespace app
} // namespace chip
