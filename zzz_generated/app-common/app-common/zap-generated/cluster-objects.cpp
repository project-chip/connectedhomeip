/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <app-common/zap-generated/cluster-objects.h>

#pragma GCC diagnostic ignored "-Wstack-usage="

namespace chip {
namespace app {
namespace Clusters {
namespace PowerConfiguration {
}

namespace DeviceTemperatureConfiguration {
}

namespace Identify {
}

namespace Groups {
}

namespace Scenes {
}

namespace OnOff {
}

namespace OnOffSwitchConfiguration {
}

namespace LevelControl {
}

namespace Alarms {
}

namespace Time {
}

namespace BinaryInputBasic {
}

namespace PowerProfile {
}

namespace ApplianceControl {
}

namespace Descriptor {
namespace DeviceType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kTypeFieldId), type));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRevisionFieldId), revision));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kTypeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, type));
            break;
        case kRevisionFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, revision));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace DeviceType
} // namespace Descriptor

namespace PollControl {
}

namespace Basic {
}

namespace OtaSoftwareUpdateProvider {
}

namespace OtaSoftwareUpdateRequestor {
}

namespace PowerSource {
}

namespace GeneralCommissioning {
namespace BasicCommissioningInfoType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFailSafeExpiryLengthMsFieldId), failSafeExpiryLengthMs));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFailSafeExpiryLengthMsFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, failSafeExpiryLengthMs));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace BasicCommissioningInfoType
} // namespace GeneralCommissioning

namespace NetworkCommissioning {
namespace ThreadInterfaceScanResult {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDiscoveryResponseFieldId), discoveryResponse));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kDiscoveryResponseFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, discoveryResponse));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ThreadInterfaceScanResult
namespace WiFiInterfaceScanResult {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSecurityFieldId), security));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSsidFieldId), ssid));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBssidFieldId), bssid));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kChannelFieldId), channel));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFrequencyBandFieldId), frequencyBand));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kSecurityFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, security));
            break;
        case kSsidFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, ssid));
            break;
        case kBssidFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, bssid));
            break;
        case kChannelFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, channel));
            break;
        case kFrequencyBandFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, frequencyBand));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace WiFiInterfaceScanResult
} // namespace NetworkCommissioning

namespace DiagnosticLogs {
}

namespace GeneralDiagnostics {
namespace NetworkInterfaceType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricConnectedFieldId), fabricConnected));
    ReturnErrorOnFailure(
        DataModel::Encode(writer, TLV::ContextTag(kOffPremiseServicesReachableIPv4FieldId), offPremiseServicesReachableIPv4));
    ReturnErrorOnFailure(
        DataModel::Encode(writer, TLV::ContextTag(kOffPremiseServicesReachableIPv6FieldId), offPremiseServicesReachableIPv6));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kHardwareAddressFieldId), hardwareAddress));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kTypeFieldId), type));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kFabricConnectedFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricConnected));
            break;
        case kOffPremiseServicesReachableIPv4FieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, offPremiseServicesReachableIPv4));
            break;
        case kOffPremiseServicesReachableIPv6FieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, offPremiseServicesReachableIPv6));
            break;
        case kHardwareAddressFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, hardwareAddress));
            break;
        case kTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            type = static_cast<InterfaceType>(v);
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NetworkInterfaceType
} // namespace GeneralDiagnostics

namespace SoftwareDiagnostics {
namespace ThreadMetrics {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kIdFieldId), id));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kStackFreeCurrentFieldId), stackFreeCurrent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kStackFreeMinimumFieldId), stackFreeMinimum));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kStackSizeFieldId), stackSize));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, id));
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kStackFreeCurrentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, stackFreeCurrent));
            break;
        case kStackFreeMinimumFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, stackFreeMinimum));
            break;
        case kStackSizeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, stackSize));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ThreadMetrics
} // namespace SoftwareDiagnostics

namespace ThreadNetworkDiagnostics {
namespace NeighborTable {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kExtAddressFieldId), extAddress));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAgeFieldId), age));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRloc16FieldId), rloc16));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLinkFrameCounterFieldId), linkFrameCounter));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMleFrameCounterFieldId), mleFrameCounter));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLqiFieldId), lqi));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAverageRssiFieldId), averageRssi));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLastRssiFieldId), lastRssi));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFrameErrorRateFieldId), frameErrorRate));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMessageErrorRateFieldId), messageErrorRate));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRxOnWhenIdleFieldId), rxOnWhenIdle));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFullThreadDeviceFieldId), fullThreadDevice));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFullNetworkDataFieldId), fullNetworkData));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kIsChildFieldId), isChild));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kExtAddressFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, extAddress));
            break;
        case kAgeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, age));
            break;
        case kRloc16FieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, rloc16));
            break;
        case kLinkFrameCounterFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, linkFrameCounter));
            break;
        case kMleFrameCounterFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, mleFrameCounter));
            break;
        case kLqiFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, lqi));
            break;
        case kAverageRssiFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, averageRssi));
            break;
        case kLastRssiFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, lastRssi));
            break;
        case kFrameErrorRateFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, frameErrorRate));
            break;
        case kMessageErrorRateFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, messageErrorRate));
            break;
        case kRxOnWhenIdleFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, rxOnWhenIdle));
            break;
        case kFullThreadDeviceFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fullThreadDevice));
            break;
        case kFullNetworkDataFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fullNetworkData));
            break;
        case kIsChildFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, isChild));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NeighborTable
namespace OperationalDatasetComponents {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kActiveTimestampPresentFieldId), activeTimestampPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPendingTimestampPresentFieldId), pendingTimestampPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMasterKeyPresentFieldId), masterKeyPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNetworkNamePresentFieldId), networkNamePresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kExtendedPanIdPresentFieldId), extendedPanIdPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMeshLocalPrefixPresentFieldId), meshLocalPrefixPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDelayPresentFieldId), delayPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPanIdPresentFieldId), panIdPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kChannelPresentFieldId), channelPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPskcPresentFieldId), pskcPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSecurityPolicyPresentFieldId), securityPolicyPresent));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kChannelMaskPresentFieldId), channelMaskPresent));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kActiveTimestampPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, activeTimestampPresent));
            break;
        case kPendingTimestampPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, pendingTimestampPresent));
            break;
        case kMasterKeyPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, masterKeyPresent));
            break;
        case kNetworkNamePresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, networkNamePresent));
            break;
        case kExtendedPanIdPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, extendedPanIdPresent));
            break;
        case kMeshLocalPrefixPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, meshLocalPrefixPresent));
            break;
        case kDelayPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, delayPresent));
            break;
        case kPanIdPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, panIdPresent));
            break;
        case kChannelPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, channelPresent));
            break;
        case kPskcPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, pskcPresent));
            break;
        case kSecurityPolicyPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, securityPolicyPresent));
            break;
        case kChannelMaskPresentFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, channelMaskPresent));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace OperationalDatasetComponents
namespace RouteTable {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kExtAddressFieldId), extAddress));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRloc16FieldId), rloc16));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRouterIdFieldId), routerId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNextHopFieldId), nextHop));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPathCostFieldId), pathCost));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLQIInFieldId), lQIIn));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLQIOutFieldId), lQIOut));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAgeFieldId), age));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAllocatedFieldId), allocated));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLinkEstablishedFieldId), linkEstablished));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kExtAddressFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, extAddress));
            break;
        case kRloc16FieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, rloc16));
            break;
        case kRouterIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, routerId));
            break;
        case kNextHopFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, nextHop));
            break;
        case kPathCostFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, pathCost));
            break;
        case kLQIInFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, lQIIn));
            break;
        case kLQIOutFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, lQIOut));
            break;
        case kAgeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, age));
            break;
        case kAllocatedFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, allocated));
            break;
        case kLinkEstablishedFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, linkEstablished));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace RouteTable
namespace SecurityPolicy {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRotationTimeFieldId), rotationTime));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFlagsFieldId), flags));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kRotationTimeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, rotationTime));
            break;
        case kFlagsFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, flags));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace SecurityPolicy
} // namespace ThreadNetworkDiagnostics

namespace WiFiNetworkDiagnostics {
}

namespace EthernetNetworkDiagnostics {
}

namespace BridgedDeviceBasic {
}

namespace Switch {
}

namespace AdministratorCommissioning {
}

namespace OperationalCredentials {
namespace FabricDescriptor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIndexFieldId), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRootPublicKeyFieldId), rootPublicKey));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kVendorIdFieldId), vendorId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIdFieldId), fabricId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNodeIdFieldId), nodeId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLabelFieldId), label));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFabricIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricIndex));
            break;
        case kRootPublicKeyFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, rootPublicKey));
            break;
        case kVendorIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, vendorId));
            break;
        case kFabricIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricId));
            break;
        case kNodeIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, nodeId));
            break;
        case kLabelFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, label));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace FabricDescriptor
namespace NOCStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIndexFieldId), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNocFieldId), noc));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFabricIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricIndex));
            break;
        case kNocFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, noc));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NOCStruct
} // namespace OperationalCredentials

namespace FixedLabel {
namespace LabelStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLabelFieldId), label));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kValueFieldId), value));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kLabelFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, label));
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace LabelStruct
} // namespace FixedLabel

namespace ShadeConfiguration {
}

namespace DoorLock {
}

namespace WindowCovering {
}

namespace BarrierControl {
}

namespace PumpConfigurationAndControl {
}

namespace Thermostat {
}

namespace FanControl {
}

namespace DehumidificationControl {
}

namespace ThermostatUserInterfaceConfiguration {
}

namespace ColorControl {
}

namespace BallastConfiguration {
}

namespace IlluminanceMeasurement {
}

namespace IlluminanceLevelSensing {
}

namespace TemperatureMeasurement {
}

namespace PressureMeasurement {
}

namespace FlowMeasurement {
}

namespace RelativeHumidityMeasurement {
}

namespace OccupancySensing {
}

namespace CarbonMonoxideConcentrationMeasurement {
}

namespace CarbonDioxideConcentrationMeasurement {
}

namespace EthyleneConcentrationMeasurement {
}

namespace EthyleneOxideConcentrationMeasurement {
}

namespace HydrogenConcentrationMeasurement {
}

namespace HydrogenSulphideConcentrationMeasurement {
}

namespace NitricOxideConcentrationMeasurement {
}

namespace NitrogenDioxideConcentrationMeasurement {
}

namespace OxygenConcentrationMeasurement {
}

namespace OzoneConcentrationMeasurement {
}

namespace SulfurDioxideConcentrationMeasurement {
}

namespace DissolvedOxygenConcentrationMeasurement {
}

namespace BromateConcentrationMeasurement {
}

namespace ChloraminesConcentrationMeasurement {
}

namespace ChlorineConcentrationMeasurement {
}

namespace FecalColiformAndEColiConcentrationMeasurement {
}

namespace FluorideConcentrationMeasurement {
}

namespace HaloaceticAcidsConcentrationMeasurement {
}

namespace TotalTrihalomethanesConcentrationMeasurement {
}

namespace TotalColiformBacteriaConcentrationMeasurement {
}

namespace TurbidityConcentrationMeasurement {
}

namespace CopperConcentrationMeasurement {
}

namespace LeadConcentrationMeasurement {
}

namespace ManganeseConcentrationMeasurement {
}

namespace SulfateConcentrationMeasurement {
}

namespace BromodichloromethaneConcentrationMeasurement {
}

namespace BromoformConcentrationMeasurement {
}

namespace ChlorodibromomethaneConcentrationMeasurement {
}

namespace ChloroformConcentrationMeasurement {
}

namespace SodiumConcentrationMeasurement {
}

namespace IasZone {
}

namespace IasAce {
}

namespace IasWd {
}

namespace WakeOnLan {
}

namespace TvChannel {
namespace TvChannelInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMajorNumberFieldId), majorNumber));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMinorNumberFieldId), minorNumber));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCallSignFieldId), callSign));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAffiliateCallSignFieldId), affiliateCallSign));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kMajorNumberFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, majorNumber));
            break;
        case kMinorNumberFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, minorNumber));
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kCallSignFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, callSign));
            break;
        case kAffiliateCallSignFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, affiliateCallSign));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TvChannelInfo
namespace TvChannelLineupInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kOperatorNameFieldId), operatorName));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLineupNameFieldId), lineupName));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPostalCodeFieldId), postalCode));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLineupInfoTypeFieldId), lineupInfoType));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kOperatorNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, operatorName));
            break;
        case kLineupNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, lineupName));
            break;
        case kPostalCodeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, postalCode));
            break;
        case kLineupInfoTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            lineupInfoType = static_cast<TvChannelLineupInfoType>(v);
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TvChannelLineupInfo
} // namespace TvChannel

namespace TargetNavigator {
namespace NavigateTargetTargetInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kIdentifierFieldId), identifier));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kIdentifierFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, identifier));
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NavigateTargetTargetInfo
} // namespace TargetNavigator

namespace MediaPlayback {
namespace MediaPlaybackPosition {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kUpdatedAtFieldId), updatedAt));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPositionFieldId), position));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kUpdatedAtFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, updatedAt));
            break;
        case kPositionFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, position));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace MediaPlaybackPosition
} // namespace MediaPlayback

namespace MediaInput {
namespace MediaInputInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kIndexFieldId), index));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kInputTypeFieldId), inputType));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDescriptionFieldId), description));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, index));
            break;
        case kInputTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            inputType = static_cast<MediaInputType>(v);
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kDescriptionFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, description));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace MediaInputInfo
} // namespace MediaInput

namespace LowPower {
}

namespace KeypadInput {
}

namespace ContentLauncher {
namespace ContentLaunchAdditionalInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kValueFieldId), value));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchAdditionalInfo
namespace ContentLaunchParamater {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kTypeFieldId), type));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kValueFieldId), value));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kExternalIDListFieldId), externalIDList));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            type = static_cast<ContentLaunchParameterEnum>(v);
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        case kExternalIDListFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            type = static_cast<ContentLaunchParameterEnum>(v);
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        case kExternalIDListFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, externalIDList));
            break;
        default:
            break;
        }
    }

    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchParamater
namespace ContentLaunchBrandingInformation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kProviderNameFieldId), providerName));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBackgroundFieldId), background));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLogoFieldId), logo));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kProgressBarFieldId), progressBar));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSplashFieldId), splash));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kWaterMarkFieldId), waterMark));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kProviderNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, providerName));
            break;
        case kBackgroundFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, background));
            break;
        case kLogoFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, logo));
            break;
        case kProgressBarFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, progressBar));
            break;
        case kSplashFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, splash));
            break;
        case kWaterMarkFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, waterMark));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchBrandingInformation
namespace ContentLaunchDimension {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kWidthFieldId), width));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kHeightFieldId), height));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMetricFieldId), metric));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kWidthFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, width));
            break;
        case kHeightFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, height));
            break;
        case kMetricFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            metric = static_cast<ContentLaunchMetricType>(v);
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchDimension
namespace ContentLaunchStyleInformation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kImageUrlFieldId), imageUrl));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kColorFieldId), color));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSizeFieldId), size));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kImageUrlFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, imageUrl));
            break;
        case kColorFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, color));
            break;
        case kSizeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, size));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchStyleInformation
} // namespace ContentLauncher

namespace AudioOutput {
namespace AudioOutputInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kIndexFieldId), index));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kOutputTypeFieldId), outputType));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, index));
            break;
        case kOutputTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            outputType = static_cast<AudioOutputType>(v);
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace AudioOutputInfo
} // namespace AudioOutput

namespace ApplicationLauncher {
namespace ApplicationLauncherApp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCatalogVendorIdFieldId), catalogVendorId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kApplicationIdFieldId), applicationId));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kCatalogVendorIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, catalogVendorId));
            break;
        case kApplicationIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, applicationId));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ApplicationLauncherApp
} // namespace ApplicationLauncher

namespace ApplicationBasic {
}

namespace AccountLogin {
}

namespace TestCluster {
namespace SimpleStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBFieldId), b));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCFieldId), c));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDFieldId), d));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kEFieldId), e));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            c = static_cast<SimpleEnum>(v);
            break;
        case kDFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, d));
            break;
        case kEFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, e));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace SimpleStruct
namespace NestedStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBFieldId), b));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCFieldId), c));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, c));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NestedStruct
namespace NestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBFieldId), b));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCFieldId), c));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDFieldId), d));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kEFieldId), e));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFFieldId), f));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGFieldId), g));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, c));
            break;
        case kDFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kEFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kFFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kGFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, c));
            break;
        case kDFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, d));
            break;
        case kEFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, e));
            break;
        case kFFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, f));
            break;
        case kGFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, g));
            break;
        default:
            break;
        }
    }

    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NestedStructList
namespace DoubleNestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        default:
            break;
        }
    }

    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace DoubleNestedStructList
namespace TestListStructOctet {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIndexFieldId), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kOperationalCertFieldId), operationalCert));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFabricIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricIndex));
            break;
        case kOperationalCertFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, operationalCert));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TestListStructOctet
} // namespace TestCluster

namespace Messaging {
}

namespace ApplianceIdentification {
}

namespace MeterIdentification {
}

namespace ApplianceEventsAndAlert {
}

namespace ApplianceStatistics {
}

namespace ElectricalMeasurement {
}

namespace Binding {
}

namespace GroupKeyManagement {
namespace GroupKey {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kVendorIdFieldId), vendorId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGroupKeyIndexFieldId), groupKeyIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGroupKeyRootFieldId), groupKeyRoot));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGroupKeyEpochStartTimeFieldId), groupKeyEpochStartTime));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGroupKeySecurityPolicyFieldId), groupKeySecurityPolicy));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kVendorIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, vendorId));
            break;
        case kGroupKeyIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, groupKeyIndex));
            break;
        case kGroupKeyRootFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, groupKeyRoot));
            break;
        case kGroupKeyEpochStartTimeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, groupKeyEpochStartTime));
            break;
        case kGroupKeySecurityPolicyFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            groupKeySecurityPolicy = static_cast<GroupKeySecurityPolicy>(v);
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace GroupKey
namespace GroupState {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kVendorIdFieldId), vendorId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kVendorGroupIdFieldId), vendorGroupId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGroupKeySetIndexFieldId), groupKeySetIndex));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kVendorIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, vendorId));
            break;
        case kVendorGroupIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, vendorGroupId));
            break;
        case kGroupKeySetIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, groupKeySetIndex));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace GroupState
} // namespace GroupKeyManagement

namespace SampleMfgSpecificCluster {
}

namespace SampleMfgSpecificCluster2 {
}

} // namespace Clusters
} // namespace app
} // namespace chip
