/*
 *
 *    Copyright (c) 2021 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP

#include <app-common/zap-generated/cluster-objects.h>

#pragma GCC diagnostic ignored "-Wstack-usage="

namespace chip {
namespace app {
namespace clusters {
namespace AccountLogin {
}

namespace ApplicationLauncher {
namespace ApplicationLauncherApp {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCatalogVendorIdFieldId), catalogVendorId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kApplicationIdFieldId), applicationId));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kCatalogVendorIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, catalogVendorId));
            break;
        case kApplicationIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, applicationId));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ApplicationLauncherApp
} // namespace ApplicationLauncher

namespace ContentLauncher {
namespace ContentLaunchAdditionalInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kValueFieldId), value));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchAdditionalInfo
namespace ContentLaunchParamater {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kTypeFieldId), type));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kValueFieldId), value));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kExternalIDListFieldId), externalIDList));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            type = static_cast<ContentLaunchParameterEnum>(v);
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        case kExternalIDListFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            type = static_cast<ContentLaunchParameterEnum>(v);
            break;
        case kValueFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, value));
            break;
        case kExternalIDListFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, externalIDList));
            break;
        default:
            break;
        }
    }

    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchParamater
namespace ContentLaunchBrandingInformation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kProviderNameFieldId), providerName));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBackgroundFieldId), background));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLogoFieldId), logo));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kProgressBarFieldId), progressBar));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSplashFieldId), splash));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kWaterMarkFieldId), waterMark));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kProviderNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, providerName));
            break;
        case kBackgroundFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, background));
            break;
        case kLogoFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, logo));
            break;
        case kProgressBarFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, progressBar));
            break;
        case kSplashFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, splash));
            break;
        case kWaterMarkFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, waterMark));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchBrandingInformation
namespace ContentLaunchDimension {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kWidthFieldId), width));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kHeightFieldId), height));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMetricFieldId), metric));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kWidthFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, width));
            break;
        case kHeightFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, height));
            break;
        case kMetricFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            metric = static_cast<ContentLaunchMetricType>(v);
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchDimension
namespace ContentLaunchStyleInformation {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kImageUrlFieldId), imageUrl));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kColorFieldId), color));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSizeFieldId), size));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kImageUrlFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, imageUrl));
            break;
        case kColorFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, color));
            break;
        case kSizeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, size));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ContentLaunchStyleInformation
} // namespace ContentLauncher

namespace DoorLock {
}

namespace GeneralCommissioning {
namespace BasicCommissioningInfoType {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFailSafeExpiryLengthMsFieldId), failSafeExpiryLengthMs));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFailSafeExpiryLengthMsFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, failSafeExpiryLengthMs));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace BasicCommissioningInfoType
} // namespace GeneralCommissioning

namespace Groups {
}

namespace Identify {
}

namespace KeypadInput {
}

namespace MediaPlayback {
namespace MediaPlaybackPosition {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kUpdatedAtFieldId), updatedAt));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPositionFieldId), position));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kUpdatedAtFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, updatedAt));
            break;
        case kPositionFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, position));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace MediaPlaybackPosition
} // namespace MediaPlayback

namespace NetworkCommissioning {
namespace ThreadInterfaceScanResult {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDiscoveryResponseFieldId), discoveryResponse));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kDiscoveryResponseFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, discoveryResponse));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace ThreadInterfaceScanResult
namespace WiFiInterfaceScanResult {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSecurityFieldId), security));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kSsidFieldId), ssid));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBssidFieldId), bssid));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kChannelFieldId), channel));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFrequencyBandFieldId), frequencyBand));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kSecurityFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, security));
            break;
        case kSsidFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, ssid));
            break;
        case kBssidFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, bssid));
            break;
        case kChannelFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, channel));
            break;
        case kFrequencyBandFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, frequencyBand));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace WiFiInterfaceScanResult
} // namespace NetworkCommissioning

namespace OtaSoftwareUpdateProvider {
}

namespace OperationalCredentials {
namespace FabricDescriptor {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIndexFieldId), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kRootPublicKeyFieldId), rootPublicKey));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kVendorIdFieldId), vendorId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIdFieldId), fabricId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNodeIdFieldId), nodeId));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLabelFieldId), label));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFabricIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricIndex));
            break;
        case kRootPublicKeyFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, rootPublicKey));
            break;
        case kVendorIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, vendorId));
            break;
        case kFabricIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricId));
            break;
        case kNodeIdFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, nodeId));
            break;
        case kLabelFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, label));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace FabricDescriptor
namespace NOCStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIndexFieldId), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNocFieldId), noc));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFabricIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricIndex));
            break;
        case kNocFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, noc));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NOCStruct
} // namespace OperationalCredentials

namespace Scenes {
}

namespace TvChannel {
namespace TvChannelInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMajorNumberFieldId), majorNumber));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kMinorNumberFieldId), minorNumber));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCallSignFieldId), callSign));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAffiliateCallSignFieldId), affiliateCallSign));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kMajorNumberFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, majorNumber));
            break;
        case kMinorNumberFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, minorNumber));
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        case kCallSignFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, callSign));
            break;
        case kAffiliateCallSignFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, affiliateCallSign));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TvChannelInfo
namespace TvChannelLineupInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kOperatorNameFieldId), operatorName));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLineupNameFieldId), lineupName));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kPostalCodeFieldId), postalCode));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kLineupInfoTypeFieldId), lineupInfoType));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kOperatorNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, operatorName));
            break;
        case kLineupNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, lineupName));
            break;
        case kPostalCodeFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, postalCode));
            break;
        case kLineupInfoTypeFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            lineupInfoType = static_cast<TvChannelLineupInfoType>(v);
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TvChannelLineupInfo
} // namespace TvChannel

namespace TargetNavigator {
namespace NavigateTargetTargetInfo {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kIdentifierFieldId), identifier));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kNameFieldId), name));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kIdentifierFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, identifier));
            break;
        case kNameFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, name));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NavigateTargetTargetInfo
} // namespace TargetNavigator

namespace TestCluster {
namespace SimpleStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBFieldId), b));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCFieldId), c));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDFieldId), d));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kEFieldId), e));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            uint8_t v;
            ReturnErrorOnFailure(DataModel::Decode(reader, v));
            c = static_cast<SimpleEnum>(v);
            break;
        case kDFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, d));
            break;
        case kEFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, e));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace SimpleStruct
namespace NestedStruct {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBFieldId), b));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCFieldId), c));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, c));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NestedStruct
namespace NestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kBFieldId), b));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kCFieldId), c));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kDFieldId), d));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kEFieldId), e));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFFieldId), f));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kGFieldId), g));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, c));
            break;
        case kDFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kEFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kFFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        case kGFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        case kBFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, b));
            break;
        case kCFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, c));
            break;
        case kDFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, d));
            break;
        case kEFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, e));
            break;
        case kFFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, f));
            break;
        case kGFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, g));
            break;
        default:
            break;
        }
    }

    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace NestedStructList
namespace DoubleNestedStructList {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kAFieldId), a));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            return CHIP_ERROR_NOT_IMPLEMENTED;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
CHIP_ERROR DecodableType::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    return CHIP_ERROR_BAD_REQUEST;
}

CHIP_ERROR DecodableType::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);

    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kAFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, a));
            break;
        default:
            break;
        }
    }

    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace DoubleNestedStructList
namespace TestListStructOctet {
CHIP_ERROR Type::Encode(TLV::TLVWriter & writer, uint64_t tag) const
{
    TLV::TLVType outer;
    ReturnErrorOnFailure(writer.StartContainer(tag, TLV::kTLVType_Structure, outer));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kFabricIndexFieldId), fabricIndex));
    ReturnErrorOnFailure(DataModel::Encode(writer, TLV::ContextTag(kOperationalCertFieldId), operationalCert));
    ReturnErrorOnFailure(writer.EndContainer(outer));
    return CHIP_NO_ERROR;
}

CHIP_ERROR Type::Decode(TLV::TLVReader & reader)
{
    CHIP_ERROR err;
    TLV::TLVType outer;
    err = reader.EnterContainer(outer);
    ReturnErrorOnFailure(err);
    while ((err = reader.Next()) == CHIP_NO_ERROR)
    {
        switch (chip::TLV::TagNumFromTag(reader.GetTag()))
        {
        case kFabricIndexFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, fabricIndex));
            break;
        case kOperationalCertFieldId:
            ReturnErrorOnFailure(DataModel::Decode(reader, operationalCert));
            break;
        default:
            break;
        }
    }
    VerifyOrReturnError(err == CHIP_END_OF_TLV, err);
    ReturnErrorOnFailure(reader.ExitContainer(outer));
    return CHIP_NO_ERROR;
}
} // namespace TestListStructOctet
} // namespace TestCluster

} // namespace clusters
} // namespace app
} // namespace chip
